REPORT zrmafru00 MESSAGE-ID ru
                LINE-SIZE 132.

*---------------------------------------------------------------------*
*        Type Pools                                                   *
*---------------------------------------------------------------------*
TYPE-POOLS: icon,
            slis.

*---------------------------------------------------------------------*
*        Tables                                                       *
*---------------------------------------------------------------------*
TABLES: m_afrhb,
        afrh,
        afrud,
        afrv,
        afru_wf,
        afvgd,
        *afvgd,
        cooprkey,
        kbedd,
        pderr,
        rc27x.

*---------------------------------------------------------------------*
*        Internal Tables / Structures                                 *
*---------------------------------------------------------------------*
DATA: m_afrhb_tab TYPE m_afrhb OCCURS 0 WITH HEADER LINE,
      afrh_tab    TYPE afrh    OCCURS 0 WITH HEADER LINE,
      afrv_tab    TYPE afrv    OCCURS 0 WITH HEADER LINE.
DATA: BEGIN OF out_tab OCCURS 0,
        datum LIKE sy-datum,
        uzeit LIKE sy-uzeit,
        afruv TYPE afrh-afruv,
      END   OF out_tab.
DATA: BEGIN OF afruv_old,
        const(3) TYPE c,
        datum    LIKE sy-datum,
        uzeit    LIKE sy-uzeit,
        fillr(3) TYPE c,
      END   OF afruv_old,
      BEGIN OF afruv_new,
        pdsnr TYPE afrv-pdsnr,
        fill1(1) TYPE c,
        uzeit    LIKE sy-uzeit,
        fill2(1) TYPE c,
      END   OF afruv_new,
      BEGIN OF afruv_chk,
        key(17)  TYPE c,
        fillr(3) TYPE c,
      END   OF afruv_chk.
DATA: BEGIN OF tmp_afrv OCCURS 0.
        INCLUDE STRUCTURE afrv.
DATA: END   OF tmp_afrv.
DATA: BEGIN OF afrv_key,
        mandt   LIKE sy-mandt,
        afori   TYPE afrv-afori,
        afruv   TYPE afrv-afruv,
        counter TYPE afrv-counter,
      END   OF afrv_key.
DATA: BEGIN   OF excl_tab OCCURS 0.
INCLUDE TYPE cuafcode.
DATA: END OF excl_tab.

*     Daten der selektieren Fehlers#tze f¨¹r ALV
DATA: gt_afrh_alv TYPE afrh_t_alv WITH HEADER LINE.
DATA: gt_afrv_alv TYPE afrv_t_alv WITH HEADER LINE.

DATA: BEGIN OF gt_out_fc OCCURS 0,
        afruv   LIKE afrh-afruv,
        afrvtxt LIKE afrh-afrvtxt,
        ernam   LIKE afrh-ernam,
        datum   LIKE afrh-erdat,
        uzeit   LIKE afru-erzet,
      END   OF gt_out_fc.
DATA: BEGIN OF gt_out_tab OCCURS 0,
        box     TYPE c,
        afruv   LIKE afrh-afruv,
        afrvtxt LIKE afrh-afrvtxt,
        ernam   LIKE afrh-ernam,
        datum   LIKE afrh-erdat,
        uzeit   LIKE afru-erzet,
      END   OF gt_out_tab.

*---------------------------------------------------------------------*
*        Variables                                                    *
*---------------------------------------------------------------------*
DATA: antwort,
      aktyp_pic,
      autyp     TYPE caufvd-autyp,
      feldpos   LIKE sy-fdpos,
      flg_intensif,
      flg_wf    TYPE xfeld VALUE 'X',
      ok_code   TYPE tc02-fcode,
      rmzhl_upd TYPE afrud-rmzhl,
      tabix     LIKE sy-tabix,
      zeile     LIKE sy-curow,
      found     TYPE xfeld,
      hex_afrv(900) TYPE x.
*{   INSERT         CD1K958337                                        1
tables: rihafvr.

* PARAMETERS: herkunft LIKE afrh-afori no-display,
*            p_werks  like afrv-werks obligatory memory id WRK.
* Replaced because in ECC6 HERKUNFT already defined aa PARAMETER

*** js-001 * begin ***
* Modification : CR1043 CS-IW46 : Multiple Plant Selection
* Request-id.: CD1K950814
*PARAMETERS: p_werks  like afrv-werks obligatory memory id WRK.
select-options: s_werks for rihafvr-werki
                        obligatory
                        memory id WRK.
*** js-001 * end ***

select-options: s_arbpl  for RIHAFVR-iarbpl.

data: ld_message type string.
*}   INSERT

*---------------------------------------------------------------------*
*        Constants                                                    *
*---------------------------------------------------------------------*
* Konstanten
CONSTANTS:
      ya                          VALUE 'A',    "Abbrechen
      yja                         VALUE 'J',    "Ja
      ynein                       VALUE 'N',    "Nein
      yx                          VALUE 'X',    "Ankreuzen
      yspace                      VALUE ' ',    "Nichts
* Aktivit#tstyp
      aktyp_hin  TYPE aktyp       VALUE 'H',    "Anlegen
      aktyp_ver  TYPE aktyp       VALUE 'V',    "Aendern
* Bearbeitungs-Kennzeichen
      beaknz_del TYPE afrv-beaknz VALUE 'D',
      beaknz_hdr TYPE afrv-beaknz VALUE 'H',
      beaknz_upd TYPE afrv-beaknz VALUE 'U',
* Herkunftscodes
      herkunft_2 TYPE afrh-afori  VALUE '2',    "PP-SFC
      herkunft_6 TYPE afrh-afori  VALUE '6',    "PP-PI
* Funktionscodes
      fc_auft LIKE sy-ucomm VALUE 'AUFT',       "Auftrag anzeigen
      fc_back LIKE sy-ucomm VALUE 'BACK',       "Zur¨¹ck
      fc_bacl LIKE sy-ucomm VALUE 'BACL',       "Zur¨¹ck z. Liste
      fc_del  LIKE sy-ucomm VALUE 'DEL ',       "Vorrat l#schen
      fc_dele LIKE sy-ucomm VALUE 'DELE',       "L#schen
      fc_end  LIKE sy-ucomm VALUE 'END ',       "Beenden
      fc_fail LIKE sy-ucomm VALUE 'FAIL',       "Fehler
      fc_istr LIKE sy-ucomm VALUE 'ISTR',       "Istdaten
      fc_pick LIKE sy-ucomm VALUE 'PICK',       "Detail
      fc_rw   LIKE sy-ucomm VALUE 'RW  ',       "Abbrechen
      fc_rwl  LIKE sy-ucomm VALUE 'RWL ',       "Abbrechen d. Liste
      fc_save LIKE sy-ucomm VALUE 'BU  '.       "Buchen

*---------------------------------------------------------------------*
*        ALV-Data                                                     *
*---------------------------------------------------------------------*
* Callback routines
CONSTANTS:
  g_repid             LIKE sy-repid      VALUE 'ZRMAFRU00',
  g_user_command_afrh TYPE slis_formname VALUE 'USER_COMMAND_AFRH',
  g_user_command_afrv TYPE slis_formname VALUE 'USER_COMMAND_AFRV',
  g_status_set_afrh   TYPE slis_formname VALUE 'SET_STATUS_AFRH',
  g_status_set_afrv   TYPE slis_formname VALUE 'SET_STATUS_AFRV',
  g_context_menu_afrh TYPE slis_formname VALUE 'CONTEXT_MENU_AFRH',
  g_context_menu_afrv TYPE slis_formname VALUE 'CONTEXT_MENU_AFRV'.
* Define fieldcatalog
DATA: gt_fieldcat TYPE slis_t_fieldcat_alv.
* Define events
DATA: gt_events   TYPE slis_t_event.
* List layout description
DATA: gs_layout   TYPE slis_layout_alv.
DATA: gs_variant  LIKE disvariant.
DATA: g_boxnam    TYPE slis_fieldname VALUE 'BOX'.
DATA: g_title     TYPE lvc_title.
*-------------------------------------------------------------------*
* data declaration for time zone functionality                      *
*-------------------------------------------------------------------*
TYPE-POOLS abap.
TYPE-POOLS tzs1.
DATA: gb_badi_time_zone_coru TYPE REF TO badi_eam_tz_coru_core.
DATA: gb_badi_time_zone_generic TYPE REF TO badi_eam_tz_generic_core.
DATA: gv_time_zone_active       TYPE tz_d_active.
DATA: gs_time_zone_func_dyntxt  TYPE smp_dyntxt.
DATA: gv_list_time_zone         TYPE tznzone.

*---------------------------------------------------------------------*
*        Includes                                                     *
*---------------------------------------------------------------------*
* Auftragstypen
INCLUDE lcokotyp.
* BDE-Satzarten
INCLUDE lcorsart.
* Vorratsherkunft und Applikation
INCLUDE lcorpher.
* For time zone support
INCLUDE lcorufs3.
*---------------------------------------------------------------------*
*        Selection                                                    *
*---------------------------------------------------------------------*
PARAMETERS: herkunft TYPE afrh-afori.

PARAMETERS: p_old TYPE coru_list_display DEFAULT ' ' NO-DISPLAY.
*{   INSERT         CD1K958337                                        2

at selection-screen.
  sy-subrc = 0.

*}   INSERT

*---------------------------------------------------------------------
* LOAD OF PROGRAM
*---------------------------------------------------------------------
*LOAD-OF-PROGRAM.
**--- check if time zone support is active for the function group once
*  PERFORM initialize_time_zone.
**--- set time zone button for output list
*  PERFORM create_time_zone_button_f90 USING 'FC01'.

START-OF-SELECTION.

  IF NOT p_old IS INITIAL OR
     herkunft = afrhori-pi OR       "Proze#auftrag
     herkunft = afrhori-pp OR       "Fertigungsauftrag
     herkunft = afrhori-sy.         "Systemfehler
*   CUA-Status setzen
    IF herkunft = afrhori-sy.
      SET PF-STATUS 'SBDE'.
    ELSE.
      SET PF-STATUS 'MAIN' EXCLUDING excl_tab.
    ENDIF.
    IF herkunft = afrhori-pi OR
       herkunft = afrhori-pp.
      SET TITLEBAR '001'.
    ENDIF.
    afru_wf-rvope = yx.
    SELECT * FROM m_afrhb INTO TABLE m_afrhb_tab.
    IF NOT m_afrhb_tab[] IS INITIAL.
      SELECT * FROM afrh INTO TABLE afrh_tab
               FOR ALL ENTRIES IN m_afrhb_tab
               WHERE afori = herkunft
               AND   afruv = m_afrhb_tab-afruv
               ORDER BY PRIMARY KEY.
      IF sy-dbcnt > 0.
        found = yx.
*       Nachbearbeitung l#schen, wenn keine Positionen vorhanden
        SELECT * FROM afrv INTO TABLE afrv_tab
                 FOR ALL ENTRIES IN afrh_tab
                 WHERE afori = afrh_tab-afori
                 AND   afruv = afrh_tab-afruv
                 AND   beaknz = space.
        SORT afrv_tab BY afori afruv.

        LOOP AT afrh_tab.
          READ TABLE afrv_tab WITH KEY
                        afori = afrh_tab-afori
                        afruv = afrh_tab-afruv
                        BINARY SEARCH.
          IF NOT sy-subrc IS INITIAL.

            CALL FUNCTION 'DELETE_CONFIRMATION_RESERVE'
              EXPORTING
                afori_imp = afrh_tab-afori
                afruv_imp = afrh_tab-afruv
                no_dialog = yx.
            DELETE afrh_tab.

          ENDIF.
*{   INSERT         CD1K958337                                        1
*........ Filter entries based on entered plant
*        if afrv_tab-werks ne p_werks or          "js-001
        if not afrv_tab-werks in s_werks or       "js-001
           not afrv_tab-arbpl in s_arbpl.
* begin of change air21099 dd.2008/04/11
*         delete afrh_tab index sy-tabix.
          delete afrh_tab where afori = afrh_tab-afori
                            and afruv = afrh_tab-afruv.
* end of change air21099 dd.2008/04/11
          delete afrv_tab where afori = afrh_tab-afori
                            and afruv = afrh_tab-afruv.
        endif.
*}   INSERT
        ENDLOOP.
      ELSE.
        found = space.
      ENDIF.
*{   INSERT         CD1K958337                                        2
    if found ne space.
*...... Write header
*** js-001 * begin ***
*      write: 'Selected plant: ',
*             p_werks.
      loop at s_werks.
        write: / 'Selected plants: ',
                 s_werks-low.
        if not s_werks-high is initial.
          write: '-->', s_werks-high.
        endif.
      endloop.
*** js-001 * end ***
      skip.
      format color col_heading.
      WRITE: / sy-uline(123),
             / sy-vline,
               'Created',
               14 sy-vline,
               'Time',
               25 sy-vline,
               'Description',
               108 sy-vline,
               'Created by',
               123 sy-vline,
             / sy-uline(123).
      format color col_normal.
    endif.

*}   INSERT
      LOOP AT afrh_tab.
        IF afrh_tab-afruv(4) = 'BAPI' OR
           afrh_tab-afruv+4(8)  CN '1234567890' OR
           afrh_tab-afruv+13(4) CN '1234567890'.
*         keine Original-BDE-Fehlers#tze
          WRITE: / afrh_tab-afruv,
                   afrh_tab-afrvtxt,
                   afrh_tab-ernam,
                   afrh_tab-erdat.
          afrh = afrh_tab.
          HIDE afrh.
          CONTINUE.
        ENDIF.
        afruv_chk = afrh_tab-afruv.
        IF afruv_chk-fillr IS INITIAL.
*         alter Schl¨¹ssel
          afruv_old = afrh_tab-afruv.
          out_tab-datum = afruv_old-datum.
          out_tab-uzeit = afruv_old-uzeit.
          out_tab-afruv = afrh_tab-afruv.
        ELSE.
*         neuer Schl¨¹ssel
          afruv_new = afrh_tab-afruv.
          out_tab-datum = afrh_tab-erdat.
          out_tab-uzeit = afruv_new-uzeit.
          out_tab-afruv = afrh_tab-afruv.
        ENDIF.
        APPEND out_tab.
      ENDLOOP.
      SORT out_tab BY datum uzeit.

      LOOP AT out_tab.
** convert the out put date and time as per user time zone
        BREAK-POINT ID eam_tzs_gen.
        PERFORM change_conf_list_disp CHANGING
                              out_tab-datum
                              out_tab-uzeit.

        READ TABLE afrh_tab INTO afrh
                       WITH KEY afori = herkunft
                                afruv = out_tab-afruv
                                BINARY SEARCH.
*{   REPLACE        CD1K958337                                        3
*\        WRITE: / out_tab-datum,
*\                 out_tab-uzeit,
*\                 afrh-afrvtxt,
*\                 afrh-ernam.
*...... Get message link
      clear ld_message.
      READ TABLE afrv_tab WITH KEY
                      afori = afrh-afori
                      afruv = afrh-afruv
                      BINARY SEARCH.
      if sy-subrc eq 0.
        select single *
        from pderr
        where pdsnr eq afrv_tab-pdsnr.

        CALL FUNCTION 'MESSAGE_TEXT_BUILD'
          EXPORTING
            msgid                     = pderr-msgid
            msgnr                     = pderr-msgno
            MSGV1                     = pderr-msgv1
            MSGV2                     = pderr-msgv2
            MSGV3                     = pderr-msgv3
            MSGV4                     = pderr-msgv4
          IMPORTING
            MESSAGE_TEXT_OUTPUT       = ld_message
                  .
      endif.

      WRITE: / sy-vline,
               out_tab-datum,
               sy-vline,
               out_tab-uzeit,
               sy-vline,
               (80) ld_message,
*              afrh-afrvtxt,
               sy-vline,
               afrh-ernam,
               sy-vline.
*}   REPLACE
        HIDE afrh.
      ENDLOOP.
    ENDIF.
    CLEAR afrh.

    IF found IS INITIAL.
      MESSAGE i255.
*{   INSERT         CD1K958337                                        4
  else.
    WRITE: / sy-uline(123).
*}   INSERT
    ENDIF.
  ELSEIF herkunft = afrhori-pm OR        "Netzplan
         herkunft = afrhori-ps OR        "Instandhaltung
         herkunft = afrhori-re.          "Kanban
*   display PM-, PS and Kanban-reserve using ALV-Grid
    PERFORM list_entries_alv.
  ENDIF.

AT LINE-SELECTION.

  IF sy-pfkey = 'LST1'.
*   Istdaten anzeigen
    IF herkunft EQ afrhori-re.                "Andere Routine f¨¹r Kanban
      PERFORM show_act_data_kanban.
    ELSE.
      PERFORM show_act_data.
    ENDIF.
  ELSE.
*   Daten ¨¹ber Memory an Sammelr¨¹ckmeldung ¨¹bergeben
    IF herkunft <> afrhori-pp AND
       herkunft <> afrhori-pi.
      EXPORT afrh
             flg_wf
             afru_wf-rvall
             afru_wf-rvclo
             afru_wf-rvope
      TO MEMORY ID 'WF0'.
    ENDIF.

*   abh#ngig von der Herkunft verschiedene Verarbeitungslogiken
    CASE herkunft.
      WHEN afrhori-pp.
*       einzelne Fehlers#tze auflisten
        PERFORM detail_list.
      WHEN afrhori-pi.
*       einzelne Fehlers#tze auflisten
        PERFORM detail_list.
      WHEN afrhori-re.
*       einzelne Fehlers#tze auflisten
        PERFORM detail_list_kanban.
      WHEN afrhori-ps.
*       Sammelr¨¹ckmeldung aufrufen
        CALL TRANSACTION 'CN27'.
      WHEN afrhori-pm.
*       Sammelr¨¹ckmeldung aufrufen
        CALL TRANSACTION 'IW44'.
    ENDCASE.

    CLEAR afrh.
  ENDIF.

AT USER-COMMAND.

  CASE sy-ucomm.
*   Zur¨¹ck, Abbrechen bzw. Beenden
    WHEN fc_bacl OR
         fc_rwl  OR
         fc_end.
      LOOP AT tmp_afrv WHERE NOT beaknz IS INITIAL.
        EXIT.
      ENDLOOP.
      IF sy-subrc = 0.
*       Sicherheitsabfrage
        CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
          EXPORTING
            diagnosetext1 = text-011
            textline1     = text-012
            titel         = text-003
          IMPORTING
            answer        = antwort.                        "#EC *
        CASE antwort.
          WHEN ya.
            EXIT.
          WHEN yja.
*           R¨¹ckmeldungen sichern
            PERFORM save_changes.
        ENDCASE.
      ENDIF.
      IF sy-ucomm = fc_end.
        LEAVE TO SCREEN 0.
      ELSE.
        LEAVE TO TRANSACTION sy-tcode.
      ENDIF.
*   R¨¹ckmeldungen sichern
    WHEN fc_save.
      PERFORM save_changes.
*   Fehlersatz l#schen
    WHEN fc_dele.
      PERFORM delete_entry.
*   Fehler anzeigen
    WHEN fc_fail.
      PERFORM show_failure.
*   Istdaten anzeigen
    WHEN fc_istr.
      IF herkunft EQ afrhori-re.             "Andere Routine f¨¹r Kanban
        PERFORM show_act_data_kanban.
      ELSE.
        PERFORM show_act_data.
      ENDIF.
*   Vorrat l#schen
    WHEN fc_del.
      CALL FUNCTION 'DELETE_CONFIRMATION_RESERVE'
        EXPORTING
          afori_imp = herkunft
          afruv_imp = afrh-afruv.
      MODIFY CURRENT LINE LINE FORMAT INVERSE.
      CLEAR afrh.
*   Vorratseinzels#tze auflisten (nur Herkunft AFRHORI-SY)
    WHEN 'AVLS'.
      PERFORM systemfehler_list.
      CLEAR afrh.
    WHEN 'HEX '.
      PERFORM hexadecimal_list.
      CLEAR afrh.
  ENDCASE.

TOP-OF-PAGE DURING LINE-SELECTION.
  CASE sy-pfkey.
    WHEN 'LST1'.
      FORMAT COLOR COL_HEADING.
      tmp_afrv-beaknz = beaknz_hdr.    "Zeilen als Header-Zeilen kennz.
      HIDE: tmp_afrv-beaknz.
      SKIP.
      HIDE: tmp_afrv-beaknz.
      ULINE.
      HIDE: tmp_afrv-beaknz.
      IF herkunft EQ afrhori-re.
        WRITE /5 text-007.            "f¨¹r Kanban eigene #berschrift
      ELSE.
        WRITE /5 text-002.
      ENDIF.
      WRITE  1 sy-vline.
      POSITION sy-linsz.
      WRITE    sy-vline.
      HIDE: tmp_afrv-beaknz.
      ULINE.
      HIDE: tmp_afrv-beaknz.
  ENDCASE.

*&---------------------------------------------------------------------*
*&      Form  DETAIL_LIST
*&---------------------------------------------------------------------*
*       Liste mit Einzels#tze aus dem PP                               *
*----------------------------------------------------------------------*
FORM detail_list.

  DATA: flg_locked  TYPE c,
        l_user      LIKE sy-msgv1.

  REFRESH tmp_afrv.
  CLEAR   tmp_afrv.

* Flag "Vorrat bearbeitet" zur¨¹cksetzen
  CALL FUNCTION 'CO_RP_RESET_FLG_UPD'.

* 'Radio-bottons' setzen
  CLEAR afru_wf.
  afru_wf-rvope = yx.
  CALL FUNCTION 'READ_CONFIRMATION_RESERVE'
    EXPORTING
      afori_imp = herkunft
      afruv_imp = afrh-afruv
      rvall_imp = afru_wf-rvall
      rvclo_imp = afru_wf-rvclo
      rvope_imp = afru_wf-rvope
    IMPORTING
      afrh_exp  = afrh
    TABLES
      afrv_tab  = tmp_afrv
    EXCEPTIONS
      not_found = 01.

  IF NOT sy-subrc IS INITIAL.
    EXIT.
  ENDIF.
* alle bereits bearbeiteten Fehlers#tze aus Vorrat entfernen
  LOOP AT tmp_afrv WHERE NOT beaknz IS INITIAL.
    DELETE tmp_afrv.
  ENDLOOP.
  DESCRIBE TABLE tmp_afrv LINES sy-tfill.
  IF sy-tfill = 0.
    EXIT.
  ENDIF.

  SET PF-STATUS 'LST1'.

  NEW-PAGE LINE-SIZE 80.

  CLEAR flg_intensif.
  FORMAT COLOR COL_NORMAL.
  LOOP AT tmp_afrv.
* Lock AFRV also to be consistent with CO16N
    CALL FUNCTION 'ENQUEUE_EAFRV'
      EXPORTING
        afori          = tmp_afrv-afori
        afruv          = tmp_afrv-afruv
        counter        = tmp_afrv-counter
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      flg_locked = yx.
*     don't offer this line for selection
      DELETE tmp_afrv.
      CONTINUE.
    ENDIF.
    IF flg_intensif = yx.
      FORMAT INTENSIFIED.
      CLEAR flg_intensif.
    ELSE.
      FORMAT INTENSIFIED OFF.
      flg_intensif = yx.
    ENDIF.
    WRITE: /03 rc27x-flg_sel AS CHECKBOX,
            05 tmp_afrv-aufnr,
            18 tmp_afrv-aplfl,
            25 tmp_afrv-vornr,
            30 tmp_afrv-uvorn,
            35 tmp_afrv-kapar,
            39 tmp_afrv-split NO-ZERO,
            43 tmp_afrv-satza,
            47 tmp_afrv-ldate,
            58 tmp_afrv-ltime,
            67 tmp_afrv-werks,
            72 tmp_afrv-arbpl.
    WRITE 1  sy-vline.
    POSITION sy-linsz.
    WRITE    sy-vline.
    CLEAR : tmp_afrv-beaknz, rmzhl_upd.
    HIDE: tmp_afrv-afori, tmp_afrv-afruv, tmp_afrv-counter,
          tmp_afrv-beaknz, rmzhl_upd.
  ENDLOOP.
  IF flg_locked = yx.
    l_user = sy-msgv1.
*   R¨¹ckmeldevorrat &1 wird bereits von &2 bearbeitet
    MESSAGE i242 WITH tmp_afrv-afruv l_user.
  ENDIF.
* Any entry left?
  DESCRIBE TABLE tmp_afrv LINES sy-tfill.
  IF sy-tfill = 0.
    EXIT.
  ENDIF.

  ULINE.

ENDFORM.                               " DETAIL_LIST
*&---------------------------------------------------------------------*
*&      Form  DELETE_ENTRY                                             *
*&---------------------------------------------------------------------*
*       markierten Eintrag l#schen                                     *
*----------------------------------------------------------------------*
FORM delete_entry.

  DATA: tmp_tline(40).
  DATA: l_auart TYPE caufvd-auart.

  tabix = 0.
  zeile = 0.
  DO.
    zeile = zeile + 1.
    READ LINE zeile.
    IF sy-subrc <> 0.
      zeile = 0.
      EXIT.
    ENDIF.
    CHECK sy-lisel+2(1) = yx.
    IF tmp_afrv-beaknz = beaknz_del OR
       tmp_afrv-beaknz = beaknz_hdr.
      zeile = 0.
    ENDIF.
    EXIT.
  ENDDO.
  IF zeile = 0.
    GET CURSOR LINE zeile.
    READ LINE zeile.
    IF tmp_afrv-beaknz = beaknz_del OR
       tmp_afrv-beaknz = beaknz_hdr.
      zeile = 0.
    ENDIF.
  ENDIF.
  CHECK zeile <> 0.
  IF text-005 CA ' '.
  ENDIF.
  feldpos = sy-fdpos.
  WRITE text-005 TO tmp_tline(feldpos).
  feldpos = feldpos + 1.
  IF tmp_afrv-autyp = '10' OR
     tmp_afrv-autyp = '20' OR
     tmp_afrv-autyp = '40'.
    SELECT SINGLE auart FROM caufv INTO l_auart
                       WHERE aufnr = tmp_afrv-aufnr.
    IF sy-subrc IS INITIAL.
      AUTHORITY-CHECK OBJECT 'C_AFRU_AWK'
           ID 'ACTVT'  FIELD '02'
           ID 'WERKS'  FIELD tmp_afrv-werks
           ID 'AUFART' FIELD l_auart.
      IF NOT sy-subrc IS INITIAL.
        MESSAGE e196 WITH l_auart tmp_afrv-werks.
      ENDIF.
    ENDIF.
  ENDIF.
  WRITE tmp_afrv-aufnr TO tmp_tline+feldpos.
* Popup mit Sicherheitsabfrage beim Stornieren
  CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
    EXPORTING
      diagnosetext1 = text-004
      diagnosetext2 = tmp_tline
      textline1     = text-006
      titel         = text-003
    IMPORTING
      answer        = antwort.                              "#EC *
  CHECK antwort = yja.
  MOVE-CORRESPONDING tmp_afrv TO afrv_key.                  "#EC ENHOK
  afrv_key-mandt = sy-mandt.
  READ TABLE tmp_afrv WITH KEY afrv_key.
  CHECK sy-subrc = 0.
  tabix = sy-tabix.
  IF tmp_afrv-beaknz = beaknz_upd.
*   AFRU-Satz aus Belegtabelle l#schen
    CALL FUNCTION 'CO_RU_CONFIRMATION'
      EXPORTING
        delete_flg = yx
        rmzhl_imp  = tmp_afrv-rmzhl
        rueck_imp  = tmp_afrv-rueck.
  ENDIF.
  READ LINE zeile.
  tmp_afrv-beaknz = beaknz_del.
  MODIFY tmp_afrv INDEX tabix.
  MODIFY LINE zeile LINE FORMAT  COLOR col_negative
                    FIELD FORMAT rc27x-flg_sel INPUT OFF
                    FIELD VALUE  rc27x-flg_sel FROM space.

ENDFORM.                               " DELETE_ENTRY
*&---------------------------------------------------------------------*
*&      Form  DELETE_ENTRY_ALV                                         *
*&---------------------------------------------------------------------*
*       markierten Eintrag l#schen                                     *
*----------------------------------------------------------------------*
FORM delete_entry_alv.

  DATA: l_tline(40).
  DATA: l_fail TYPE xfeld.
  DATA: l_index1 LIKE sy-tabix,
        l_index2 LIKE sy-tabix.

* ALV-Detailliste mit Loeschbutton derzeit nur bei Kanban
  IF herkunft = afrhori-re.
*   check whether not more than one entry is marked
    PERFORM check_mark_single USING yx CHANGING l_fail.
    CHECK l_fail IS INITIAL.
*   check whether at least one entry is marked
    PERFORM check_mark_any CHANGING l_fail.
    CHECK l_fail IS INITIAL.
    READ TABLE gt_afrv_alv WITH KEY box = yx.
    IF gt_afrv_alv-beaknz = beaknz_del OR
       gt_afrv_alv-beaknz = beaknz_hdr.
      EXIT.
    ENDIF.
    l_index1 = sy-tabix.
    CONCATENATE text-015 gt_afrv_alv-pkkey INTO l_tline
      SEPARATED BY space.
*   Popup to confirm with message
    CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
      EXPORTING
        diagnosetext1 = text-004
        diagnosetext2 = l_tline
        textline1     = text-006
        titel         = text-003
      IMPORTING
        answer        = antwort.                            "#EC *
    CHECK antwort = yja.
    MOVE-CORRESPONDING gt_afrv_alv TO afrv_key.             "#EC ENHOK
    afrv_key-mandt = sy-mandt.
    READ TABLE tmp_afrv WITH KEY afrv_key.
    CHECK sy-subrc = 0.
    l_index2 = sy-tabix.
*   set deletion indicator
    gt_afrv_alv-beaknz = beaknz_del.
    gt_afrv_alv-status = icon_delete.
    MODIFY gt_afrv_alv INDEX l_index1.
    tmp_afrv-beaknz = beaknz_del.
    MODIFY tmp_afrv INDEX l_index2.
  ELSE.
* ......
  ENDIF.

ENDFORM.                               " DELETE_ENTRY_ALV
*&---------------------------------------------------------------------*
*&      Form  DELETE_RESERVE_ALV                                       *
*&---------------------------------------------------------------------*
*       Markierten Vorrat l#schen                                      *
*----------------------------------------------------------------------*
FORM delete_reserve_alv.

  DATA: l_fail TYPE xfeld.

* check whether not more than one entry is marked
  PERFORM check_mark_single USING space CHANGING l_fail.
  CHECK l_fail IS INITIAL.

* AFRH einlesen
  READ TABLE gt_afrh_alv INTO afrh WITH KEY afori = herkunft
                                            afruv = gt_out_tab-afruv.
  IF sy-subrc = 0.
    CALL FUNCTION 'DELETE_CONFIRMATION_RESERVE'
      EXPORTING
        afori_imp = herkunft
        afruv_imp = afrh-afruv.
    CLEAR afrh.
*   refresh
    PERFORM refresh_alv.
  ELSE.
*   darf nicht sein...
    MESSAGE a888(ru) WITH sy-repid.
  ENDIF.

ENDFORM.                               " DELETE_RESERVE_ALV
*----------------------------------------------------------------------*
*       FORM CHECK_MARK_SINGLE                                         *
*----------------------------------------------------------------------*
*       Pruefen, ob nur ein Eintrag markiert ist                       *
*----------------------------------------------------------------------*
FORM check_mark_single USING i_from_afrv TYPE xfeld
                       CHANGING e_fail TYPE xfeld.

  DATA: l_tabix LIKE sy-tabix.

  IF i_from_afrv IS INITIAL.
    LOOP AT gt_out_tab WHERE NOT box IS INITIAL.
      l_tabix = l_tabix + 1.
      IF l_tabix > 1.
        MESSAGE s280.
        e_fail = yx.
        EXIT.
      ENDIF.
    ENDLOOP.
  ELSE.
    LOOP AT gt_afrv_alv WHERE NOT box IS INITIAL.
      l_tabix = l_tabix + 1.
      IF l_tabix > 1.
        MESSAGE s280.
        e_fail = yx.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                               " CHECK_MARK_SINGLE
*----------------------------------------------------------------------*
*       FORM CHECK_MARK_ANY                                            *
*----------------------------------------------------------------------*
*       Pruefen, ob mindestens ein Eintrag markiert ist                *
*----------------------------------------------------------------------*
FORM check_mark_any CHANGING e_fail TYPE xfeld.

  LOOP AT gt_afrv_alv WHERE NOT box IS INITIAL.
    EXIT.
  ENDLOOP.
  IF NOT sy-subrc IS INITIAL.
    MESSAGE s279.
    e_fail = yx.
    EXIT.
  ENDIF.

ENDFORM.                               "CHECK_MARK_ANY
*&---------------------------------------------------------------------*
*&      Form  LIST_ENTRIES_ALV
*&---------------------------------------------------------------------*
*       Vorratsliste ALV                                               *
*----------------------------------------------------------------------*
FORM list_entries_alv.

  DATA: l_found TYPE xfeld.
  DATA: l_multi TYPE xfeld.

  l_multi = yx.
  afru_wf-rvope = yx.
  SELECT * FROM m_afrhb INTO TABLE m_afrhb_tab.
  IF NOT m_afrhb_tab[] IS INITIAL.
    SELECT * FROM afrh INTO TABLE gt_afrh_alv
             FOR ALL ENTRIES IN m_afrhb_tab
             WHERE afori = herkunft
             AND   afruv = m_afrhb_tab-afruv
             ORDER BY PRIMARY KEY.
    IF sy-dbcnt > 0.
      l_found = yx.
*     Nachbearbeitung l#schen, wenn keine Positionen vorhanden
      SELECT * FROM afrv INTO CORRESPONDING FIELDS OF TABLE gt_afrv_alv
               FOR ALL ENTRIES IN gt_afrh_alv
               WHERE afori = gt_afrh_alv-afori
               AND   afruv = gt_afrh_alv-afruv
               AND  beaknz = space.
      SORT gt_afrv_alv BY afori afruv.

      LOOP AT gt_afrh_alv.
        READ TABLE gt_afrv_alv WITH KEY
                      afori = gt_afrh_alv-afori
                      afruv = gt_afrh_alv-afruv
                      BINARY SEARCH.
        IF NOT sy-subrc IS INITIAL.
*         gesamter R¨¹ckmeldevorrat l#schen
          CALL FUNCTION 'DELETE_CONFIRMATION_RESERVE'
            EXPORTING
              afori_imp = gt_afrh_alv-afori
              afruv_imp = gt_afrh_alv-afruv
              no_dialog = yx.
          DELETE gt_afrh_alv.
        ENDIF.
*{   INSERT         CD1K958337                                        1
*........ Filter entries based on entered plant
*        if gt_afrv_alv-werks ne p_werks or       "js-001
        if not gt_afrv_alv-werks in s_werks or    "js-001
           not gt_afrv_alv-arbpl in s_arbpl.
          delete gt_afrh_alv where afori = gt_afrh_alv-afori
                               and afruv = gt_afrh_alv-afruv.
          delete gt_afrv_alv where afori = gt_afrh_alv-afori
                               and afruv = gt_afrh_alv-afruv.
        endif.
*}   INSERT
      ENDLOOP.
    ELSE.
      l_found = space.
    ENDIF.
    LOOP AT gt_afrh_alv.
      IF gt_afrh_alv-afruv(4) = 'BAPI' OR
         gt_afrh_alv-afruv+4(8)  CN '1234567890' OR
         gt_afrh_alv-afruv+13(4) CN '1234567890'.
*       keine Original-BDE-Fehlers#tze
        gt_out_tab-afruv   = gt_afrh_alv-afruv.
        gt_out_tab-afrvtxt = gt_afrh_alv-afrvtxt.
        gt_out_tab-ernam   = gt_afrh_alv-ernam.
        gt_out_tab-datum   = gt_afrh_alv-erdat.
        gt_out_tab-uzeit   = gt_afrh_alv-afruv+12(6).
        BREAK-POINT ID eam_tzs_gen.
** convert the out put date and time as per user time zone
        PERFORM change_conf_list_disp CHANGING
                  gt_out_tab-datum
                  gt_out_tab-uzeit.

        APPEND gt_out_tab.
        afrh = gt_afrh_alv.
        CONTINUE.
      ENDIF.
      afruv_chk = gt_afrh_alv-afruv.
      IF afruv_chk-fillr IS INITIAL.
*       alter Schl¨¹ssel
        afruv_old = gt_afrh_alv-afruv.
        out_tab-datum = afruv_old-datum.
        out_tab-uzeit = afruv_old-uzeit.
        out_tab-afruv = gt_afrh_alv-afruv.
      ELSE.
*       neuer Schl¨¹ssel
        afruv_new = gt_afrh_alv-afruv.
        out_tab-datum = gt_afrh_alv-erdat.
        out_tab-uzeit = afruv_new-uzeit.
        out_tab-afruv = gt_afrh_alv-afruv.
      ENDIF.
      BREAK-POINT ID eam_tzs_gen.
** convert the out put date and time as per user time zone
      PERFORM change_conf_list_disp CHANGING
               out_tab-datum
               out_tab-uzeit.

      APPEND out_tab.
    ENDLOOP.
    SORT out_tab BY datum uzeit.
    LOOP AT out_tab.
      READ TABLE gt_afrh_alv INTO afrh
                     WITH KEY afori = herkunft
                              afruv = out_tab-afruv
                              BINARY SEARCH.
      gt_out_tab-afruv   = out_tab-afruv.
*{   REPLACE        CD1K958337                                        2
*\      gt_out_tab-afrvtxt = afrh-afrvtxt.
*...... Get message link
        clear ld_message.
        READ TABLE gt_afrv_alv WITH KEY
                      afori = afrh-afori
                      afruv = afrh-afruv
                      BINARY SEARCH.
        if sy-subrc eq 0.
          select single *
          from pderr
          where pdsnr eq gt_afrv_alv-pdsnr.

          CALL FUNCTION 'MESSAGE_TEXT_BUILD'
            EXPORTING
              msgid                     = pderr-msgid
              msgnr                     = pderr-msgno
              MSGV1                     = pderr-msgv1
              MSGV2                     = pderr-msgv2
              MSGV3                     = pderr-msgv3
              MSGV4                     = pderr-msgv4
            IMPORTING
              MESSAGE_TEXT_OUTPUT       = ld_message.
        endif.
        gt_out_tab-afrvtxt = ld_message.
*}   REPLACE
      gt_out_tab-ernam   = afrh-ernam.
      gt_out_tab-datum   = out_tab-datum.
      gt_out_tab-uzeit   = out_tab-uzeit.

      APPEND gt_out_tab.
    ENDLOOP.
    IF NOT gt_out_tab[] IS INITIAL.
*     define layout
      PERFORM layout_build USING gs_layout.
*     build up fieldcatalog
      CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
        EXPORTING
          i_program_name     = g_repid
          i_internal_tabname = 'GT_OUT_FC'
          i_inclname         = g_repid
        CHANGING
          ct_fieldcat        = gt_fieldcat.
*     create events table
      PERFORM set_events_afrh CHANGING gt_events.
*     create title
      PERFORM title_build USING l_multi CHANGING g_title.
*     create variant
      PERFORM variant_build_afrh CHANGING gs_variant.
*     display list
      CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
        EXPORTING
          i_callback_program       = g_repid
          i_callback_pf_status_set = g_status_set_afrh
          i_callback_user_command  = g_user_command_afrh
          is_layout                = gs_layout
          it_fieldcat              = gt_fieldcat[]
          i_grid_title             = g_title
          i_default                = 'X'
          i_save                   = 'A'
          is_variant               = gs_variant
          it_events                = gt_events
        TABLES
          t_outtab                 = gt_out_tab
        EXCEPTIONS
          program_error            = 1
          OTHERS                   = 2.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
*{   INSERT         CD1K958337                                        3
    else.
      message i255.
*}   INSERT
    ENDIF.
  ENDIF.
  CLEAR afrh.
  IF l_found IS INITIAL.
    MESSAGE i255.
  ENDIF.

ENDFORM.                               " LIST_ENTRIES_ALV
*&---------------------------------------------------------------------*
*&      Form  PICK_ENTRY_ALV                                           *
*&---------------------------------------------------------------------*
*       Eintrag aus Vorratsliste ¨¹bernehmen und im Detail bearbeiten   *
*----------------------------------------------------------------------*
FORM pick_entry_alv.

  DATA: l_fail TYPE xfeld.

*   check whether not more than one entry is marked
    PERFORM check_mark_single USING space CHANGING l_fail.
    CHECK l_fail IS INITIAL.
*   write data back into AFRH
    READ TABLE gt_afrh_alv INTO afrh WITH KEY afori = herkunft
                                              afruv = gt_out_tab-afruv.
    IF sy-subrc = 0.
* export data to memory for PM/PS-collective entry
      IF herkunft = afrhori-pm OR
         herkunft = afrhori-ps .
        EXPORT afrh
             flg_wf
             afru_wf-rvall
             afru_wf-rvclo
             afru_wf-rvope
      TO MEMORY ID 'WF0'.
      ENDIF.
    ELSE.
*     should never happen...
      MESSAGE a888(ru) WITH sy-repid.
    ENDIF.

* origin-dependent follow ups.....
  CASE herkunft.
    WHEN afrhori-ps.
*     call collective entry
      CALL TRANSACTION 'CN27'.
    WHEN afrhori-pm.
*     call collective entry
      CALL TRANSACTION 'IW44'.
    WHEN afrhori-re.
*     call Kanban detail list
      PERFORM detail_list_kanban_alv.
    WHEN OTHERS.
*     Not possible since ALV is called for PS, PM und RE only
  ENDCASE.
  CLEAR afrh.

ENDFORM.                               " PICK_ENTRY_ALV
*&---------------------------------------------------------------------*
*&      Form  SHOW_ACT_DATA_ALV                                        *
*&---------------------------------------------------------------------*
*       Eintrag aus der Detailliste bearbeiten                         *
*----------------------------------------------------------------------*
FORM show_act_data_alv.

* ALV-detail list currently for Kanban only
  IF herkunft = afrhori-re.
    PERFORM show_act_data_kanban.
  ELSE.
* ......
  ENDIF.

ENDFORM.                               " SHOW_ACT_DATA_ALV
*&---------------------------------------------------------------------*
*&      Form  LEAVE_ALV                                                *
*&---------------------------------------------------------------------*
*       Einzelliste verlassen                                          *
*----------------------------------------------------------------------*
FORM leave_alv.

  LOOP AT tmp_afrv WHERE NOT beaknz IS INITIAL.
    EXIT.
  ENDLOOP.
  IF sy-subrc = 0.
*   Popup to confirm with message
    CALL FUNCTION 'POPUP_TO_CONFIRM_WITH_MESSAGE'
      EXPORTING
        diagnosetext1 = text-011
        textline1     = text-012
        titel         = text-003
      IMPORTING
        answer        = antwort.                            "#EC *
    CASE antwort.
      WHEN ya.
        EXIT.
      WHEN yja.
        PERFORM save_changes.
    ENDCASE.
  ENDIF.
* back to Reserve Screen
  LEAVE TO TRANSACTION sy-tcode.

ENDFORM.                               " LEAVE_ALV
*&---------------------------------------------------------------------*
*&      Form  REFRESH_ALV                                              *
*&---------------------------------------------------------------------*
*       Vorrat aktualisieren                                           *
*----------------------------------------------------------------------*
FORM refresh_alv.

  DATA: l_found TYPE xfeld.

  CLEAR:   gt_afrh_alv,
           gt_afrv_alv,
           gt_out_tab,
           out_tab.
  REFRESH: gt_afrh_alv,
           gt_afrv_alv,
           gt_out_tab,
           out_tab.
  afru_wf-rvope = yx.
  SELECT * FROM m_afrhb INTO TABLE m_afrhb_tab.
  IF NOT m_afrhb_tab[] IS INITIAL.
    SELECT * FROM afrh INTO TABLE gt_afrh_alv
             FOR ALL ENTRIES IN m_afrhb_tab
             WHERE afori = herkunft
             AND   afruv = m_afrhb_tab-afruv
             ORDER BY PRIMARY KEY.
    IF sy-dbcnt > 0.
      l_found = yx.
*     Nachbearbeitung l#schen, wenn keine Positionen vorhanden
      SELECT * FROM afrv INTO CORRESPONDING FIELDS OF TABLE gt_afrv_alv
               FOR ALL ENTRIES IN gt_afrh_alv
               WHERE afori = gt_afrh_alv-afori
               AND   afruv = gt_afrh_alv-afruv
               AND  beaknz = space.
      SORT gt_afrv_alv BY afori afruv.

      LOOP AT gt_afrh_alv.
        READ TABLE gt_afrv_alv WITH KEY
                      afori = gt_afrh_alv-afori
                      afruv = gt_afrh_alv-afruv
                      BINARY SEARCH.
        IF NOT sy-subrc IS INITIAL.
*         gesamter R¨¹ckmeldevorrat l#schen
          CALL FUNCTION 'DELETE_CONFIRMATION_RESERVE'
            EXPORTING
              afori_imp = gt_afrh_alv-afori
              afruv_imp = gt_afrh_alv-afruv
              no_dialog = yx.
          DELETE gt_afrh_alv.
        ENDIF.
*{   INSERT         CD1K958337                                        1
*...... Filter entries based on entered plant
*        if gt_afrv_alv-werks ne p_werks or       "js-001
        if not gt_afrv_alv-werks in s_werks or    "js-001
           not gt_afrv_alv-arbpl in s_arbpl.
          delete gt_afrh_alv where afori = gt_afrh_alv-afori
                               and afruv = gt_afrh_alv-afruv.
          delete gt_afrv_alv where afori = gt_afrh_alv-afori
                               and afruv = gt_afrh_alv-afruv.
        endif.
*}   INSERT
      ENDLOOP.
    ELSE.
      l_found = space.
    ENDIF.
    LOOP AT gt_afrh_alv.
      IF gt_afrh_alv-afruv(4) = 'BAPI' OR
         gt_afrh_alv-afruv+4(8)  CN '1234567890' OR
         gt_afrh_alv-afruv+13(4) CN '1234567890'.
*       keine Original-BDE-Fehlers#tze
        gt_out_tab-afruv   = gt_afrh_alv-afruv.
        gt_out_tab-afrvtxt = gt_afrh_alv-afrvtxt.
        gt_out_tab-ernam   = gt_afrh_alv-ernam.
        gt_out_tab-datum   = gt_afrh_alv-erdat.
        gt_out_tab-uzeit   = gt_afrh_alv-afruv+12(6).
        BREAK-POINT ID eam_tzs_gen.
** convert the out put date and time as per user time zone
        PERFORM change_conf_list_disp CHANGING
                  gt_out_tab-datum
                  gt_out_tab-uzeit.

        APPEND gt_out_tab.
        afrh = gt_afrh_alv.
        CONTINUE.
      ENDIF.
      afruv_chk = gt_afrh_alv-afruv.
      IF afruv_chk-fillr IS INITIAL.
*       alter Schl¨¹ssel
        afruv_old = gt_afrh_alv-afruv.
        out_tab-datum = afruv_old-datum.
        out_tab-uzeit = afruv_old-uzeit.
        out_tab-afruv = gt_afrh_alv-afruv.
      ELSE.
*       neuer Schl¨¹ssel
        afruv_new = gt_afrh_alv-afruv.
        out_tab-datum = gt_afrh_alv-erdat.
        out_tab-uzeit = afruv_new-uzeit.
        out_tab-afruv = gt_afrh_alv-afruv.
      ENDIF.
      BREAK-POINT ID eam_tzs_gen.
** convert the out put date and time as per user time zone
      PERFORM change_conf_list_disp CHANGING
               out_tab-datum
               out_tab-uzeit.

      APPEND out_tab.
    ENDLOOP.
    SORT out_tab BY datum uzeit.
    LOOP AT out_tab.
      READ TABLE gt_afrh_alv INTO afrh
                     WITH KEY afori = herkunft
                              afruv = out_tab-afruv
                              BINARY SEARCH.
      gt_out_tab-afruv   = out_tab-afruv.
*{   REPLACE        CD1K958337                                        2
*\      gt_out_tab-afrvtxt = afrh-afrvtxt.
*...... Get message link
        clear ld_message.
        READ TABLE gt_afrv_alv WITH KEY
                      afori = afrh-afori
                      afruv = afrh-afruv
                      BINARY SEARCH.
        if sy-subrc eq 0.
          select single *
          from pderr
          where pdsnr eq gt_afrv_alv-pdsnr.

          CALL FUNCTION 'MESSAGE_TEXT_BUILD'
            EXPORTING
              msgid                     = pderr-msgid
              msgnr                     = pderr-msgno
              MSGV1                     = pderr-msgv1
              MSGV2                     = pderr-msgv2
              MSGV3                     = pderr-msgv3
              MSGV4                     = pderr-msgv4
            IMPORTING
              MESSAGE_TEXT_OUTPUT       = ld_message.
        endif.
        gt_out_tab-afrvtxt = ld_message.
*}   REPLACE
      gt_out_tab-ernam   = afrh-ernam.
      gt_out_tab-datum   = out_tab-datum.
      gt_out_tab-uzeit   = out_tab-uzeit.
      APPEND gt_out_tab.
    ENDLOOP.
  ENDIF.
  MESSAGE s754.

ENDFORM.                               " REFRESH_ALV
*&---------------------------------------------------------------------*
*&      Form  SHOW_FAILURE                                             *
*&---------------------------------------------------------------------*
*       zu markiertem Eintrag Fehlermeldung anzeigen                   *
*----------------------------------------------------------------------*
FORM show_failure.

  tabix = 0.
  zeile = 0.
  DO.
    zeile = zeile + 1.
    READ LINE zeile.
    IF sy-subrc <> 0.
      zeile = 0.
      EXIT.
    ENDIF.
    CHECK sy-lisel+2(1) = yx.
    IF tmp_afrv-beaknz = beaknz_del OR
       tmp_afrv-beaknz = beaknz_hdr.
      zeile = 0.
    ENDIF.
    EXIT.
  ENDDO.
  IF zeile = 0.
    GET CURSOR LINE zeile.
    READ LINE zeile.
    IF tmp_afrv-beaknz = beaknz_del OR
       tmp_afrv-beaknz = beaknz_hdr.
      zeile = 0.
    ENDIF.
  ENDIF.
  CHECK zeile <> 0.
  MOVE-CORRESPONDING tmp_afrv TO afrv_key.                  "#EC ENHOK
  afrv_key-mandt = sy-mandt.
  READ TABLE tmp_afrv WITH KEY afrv_key.
  CHECK sy-subrc = 0.
  SELECT SINGLE * FROM pderr
                  WHERE pdsnr = tmp_afrv-pdsnr.
  CHECK sy-subrc = 0.
  CHECK NOT pderr-msgid IS INITIAL AND
        NOT pderr-msgno IS INITIAL.
  MESSAGE ID pderr-msgid TYPE 'I' NUMBER pderr-msgno
             WITH pderr-msgv1 pderr-msgv2
                  pderr-msgv3 pderr-msgv4.

ENDFORM.                               " SHOW_FAILURE
*&---------------------------------------------------------------------*
*&      Form  SHOW_FAILURE_ALV                                         *
*&---------------------------------------------------------------------*
*       zu markiertem Eintrag Fehlermeldung anzeigen                   *
*----------------------------------------------------------------------*
FORM show_failure_alv.

  DATA: l_fail TYPE xfeld.

* check whether not more than one entry is marked
  PERFORM check_mark_single USING yx CHANGING l_fail.
  CHECK l_fail IS INITIAL.
* check whether at least one entry is marked
  PERFORM check_mark_any CHANGING l_fail.
  IF NOT l_fail IS INITIAL.
*   no record marked -> use cursor position
*   Info about cursor's already in header line
  ELSE.
*   process marked entry
    READ TABLE gt_afrv_alv WITH KEY box = yx.
    CHECK sy-subrc = 0.
  ENDIF.

  SELECT SINGLE * FROM pderr
                  WHERE pdsnr = gt_afrv_alv-pdsnr.
  CHECK sy-subrc = 0.
  CHECK NOT pderr-msgid IS INITIAL AND
        NOT pderr-msgno IS INITIAL.
* display failure as info message
  MESSAGE ID pderr-msgid TYPE 'I' NUMBER pderr-msgno
             WITH pderr-msgv1 pderr-msgv2
                  pderr-msgv3 pderr-msgv4.

ENDFORM.                               " SHOW_FAILURE_ALV
*&---------------------------------------------------------------------*
*&      Form  SHOW_ACT_DATA                                            *
*&---------------------------------------------------------------------*
*       Detailbild anzeigen                                            *
*----------------------------------------------------------------------*
FORM show_act_data.

  DATA: BEGIN OF tmp_afvgdg OCCURS 0.
  INCLUDE TYPE afvgdget.
  DATA: END   OF tmp_afvgdg.
  DATA: BEGIN OF tmp_kbedd OCCURS 0.
  INCLUDE TYPE kbedd.
  DATA: END   OF tmp_kbedd.
  DATA: tmp_objnr TYPE afvgd-objnr.

  tabix = 0.
  zeile = 0.
  IF sy-ucomm = 'ISTR'.
    DO.
      zeile = zeile + 1.
      READ LINE zeile.
      IF sy-subrc <> 0.
        zeile = 0.
        EXIT.
      ENDIF.
      CHECK sy-lisel+2(1) = yx.
      IF tmp_afrv-beaknz = beaknz_del OR
         tmp_afrv-beaknz = beaknz_hdr.
        zeile = 0.
      ENDIF.
      EXIT.
    ENDDO.
  ENDIF.
  IF zeile = 0.
    GET CURSOR LINE zeile.
    READ LINE zeile.
    IF tmp_afrv-beaknz = beaknz_del OR
       tmp_afrv-beaknz = beaknz_hdr.
      zeile = 0.
    ENDIF.
  ENDIF.
  CHECK zeile <> 0.
  MOVE-CORRESPONDING tmp_afrv TO afrv_key.                  "#EC ENHOK
  afrv_key-mandt = sy-mandt.
  READ TABLE tmp_afrv WITH KEY afrv_key.
  CHECK sy-subrc = 0.
  tabix = sy-tabix.
  MOVE-CORRESPONDING tmp_afrv TO afrud.                     "#EC ENHOK
  MOVE-CORRESPONDING tmp_afrv TO cooprkey.                  "#EC ENHOK
  IF afrud-satza = bde_satzart-a10 OR
     afrud-satza = bde_satzart-a20 OR
     afrud-satza = bde_satzart-a30 OR
     afrud-satza = bde_satzart-a40 OR
     afrud-satza = bde_satzart-b10 OR
     afrud-satza = bde_satzart-b20 OR
     afrud-satza = bde_satzart-b30 OR
     afrud-satza = bde_satzart-b40 OR
     afrud-satza = bde_satzart-r10 OR
     afrud-satza = bde_satzart-r20 OR
     afrud-satza = bde_satzart-r30 OR
     afrud-satza = bde_satzart-r40 OR
     afrud-satza = bde_satzart-n10 OR
     afrud-satza = bde_satzart-n20 OR
     afrud-satza = bde_satzart-n30 OR
     afrud-satza = bde_satzart-n40 OR
     afrud-satza = bde_satzart-w10 OR
     afrud-satza = bde_satzart-w20 OR
     afrud-satza = bde_satzart-w30 OR
     afrud-satza = bde_satzart-w40.
*  Zeitereignis: Datum Uhrzeit werden ¨¹ber LDATE und LTIME ¨¹bergeben
    CLEAR: afrud-isdd,
           afrud-isdz,
           afrud-ierd,
           afrud-ierz,
           afrud-isbd,
           afrud-isbz,
           afrud-iebd,
           afrud-iebz,
           afrud-isad,
           afrud-isaz,
           afrud-iedd,
           afrud-iedz.
    CASE afrud-satza.
*     Abr¨¹sten PP
      WHEN bde_satzart-a10.
        afrud-isad = tmp_afrv-ldate.
        afrud-isaz = tmp_afrv-ltime.
      WHEN bde_satzart-a20.
        afrud-iedd = tmp_afrv-ldate.
        afrud-iedz = tmp_afrv-ltime.
      WHEN bde_satzart-a30.
        afrud-iedd = tmp_afrv-ldate.
        afrud-iedz = tmp_afrv-ltime.
      WHEN bde_satzart-a40.
        afrud-iedd = tmp_afrv-ldate.
        afrud-iedz = tmp_afrv-ltime.
*     Bearbeiten PP
      WHEN bde_satzart-b10.
        afrud-isbd = tmp_afrv-ldate.
        afrud-isbz = tmp_afrv-ltime.
      WHEN bde_satzart-b20.
        afrud-iebd = tmp_afrv-ldate.
        afrud-iebz = tmp_afrv-ltime.
      WHEN bde_satzart-b30.
        afrud-iebd = tmp_afrv-ldate.
        afrud-iebz = tmp_afrv-ltime.
      WHEN bde_satzart-b40.
        afrud-iebd = tmp_afrv-ldate.
        afrud-iebz = tmp_afrv-ltime.
*     R¨¹sten PP
      WHEN bde_satzart-r10.
        afrud-isdd = tmp_afrv-ldate.
        afrud-isdz = tmp_afrv-ltime.
      WHEN bde_satzart-r20.
        afrud-ierd = tmp_afrv-ldate.
        afrud-ierz = tmp_afrv-ltime.
      WHEN bde_satzart-r30.
        afrud-ierd = tmp_afrv-ldate.
        afrud-ierz = tmp_afrv-ltime.
      WHEN bde_satzart-r40.
        afrud-ierd = tmp_afrv-ldate.
        afrud-ierz = tmp_afrv-ltime.
*     Arbeiten PM
      WHEN bde_satzart-n10.
        afrud-isdd = tmp_afrv-ldate.
        afrud-isdz = tmp_afrv-ltime.
      WHEN bde_satzart-n20.
        afrud-iedd = tmp_afrv-ldate.
        afrud-iedz = tmp_afrv-ltime.
      WHEN bde_satzart-n30.
        afrud-iedd = tmp_afrv-ldate.
        afrud-iedz = tmp_afrv-ltime.
      WHEN bde_satzart-n40.
        afrud-iedd = tmp_afrv-ldate.
        afrud-iedz = tmp_afrv-ltime.
*     Arbeiten PS
      WHEN bde_satzart-w10.
        afrud-isdd = tmp_afrv-ldate.
        afrud-isdz = tmp_afrv-ltime.
      WHEN bde_satzart-w20.
        afrud-iedd = tmp_afrv-ldate.
        afrud-iedz = tmp_afrv-ltime.
      WHEN bde_satzart-w30.
        afrud-iedd = tmp_afrv-ldate.
        afrud-iedz = tmp_afrv-ltime.
      WHEN bde_satzart-w40.
        afrud-iedd = tmp_afrv-ldate.
        afrud-iedz = tmp_afrv-ltime.
    ENDCASE.
  ELSE.
*   Lohnschein: Zeitpunkte Start-/Ende Durchf¨¹hren versorgen
    afrud-isdd = tmp_afrv-isdd.
    afrud-isdz = tmp_afrv-isdz.
    afrud-iedd = tmp_afrv-iedd.
    afrud-iedz = tmp_afrv-iedz.
    IF afrud-isdd IS INITIAL.
      afrud-isdd = tmp_afrv-ldate.
      afrud-isdz = tmp_afrv-ltime.
    ENDIF.
    IF afrud-iedd IS INITIAL.
      afrud-iedd = tmp_afrv-ldate.
      afrud-iedz = tmp_afrv-ltime.
    ENDIF.
  ENDIF.

  CLEAR: afrud-aufnr,
         afrud-aplfl,
         afrud-vornr,
         afrud-uvorn,
         afrud-kapar,
         afrud-kapid,
         afrud-rueck.

  IF tmp_afrv-beaknz = beaknz_upd.
    aktyp_pic = aktyp_ver.
    rmzhl_upd = tmp_afrv-rmzhl.
  ELSE.
    aktyp_pic = aktyp_hin.
    CLEAR rmzhl_upd.
  ENDIF.
  IF herkunft = herkunft_2.
    autyp = auftragstyp-fert.
  ENDIF.
  IF herkunft = herkunft_6.
    autyp = auftragstyp-bord.
  ENDIF.
* FLG_BDE_ERROR im SAPLCORF setzen
  PERFORM set_flg_bde_error IN PROGRAM saplcorf.

  IF NOT tmp_afrv-beaknz IS INITIAL.
*   Vorgangsdaten bereitstellen
    CALL FUNCTION 'CO_BO_OPR_OF_ORDER_GET'
      EXPORTING
        aufnr_imp = tmp_afrv-aufnr
      TABLES
        afvgd_get = tmp_afvgdg.
    LOOP AT tmp_afvgdg WHERE aplfl = tmp_afrv-aplfl
                       AND   vornr = tmp_afrv-vornr
                       AND   uvorn = tmp_afrv-uvorn.
      EXIT.
    ENDLOOP.
    IF tmp_afrv-kapar IS INITIAL AND
       tmp_afrv-split IS INITIAL.
*     R¨¹ckmeldung zum Vorgang
      tmp_objnr = tmp_afvgdg-objnr.
    ELSE.
*     R¨¹ckmeldung zur Einzelkapazit#t
      CALL FUNCTION 'CY_BT_KBED_TAB_GET'
        EXPORTING
          i_aufnr = tmp_afrv-aufnr
          i_bedid = tmp_afvgdg-bedid
        TABLES
          t_kbedd = tmp_kbedd.
      LOOP AT tmp_kbedd WHERE bedid = tmp_afvgdg-bedid
                        AND   bedzl = tmp_afvgdg-bedzl
                        AND   kapar = tmp_afrv-kapar
                        AND   split = tmp_afrv-split.
        EXIT.
      ENDLOOP.
      tmp_objnr = tmp_kbedd-kbsta.
      FREE tmp_kbedd.
    ENDIF.
    FREE tmp_afvgdg.
  ENDIF.
* Funktionsbaustein zum R¨¹ckmelden Vorgang aufrufen
  CALL FUNCTION 'CO_RU_CONFIRMATION'
    EXPORTING
      afrud_imp                    = afrud
      aktyp_imp                    = 'H'
      aktyp_pic_imp                = tmp_afrv-beaknz
      autyp_imp                    = autyp
      kapar_imp                    = tmp_afrv-kapar
      oper_key                     = cooprkey
      rmzhl_upd                    = rmzhl_upd
      split_imp                    = tmp_afrv-split
      suppress_suggestion          = yx
    IMPORTING
      afrud_exp                    = afrud
      afvgd_exp                    = afvgd
      afvgd_sop_exp                = *afvgd
      kbedd_exp                    = kbedd
      ok_code_exp                  = ok_code
    EXCEPTIONS
      interrupt_by_user            = 01
      key_not_defined              = 02
      material_data_not_found      = 03
      not_found                    = 04
      order_category_not_valid     = 05
      predec_not_confirmed         = 06
      sequence_not_found           = 07
      split_not_found              = 08
      table_entry_not_found        = 09
      unit_conversion_not_possible = 10.
  IF sy-subrc <> 0.
    IF NOT sy-msgno IS INITIAL.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    EXIT.
  ENDIF.
  IF ok_code = fc_end.
    SET SCREEN 0.
    LEAVE SCREEN.
  ENDIF.
  CHECK NOT afrud-rmzhl IS INITIAL.
* Logisches Datum und Uhrzeit abh#ngig von der Satzart bereitstellen
  CASE afrud-satza.
*   Abr¨¹sten PP
    WHEN bde_satzart-a10.
      afrud-ldate = afrud-isad.
      afrud-ltime = afrud-isaz.
    WHEN bde_satzart-a20 OR
         bde_satzart-a30 OR
         bde_satzart-a40.
      afrud-ldate = afrud-iedd.
      afrud-ltime = afrud-iedz.
*   Bearbeitenn PP
    WHEN bde_satzart-b10.
      afrud-ldate = afrud-isbd.
      afrud-ltime = afrud-isbz.
    WHEN bde_satzart-b20 OR
         bde_satzart-b30 OR
         bde_satzart-b40.
      afrud-ldate = afrud-iebd.
      afrud-ltime = afrud-iebz.
*   R¨¹sten PP
    WHEN bde_satzart-r10.
      afrud-ldate = afrud-isdd.
      afrud-ltime = afrud-isdz.
    WHEN bde_satzart-r20 OR
         bde_satzart-r30 OR
         bde_satzart-r40.
      afrud-ldate = afrud-ierd.
      afrud-ltime = afrud-ierz.
*   Arbeiten PM
    WHEN bde_satzart-n10.
      afrud-ldate = afrud-isdd.
      afrud-ltime = afrud-isdz.
    WHEN bde_satzart-n20 OR
         bde_satzart-n30 OR
         bde_satzart-n40.
      afrud-ldate = afrud-iedd.
      afrud-ltime = afrud-iedz.
*   Arbeiten PS
    WHEN bde_satzart-w10.
      afrud-ldate = afrud-isdd.
      afrud-ltime = afrud-isdz.
    WHEN bde_satzart-w20 OR
         bde_satzart-w30 OR
         bde_satzart-w40.
      afrud-ldate = afrud-iedd.
      afrud-ltime = afrud-iedz.
*   Sonstiges
    WHEN OTHERS.
      afrud-ldate = afrud-iedd.
      afrud-ltime = afrud-iedz.
  ENDCASE.

  IF NOT *afvgd IS INITIAL.
*   Untervorgangdaten bereitstellen
    afvgd = *afvgd.
  ENDIF.
* aktuelle Zeile nachlesen
  READ LINE zeile.
  MOVE-CORRESPONDING afrud TO tmp_afrv.                     "#EC ENHOK
  tmp_afrv-beaknz = beaknz_upd.
  rmzhl_upd = afrud-rmzhl.
  MODIFY tmp_afrv INDEX tabix.
  MODIFY LINE zeile LINE FORMAT COLOR col_positive.

  IF afrud-kapar IS INITIAL AND
     afrud-split IS INITIAL AND
    tmp_objnr = afvgd-objnr.
  ELSE.
    tmp_objnr = kbedd-kbsta.
  ENDIF.

ENDFORM.                               " SHOW_ACT_DATA
*eject
*&--------------------------------------------------------------------*
*&      Form  SAVE_CHANGES                                            *
*&--------------------------------------------------------------------*
*&      #nderungen sichern                                            *
*&--------------------------------------------------------------------*
FORM save_changes.

  DATA: flg_call_coru TYPE xfeld,
        flg_vb_reserv TYPE xfeld.

  DATA: ls_afvgd    TYPE afvgd,
        ls_kbedd    TYPE kbedd,
        ls_caufvd   TYPE caufvd,
        ls_afrud    TYPE afrud,
        ls_afrud_bt TYPE afrud.

  DATA: lv_delete   TYPE sy-tabix.

  CLEAR: flg_call_coru,
         flg_vb_reserv,
         tabix.
* alle korrigierten bzw. gel#schten Fehlers#tze mit dem Bearbeitungs-
* Kennzeichen versehen
  LOOP AT tmp_afrv WHERE NOT beaknz IS INITIAL.
    tabix = tabix + 1.
    IF tmp_afrv-beaknz = beaknz_del.
      lv_delete = lv_delete + 1.
    ENDIF.
    IF tmp_afrv-beaknz = beaknz_upd.
      flg_call_coru = yx.
    ELSE.
*     Update der Vorratsposition
      CALL FUNCTION 'UPDATE_CONFIRMATION_RESERVE'
        EXPORTING
          pdsnr_imp = tmp_afrv-pdsnr.
      IF flg_vb_reserv IS INITIAL.
        flg_vb_reserv = yx.
      ENDIF.
    ENDIF.
    IF herkunft = afrhori-pp AND
       tmp_afrv-beaknz = beaknz_upd.
*     Calculate target activities
      IF NOT tmp_afrv-slk01 IS INITIAL OR
         NOT tmp_afrv-slk02 IS INITIAL OR
         NOT tmp_afrv-slk03 IS INITIAL OR
         NOT tmp_afrv-slk04 IS INITIAL OR
         NOT tmp_afrv-slk05 IS INITIAL OR
         NOT tmp_afrv-slk06 IS INITIAL OR
         NOT tmp_afrv-sprk1 IS INITIAL.
        CLEAR: ls_afvgd,
               ls_kbedd,
               ls_caufvd,
               ls_afrud,
               ls_afrud_bt.
        MOVE-CORRESPONDING tmp_afrv TO ls_afrud.            "#EC ENHOK
        CALL FUNCTION 'CO_BT_CAUFV_READ_WITH_KEY'
          EXPORTING
            aufnr_act  = ls_afrud-aufnr
          IMPORTING
            caufvd_exp = ls_caufvd
          EXCEPTIONS
            not_found  = 1
            OTHERS     = 2.
        CHECK sy-subrc IS INITIAL.
        CALL FUNCTION 'CO_RU_GET_OPERATION'
          EXPORTING
            aplfl_imp             = ls_afrud-aplfl
            aufnr_imp             = ls_afrud-aufnr
            uvorn_imp             = ls_afrud-uvorn
            vornr_imp             = ls_afrud-vornr
          IMPORTING
            afvgd_exp             = ls_afvgd
          EXCEPTIONS
            operation_not_found   = 1
            order_data_missing    = 2
            table_entry_not_found = 3
            OTHERS                = 4.
        CHECK sy-subrc IS INITIAL.
        IF ls_afrud-kapar IS INITIAL OR
           ls_afrud-split IS INITIAL.
          CLEAR ls_kbedd.
        ELSE.
          CALL FUNCTION 'CY_BT_KBED_READ_WITH_KEY'
            EXPORTING
              i_aufnr    = ls_caufvd-aufnr
              i_bedid    = ls_afvgd-bedid
              i_bedzl    = ls_afvgd-bedzl
              i_canum    = ls_afrud-canum
              i_flg_conv = yx
              i_flg_work = yx
            IMPORTING
              kbedd_exp  = ls_kbedd
            EXCEPTIONS
              no_entry   = 1
              OTHERS     = 2.
          CHECK sy-subrc IS INITIAL.
        ENDIF.
        PERFORM compute_target_activity IN PROGRAM saplcori
                                             USING ls_afvgd
                                                   ls_kbedd
                                                   ls_caufvd-matnr
                                                   ls_caufvd-plnme
                                                   ls_caufvd-aufnr
                                          CHANGING ls_afrud.
*       Read confirmation from buffer table
        CALL FUNCTION 'CO_RU_BT_AFRU_READ_WITH_KEY'
          EXPORTING
            rmzhl     = ls_afrud-rmzhl
            rueck     = ls_afrud-rueck
          IMPORTING
            afrud_exp = ls_afrud_bt
          EXCEPTIONS
            not_found = 1
            OTHERS    = 2.
        IF NOT sy-subrc IS INITIAL.
          CONTINUE.
        ELSE.
*         move calculated target activities to buffer table
          ls_afrud_bt-ism01 = ls_afrud-ism01.
          ls_afrud_bt-ile01 = ls_afrud-ile01.
          ls_afrud_bt-lek01 = ls_afrud-lek01.
          ls_afrud_bt-ism02 = ls_afrud-ism02.
          ls_afrud_bt-ile02 = ls_afrud-ile02.
          ls_afrud_bt-lek02 = ls_afrud-lek02.
          ls_afrud_bt-ism03 = ls_afrud-ism03.
          ls_afrud_bt-ile03 = ls_afrud-ile03.
          ls_afrud_bt-lek03 = ls_afrud-lek03.
          ls_afrud_bt-ism04 = ls_afrud-ism04.
          ls_afrud_bt-ile04 = ls_afrud-ile04.
          ls_afrud_bt-lek04 = ls_afrud-lek04.
          ls_afrud_bt-ism05 = ls_afrud-ism05.
          ls_afrud_bt-ile05 = ls_afrud-ile05.
          ls_afrud_bt-lek05 = ls_afrud-lek05.
          ls_afrud_bt-ism06 = ls_afrud-ism06.
          ls_afrud_bt-ile06 = ls_afrud-ile06.
          ls_afrud_bt-lek06 = ls_afrud-lek06.
          ls_afrud_bt-iprz1 = ls_afrud-iprz1.
          ls_afrud_bt-ipre1 = ls_afrud-ipre1.
          ls_afrud_bt-iprk1 = ls_afrud-iprk1.
*         update buffer table
          CALL FUNCTION 'CO_RU_BT_AFRU_UPDATE'
            EXPORTING
              afrud_new = ls_afrud_bt
              tabix_old = ls_afrud_bt-indbt.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF flg_call_coru = yx.
*   Verbuchung der erfa#ten R¨¹ckmeldungen
    CALL FUNCTION 'CO_RU_CONFIRMATION'
      EXPORTING
        add_post_only_flg    = yx
        aktyp_imp            = aktyp_hin
        gprot_flg            = yx
        no_back_flush_flg    = yx
        no_goods_receipt_flg = yx.
    COMMIT WORK.
  ELSE.
    IF flg_vb_reserv = yx.
      LOOP AT tmp_afrv WHERE NOT beaknz IS INITIAL.
        EXIT.
      ENDLOOP.
      IF sy-subrc = 0.
        PERFORM vb_reserve ON COMMIT.
*       Vorratss#tze wurden gel#scht -> Aufruf der Verbuchungsroutinen
        COMMIT WORK.
      ENDIF.
    ENDIF.
  ENDIF.
* Meldung ausgeben und Programm verlassen
  IF NOT p_old IS INITIAL.
    MESSAGE s194 WITH tabix.
    LEAVE TO TRANSACTION sy-tcode.
  ELSE.
    IF lv_delete IS INITIAL.
      MESSAGE s194 WITH tabix.
    ELSE.
      MESSAGE s512 WITH lv_delete.
    ENDIF.
    IF sy-binpt IS INITIAL AND sy-calld EQ yx.
      LEAVE PROGRAM.
    ELSE.
      LEAVE TO TRANSACTION sy-tcode.
    ENDIF.
  ENDIF.

ENDFORM.                               " SAVE_CHANGES
*eject
*&--------------------------------------------------------------------*
*&      Form  SAVE_CHANGES_ALV                                        *
*&--------------------------------------------------------------------*
*&      bearbeitete Vorratszeilen aktualisieren                       *
*&--------------------------------------------------------------------*
FORM save_changes_alv.

  DATA: l_fail TYPE xfeld.

* Check whether at least one entry is marked
  PERFORM check_mark_any CHANGING l_fail.
  CHECK l_fail IS INITIAL.

  PERFORM save_changes.

ENDFORM.                               " SAVE_CHANGES_ALV
*eject
*&--------------------------------------------------------------------*
*&      Form  VB_RESERVE                                              *
*&--------------------------------------------------------------------*
*&      bearbeitete Vorratszeilen aktualisieren                       *
*&--------------------------------------------------------------------*
FORM vb_reserve.

  DATA: tmp_afrub TYPE afrub OCCURS 0,
        tmp_prte  TYPE prte  OCCURS 0.

  tabix = 0.
  LOOP AT tmp_afrv WHERE beaknz IS INITIAL.
    tabix = tabix + 1.
    DELETE tmp_afrv.
  ENDLOOP.
  IF tabix = 0.
    READ TABLE tmp_afrv INDEX 1.
    CHECK sy-subrc = 0.
*   alle Positionen des Vorrats wurden bearbeitet, deshalb
*   kompletten Vorrat l#schen
    CALL FUNCTION 'DELETE_CONFIRMATION_RESERVE'
      EXPORTING
        afori_imp = tmp_afrv-afori
        afruv_imp = tmp_afrv-afruv.
  ELSE.
    CALL FUNCTION 'CO_RU_VB_CONFIRMATION_POST' IN UPDATE TASK
      TABLES
        afru_bt  = tmp_afrub
        afrv_sav = tmp_afrv
        prte_tab = tmp_prte.

  ENDIF.

ENDFORM.                               " VB_RESERVE
*eject
*&---------------------------------------------------------------------*
*&      Form  SYSTEMFEHLER_LIST
*&---------------------------------------------------------------------*
*       Liste mit Einzels#tzen, die nicht nachverbuchbar sind          *
*       anzeigen                                                       *
*----------------------------------------------------------------------*
FORM systemfehler_list.

  FIELD-SYMBOLS: <f> TYPE ANY.

  REFRESH tmp_afrv.
  CLEAR tmp_afrv.

* Flag "Vorrat bearbeitet" zur¨¹cksetzen
  CALL FUNCTION 'CO_RP_RESET_FLG_UPD'.

* 'Radio-bottons' setzen
  CLEAR afru_wf.
  afru_wf-rvall = yx.
  CALL FUNCTION 'READ_CONFIRMATION_RESERVE'
    EXPORTING
      afori_imp = herkunft
      afruv_imp = afrh-afruv
      rvall_imp = afru_wf-rvall
      rvclo_imp = afru_wf-rvclo
      rvope_imp = afru_wf-rvope
      lock_flag = space
    IMPORTING
      afrh_exp  = afrh
    TABLES
      afrv_tab  = tmp_afrv
    EXCEPTIONS
      not_found = 01.

  IF NOT sy-subrc IS INITIAL.
    EXIT.
  ENDIF.

  SET PF-STATUS 'AVLS'.

  WRITE: / text-001.
  ULINE.

  WRITE: /30 text-100.
  ULINE.

  LOOP AT tmp_afrv.
    WRITE: /   tmp_afrv-afruv.
    WRITE:  21 tmp_afrv-counter.
    ASSIGN tmp_afrv TO <f> CASTING TYPE c.
    WRITE  30 <f>+0(50).
    WRITE: / '+  50'.
    WRITE:  30 <f>+50(50).
    WRITE: / '+ 100'.
    WRITE:  30 <f>+100(50).
    WRITE: / '+ 150'.
    WRITE:  30 <f>+150(50).
    WRITE: / '+ 200'.
    WRITE:  30 <f>+200(50).
    WRITE: / '+ 250'.
    WRITE:  30 <f>+250(50).
    WRITE: / '+ 300'.
    WRITE:  30 <f>+300(50).
    WRITE: / '+ 350'.
    WRITE:  30 <f>+350(50).
    WRITE: / '+ 400'.
    WRITE:  30 <f>+400(50).
    WRITE: / '+ 450'.
    WRITE:  30 <f>+450(50).
    WRITE: / '+ 500'.
    WRITE:  30 <f>+500(50).
    WRITE: / '+ 550'.
    WRITE:  30 <f>+550(50).
    WRITE: / '+ 600'.
    WRITE:  30 <f>+600(50).
    WRITE: / '+ 650'.
    WRITE:  30 <f>+650(50).
    WRITE: / '+ 700'.
    WRITE:  30 <f>+700(50).
    WRITE: / '+ 750'.
    WRITE:  30 <f>+750(50).
    WRITE: / '+ 800'.
    WRITE:  30 <f>+800(50).
    WRITE: / '+ 850'.
  ENDLOOP.

ENDFORM.                               " SYSTEMFEHLER_LIST
*&---------------------------------------------------------------------*
*&      Form  HEXADECIMAL_LIST                                         *
*&---------------------------------------------------------------------*
*       Liste mit Einzels#tzen, die nicht nachverbuchbar sind          *
*       anzeigen (hexadezimal)                                         *
*----------------------------------------------------------------------*
FORM hexadecimal_list.

  DATA: offsetx TYPE i.
  FIELD-SYMBOLS: <f> TYPE ANY.

  DESCRIBE FIELD tmp_afrv LENGTH offsetx IN BYTE MODE.

  SET PF-STATUS 'AVLH'.

  WRITE: / text-001.
  ULINE.

  WRITE: /30 text-101.
  ULINE.

  LOOP AT tmp_afrv.
    ASSIGN tmp_afrv TO <f> CASTING TYPE x.
    WRITE: /   tmp_afrv-afruv.
    WRITE:  21 tmp_afrv-counter.
    WRITE:  30 <f>+0(50).
    WRITE: / '+  50'.
    WRITE:  30 <f>+50(50).
    WRITE: / '+ 100'.
    WRITE:  30 <f>+100(50).
    WRITE: / '+ 150'.
    WRITE:  30 <f>+150(50).
    WRITE: / '+ 200'.
    WRITE:  30 <f>+200(50).
    WRITE: / '+ 250'.
    WRITE:  30 <f>+250(50).
    WRITE: / '+ 300'.
    WRITE:  30 <f>+300(50).
    WRITE: / '+ 350'.
    WRITE:  30 <f>+350(50).
    WRITE: / '+ 400'.
    WRITE:  30 <f>+400(50).
    WRITE: / '+ 450'.
    WRITE:  30 <f>+450(50).
    WRITE: / '+ 500'.
    WRITE:  30 <f>+500(50).
    WRITE: / '+ 550'.
    WRITE:  30 <f>+550(50).
    WRITE: / '+ 600'.
    WRITE:  30 <f>+600(50).
    WRITE: / '+ 650'.
    WRITE:  30 <f>+650(50).
    WRITE: / '+ 700'.
    WRITE:  30 <f>+700(50).
    WRITE: / '+ 750'.
    WRITE:  30 <f>+750(50).
    WRITE: / '+ 800'.
    WRITE:  30 <f>+800(50).
    WRITE: / '+ 850'.
    WRITE:  30 <f>+850(50).
  ENDLOOP.

ENDFORM.                               " SYSTEMFEHLER_LIST
*&---------------------------------------------------------------------*
*&      Form  DETAIL_LIST_KANBAN                                       *
*&---------------------------------------------------------------------*
*       Wie DETAIL_LIST aber andere Listausgabe                        *
*----------------------------------------------------------------------*
FORM detail_list_kanban.

  DATA: flg_locked  TYPE c,
        l_user      LIKE sy-msgv1.

  REFRESH tmp_afrv.
  CLEAR tmp_afrv.

* Flag "Vorrat bearbeitet" zur¨¹cksetzen
  CALL FUNCTION 'CO_RP_RESET_FLG_UPD'.

* 'Radio-bottons' setzen
  CLEAR afru_wf.
  afru_wf-rvope = yx.
  CALL FUNCTION 'READ_CONFIRMATION_RESERVE'
    EXPORTING
      afori_imp = herkunft
      afruv_imp = afrh-afruv
      rvall_imp = afru_wf-rvall
      rvclo_imp = afru_wf-rvclo
      rvope_imp = afru_wf-rvope
      lock_flag = space
    IMPORTING
      afrh_exp  = afrh
    TABLES
      afrv_tab  = tmp_afrv
    EXCEPTIONS
      not_found = 01.

  IF NOT sy-subrc IS INITIAL.
    EXIT.
  ENDIF.
* alle bereits bearbeiteten Fehlers#tze aus Vorrat entfernen
  LOOP AT tmp_afrv WHERE NOT beaknz IS INITIAL.
    DELETE tmp_afrv.
  ENDLOOP.
  DESCRIBE TABLE tmp_afrv LINES sy-tfill.
  IF sy-tfill = 0.
    EXIT.
  ENDIF.

  SET PF-STATUS 'LST1'.

  NEW-PAGE LINE-SIZE 80.

  CLEAR flg_intensif.
  FORMAT COLOR COL_NORMAL.
  LOOP AT tmp_afrv.
*   Lock AFRV also to be consistent with CO16N
    CALL FUNCTION 'ENQUEUE_EAFRV'
      EXPORTING
        afori          = tmp_afrv-afori
        afruv          = tmp_afrv-afruv
        counter        = tmp_afrv-counter
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      flg_locked = yx.
*     don't offer this line for selection
      DELETE tmp_afrv.
      CONTINUE.
    ENDIF.
    IF flg_intensif = yx.
      FORMAT INTENSIFIED.
      CLEAR flg_intensif.
    ELSE.
      FORMAT INTENSIFIED OFF.
      flg_intensif = yx.
    ENDIF.
    IF tmp_afrv-satza EQ 'K10'.                        "Kanbanimpuls
      WRITE: /03 rc27x-flg_sel AS CHECKBOX,
              05 tmp_afrv-pkkey,
              16 tmp_afrv-pknum,
              24 tmp_afrv-pkpos,
              28 tmp_afrv-pkimg UNIT afrv-meinh,
              45 tmp_afrv-satza,                             "61
              49 tmp_afrv-ldate DD/MM/YY,                    "65
              58 tmp_afrv-ltime(5) USING EDIT MASK '__:__'.  "74
    ELSEIF tmp_afrv-satza EQ 'K20'.                     "Mengenimpuls
      WRITE: /03 rc27x-flg_sel AS CHECKBOX,
              05 tmp_afrv-pkkey,
              16 tmp_afrv-pknum,
              24 tmp_afrv-pkpos,
              28 tmp_afrv-abmng UNIT afrv-meinh,              "44
              45 tmp_afrv-satza,                              "61
              49 tmp_afrv-ldate DD/MM/YY,                     "65
              58 tmp_afrv-ltime(5) USING EDIT MASK '__:__'.   "74
    ELSEIF tmp_afrv-satza EQ 'K30'.
      WRITE: /03 rc27x-flg_sel AS CHECKBOX,
              05 tmp_afrv-pkkey,
              16 tmp_afrv-pknum,
              24 tmp_afrv-pkpos,
              28 tmp_afrv-pkbmg UNIT afrv-meinh,
              45 tmp_afrv-satza,
              49 tmp_afrv-ldate DD/MM/YY,
              58 tmp_afrv-ltime(5) USING EDIT MASK '__:__'.
    ENDIF.


    WRITE 1  sy-vline.
    POSITION sy-linsz.
    WRITE    sy-vline.
    CLEAR : tmp_afrv-beaknz, rmzhl_upd.
    HIDE: tmp_afrv-afori, tmp_afrv-afruv, tmp_afrv-counter,
          tmp_afrv-beaknz, rmzhl_upd.
  ENDLOOP.
  IF flg_locked = yx.
    l_user = sy-msgv1.
*   R¨¹ckmeldevorrat &1 wird bereits von &2 bearbeitet
    MESSAGE i242 WITH tmp_afrv-afruv l_user.
  ENDIF.
* Any entries left?
  DESCRIBE TABLE tmp_afrv LINES sy-tfill.
  IF sy-tfill = 0.
    EXIT.
  ENDIF.

  ULINE.

ENDFORM.                               " DETAIL_LIST_KANBAN
*&---------------------------------------------------------------------*
*&      Form  DETAIL_LIST_KANBAN_ALV                                   *
*&---------------------------------------------------------------------*
*       Wie DETAIL_LIST_KANBAN, Ausgabe jedoch als ALV-Grid
*----------------------------------------------------------------------*
FORM detail_list_kanban_alv.

* define fieldcatalog
  DATA: lt_fieldcat TYPE slis_t_fieldcat_alv.
* define except_qinfo table
  DATA: lt_exctab TYPE TABLE OF alv_s_qinf.

  DATA: lv_afruv TYPE afrv-afruv,
        l_multi  TYPE xfeld,
        l_locked TYPE xfeld,
        l_user   TYPE uname.

  REFRESH tmp_afrv.
  CLEAR   tmp_afrv.
  REFRESH gt_afrv_alv.
  CLEAR   gt_afrv_alv.

* reset update flag in CORP
  CALL FUNCTION 'CO_RP_RESET_FLG_UPD'.

* set 'radio-buttons'
  CLEAR afru_wf.
  afru_wf-rvope = yx.
  CALL FUNCTION 'READ_CONFIRMATION_RESERVE'
    EXPORTING
      afori_imp = herkunft
      afruv_imp = afrh-afruv
      rvall_imp = afru_wf-rvall
      rvclo_imp = afru_wf-rvclo
      rvope_imp = afru_wf-rvope
      lock_flag = space
    IMPORTING
      afrh_exp  = afrh
    TABLES
      afrv_tab  = tmp_afrv
    EXCEPTIONS
      not_found = 01.
  IF NOT sy-subrc IS INITIAL.
    EXIT.
  ENDIF.

* built up global table for ALV
  LOOP AT tmp_afrv.
*   remove all entries with update indicator
    IF NOT tmp_afrv-beaknz IS INITIAL.
      DELETE tmp_afrv.
      CONTINUE.
    ENDIF.
*   check whether entry is already locked
    CALL FUNCTION 'ENQUEUE_EAFRV'
      EXPORTING
        afori          = tmp_afrv-afori
        afruv          = tmp_afrv-afruv
        counter        = tmp_afrv-counter
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      l_locked = yx.
      l_user = sy-msgv1.
      lv_afruv = tmp_afrv-afruv.
*     don't offer this line for selection
      DELETE tmp_afrv.
      CONTINUE.
    ENDIF.
    MOVE-CORRESPONDING tmp_afrv TO gt_afrv_alv.             "#EC ENHOK
    APPEND gt_afrv_alv.
  ENDLOOP.

  IF l_locked = yx.
*   confirmation reserve already locked
    MESSAGE i242 WITH lv_afruv l_user.
  ENDIF.

  IF NOT gt_afrv_alv[] IS INITIAL.
*   define layout
    PERFORM layout_build USING gs_layout.
*   build up fieldcatalog
    CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
      EXPORTING
        i_program_name   = g_repid
        i_structure_name = 'AFRV_S_ALV'
      CHANGING
        ct_fieldcat      = lt_fieldcat.
*   edit fieldcatalog
    PERFORM fieldcat_edit CHANGING lt_fieldcat.
*   create events table
    PERFORM set_events_afrv CHANGING gt_events.
*   create excluding tab
    PERFORM exctab_init CHANGING lt_exctab.
*   create title
    PERFORM title_build USING l_multi CHANGING g_title.
*   create variant
    PERFORM variant_build_afrv CHANGING gs_variant.
*   display list
    CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
      EXPORTING
        i_callback_program       = g_repid
        i_callback_pf_status_set = g_status_set_afrv
        i_callback_user_command  = g_user_command_afrv
        is_layout                = gs_layout
        it_fieldcat              = lt_fieldcat[]
        it_except_qinfo          = lt_exctab
        i_grid_title             = g_title
        i_default                = 'X'
        i_save                   = 'A'
        is_variant               = gs_variant
        it_events                = gt_events
      TABLES
        t_outtab                 = gt_afrv_alv
      EXCEPTIONS
        program_error            = 1
        OTHERS                   = 2.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.

ENDFORM.                               " DETAIL_LIST_KANBAN
*&---------------------------------------------------------------------*
*&      Form  SHOW_ACT_DATA_KANBAN                                     *
*&---------------------------------------------------------------------*
*       Verarbeitung der Fehlers#tze f¨¹r Kanban                        *
*----------------------------------------------------------------------*
FORM show_act_data_kanban.

  TABLES: rmpkb.
  DATA:   verbucht.
  DATA BEGIN OF save_afrv.
  INCLUDE TYPE afrv.
  DATA END OF save_afrv.

  DATA: l_fail TYPE xfeld.

  IF NOT p_old IS INITIAL.
*   alte Listausgabe
    tabix = 0.
    zeile = 0.
    IF sy-ucomm = 'ISTR'.
      DO.
        zeile = zeile + 1.
        READ LINE zeile.
        IF sy-subrc <> 0.
          zeile = 0.
          EXIT.
        ENDIF.
        CHECK sy-lisel+2(1) = yx.
        IF tmp_afrv-beaknz = beaknz_del OR
           tmp_afrv-beaknz = beaknz_hdr.
          zeile = 0.
        ENDIF.
        EXIT.
      ENDDO.
    ENDIF.
    IF zeile = 0.
      GET CURSOR LINE zeile.
      READ LINE zeile.
      IF tmp_afrv-beaknz = beaknz_del OR
         tmp_afrv-beaknz = beaknz_hdr.
        zeile = 0.
      ENDIF.
    ENDIF.
    CHECK zeile <> 0.
    MOVE-CORRESPONDING tmp_afrv TO afrv_key.                "#EC ENHOK
  ELSE.
*   called by ALV
*   check whether not more than one entry is marked
    PERFORM check_mark_single USING yx CHANGING l_fail.
    CHECK l_fail IS INITIAL.
*   check whether at least one entry is marked
    PERFORM check_mark_any CHANGING l_fail.
    CHECK l_fail IS INITIAL.
    READ TABLE gt_afrv_alv WITH KEY box = yx.
    IF gt_afrv_alv-beaknz = beaknz_del OR
       gt_afrv_alv-beaknz = beaknz_hdr.
      MESSAGE i759.
      EXIT.
    ENDIF.
    MOVE-CORRESPONDING gt_afrv_alv TO afrv_key.             "#EC ENHOK
  ENDIF.
* following section valid for ABAP as well as ALV
  afrv_key-mandt = sy-mandt.
  READ TABLE tmp_afrv WITH KEY afrv_key.
  CHECK sy-subrc = 0.
  tabix = sy-tabix.
  MOVE afrv TO save_afrv.
  MOVE-CORRESPONDING afrv_key TO afrv.                      "#EC ENHOK
  CLEAR rmpkb.
  CLEAR verbucht.
  IF tmp_afrv-satza EQ 'K10'.
    rmpkb-barco(10)   = tmp_afrv-pkkey.
    rmpkb-barco+10(1) = tmp_afrv-pkbst.
    rmpkb-pkimg       = tmp_afrv-pkimg.
    EXPORT rmpkb afrv TO MEMORY ID 'RMAFRU00_KANBAN'.
    CALL TRANSACTION 'PKBC'.
  ELSEIF tmp_afrv-satza EQ 'K20'.
    rmpkb-pknum = tmp_afrv-pknum.
    rmpkb-pkamg = tmp_afrv-abmng.
    EXPORT rmpkb afrv TO MEMORY ID 'RMAFRU00_KANBAN'.
    CALL TRANSACTION 'PK22'.
  ELSEIF tmp_afrv-satza EQ 'K30'.
    rmpkb-pknum = tmp_afrv-pknum.
    rmpkb-pkbmg = tmp_afrv-pkbmg.
    rmpkb-pkluz = tmp_afrv-pkluz.
    rmpkb-pkldt = tmp_afrv-pkldt.
    EXPORT rmpkb afrv TO MEMORY ID 'RMAFRU00_KANBAN'.
    CALL TRANSACTION 'PK23'.
  ENDIF.
  IMPORT verbucht FROM MEMORY ID 'RMAFRU00_KANBAN'.
  IF verbucht EQ yx.
    DELETE tmp_afrv INDEX tabix.
    IF p_old IS INITIAL.
      CLEAR gt_afrv_alv.
      DELETE gt_afrv_alv WHERE NOT box IS INITIAL.
    ENDIF.
  ENDIF.
  MOVE save_afrv TO afrv.

ENDFORM.                               " SHOW_ACT_DATA_KANBAN
*----------------------------------------------------------------------*
*       FORM LAYOUT_BUILD                                              *
*----------------------------------------------------------------------*
FORM layout_build USING p_layout TYPE slis_layout_alv.

  p_layout-box_fieldname        = g_boxnam.
  p_layout-colwidth_optimize    = yx.
  p_layout-zebra                = yx.
  p_layout-allow_switch_to_list = yx.

ENDFORM.                               "LAYOUT_BUILD
*----------------------------------------------------------------------*
*       FORM TITLE_BUILD                                               *
*----------------------------------------------------------------------*
FORM title_build USING    p_multi TYPE xfeld
                 CHANGING p_title TYPE lvc_title.

  DATA: l_datum(10).

  WRITE sy-datlo TO l_datum.

  IF NOT p_multi IS INITIAL.
*   Reserve List
    IF herkunft EQ '5'.
      CONCATENATE l_datum text-014 INTO p_title SEPARATED BY space.
    ELSE.
      CONCATENATE l_datum text-013 INTO p_title SEPARATED BY space.
    ENDIF.
  ELSE.
*   Detail List
    CONCATENATE l_datum text-001 INTO p_title SEPARATED BY space.
  ENDIF.

ENDFORM.                               "TITLE_BUILD
*----------------------------------------------------------------------*
*       FORM VARIANT_BUILD_AFRH                                        *
*----------------------------------------------------------------------*
FORM variant_build_afrh CHANGING rs_variant TYPE disvariant.

  DATA: l_repid LIKE sy-repid.

  CONCATENATE sy-repid 'H' INTO l_repid.
  rs_variant-report = l_repid.
  rs_variant-username = sy-uname.

ENDFORM.                               "VARIANT_BUILD
*----------------------------------------------------------------------*
*       FORM VARIANT_BUILD_AFRV                                        *
*----------------------------------------------------------------------*
FORM variant_build_afrv CHANGING rs_variant TYPE disvariant.

  DATA: l_repid LIKE sy-repid.

  CONCATENATE sy-repid 'V' INTO l_repid.
  rs_variant-report = l_repid.
  rs_variant-username = sy-uname.

ENDFORM.                               "VARIANT_BUILD
*----------------------------------------------------------------------*
*       FORM EXCTAB_INIT
*----------------------------------------------------------------------*
FORM exctab_init CHANGING rt_exctab TYPE alv_t_qinf.

  DATA: ls_exctab TYPE alv_s_qinf.

  ls_exctab-type  = cl_salv_tooltip=>c_type_icon.
  ls_exctab-value = ICON_DELETE.
  ls_exctab-text  = text-016.
  APPEND ls_exctab TO rt_exctab.

ENDFORM.                               "EXCTAB_INIT
*----------------------------------------------------------------------*
*       FORM FIELDCAT_EDIT                                             *
*----------------------------------------------------------------------*
FORM fieldcat_edit CHANGING rt_fieldcat TYPE slis_t_fieldcat_alv.

  DATA: ls_fieldcat TYPE slis_fieldcat_alv.

* Change/Hide field(s)
  LOOP AT rt_fieldcat INTO ls_fieldcat.
    CLEAR ls_fieldcat-col_pos.
    CLEAR ls_fieldcat-no_out.
    CLEAR ls_fieldcat-tech.
    CASE ls_fieldcat-fieldname.
*     bring in correct order
      WHEN 'STATUS'.
        ls_fieldcat-col_pos = 1.
        ls_fieldcat-icon = yx.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
      WHEN 'PKKEY'.
        ls_fieldcat-col_pos = 2.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
      WHEN 'PKNUM'.
        ls_fieldcat-col_pos = 3.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
      WHEN 'PKPOS'.
        ls_fieldcat-col_pos = 4.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
      WHEN 'PKBST'.
        ls_fieldcat-col_pos = 5.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
      WHEN 'SATZA'.
        ls_fieldcat-col_pos = 6.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
      WHEN 'PKIMG'.
        ls_fieldcat-col_pos = 7.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
      WHEN 'ABMNG'.
        ls_fieldcat-col_pos = 8.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
      WHEN 'PKBMG'.
        ls_fieldcat-col_pos = 9.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
      WHEN 'MEINH'.
        ls_fieldcat-col_pos = 10.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
*     remain unchanged
      WHEN 'LDATE' OR 'LTIME' OR 'PKLUZ' OR 'PKLDT'.
*     never display
      WHEN 'AFORI' OR 'AFRUV' OR 'COUNTER' OR 'BEAKNZ' OR 'BOX'.
        ls_fieldcat-tech = yx.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
*     hide all other fields
      WHEN OTHERS.
        ls_fieldcat-no_out = yx.
        MODIFY rt_fieldcat INDEX sy-tabix FROM ls_fieldcat.
    ENDCASE.
  ENDLOOP.

ENDFORM.                               "FIELDCAT_EDIT
*----------------------------------------------------------------------*
*       FORM SET_STATUS_AFRH                                           *
*----------------------------------------------------------------------*
FORM set_status_afrh USING rt_extab TYPE slis_t_extab.      "#EC CALLED

  DATA: wa_extab TYPE slis_extab.
  DATA: l_delete TYPE xfeld.

* Switch for displaying delete button
  l_delete = 'X'.                    "active in standard

  IF l_delete IS INITIAL.
    wa_extab-fcode = fc_del.
    APPEND wa_extab TO rt_extab.
  ENDIF.
  wa_extab-fcode = fc_save.          "hide save button
  APPEND wa_extab TO rt_extab.
* allow specific functions
  LOOP AT rt_extab INTO wa_extab WHERE fcode = '&ILD'.
    DELETE rt_extab.
  ENDLOOP.
*--- do not show the time zone icon, if time zone support is active
  IF gv_time_zone_active NE tzs1_active-yes.
    APPEND '+STZ' TO rt_extab.
  ENDIF.

* set status excluding FCodes
  SET PF-STATUS 'ALV_AFRH' EXCLUDING rt_extab.
ENDFORM.                               "SET_STATUS_AFRH
*----------------------------------------------------------------------*
*       FORM SET_STATUS_AFRV                                           *
*----------------------------------------------------------------------*
FORM set_status_afrv USING rt_extab TYPE slis_t_extab.      "#EC CALLED

  DATA: wa_extab TYPE slis_extab.
  DATA: l_delete TYPE xfeld.

* Switch for displaying delete button
  l_delete = 'X'.                    "active in standard

  IF l_delete IS INITIAL.
    wa_extab-fcode = fc_dele.
    APPEND wa_extab TO rt_extab.
  ENDIF.
* allow specific functions
  LOOP AT rt_extab INTO wa_extab WHERE fcode = '&ILD'.
    DELETE rt_extab.
  ENDLOOP.

*--- do not show the time zone icon, if time zone support is active
  IF gv_time_zone_active NE tzs1_active-yes.
    APPEND '+STZ' TO rt_extab.
  ENDIF.
* set status excluding FCodes
  SET PF-STATUS 'ALV_AFRV' EXCLUDING rt_extab.
ENDFORM.                               "SET_STATUS_AFRV
*----------------------------------------------------------------------*
*       FORM SET_EVENTS_AFRH
*----------------------------------------------------------------------*
FORM set_events_afrh CHANGING rt_events TYPE slis_t_event.

  FIELD-SYMBOLS: <ls_event> TYPE slis_alv_event.

  DATA: l_event TYPE lvc_fname VALUE 'CONTEXT_MENU'.

  CALL FUNCTION 'REUSE_ALV_EVENTS_GET'
    EXPORTING
      i_list_type     = 4
    IMPORTING
      et_events       = rt_events
    EXCEPTIONS
      list_type_wrong = 1
      OTHERS          = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
*   There's only one event to be set in CN30/IW46/PK51...
    READ TABLE rt_events ASSIGNING <ls_event>
               WITH KEY name = l_event.
    IF sy-subrc EQ 0.
      MOVE g_context_menu_afrh TO <ls_event>-form.
    ENDIF.
  ENDIF.

ENDFORM.                               "SET_EVENTS_AFRH
*----------------------------------------------------------------------*
*       FORM SET_EVENTS_AFRV
*----------------------------------------------------------------------*
FORM set_events_afrv CHANGING rt_events TYPE slis_t_event.

  FIELD-SYMBOLS: <ls_event> TYPE slis_alv_event.

  DATA: l_event TYPE lvc_fname VALUE 'CONTEXT_MENU'.

  CALL FUNCTION 'REUSE_ALV_EVENTS_GET'
    EXPORTING
      i_list_type     = 4
    IMPORTING
      et_events       = rt_events
    EXCEPTIONS
      list_type_wrong = 1
      OTHERS          = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
*   There's only one event to be set in PK51...
    READ TABLE rt_events ASSIGNING <ls_event>
               WITH KEY name = l_event.
    IF sy-subrc EQ 0.
      MOVE g_context_menu_afrv TO <ls_event>-form.
    ENDIF.
  ENDIF.

ENDFORM.                               "SET_EVENTS_AFRV
*----------------------------------------------------------------------*
*       FORM USER_COMMAND_AFRH                                         *
*----------------------------------------------------------------------*
*       OK-Code-Verarbeitung der ALV-Grid-Vorratsliste                 *
*----------------------------------------------------------------------*
FORM user_command_afrh USING rf_ucomm    LIKE sy-ucomm
                       rs_selfield TYPE slis_selfield.      "#EC CALLED

* determine actual cursor position
  READ TABLE gt_out_tab INTO gt_out_tab
       INDEX rs_selfield-tabindex.

  CASE rf_ucomm.
    WHEN fc_del.                      "Vorrat l#schen
      PERFORM delete_reserve_alv.
      CLEAR rf_ucomm.
      rs_selfield-refresh = yx.
    WHEN fc_pick.                     "Vorrat ausw#hlen
      PERFORM pick_entry_alv.
      CLEAR rf_ucomm.
    WHEN '&IC1'.                      "Doppelklick
*     doubleclick on reserve means 'pick entry'
      CHECK sy-subrc = 0.
      PERFORM pick_entry_alv.
      CLEAR rf_ucomm.
    WHEN '+STZ'.                      "time zone button
      PERFORM time_zone_button_on_list_fs3.
      CLEAR rf_ucomm.
  ENDCASE.

ENDFORM.                               "USER_COMMAND_AFRH
*----------------------------------------------------------------------*
*       FORM USER_COMMAND_AFRV                                         *
*----------------------------------------------------------------------*
*       OK-Code-Verarbeitung der ALV-Grid-Einzelliste                  *
*----------------------------------------------------------------------*
FORM user_command_afrv USING rf_ucomm    LIKE sy-ucomm
                       rs_selfield TYPE slis_selfield.      "#EC CALLED

* determine actual cursor position
  READ TABLE gt_afrv_alv INTO gt_afrv_alv
       INDEX rs_selfield-tabindex.

  CASE rf_ucomm.
    WHEN fc_bacl OR                   "Zur¨¹ck zum Vorrat
         fc_end  OR
         fc_rwl.
      PERFORM leave_alv.
      CLEAR rf_ucomm.
    WHEN fc_save.                     "Sichern
      PERFORM save_changes_alv.
      CLEAR rf_ucomm.
      rs_selfield-refresh = yx.
    WHEN fc_dele.                     "Einzelsatz l#schen
      PERFORM delete_entry_alv.
      CLEAR rf_ucomm.
      rs_selfield-refresh = yx.
    WHEN fc_fail.                     "Fehler anzeigen
      PERFORM show_failure_alv.
      CLEAR rf_ucomm.
    WHEN fc_istr.                     "Nachbearbeiten
      PERFORM show_act_data_alv.
      CLEAR rf_ucomm.
    WHEN '&IC1'.                      "Doppelklick
*     doubleclick on reserve means 'show actual data'
      CHECK sy-subrc = 0.
      PERFORM show_act_data_alv.
      CLEAR rf_ucomm.
    WHEN '+STZ'.                      "time zone button
      PERFORM time_zone_button_on_list_fs3.
      CLEAR rf_ucomm.
  ENDCASE.

ENDFORM.                               "USER_COMMAND_AFRV
*----------------------------------------------------------------------*
*       FORM CONTEXT_MENU_AFRH
*----------------------------------------------------------------------*
*       Kontext-Menu f¨¹r Vorrat erzeugen                               *
*----------------------------------------------------------------------*
FORM context_menu_afrh USING c_object TYPE REF TO cl_ctmenu. "#EC CALLED

  CALL METHOD c_object->add_separator.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = 'PICK'
      text  = text-C03.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = 'DEL '
      text  = text-C04.

  CALL METHOD c_object->add_separator.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = '&ALL'
      text  = text-C11.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = '&SAL'
      text  = text-C12.

ENDFORM.                               "CONTEXT_MENU_AFRH
*----------------------------------------------------------------------*
*       FORM CONTEXT_MENU_AFRV
*----------------------------------------------------------------------*
*       Kontext-Menu f¨¹r Einzelliste erzeugen                          *
*----------------------------------------------------------------------*
FORM context_menu_afrv USING c_object TYPE REF TO cl_ctmenu. "#EC CALLED

  CALL METHOD c_object->add_separator.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = 'BU  '
      text  = text-C01.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = 'ISTR'
      text  = text-C02.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = 'DELE'
      text  = text-C05.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = 'FAIL'
      text  = text-C06.

  CALL METHOD c_object->add_separator.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = '&ALL'
      text  = text-C11.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = '&SAL'
      text  = text-C12.

  CALL METHOD c_object->add_separator.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = 'BACL'
      text  = text-C21.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = 'END '
      text  = text-C22.

  CALL METHOD c_object->add_function
    EXPORTING
      fcode = 'RWL '
      text  = text-C23.

ENDFORM.                               "CONTEXT_MENU_AFRV

*Text symbol text£º
*001:Individual records (pool)
*002:Order        Seq.   Op.  SbOp.CTp Spl RTp Date       Time     Plnt WrkCenter
*003:Confirmation prompt
*004:Delete Error Record for
*005:Order
*006:Do you really want to delete?
*007:Kanban ID  CtrlCyc Itm Qty              RTp Date     Time
*011:Confirmations were processed
*012:Do you want to save the changes?
*013:Pool of Incorrect Confirmations
*014:List of Incorrect Kanban Backflushes
*015:Kanban with Identification No.
*016:Marked for Deletion
*100:>...+....1....+....2....+....3....+....4....+....5
*101:>.......+.........10........+.........20........+.........30.........+........40........+.........50
*C00:* Function Texts for ALV Grid Context Menu *
*C01:Save
*C02:Actual Data/Details
*C03:Choose
*C04:Delete Pool
*C05:Delete
*C06:Display Errors
*C11:Select All
*C12:Deselect All
*C21:Back
*C22:Exit

*C23:Cancel
*Selection text£º
*HERKUNFT:        Origin
*S_ARBPL:        Workcenter
*S_WERKS:        Plant
