***********************************************************************
*& Program           : ZIBM_TS_GENERATOR                              *
*& Module            : Utility Module                                 *
*& Sub-Module        : Technical Specification                        *
*& Functional Contact: N/A                                            *
*& Funct. Spec. Ref. : N/A                                            *
*& Developer(Company): Apan K Motilal/India/IBM,                      *
*&                     Sayak Nandy1/India/IBM,                        *
*&                     Subhasree Roy/India/IBM,                       *
*&                     Chandrani Dutta/India/IBM,                     *
*&                     Bikash Singha/India/IBM,                       *
*&                     Sudip Pal1/India/IBM,                          *
*&                     Amitava De1/India/IBM                          *
*& Create Date       : 1st August, 2009                               *
*& Program Type      : REPORT - Basic ABAP/4 Report                   *
*& Project Phase     : N/A                                            *
*& Description       : This Program will generate Technical Spec for  *
*&                     the given input in the selection screen        *
***********************************************************************
***********************************************************************
*&  REVISION LOG                                                      *
*---------------------------------------------------------------------*
*& Date                : MM/DD/YYYY                                   *
*& Ticket/Change Req.# : Help desk ticket number                      *
*& Requested by        : Business Analyst Name                        *
*& Developer(Company)  : Developer Name (Company Name)                *
*& Description         : Brief description of change                  *
***********************************************************************

REPORT  zibm_ts_generator            LINE-SIZE 132
                                     LINE-COUNT 65
                                     NO STANDARD PAGE HEADING
                                     MESSAGE-ID 00.

***********************************************************************
*                                                                     *
*                      GLOBAL DECLARATIONS                            *
*                                                                     *
***********************************************************************
TYPE-POOLS: sscr,sedi.

***********************************************************************
* INCLUDE                                                             *
***********************************************************************
INCLUDE : ole2incl.

***********************************************************************
* TABLES                                                              *
***********************************************************************
TABLES : e070,
         dd02l,
         dd30l,
         sscrfields.

***********************************************************************
* TYPES                                                               *
***********************************************************************
TYPES: BEGIN OF x_fields,
        fieldname   TYPE fieldname,     "Field name
        description TYPE as4text,       "Field description
        dataelmt    TYPE rollname,      "Data element
        datatype    TYPE dynptype,      "Data type
        length      TYPE ddleng,        "Length
        key         TYPE keyflag,       "Key field
        chktable    TYPE tabname,       "Check Table Name
        comment     TYPE char30,        "Comment
      END OF x_fields,

      BEGIN OF x_table,
        tab         TYPE tabname,
      END OF x_table,

      BEGIN OF x_tab_det_info,
        desc(30)    TYPE c,
        data(30)    TYPE c,
      END OF x_tab_det_info,

      BEGIN OF x_search,
        srchhelp    TYPE shlpname,
      END OF x_search,

      BEGIN OF x_clipbrd,
         line(10000) TYPE c,
         flg        TYPE char1,
      END OF x_clipbrd,

      BEGIN OF x_errmsg_utp,
        condition   TYPE string,
        steps(5)    TYPE c,
        stepdsc(75) TYPE c,
        tstdata(50) TYPE c,
           orgmsg(100) TYPE c,
           expresult   TYPE string,
           exebydt     TYPE string,
           remarks     TYPE string,
           megtype(1)  TYPE c,
      END OF x_errmsg_utp,

* For selection screen details
        BEGIN OF x_selscr,
          zzfldnme(8)  TYPE c,  "Field Name
          zzfldtyp(30) TYPE c,  "Field Type
          zzseltyp1(1) TYPE c,  "Selection Field Type(P:Para/S:Sel Opt)
          zzflddes(60) TYPE c,  "Field Description
          zzselcmt(50) TYPE c,  "Comments
          zzdefval(20) TYPE c,  "Default Value
        END OF x_selscr,

BEGIN OF x_selection,
           name(8)     TYPE c,
           ztype(30)   TYPE c,
           type1(1)    TYPE c,
           desc(60)    TYPE c,
           comment(50) TYPE c,
           zdefault(20) TYPE c,
         END OF x_selection,

       BEGIN OF x_source_code,
           line       TYPE char200,
       END OF x_source_code,

       BEGIN OF x_errmsg,
           msg_type(1)    TYPE c,     "Single-Character Flag
           msg(100)      TYPE c,     "Character 100
           msg_class     TYPE arbgb, "Application Area
           msgno         TYPE symsgno, "Messages, Message Number
        END OF x_errmsg.

***********************************************************************
* INTERNAL TABLES                                                     *
***********************************************************************
DATA : i_clipbrd TYPE STANDARD TABLE OF x_clipbrd.
***********************************************************************
* WORK AREAS                                                          *
***********************************************************************
DATA : wa_clipbrd TYPE x_clipbrd.

***********************************************************************
* VARIABLES                                                           *
***********************************************************************
DATA:   v_word         TYPE ole2_object , "OLE object handle
        v_documents    TYPE ole2_object , "Documents
        v_actdoc       TYPE ole2_object , "Active document
        v_application  TYPE ole2_object , "Application
        v_selection    TYPE ole2_object , "Selection
        v_pseudo_code(10000) TYPE c,
        v_char2        TYPE char10,
        l_row          TYPE i,
        v_flag         TYPE char1,
        wa_functxt     TYPE smp_dyntxt,    " Function Text
        wa_functxt1    TYPE smp_dyntxt,    " Function Text
        wa_functxt2    TYPE smp_dyntxt.    " Function Text

***********************************************************************
* CONSTANTS                                                           *
***********************************************************************
CONSTANTS: c_check   TYPE char1 VALUE 'X',        "Check
           c_dash    TYPE char1 VALUE '-',        "Dash
           c_separator TYPE char1
                       VALUE cl_abap_char_utilities=>horizontal_tab,
           c_na      TYPE char4 VALUE ' N/A',     "N/A
           c_y       TYPE char1 VALUE 'Y',        "Y
           c_n       TYPE char1 VALUE 'N'.        "N

TYPES:
BEGIN OF x_zinclude_name,
zzincludes TYPE token_str ,
END OF x_zinclude_name.

TYPES: x_zinclude_name_t TYPE TABLE OF x_zinclude_name.

TYPES:
BEGIN OF x_zsearch_help_info,
fieldname TYPE shlpfield ,
description TYPE as4text ,
import_export TYPE char3 ,
key(1) TYPE c ,
dataelement TYPE shlpsparde ,
datatype TYPE datatype_d ,
length TYPE ddleng ,
default_value TYPE ddshdefval ,
END OF x_zsearch_help_info.

DATA: wa_zsearch_help_info TYPE x_zsearch_help_info.

TYPES:
BEGIN OF x_zsearch_help_desc,
shlpname TYPE shlpname ,
description TYPE ddtext ,
hotkey TYPE ddshhotkey ,
text TYPE ddtext ,
sel_method TYPE selmethod ,
* BOC Chandrani 07/31/2009
selmexit   TYPE ddshselext,
* EOC Chandrani 07/31/2009
dialogtype TYPE ddshdiatyp ,
dev_type(15) TYPE c ,
END OF x_zsearch_help_desc.

TYPES:
BEGIN OF x_zreport_sel_info,
zzfldnme(8) TYPE c ,
zzfldtyp(30) TYPE c ,
zzseltyp1(1) TYPE c ,
zzflddes(60) TYPE c ,
zzselcmt(50) TYPE c ,
zzdefval(20) TYPE c ,
END OF x_zreport_sel_info.

TYPES:
BEGIN OF x_zauto_field_str,
fnam TYPE fnam_____4 ,
fval TYPE bdc_fval ,
type TYPE dynptype ,
leng TYPE ddleng ,
fieldtext TYPE as4text ,
END OF x_zauto_field_str.

DATA: x_zauto_field_str_t TYPE TABLE OF x_zauto_field_str .
TYPES: x_zauto_field_str_ty TYPE TABLE OF x_zauto_field_str .

TYPES:
BEGIN OF x_zauto_recrdng_str,
program TYPE bdc_prog ,
dynpro TYPE bdc_dynr ,
zzokcode TYPE bdc_fval ,
zzcursor TYPE bdc_fval ,
zztab LIKE x_zauto_field_str_t ,
END OF x_zauto_recrdng_str.

DATA: x_zauto_recrdng_str_t TYPE TABLE OF x_zauto_recrdng_str .
TYPES: x_zauto_recodng_tab_ty TYPE TABLE OF x_zauto_recrdng_str .

TYPES:
BEGIN OF x_zibm_cust_object_text,
object_id TYPE char40 ,
object_text TYPE as4text ,
devclass TYPE devclass ,
END OF x_zibm_cust_object_text.

TYPES:
BEGIN OF x_zibm_table_common_info,
zibm_cust_object_text TYPE  x_zibm_cust_object_text,
object_id TYPE char40 ,
object_text TYPE as4text ,
devclass TYPE devclass ,
tabclass TYPE tabclass ,
clidep TYPE clidep ,
buffered TYPE buffered ,
mainflag TYPE maintflag ,
END OF x_zibm_table_common_info.

TYPES:
BEGIN OF x_zibm_table_info,
zibm_table_common_info TYPE  x_zibm_cust_object_text,
zibm_cust_object_text TYPE x_zibm_cust_object_text ,
object_id TYPE char40 ,
object_text TYPE as4text ,
devclass TYPE devclass ,
tabclass TYPE tabclass ,
clidep TYPE clidep ,
buffered TYPE buffered ,
mainflag TYPE maintflag ,
deliveryclass TYPE contflag ,
END OF x_zibm_table_info.

TYPES:x_zibm_table_info_ty TYPE TABLE OF x_zibm_table_info.


TYPES:
BEGIN OF x_zibm_datatype_info,
datatype TYPE datatype_d ,
length TYPE ddleng ,
decimals TYPE decimals ,
END OF x_zibm_datatype_info.

TYPES:
BEGIN OF x_zibm_table_structure,
tabname TYPE tabname ,
fieldname TYPE fieldname ,
is_primary_key TYPE flag ,
dataelement TYPE rollname ,
checktable TYPE checktable ,
domname TYPE domname ,
inttype TYPE inttype ,
zibm_datatype_info TYPE  x_zibm_datatype_info,
datatype TYPE datatype_d ,
length TYPE ddleng ,
decimals TYPE decimals ,
fieldtext TYPE as4text ,
END OF x_zibm_table_structure.

TYPES:x_zibm_table_structure_ty TYPE TABLE OF x_zibm_table_structure.

TYPES:
BEGIN OF x_zibm_dataelement_info,
zibm_cust_object_text TYPE x_zibm_cust_object_text,
object_id TYPE char40 ,
object_text TYPE as4text ,
devclass TYPE devclass ,
domname TYPE domname ,
shlpname TYPE shlpname ,
shlpfield TYPE shlpfield ,
zibm_datatype_info TYPE x_zibm_datatype_info,
datatype TYPE datatype_d ,
length TYPE ddleng ,
decimals TYPE decimals ,
END OF x_zibm_dataelement_info.


TYPES:x_zibm_dataelement_info_ty TYPE TABLE OF x_zibm_dataelement_info.

TYPES:
BEGIN OF x_zibm_struc_info,
zibm_table_common_info TYPE x_zibm_table_common_info,
zibm_cust_object_text TYPE x_zibm_cust_object_text,
object_id TYPE char40 ,
object_text TYPE as4text ,
devclass TYPE devclass ,
tabclass TYPE tabclass ,
clidep TYPE clidep ,
buffered TYPE buffered ,
mainflag TYPE maintflag ,
sqltab TYPE sqlappdtab ,
END OF x_zibm_struc_info.

TYPES:x_zibm_struc_info_ty TYPE TABLE OF x_zibm_struc_info.

TYPES:
BEGIN OF x_zibm_tabletype_info,
zibm_cust_object_text TYPE x_zibm_cust_object_text,
object_id TYPE char40 ,
object_text TYPE as4text ,
devclass TYPE devclass ,
rowtype TYPE ttrowtype ,
rowkind TYPE typekind ,
zibm_datatype_info TYPE x_zibm_datatype_info,
datatype TYPE datatype_d ,
length TYPE ddleng ,
decimals TYPE decimals ,
accessmode TYPE char1 ,
keydef TYPE ttypkeydef ,
keykind TYPE keykind ,
keyfdcount TYPE keyfdcnt ,
typelen TYPE ddleng ,
reftype TYPE char1 ,
END OF x_zibm_tabletype_info.

TYPES:x_zibm_tabletype_info_ty TYPE TABLE OF x_zibm_tabletype_info.

*ZSELECT_INFO_T
*---------------
TYPES:
BEGIN OF x_zdbtab_name,
dbtab_name TYPE char30 ,
alias TYPE char30 ,
END OF x_zdbtab_name.

DATA: x_zdbtab_name_t TYPE TABLE OF x_zdbtab_name .

TYPES: x_zdbtab_name_ty TYPE TABLE OF x_zdbtab_name .

TYPES:
BEGIN OF x_zoperands,
op TYPE char100 ,
type TYPE seu_type ,
END OF x_zoperands.

DATA: x_zoperands_t TYPE TABLE OF x_zoperands .
TYPES: x_zoperands_ty TYPE TABLE OF x_zoperands .

TYPES:
BEGIN OF x_zwhere_field_name,
field_name TYPE char100 ,
field_link TYPE char100 ,
table_link TYPE char100 ,
alias TYPE char100 ,
position TYPE tabfdpos ,
row TYPE numc4 ,
column TYPE numc4 ,
operator TYPE char10 ,
operand LIKE x_zoperands_t ,
andor TYPE char3 ,
END OF x_zwhere_field_name.

DATA: x_zwhere_field_name_t TYPE TABLE OF x_zwhere_field_name .
TYPES: x_zwhere_field_name_ty TYPE TABLE OF x_zwhere_field_name.

TYPES:
BEGIN OF x_zfield_name,
alias TYPE char100 ,
fieldname TYPE char100 ,
tablename TYPE char100 ,
row TYPE numc4 ,
column TYPE numc4 ,
END OF x_zfield_name.

DATA: x_zfield_name_t TYPE TABLE OF x_zfield_name.
TYPES: x_zfield_name_ty TYPE TABLE OF x_zfield_name.

TYPES:
BEGIN OF x_zselect,
code TYPE char255 ,
END OF x_zselect.

DATA: x_zselect_t TYPE TABLE OF x_zselect.
TYPES: x_zselect_ty TYPE TABLE OF x_zselect.

TYPES:
BEGIN OF x_zselect_info,
i_dbtab LIKE x_zdbtab_name_t ,
i_link_fld LIKE x_zwhere_field_name_t ,
v_int_tab TYPE char30 ,
v_int_struc TYPE char100 ,
v_foe_tab TYPE char30 ,
v_foe_struc TYPE char100 ,
i_fld LIKE x_zfield_name_t ,
i_where_fld LIKE x_zwhere_field_name_t ,
i_join_fld LIKE x_zfield_name_t ,
i_select LIKE x_zselect_t ,
sequence TYPE numc4 ,
event_code TYPE char2 ,
sub_seq TYPE numc4 ,
END OF x_zselect_info.

DATA: x_zselect_info_t TYPE TABLE OF x_zselect_info.
TYPES: x_zselect_info_ty TYPE TABLE OF x_zselect_info.

DATA  BEGIN OF stm1 OCCURS 1000.
        INCLUDE STRUCTURE sstmnt.
DATA  END OF stm1.

*FOR SCAN ABAP-SOURCE mod-Sayak
*------------------------------
TYPES:
BEGIN OF x_abap_source_info,
  source_name TYPE char100,
  tokens      TYPE sedi_tk,
  statements  TYPE sedi_stm,
  message     TYPE char255,
  word        TYPE char30,
  include     TYPE trdir-name,
  line        TYPE token_row,
  offset      TYPE token_col,
END OF x_abap_source_info.

DATA: i_abap_source_info  TYPE STANDARD TABLE OF x_abap_source_info,
      wa_abap_source_info TYPE x_abap_source_info.

FIELD-SYMBOLS: <abap_source> TYPE x_abap_source_info.

*ZTABLE_FIELD_NAME_T
*------------------

TYPES:
BEGIN OF x_ztable_field_name,
tabname TYPE tabname ,
fieldname TYPE fieldname ,
position TYPE tabfdpos ,
keyflag TYPE keyflag ,
rollname TYPE rollname ,
datatype TYPE datatype_d ,
leng TYPE ddleng ,
decimals TYPE decimals ,
row_no(4) TYPE n ,
col_no(4) TYPE n ,
END OF x_ztable_field_name.

DATA: x_ztable_field_name_t TYPE TABLE OF x_ztable_field_name.
TYPES: x_ztable_field_name_ty TYPE TABLE OF x_ztable_field_name.

*ZDBTAB_TEXT_T
*---------------
TYPES:
BEGIN OF x_zdbtab_text,
tabname TYPE tabname ,
ddtext TYPE as4text ,
END OF x_zdbtab_text.

DATA: x_zdbtab_text_t TYPE TABLE OF x_zdbtab_text.
TYPES: x_zdbtab_text_ty TYPE TABLE OF x_zdbtab_text.

*ZFIELD_DESC_T
*---------------
TYPES:
BEGIN OF x_zfield_desc,
rollname TYPE rollname ,
ddtext TYPE as4text ,
END OF x_zfield_desc.

DATA: x_zfield_desc_t TYPE TABLE OF x_zfield_desc.
TYPES: x_zfield_desc_ty TYPE TABLE OF x_zfield_desc.

*ZFM_CALL_INFO_T
*-----------------
TYPES:
BEGIN OF x_zfm_call,
code TYPE char255 ,
END OF x_zfm_call.

DATA: x_zfm_call_t TYPE TABLE OF x_zfm_call.
TYPES: x_zfm_call_ty TYPE TABLE OF x_zfm_call.

TYPES:
BEGIN OF x_zfm_call_info,
funcname TYPE rs38l_fnam ,
stext TYPE rs38l_ftxt ,
fm_call_code LIKE x_zfm_call_t ,
sequence TYPE numc4 ,
event_code TYPE char2 ,
sub_seq TYPE numc4 ,
END OF x_zfm_call_info.

DATA: x_zfm_call_info_t TYPE TABLE OF x_zfm_call_info.
TYPES: x_zfm_call_info_ty TYPE TABLE OF x_zfm_call_info.

*ZPERFORM_CALL_INFO_T
*--------------------
TYPES:
BEGIN OF x_zperform_call_info,
subroutine_name TYPE seu_name ,
*mod-SN 3rd AUG
method_name(61) TYPE c,
class_name  TYPE char30,
*mod-SN 3rd AUG
event_code TYPE char2 ,
sub_seq TYPE numc4 ,
seq_flag TYPE char1 ,
END OF x_zperform_call_info.

DATA: x_zperform_call_info_t TYPE TABLE OF x_zperform_call_info.
TYPES: x_zperform_call_info_ty TYPE TABLE OF x_zperform_call_info.

*Z_GET_PROG_MSG_INFO
*=========================

*ZMSG_INFO_T
*------------
TYPES:
BEGIN OF x_zmsg_info,
msg_type TYPE char1 ,
msg TYPE char100 ,
msg_class TYPE arbgb ,
msgno TYPE symsgno ,
END OF x_zmsg_info.

DATA: x_zmsg_info_t TYPE TABLE OF x_zmsg_info.
TYPES: x_zmsg_info_ty TYPE TABLE OF x_zmsg_info.


*Z_GET_PROG_TAB_INFO
*=========================
*ZITAB_T
*--------
TYPES:
BEGIN OF x_zitab,
itab TYPE char100 ,
END OF x_zitab.


DATA: x_zitab_t TYPE TABLE OF x_zitab.
TYPES: x_zitab_ty TYPE TABLE OF x_zitab.

*zitab_info_t
*--------------
TYPES:
BEGIN OF x_ztabinfo,
fld_label TYPE char100 ,
fld_name TYPE char100 ,
datatype TYPE char30, "datatype_d ,
leng TYPE ddleng ,
decimals TYPE decimals ,
fld_desc TYPE char100 ,
tab_name TYPE char100 ,
END OF x_ztabinfo.

DATA: x_ztabinfo_t TYPE TABLE OF x_ztabinfo.
TYPES: x_ztabinfo_ty TYPE TABLE OF x_ztabinfo.

TYPES:
BEGIN OF x_zitab_info,
tab_name TYPE char100 ,
tabinfo LIKE x_ztabinfo_t ,
END OF x_zitab_info.

DATA: x_zitab_info_t TYPE TABLE OF x_zitab_info.
TYPES: x_zitab_info_ty TYPE TABLE OF x_zitab_info.

*function-pool zole_auto.

TYPES:
* For search help
BEGIN OF x_dd30l_dd30t,
   shlpname  TYPE shlpname,   "Name of search help
   ddtext    TYPE ddtext,     "Description
   hotkey    TYPE ddshhotkey, "Hot key
   selmethod TYPE selmethod,  "Selection method
   dialogtype TYPE ddshdiatyp, "Dialog type
END OF x_dd30l_dd30t,

BEGIN OF x_dd32s,
   fieldname  TYPE shlpfield,  "Name of a search help parameter
   flposition TYPE sfposition, "Position of a search help field
   shlpinput  TYPE shlpinput,  " IMPORT Parameters for Search Help
   shlpoutput TYPE shlpoutput, " EXPORT Parameters
   rollname   TYPE shlpsparde, "Assigned data element
   defaultval TYPE ddshdefval, "Default value for a search help
                               "parameter
   datatype   TYPE datatype_d, "Data Type in ABAP Dictionary
   leng       TYPE ddleng,     "Length (No. of Characters)
END OF x_dd32s,

BEGIN OF x_code,
  line TYPE char255,
END OF x_code,

*Queue info definition
BEGIN OF x_apqi ,
 datatyp TYPE apq_dtyp,   " Queue data type
 groupid TYPE apq_grpn ,  " Group name: Batch input session name
 qid     TYPE apq_quid ,  " Queue identification (unique key)
END OF x_apqi,

BEGIN OF x_help_desc,
        shlpname     TYPE shlpname,
        description  TYPE ddtext,
        hotkey       TYPE ddshhotkey,
        text         TYPE ddtext,
        sel_method   TYPE selmethod,
* BOC Chandrani 07/31/2009
        selmexit  TYPE ddshselext,  "Search help exit
* EOC Chandrani 07/31/2009
        dialogtype   TYPE ddshdiatyp,
        dev_type(15) TYPE c,
      END OF x_help_desc,

      BEGIN OF x_help_info,
        fieldname     TYPE shlpfield,
        description   TYPE as4text,
        import_export TYPE char3,
        key(1)        TYPE c,
        dataelement   TYPE shlpsparde,
        datatype      TYPE datatype_d,
        length        TYPE ddleng,
        default_value TYPE ddshdefval,
      END OF x_help_info,

x_t_code TYPE STANDARD TABLE OF x_code.

DATA: BEGIN OF x_code_info,
  name       TYPE progname,
  code       TYPE x_t_code,
 END OF x_code_info.

DATA : wa_help_info TYPE x_help_info.

DATA:
v_space TYPE string,

wa_code_info LIKE x_code_info,

wa_apqi TYPE x_apqi,"for BDC ID info

i_bdcdata TYPE STANDARD TABLE OF bdcdata INITIAL SIZE 0,

i_code_info LIKE HASHED TABLE OF x_code_info
      WITH UNIQUE KEY name INITIAL SIZE 0,

i_nodetab TYPE STANDARD TABLE OF snodetext,

i_nodetab1 TYPE STANDARD TABLE OF snodetext,

wa_select_info TYPE x_zselect_info,

wa_msg_info TYPE x_zmsg_info,

i_select_info TYPE STANDARD TABLE OF x_zselect_info,

i_table_fields TYPE STANDARD TABLE OF x_ztable_field_name,

wa_table_fields TYPE x_ztable_field_name,

i_msg_info TYPE STANDARD TABLE OF x_zmsg_info,

i_selection TYPE STANDARD TABLE OF x_selection INITIAL SIZE 0.

DATA: BEGIN OF i_text_pool OCCURS 10.
        INCLUDE STRUCTURE textpool.
DATA: END OF i_text_pool.

DATA: v_fm TYPE char1,
      v_event_code TYPE char2,
      v_sequence   TYPE numc4,
      v_sub_seq    TYPE numc4,
      i_sub_call_info TYPE STANDARD TABLE OF x_zperform_call_info,
      i_fm_info    TYPE STANDARD TABLE OF x_zfm_call_info.

DATA: tk TYPE sedi_tk WITH HEADER LINE,
      tk1 TYPE sedi_tk WITH HEADER LINE.

DATA: o_incl,o_operation.
DATA: o_state,o_eventtype.
DATA: o_local.
DATA:  line_char TYPE swbse_max_line,
       line_char1 TYPE swbse_max_line.

DATA:
BEGIN OF x_tb_tab_struc,
  tabname TYPE tabname,
  i_info TYPE STANDARD TABLE OF x_zibm_table_structure,
END OF x_tb_tab_struc.

DATA:
i_tb_tab_struc LIKE HASHED TABLE OF x_tb_tab_struc WITH
UNIQUE KEY tabname.

DATA:
i_data_ele TYPE HASHED TABLE OF x_zibm_dataelement_info
WITH UNIQUE KEY object_id.

DATA:
t_objbin   TYPE STANDARD TABLE OF solisti1,   " Attachment data
t_objtxt   TYPE STANDARD TABLE OF solisti1,   " Message body
t_objpack  TYPE STANDARD TABLE OF sopcklsti1, " Packing list
t_reclist  TYPE STANDARD TABLE OF somlreci1,  " Receipient list
t_objhead  TYPE STANDARD TABLE OF solisti1.   " Header

DATA: wa_docdata TYPE sodocchgi1,   " Document data
      wa_objtxt  TYPE solisti1,     " Message body
      wa_objbin  TYPE solisti1,     " Attachment data
      wa_objpack TYPE sopcklsti1,   " Packing list
      wa_reclist TYPE somlreci1.    " Receipient list

DATA: w_tab_lines TYPE i.           " Table lines
DATA: l_char TYPE char120.

DATA: i_r_perform TYPE RANGE OF seu_name,
      wa_r_perform LIKE LINE OF i_r_perform.

TYPES: BEGIN OF x_method_call,
        class_name  TYPE char30,
        method_name(61) TYPE c,
       END OF x_method_call.

DATA: i_method_call TYPE STANDARD TABLE OF x_method_call.

DATA: v_op_tt TYPE char4,
      v_op_dd TYPE char4,
      v_op_yy TYPE char4.

DATA : v_fm_info      TYPE x_zfm_call_info_ty.


DATA: BEGIN OF source_main OCCURS 1000,
        line(255) TYPE c,  "statements of the program being tested
        program(30),       "progam name
        form(30),
        lineno(10) TYPE c, "line number
      END OF source_main,
      BEGIN OF t_keywords OCCURS 1,
        line(20),
      END OF t_keywords,
      i_source      TYPE x_source_code OCCURS 1000 WITH HEADER LINE,
      i_code        TYPE STANDARD TABLE OF x_code INITIAL SIZE 0,
      i_errmsg      TYPE STANDARD TABLE OF x_errmsg INITIAL  SIZE 0,
*      i_selection   TYPE STANDARD TABLE OF x_selection INITIAL  SIZE 0,
      w_code        TYPE x_code,
      w_selection   TYPE x_selection,
      i_errmsg_utp  TYPE STANDARD TABLE OF x_errmsg_utp INITIAL SIZE 0,
      wa_errmsg_utp TYPE x_errmsg_utp,
      v_count       TYPE i,
      v_transaction TYPE tcode,
      wa_usrdtl     TYPE user_addr,
      v_execute(100)  TYPE c,
      v_exeby       TYPE string,
      l_datum       TYPE char10,
      v_steps       TYPE p DECIMALS 1 VALUE '1.1'.

CONSTANTS:
c_table_type  TYPE  seu_obj VALUE 'TABL',
c_dataele_type  TYPE  seu_obj VALUE 'DTEL',
c_tabletype_type  TYPE  seu_obj VALUE 'TTYP'.

TYPES: BEGIN OF x_font_names,
       name TYPE char100,
       END OF x_font_names.
DATA : i_font_names TYPE STANDARD TABLE OF x_font_names,
       wa_font_names TYPE x_font_names.

***********************************************************************
*                                                                     *
*                      MAIN PROGRAM                                   *
*                                                                     *
***********************************************************************

SELECTION-SCREEN FUNCTION KEY 1.
SELECTION-SCREEN FUNCTION KEY 2.
SELECTION-SCREEN FUNCTION KEY 3.

***********************************************************************
* SELECTION SCREEN                                                    *
***********************************************************************
SELECTION-SCREEN: BEGIN OF BLOCK c2 WITH FRAME TITLE text-002.
SELECTION-SCREEN BEGIN OF LINE.
*For Transport Nos
SELECTION-SCREEN POSITION 2.
PARAMETERS: p_cts     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 4.
SELECTION-SCREEN COMMENT (13) text-014.

*For BDC
SELECTION-SCREEN POSITION 21.
PARAMETERS: p_bdc     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 23.
SELECTION-SCREEN COMMENT (7) text-010.

*For selectionscreen
SELECTION-SCREEN POSITION 32.
PARAMETERS: p_sel     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 34.
SELECTION-SCREEN COMMENT (20) text-011.

*For Table access diagram
SELECTION-SCREEN POSITION 56.
PARAMETERS: p_tad     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 58.
SELECTION-SCREEN COMMENT (24) text-012.
SELECTION-SCREEN END OF LINE.

*For pseudo code
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 2.
PARAMETERS: p_code     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 4.
SELECTION-SCREEN COMMENT (15) text-013.


*For UTP validations
SELECTION-SCREEN POSITION 21.
PARAMETERS: p_tab     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 23.
SELECTION-SCREEN COMMENT (7) text-009."'For table'(009).

*For message
SELECTION-SCREEN POSITION 32.
PARAMETERS: p_msg     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 34.
SELECTION-SCREEN COMMENT (11) text-015.

*For search help
SELECTION-SCREEN POSITION 56.
PARAMETERS: p_srch    TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 58.
SELECTION-SCREEN COMMENT (24) text-059.
SELECTION-SCREEN END OF LINE.

*For function module
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 2.
PARAMETERS: p_fm     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 4.
SELECTION-SCREEN COMMENT (15) text-077.


*For UTP
SELECTION-SCREEN POSITION 21.
PARAMETERS: p_utp     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 23.
SELECTION-SCREEN COMMENT (4) text-140.

*For o/p from program
SELECTION-SCREEN POSITION 32.
PARAMETERS: p_opp     TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 34.
SELECTION-SCREEN COMMENT (20) text-094.

*For o/p from FS Excel
SELECTION-SCREEN POSITION 56.
PARAMETERS: p_opxl    TYPE char1 AS CHECKBOX USER-COMMAND ucomm.
SELECTION-SCREEN POSITION 58.
SELECTION-SCREEN COMMENT (30) text-095.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN: END OF BLOCK c2.

* For Selection Screen details
SELECTION-SCREEN: BEGIN OF BLOCK c1 WITH FRAME TITLE text-001.
SELECT-OPTIONS: s_cts FOR e070-strkorr NO INTERVALS MODIF ID m6.
SELECTION-SCREEN COMMENT 65(46) text-110 MODIF ID m6.
SELECTION-SCREEN: END OF BLOCK c1.

* For table details
SELECTION-SCREEN: BEGIN OF BLOCK c3 WITH FRAME TITLE text-003.
SELECT-OPTIONS: s_tab FOR dd02l-tabname NO INTERVALS MODIF ID m1.
SELECTION-SCREEN: END OF BLOCK c3.

* For BDC details
SELECTION-SCREEN: BEGIN OF BLOCK c4 WITH FRAME TITLE text-004.
PARAMETERS: p_bdcrec TYPE groupid MODIF ID m2.
SELECTION-SCREEN COMMENT 65(56) text-111 MODIF ID m2.
SELECTION-SCREEN: END OF BLOCK c4.

* For search help details
SELECTION-SCREEN: BEGIN OF BLOCK c10 WITH FRAME TITLE text-060.
SELECT-OPTIONS: s_help FOR dd30l-shlpname NO INTERVALS MODIF ID m8.
SELECTION-SCREEN COMMENT 65(59) text-120 MODIF ID m8.
SELECTION-SCREEN: END OF BLOCK c10.

* For program Name
SELECTION-SCREEN: BEGIN OF BLOCK c6 WITH FRAME TITLE text-006.
SELECTION-SCREEN: BEGIN OF BLOCK c11 WITH FRAME.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT (9) text-112  MODIF ID m3.
PARAMETERS   p_prog RADIOBUTTON GROUP prog USER-COMMAND ucomm
                    MODIF ID m3 DEFAULT 'X'.
SELECTION-SCREEN COMMENT 20(15) text-113  MODIF ID m3.
PARAMETERS   p_func RADIOBUTTON GROUP prog MODIF ID m3.

SELECTION-SCREEN COMMENT 45(10) text-114  MODIF ID m3.
PARAMETERS   p_form RADIOBUTTON GROUP prog MODIF ID m3.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN: END OF BLOCK c11.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
SELECTION-SCREEN COMMENT (13) text-016 MODIF ID m4.
SELECTION-SCREEN POSITION 17.
PARAMETERS: p_scr2   TYPE programm MODIF ID m4.
SELECTION-SCREEN POSITION 59.
SELECTION-SCREEN COMMENT (4) text-017 MODIF ID m4.
SELECTION-SCREEN POSITION 65.
PARAMETERS: p_from2    TYPE char5 MODIF ID m4.
SELECTION-SCREEN POSITION 71.
SELECTION-SCREEN COMMENT (2) text-018 MODIF ID m4.
SELECTION-SCREEN POSITION 75.
PARAMETERS: p_to2    TYPE char5 MODIF ID m4.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT (20) text-115 MODIF ID m5.
PARAMETERS : p_fname1 TYPE funcname MODIF ID m5.
SELECTION-SCREEN POSITION 55.
SELECTION-SCREEN COMMENT 55(4) text-017 MODIF ID m5.
SELECTION-SCREEN POSITION 61.
PARAMETERS: p_from1    TYPE char4 MODIF ID m5.
SELECTION-SCREEN POSITION 68.
SELECTION-SCREEN COMMENT 68(2) text-018 MODIF ID m5.
SELECTION-SCREEN POSITION 72.
PARAMETERS: p_to1    TYPE char4 MODIF ID m5.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT (22) text-116 MODIF ID m10.
PARAMETERS : p_sname1 TYPE stxfadm-formname MODIF ID m10.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
SELECTION-SCREEN COMMENT (27) text-096 MODIF ID m7.
SELECTION-SCREEN POSITION 28.
PARAMETERS: p_itab TYPE char20 MODIF ID m7.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
PARAMETERS: p_pc_sub TYPE char1 AS CHECKBOX MODIF ID m11.
SELECTION-SCREEN POSITION 3.
SELECTION-SCREEN COMMENT (57) text-121 MODIF ID m11.
SELECTION-SCREEN POSITION 62.
PARAMETERS: p_cts_h TYPE char1 AS CHECKBOX MODIF ID m12.
SELECTION-SCREEN POSITION 65.
SELECTION-SCREEN COMMENT (30) text-143 MODIF ID m12.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN: END OF BLOCK c6.

* For Excel Update
SELECTION-SCREEN: BEGIN OF BLOCK c7 WITH FRAME TITLE text-098.
PARAMETERS : p_fname TYPE localfile MODIF ID m9. " Excel File
SELECTION-SCREEN: END OF BLOCK c7.

* More Settings screen
SELECTION-SCREEN: BEGIN OF SCREEN 2000.
SELECTION-SCREEN: BEGIN OF BLOCK c13 WITH FRAME TITLE text-201 NO
INTERVALS.
PARAMETERS: p_font_n TYPE char20,  " Font Name
            p_font_s(4) TYPE n.    " Font Size
SELECTION-SCREEN: END OF BLOCK c13.
SELECTION-SCREEN: SKIP.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
SELECTION-SCREEN COMMENT (61) text-197.
SELECTION-SCREEN POSITION 62.
PARAMETERS: p_itab_d TYPE char5.   " Internal table name starts
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
SELECTION-SCREEN COMMENT (61) text-196.
SELECTION-SCREEN POSITION 62.
PARAMETERS: p_i_loc  TYPE char5.   " Local Internal table name starts
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
SELECTION-SCREEN COMMENT (61) text-198.
SELECTION-SCREEN POSITION 59.
SELECT-OPTIONS: s_itab_e FOR v_char2
                NO INTERVALS. " Internal table ends with
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
SELECTION-SCREEN COMMENT (60) text-200.
SELECTION-SCREEN POSITION 62.
PARAMETERS: p_form_p  TYPE char5.   " Local Internal table name starts
SELECTION-SCREEN END OF LINE.

PARAMETERS:
            p_const  TYPE char5,   " Constant's name starta
            p_range  TYPE char5,   " Range table starts
            p_sel_op TYPE char5,   " Select-Option starts
            p_param  TYPE char5.   " Parameter Starts with

SELECTION-SCREEN: END OF SCREEN 2000.

***********************************************************************
* INITIALIZATION                                                      *
***********************************************************************
INITIALIZATION.

* For two extra buttons (Select all and Deselect all) in the Sel Scr

  wa_functxt-icon_id = '@4B@'.
  wa_functxt-quickinfo = 'Select All'(146).
  sscrfields-functxt_01 = wa_functxt.

  wa_functxt1-icon_id = '@4D@'.
  wa_functxt1-quickinfo = 'Deselect All'(147).
  sscrfields-functxt_02 = wa_functxt1.

  wa_functxt2-icon_id = '@04@'.
  wa_functxt2-icon_text = 'More settings'.
  wa_functxt2-quickinfo = 'More settings'(148).
  sscrfields-functxt_03 = wa_functxt2.

  PERFORM sub_set_default_value_more.

  PERFORM sub_restrict_ranges.

  PERFORM sub_get_font_names.

***********************************************************************
* AT SELECTION-SCREEN                                                 *
***********************************************************************
AT SELECTION-SCREEN.

  IF sy-ucomm = 'FC01'.
*   Select all the checkboxes in the Selection Screen
    PERFORM sub_select_all_chckbox.
  ELSEIF sy-ucomm = 'FC02'.
*   Deselect all the checkboxes
    PERFORM sub_deselect_chkbox.
  ELSEIF sy-ucomm = 'FC03'.
*   Populate more settings screen
    PERFORM sub_populate_settings_screen.
  ENDIF.

  IF sy-ucomm = 'ONLI' OR          " Execute
     sy-ucomm =  space.            " Enter

*   Mandatory check for CTS
    IF p_cts IS NOT INITIAL.
      PERFORM sub_check_cts.
    ENDIF.

*   Madatory check for tables
    IF p_tab IS NOT INITIAL.
      PERFORM sub_check_table.
    ENDIF.

*   Madatory check for BDC
    IF p_bdc IS NOT INITIAL.
      PERFORM sub_check_bdc.
    ENDIF.

*   Madatory check for search help
    IF p_srch IS NOT INITIAL.
      PERFORM sub_check_searchhelp.
    ENDIF.

*   Madatory check for table access diagram
    IF p_tad  IS NOT INITIAL OR
       p_fm   IS NOT INITIAL OR
       p_code IS NOT INITIAL OR
       p_msg  IS NOT INITIAL OR
       p_sel  IS NOT INITIAL OR
       p_opp  IS NOT INITIAL OR
       p_utp  IS NOT INITIAL.
      PERFORM sub_check_prog_name.
    ENDIF.

    IF  p_utp  IS NOT INITIAL
    AND ( p_func IS NOT INITIAL OR
          p_form IS NOT INITIAL ).

      MESSAGE e398 WITH 'UTP is only possible with Program Name'(117).
    ENDIF.

*   Check for Excel File Upload
    IF p_opxl IS NOT INITIAL.
      PERFORM sub_check_excel.
    ENDIF.

*   Font Name
    IF p_font_n IS INITIAL.
      MESSAGE e398 WITH 'Please enter Font Name in More Settings'(160).
    ENDIF.

*   Font Size
    IF p_font_s IS INITIAL.
      MESSAGE e398 WITH 'Please enter Font Size in More Settings'(161).
    ENDIF.

    IF NOT p_tad IS INITIAL OR
       NOT p_code IS  INITIAL .
*     Perform to validate More Settings screen parameters
      PERFORM sub_validate_more_settings.
    ENDIF.


  ENDIF.

***********************************************************************
* At selection-screen on F4 help for Program Name                     *
***********************************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_scr2.

* Provide a F4 help for Program Name
  PERFORM sub_progname_f4 USING p_scr2 'P_SCR2' 'PROG'.

***********************************************************************
* At selection-screen on F4 help for PC file                          *
***********************************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_fname.

* Provide a F4 help for PC file
  PERFORM sub_excel_file_f4.

***********************************************************************
* At selection-screen on F4 help for Function Module Name             *
***********************************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_fname1.

* Provide a F4 help for Function Module
  PERFORM sub_progname_f4 USING p_fname1 'P_FNAME1' 'FUNC'.


* F4 help for FIELD1
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_font_n.
  PERFORM sub_populate_f4_help USING 'P_FONT_N'.

***********************************************************************
* AT SELECTION-SCREEN OUTPUT                                          *
***********************************************************************
AT SELECTION-SCREEN OUTPUT.

* Hide different block for different conditions.
  PERFORM sub_hide_blocks.

***********************************************************************
* START-OF-SELECTION                                                  *
***********************************************************************
START-OF-SELECTION.

  IF p_cts  IS NOT INITIAL OR    "CTS details
     p_msg  IS NOT INITIAL OR
     p_sel  IS NOT INITIAL OR
     p_fm   IS NOT INITIAL OR
     p_code IS NOT INITIAL OR
     p_opp  IS NOT INITIAL OR    "O/P Layout
     p_opxl IS NOT INITIAL OR    "O/P Layout from XL
     p_utp  IS NOT INITIAL OR    "BDC details
     p_bdc  IS NOT INITIAL.      "BDC details
*   Initialize Word
    PERFORM sub_initialize_word.
    v_flag = c_check.
  ENDIF.

* Populate BDC details
  IF p_bdcrec IS NOT INITIAL AND p_bdc IS NOT INITIAL.

    PERFORM sub_populate_bdc_dtls USING v_actdoc
                                        v_selection.
  ENDIF.

* Populate CTS details
  IF p_cts IS NOT INITIAL AND s_cts[] IS NOT INITIAL.
    PERFORM sub_populate_cts USING v_actdoc
                                   v_selection.
  ENDIF.

* Populate Message details
  IF p_scr2 IS NOT INITIAL AND p_msg IS NOT INITIAL.
    PERFORM sub_populate_msg_dtls USING v_actdoc
                                        v_selection.
  ENDIF.

* Populate Selection Screen details
  IF p_scr2 IS NOT INITIAL AND p_sel IS NOT INITIAL.
    PERFORM sub_populate_sel_dtls USING v_actdoc
                                        v_selection.
  ENDIF.

* Create Table Access Diagram
  IF ( p_scr2 IS NOT INITIAL OR
       p_fname1 IS NOT INITIAL OR
       p_sname1 IS NOT INITIAL )
       AND p_tad IS NOT INITIAL.
    PERFORM sub_tad USING v_actdoc
                          v_selection
                 CHANGING v_fm_info.

    IF p_cts_h IS NOT INITIAL.
      PERFORM sub_pop_cts_history USING v_actdoc
                                        v_selection.
    ENDIF.
    v_flag = c_check.
  ENDIF.

* Populate Pseudo code
  IF ( p_scr2 IS NOT INITIAL OR
       p_fname1 IS NOT INITIAL OR
       p_sname1 IS NOT INITIAL )
      AND p_code IS NOT INITIAL
      AND p_tad  IS INITIAL.
    PERFORM sub_pop_pseudo_code USING v_actdoc
                                      v_selection.

    IF p_cts_h IS NOT INITIAL.
      PERFORM sub_pop_cts_history USING v_actdoc
                                        v_selection.
    ENDIF.
  ENDIF.

* Populate Function Module
  IF ( p_scr2 IS NOT INITIAL OR
       p_fname1 IS NOT INITIAL OR
       p_sname1 IS NOT INITIAL )
     AND p_fm IS NOT INITIAL.
    PERFORM sub_populate_fm USING v_fm_info
                                  v_actdoc
                                  v_selection.
  ENDIF.

* Populate O/P details
  IF p_scr2 IS NOT INITIAL AND p_opp IS NOT INITIAL
                           AND p_itab IS NOT INITIAL.
    PERFORM sub_populate_op USING v_actdoc
                                  v_selection.
  ENDIF.

* Upload from Excel
  IF p_opxl IS NOT INITIAL AND p_fname IS NOT INITIAL.
    PERFORM sub_populate_opxl USING v_actdoc
                                    v_selection.
  ENDIF.


  IF ( p_scr2 IS NOT INITIAL OR
     p_fname1 IS NOT INITIAL OR
     p_sname1 IS NOT INITIAL ) AND
     p_utp IS NOT INITIAL .

    PERFORM sub_populate_utp USING v_actdoc
                                   v_selection.

  ENDIF.


* Populate table details
  IF s_tab[] IS NOT INITIAL AND p_tab IS NOT INITIAL.
    PERFORM sub_populate_tab_dtls.
    v_flag = c_check.
  ENDIF.

* Populate search help details
  IF s_help[] IS NOT INITIAL AND p_srch IS NOT INITIAL.
    PERFORM sub_populate_search_help.
    v_flag = c_check.
  ENDIF.

  IF v_flag = c_check.
    MESSAGE i398 WITH 'TS Generation Complete'(093).
  ELSE.
    MESSAGE i398 WITH 'Please select atleast one check box'(097).
  ENDIF.


***********************************************************************
* END-OF-SELECTION                                                    *
***********************************************************************
END-OF-SELECTION.


*&---------------------------------------------------------------------*
*&      Form  SUB_CHECK_CTS
*&---------------------------------------------------------------------*
*       Check CTS
*----------------------------------------------------------------------*
*       No parameter passed
*----------------------------------------------------------------------*
FORM sub_check_cts .
  IF s_cts[] IS INITIAL.
    SET CURSOR FIELD 'S_CTS-LOW'.
    MESSAGE e398
      WITH 'CTS/Task is mandatory'(019).
  ELSE.
    SELECT COUNT( * )
    UP TO 1 ROWS
    FROM e070            "CTS number
    WHERE strkorr IN s_cts.
    IF sy-subrc NE 0.
      SELECT COUNT( * )
      UP TO 1 ROWS
      FROM e070            "CTS number
      WHERE trkorr IN s_cts.
      IF sy-subrc NE 0.
        SET CURSOR FIELD 'S_CTS-LOW'.
        MESSAGE e398 WITH
        'Invalid Transport Request Number/Task'(058).
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    " SUB_CHECK_CTS
*&---------------------------------------------------------------------*
*&      Form  SUB_CHECK_TABLE
*&---------------------------------------------------------------------*
*       Check table name
*----------------------------------------------------------------------*
*       No parameter passed
*----------------------------------------------------------------------*
FORM sub_check_table .
* If Table Name in Selection Screen is not blank
  IF s_tab[] IS NOT INITIAL.

    SELECT COUNT(*) UP TO 1 ROWS
    FROM dd02l " SAP Tables
    WHERE tabname IN s_tab .

*   If no records found
    IF sy-subrc NE 0.
*     Set the cursor on that Select option
      SET CURSOR FIELD 'S_TAB-LOW' .
*     Display an error message
      MESSAGE e398 WITH 'Invalid Table Name'.
    ENDIF.
  ELSE.
    SET CURSOR FIELD 'S_TAB-LOW' .
    MESSAGE e398 WITH 'Table name is mandatory'(020).
  ENDIF.

ENDFORM.                    " SUB_CHECK_TABLE

*&---------------------------------------------------------------------*
*&      Form  SUB_CHECK_BDC
*&---------------------------------------------------------------------*
*       Check BDC recording
*----------------------------------------------------------------------*
*       No parameter passed
*----------------------------------------------------------------------*
FORM sub_check_bdc .
  IF p_bdcrec IS INITIAL.
    SET CURSOR FIELD 'P_BDCREC'.
    MESSAGE e398
      WITH 'BDC recording name is mandatory'(021).
  ELSE.
    SELECT COUNT( * ) UP TO 1 ROWS
      FROM apqi
      WHERE (  datatyp = '%BDC'
            OR datatyp = 'BDC' )
        AND groupid = p_bdcrec.
    IF sy-subrc <> 0.
      SET CURSOR FIELD 'P_BDCREC'.
      MESSAGE e398 WITH 'Recording doesnot Exist'(141).
    ENDIF.
  ENDIF.
ENDFORM.                    " SUB_CHECK_BDC

*&---------------------------------------------------------------------*
*&      Form  SUB_CHECK_PROG_NAME
*&---------------------------------------------------------------------*
*       Check program name
*----------------------------------------------------------------------*
*       No parameter passed
*----------------------------------------------------------------------*
FORM sub_check_prog_name.
  DATA : catalog    TYPE tssfcat.

  IF p_scr2 IS INITIAL AND p_prog IS NOT INITIAL.
    SET CURSOR FIELD 'P_SCR2'.
    MESSAGE e398
        WITH 'Program name is mandatory'(022).
  ELSEIF p_scr2 IS NOT INITIAL AND p_prog IS NOT INITIAL.
    SELECT COUNT(*) UP TO 1 ROWS
    FROM trdir " Generated Table for View TRDIR
    WHERE name EQ p_scr2 .
*   If no records found
    IF sy-subrc NE 0.
*     Set the cursor on that Parameter
      SET CURSOR FIELD 'P_SCR2' .
*     Display an error message
      MESSAGE e398 WITH 'Invalid ABAP Program Name'(192).
    ENDIF.
  ELSEIF p_fname1 IS INITIAL AND p_func IS NOT INITIAL.
    SET CURSOR FIELD 'P_FNAME1'.
    MESSAGE e398
        WITH 'Function Module name is mandatory'(138).
  ELSEIF p_fname1 IS NOT INITIAL AND p_func IS NOT INITIAL.
    SELECT COUNT(*) UP TO 1 ROWS
    FROM tfdir " Generated Table for View TRDIR
    WHERE funcname EQ p_fname1.
*   If no records found
    IF sy-subrc NE 0.
*     Set the cursor on that Parameter
      SET CURSOR FIELD 'P_FNAME1' .
*     Display an error message
      MESSAGE e398 WITH 'Invalid Function Module Name'(193).
    ENDIF.
  ELSEIF p_sname1 IS INITIAL AND p_form IS NOT INITIAL.
    SET CURSOR FIELD 'P_SNAME1'.
    MESSAGE e398
        WITH 'Smartform name is mandatory'(139).
  ELSEIF p_sname1 IS NOT INITIAL AND p_form IS NOT INITIAL.
    CALL FUNCTION 'SSF_READ_CATALOG'
      IMPORTING
        o_tcatalog = catalog.
    SORT catalog BY formname.
    READ TABLE catalog TRANSPORTING NO FIELDS
               WITH KEY formname = p_sname1
               BINARY SEARCH.
    IF sy-subrc <> 0.
      SET CURSOR FIELD 'P_SNAME1'.
      MESSAGE e398
        WITH 'Invalid Smartform name'(194).
    ENDIF.

  ELSEIF p_utp IS NOT INITIAL AND p_scr2 IS INITIAL.
    SET CURSOR FIELD 'P_SCR2'.
    MESSAGE e398
      WITH 'Program name is mandatory'(022).
  ELSEIF p_utp IS NOT INITIAL AND p_scr2 IS NOT INITIAL.
    SELECT COUNT(*) UP TO 1 ROWS
  FROM trdir " Generated Table for View TRDIR
  WHERE name EQ p_scr2 .
*   If no records found
    IF sy-subrc NE 0.
*     Set the cursor on that Parameter
      SET CURSOR FIELD 'P_SCR2'.
*     Display an error message
      MESSAGE e398 WITH 'Invalid ABAP Program Name'(192) .
    ENDIF.
  ENDIF.
ENDFORM.                    " SUB_CHECK_PROG_NAME

*&---------------------------------------------------------------------*
*&      Form  SUB_HIDE_BLOCKS
*&---------------------------------------------------------------------*
*       Hide different blocks
*----------------------------------------------------------------------*
*       No parameter passed
*----------------------------------------------------------------------*
FORM sub_hide_blocks .

  LOOP AT SCREEN.
*   For table details
    IF screen-group1 = 'M1'.
      IF p_tab EQ c_check.
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M1'

*   For BDC details
    IF screen-group1 = 'M2'.
      IF p_bdc EQ c_check.
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M2'

*   For Program name
    IF screen-group1 = 'M4'.
      IF ( ( p_utp EQ c_check ) OR
        ( p_tad EQ c_check ) OR ( p_fm EQ c_check )
        OR ( p_sel EQ c_check ) OR ( p_msg EQ c_check )
        OR ( p_opp EQ c_check ) OR ( p_code EQ c_check ) )
        AND ( p_prog = c_check ).
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M4'

*   For CTS
    IF screen-group1 = 'M6'.
      IF p_cts EQ c_check.
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M6'

*   For o/p
    IF screen-group1 = 'M7'." or screen-group1 = 'M4'.
      IF p_opp EQ c_check.
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M7'

*   For searchhelp
    IF screen-group1 = 'M8'.
      IF p_srch EQ c_check.
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M8'

*   For excel update
    IF screen-group1 = 'M9'.
      IF p_opxl EQ c_check.
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF.

*   For program name
    IF screen-group1 = 'M3'.
      IF ( p_tad EQ c_check ) OR ( p_fm EQ c_check )
        OR ( p_msg EQ c_check ) OR ( p_opp EQ c_check )
        OR ( p_code EQ c_check ) .
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M3'

*   For Function Module name
    IF screen-group1 = 'M5'.
      IF ( ( p_tad EQ c_check ) OR ( p_fm EQ c_check )
        OR ( p_sel EQ c_check ) OR ( p_msg EQ c_check )
        OR ( p_opp EQ c_check ) OR ( p_code EQ c_check ) )
        AND ( p_func = c_check ).
        screen-invisible = 0.
        screen-active = 1.
*        clear p_utp.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M5'

*IF screen-name = 'P_UTP'.
*  IF p_func = c_check
*  or p_form = c_check.
*
*  CLEAR: p_utp.
*  screen-INPUT = 0.
*  MODIFY SCREEN.
*  ENDIF.
*ENDIF.

*   For Smart Forms
    IF screen-group1 = 'M10'.
      IF ( ( p_tad EQ c_check ) OR ( p_fm EQ c_check )
        OR ( p_sel EQ c_check ) OR ( p_msg EQ c_check )
        OR ( p_opp EQ c_check ) OR ( p_code EQ c_check ) )
        AND ( p_form = c_check ).
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M10'

*   For Pseudo code subroutines
    IF screen-group1 = 'M11'.
      IF p_code EQ c_check.
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M11'

*   For CTS version History
    IF screen-group1 = 'M12'.
      IF p_code EQ c_check AND
        ( p_prog IS NOT INITIAL OR p_func IS NOT INITIAL ).
        screen-invisible = 0.
        screen-active = 1.
        MODIFY SCREEN .
      ELSE.
        screen-invisible = 1.
        screen-active = 0.
        MODIFY SCREEN .
      ENDIF.
    ENDIF. " IF screen-group1 = 'M11'
  ENDLOOP.
ENDFORM.                    " SUB_HIDE_BLOCKS

*&---------------------------------------------------------------------*
*&      Form sub_progname_f4
*&---------------------------------------------------------------------*
*       Provide a F4 help for Program name
*----------------------------------------------------------------------*
*       No parameter passed
*----------------------------------------------------------------------*
FORM sub_progname_f4 USING p_progname TYPE any
                           p_fldname  TYPE c
                           p_ptype    TYPE any.

  DATA : l_object_type TYPE euobj-id,
         l_object_name TYPE char40,
         l_suppress_selection   TYPE sy-input,
         l_object_name_selected TYPE char40,
         l_repid       TYPE syrepid,
         l_dnum        TYPE sychar04,
         l_i_dynflds   TYPE STANDARD TABLE OF dynpread,
         l_wa_dynflds  TYPE dynpread.

  l_wa_dynflds-fieldname  = p_fldname.
  APPEND l_wa_dynflds TO l_i_dynflds.
  l_repid = sy-repid.
  l_dnum = '1000'.
  CALL FUNCTION 'DYNP_VALUES_READ'
       EXPORTING
            dyname     = l_repid
            dynumb     = l_dnum
       TABLES
            dynpfields = l_i_dynflds
       EXCEPTIONS
            OTHERS.
  READ TABLE l_i_dynflds INTO l_wa_dynflds INDEX 1.



  l_object_type = p_ptype. "'PROG'.
  l_object_name = l_wa_dynflds-fieldvalue.
  l_suppress_selection = 'X'.


  CALL FUNCTION 'REPOSITORY_INFO_SYSTEM_F4'
    EXPORTING
      object_type          = l_object_type
      object_name          = l_object_name
      suppress_selection   = l_suppress_selection
    IMPORTING
      object_name_selected = l_object_name_selected
    EXCEPTIONS
      cancel               = 1.
  IF sy-subrc = 0.
    p_progname = l_object_name_selected.
  ENDIF.

ENDFORM.                    "sub_progname_f4

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_CTS
*&---------------------------------------------------------------------*
*       Populate CTs details
*----------------------------------------------------------------------*
*      -->P_V_ACTDOC  text
*      -->P_V_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_cts  USING    p_v_actdoc    TYPE ole2_object
                                p_v_selection TYPE ole2_object.

* Local variable declaration
***********************************************************************
* TYPES                                                               *
***********************************************************************
  TYPES: BEGIN OF l_x_e070,
           trkorr	 TYPE trkorr ,"Request/Task
           strkorr TYPE strkorr,"Higher-Level Request
         END OF   l_x_e070,

        BEGIN OF l_x_e071,
           trkorr	  TYPE trkorr ,   "Request/Task
           object   TYPE trobjtype ,"Object Type
           obj_name TYPE trobj_name,"Object Name in Object List
        END OF l_x_e071,

        BEGIN OF l_x_final_cts ,
          strkorr    TYPE strkorr,     "CTS
          trkorr     TYPE trkorr ,     "Request/Task
          obj_name   TYPE trobj_name, "Object Name in Object List
          object(60) TYPE c  ,        "Object Type
        END OF l_x_final_cts.

***********************************************************************
* INTERNAL TABLES                                                     *
***********************************************************************
  DATA:
  l_i_e070     TYPE STANDARD TABLE OF l_x_e070 INITIAL SIZE 0,
  l_i_e070_tmp TYPE STANDARD TABLE OF l_x_e070 INITIAL SIZE 0,
  l_i_e071     TYPE STANDARD TABLE OF l_x_e071 INITIAL SIZE 0,
  l_i_final    TYPE STANDARD TABLE OF l_x_final_cts INITIAL SIZE 0,
  l_i_text     TYPE STANDARD TABLE OF ko100.

***********************************************************************
* WORK AREAS                                                          *
***********************************************************************
  DATA: l_wa_e070   TYPE l_x_e070,
        l_wa_e071   TYPE l_x_e071,
        l_wa_final  TYPE l_x_final_cts,
        l_wa_text   TYPE ko100.

***********************************************************************
* Variables                                                          *
***********************************************************************
  DATA :
  l_tabix          TYPE sytabix,"table index
  l_v_line         TYPE i,
  l_pos            TYPE i,
  l_err            TYPE char1,       "Error Msg
  l_v_font         TYPE ole2_object, "Font
  l_v_tables       TYPE ole2_object, "Tables
  l_v_table        TYPE ole2_object, "Table
  l_v_range        TYPE ole2_object, "Range handle for various ranges
  l_v_table_border TYPE ole2_object. "Table border

* To get Text corressponding to Object type
  CALL FUNCTION 'TR_OBJECT_TABLE'
    TABLES
      wt_object_text = l_i_text.
  SORT l_i_text BY object.

* To get all the Task under the CTs number in selection screen
  SELECT trkorr  "Request/Task
         strkorr "Higher-Level Request
  FROM e070
  INTO TABLE l_i_e070
  WHERE strkorr IN s_cts.
  IF sy-subrc <> 0.
    l_err = c_check .
  ENDIF."SELECT for Tasks

* To get the CTs number for the tasks in selection screen
  SELECT trkorr  "Request/Task
         strkorr "Higher-Level Request
  FROM e070
  INTO TABLE l_i_e070_tmp
  WHERE trkorr IN s_cts.
  IF sy-subrc <> 0.
    IF l_err = c_check.
      MESSAGE i398
      WITH 'No such Transport request/Tasks found'(075).
    ENDIF.
  ENDIF. "Select for CTS

  DELETE l_i_e070_tmp WHERE strkorr IS INITIAL .
  APPEND LINES OF l_i_e070_tmp TO l_i_e070.
  SORT l_i_e070 BY strkorr trkorr.
  DELETE ADJACENT DUPLICATES FROM l_i_e070 COMPARING ALL FIELDS.
  SORT l_i_e070 BY trkorr .

* To get all the objects under a task
  SELECT trkorr   "Request/Task
         object   "Object Type
         obj_name "Object Name in Object List
  FROM e071
  INTO TABLE l_i_e071
  FOR ALL ENTRIES IN l_i_e070
  WHERE trkorr = l_i_e070-trkorr.
  IF sy-subrc = 0.
    SORT l_i_e071 BY trkorr.
  ENDIF.

*  To populate final internal table'
  LOOP AT l_i_e070 INTO l_wa_e070.

    READ TABLE l_i_e071 TRANSPORTING NO FIELDS
                      WITH KEY trkorr = l_wa_e070-trkorr
                      BINARY SEARCH.
    IF sy-subrc = 0 .
      l_tabix = sy-tabix.

*     To populate each field of the final table.
      LOOP AT l_i_e071 INTO l_wa_e071 FROM l_tabix.
        IF l_wa_e071-trkorr <> l_wa_e070-trkorr.
          EXIT.
        ENDIF.

        l_wa_final-strkorr  = l_wa_e070-strkorr.  "CTS
        l_wa_final-trkorr   = l_wa_e071-trkorr.   "Request/Task
        l_wa_final-obj_name = l_wa_e071-obj_name. "Obj Name in Obj List

        CLEAR l_wa_text.
        READ TABLE l_i_text INTO l_wa_text
                         WITH KEY object = l_wa_e071-object
                         BINARY SEARCH.
        IF sy-subrc = 0.
          l_wa_final-object  = l_wa_text-text .  "Object Type
        ENDIF.

        APPEND l_wa_final TO l_i_final.
        CLEAR l_wa_final.

      ENDLOOP."LOOP AT l_i_e071 INTO l_wa_e071 FROM l_tabix.

    ENDIF."READ TABLE l_i_e071 INTO l_wa_e071
  ENDLOOP."LOOP AT l_i_e070 INTO l_wa_e070.

  SORT l_i_final BY strkorr trkorr.

* Set font style and size
  GET PROPERTY OF p_v_selection 'Font' = l_v_font.
  SET PROPERTY OF l_v_font 'Size' = p_font_s.
  SET PROPERTY OF l_v_font 'Name' = p_font_n."'Arial'.

* get the total records in the table
*  l_v_line = LINES( l_i_final ).
  DESCRIBE TABLE l_i_final LINES l_v_line.

* Populate one text
  CALL METHOD OF p_v_selection 'TypeText'
    EXPORTING
    #1 = 'Transport information:'(078).
  CALL METHOD OF p_v_selection 'TypeParagraph'.
  CALL METHOD OF p_v_selection 'TypeParagraph'.


* Inserting table for header details
* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_v_actdoc 'Tables' = l_v_tables.

  GET PROPERTY OF p_v_selection 'Range' = l_v_range .

  l_v_line = l_v_line + 1.

*--Adding a table with rows = no of records+ header row
*and 4 columns(no of columns may also be a variable)
  CALL METHOD OF l_v_tables 'Add' = l_v_table
  EXPORTING
  #1 = l_v_range
  #2 = l_v_line  "Number of rows
  #3 = '4'.    "Number of columns

*--Setting border attribute for the table
  GET PROPERTY OF l_v_table 'Borders' = l_v_table_border.
  SET PROPERTY OF l_v_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_v_table_border 'OutsideLineWidth' = '12'. "With
  CLEAR : wa_clipbrd, i_clipbrd[].

  CONCATENATE 'Change Request #'(122)
              'Task #'(123)
              'Object Identifier (Program ID, Layout Set ID, etc)'(124)
              'Object Type(Program, Transaction,  Layout Set)'(125)
              INTO wa_clipbrd-line SEPARATED BY c_separator.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.


  LOOP AT l_i_final INTO l_wa_final.

    CONCATENATE l_wa_final-strkorr
                l_wa_final-trkorr
                l_wa_final-obj_name
                l_wa_final-object
                INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.
  ENDLOOP.

  PERFORM sub_paste_from_clipboard USING l_v_table.

  PERFORM sub_make_header_shad USING p_v_actdoc
                                     '20'.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_v_table 'Range' = l_v_range.
  GET PROPERTY OF l_v_range 'End' = l_pos .
  SET PROPERTY OF l_v_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_v_range 'Select' .

* For 1 line gap
  CALL METHOD OF p_v_selection 'TypeParagraph'.

ENDFORM.                    " SUB_POPULATE_CTS
*&---------------------------------------------------------------------*
*&      Form  SUB_INITIALIZE_WORD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_initialize_word .
  DATA : l_font TYPE ole2_object.

* Create global word application
  CREATE OBJECT v_word 'WORD.APPLICATION'.

  IF sy-subrc NE 0 .
    MESSAGE i398 WITH 'Error while creating OLE Object'(028).
    LEAVE LIST-PROCESSING .
  ENDIF .

* Setting object's visibility property
  SET PROPERTY OF v_word 'Visible' = '1' .

* Opening a new document
  GET PROPERTY OF v_word 'Documents' = v_documents .

  CALL METHOD OF v_documents 'Add' .

* Getting active document handle
  GET PROPERTY OF v_word 'ActiveDocument' = v_actdoc.

* Getting applications handle
  GET PROPERTY OF v_actdoc 'Application' = v_application .

* Getting handle for the selection which is here the character at the
* cursor position
  GET PROPERTY OF v_application 'Selection' = v_selection .

* Set font style and size
  GET PROPERTY OF v_selection 'Font' = l_font.
  SET PROPERTY OF l_font 'Size' = p_font_s.                 "'10'.
  SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.
ENDFORM.                    " SUB_INITIALIZE_WORD

*&---------------------------------------------------------------------*
*&      Form  SUB_FILL_CELL
*&---------------------------------------------------------------------*
*       Fill cells
*----------------------------------------------------------------------*
*      -->P_1      text
*      -->P_1      text
*      -->P_1      text
*      -->P_0926   text
*      -->P_L_TABLE  text
*      -->P_L_RANGE  text
*----------------------------------------------------------------------*
FORM sub_fill_cell  USING    p_i
                             p_j
                             p_bold
                             p_val
                             p_l_table
                             p_l_range
                             p_l_shad
                             p_l_cntr.
  DATA : l_cell   TYPE ole2_object ,  "One cell of a table
         l_range  TYPE ole2_object ,
         l_font   TYPE ole2_object ,
         l_shad   TYPE ole2_object,
         l_gs_pformat TYPE ole2_object.


* Getting cell coordinates
  CALL METHOD OF p_l_table 'Cell' = l_cell
    EXPORTING #1 = p_i #2 = p_j.

* Getting the range handle to write the value
  GET PROPERTY OF l_cell 'Range' = l_range .

* Filling the cell
  SET PROPERTY OF l_range 'Text' = p_val .
  GET PROPERTY OF l_range 'Font' = l_font.
  SET PROPERTY OF l_font 'Bold' = p_bold .

* For shading
  IF p_l_shad EQ c_check.
    GET PROPERTY OF l_range 'Shading' = l_shad.
    SET PROPERTY OF l_shad 'Texture' = '0' .
    SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216' .
    SET PROPERTY OF l_shad 'BackgroundPatternColor' = '14277081' .
  ENDIF.

* Centre allignment
  IF p_l_cntr = c_check.
    GET PROPERTY OF l_range 'ParagraphFormat' = l_gs_pformat.
    SET PROPERTY OF l_gs_pformat 'Alignment' = '1'.
  ENDIF.

ENDFORM.                    " SUB_FILL_CELL
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_TAB_DTLS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_populate_tab_dtls .

***********************************************************************
* VARIABLES                                                           *
***********************************************************************
  DATA : l_word        TYPE ole2_object, "OLE object handle
         l_documents   TYPE ole2_object, "Documents
         l_actdoc      TYPE ole2_object , "Active document
         l_application TYPE ole2_object , "Applicationx
         l_selection   TYPE ole2_object , "Selection
         l_font        TYPE ole2_object,
         l_temp        TYPE ole2_object,
         l_temp1       TYPE ole2_object,
         l_view        TYPE ole2_object,
         l_sele        TYPE ole2_object,
         l_appl        TYPE ole2_object,
         l_i_range     TYPE RANGE OF tabname,
         l_wa_tab      LIKE LINE OF l_i_range,
         l_wa_table    TYPE x_table,
         l_wa_x030l    TYPE x030l,
         l_obj         TYPE dd02v-tabclass,
         l_i_dfies     TYPE STANDARD TABLE OF dfies,
         l_i_table     TYPE STANDARD TABLE OF x_table,
         l_i_lockobj   TYPE STANDARD TABLE OF dd25l INITIAL SIZE 0,
         l_i_tabcat    TYPE STANDARD TABLE OF dd09l INITIAL SIZE 0.

* Get all table names
  LOOP AT s_tab INTO l_wa_tab.
    l_wa_table-tab = l_wa_tab-low.
    APPEND l_wa_table TO l_i_table.
    CLEAR l_wa_table.
  ENDLOOP.

* Get all the lock object of the given tables
  IF NOT l_i_table[] IS INITIAL.
    SELECT * FROM dd25l
    INTO TABLE l_i_lockobj
    FOR ALL ENTRIES IN l_i_table
    WHERE as4local = 'A'
      AND as4vers = '000'
      AND roottab =  l_i_table-tab.
    IF sy-subrc = 0.
      SORT l_i_lockobj BY roottab.
    ENDIF.
* Get table category
    SELECT * FROM dd09l
    INTO TABLE l_i_tabcat
    FOR ALL ENTRIES IN l_i_table
    WHERE tabname = l_i_table-tab
      AND as4local = 'A'
      AND as4vers = '000'.
    IF sy-subrc = 0.
      SORT l_i_tabcat BY tabname.
    ENDIF.
  ENDIF.

* Creating ole object handle variable
  CREATE OBJECT l_word 'WORD.APPLICATION' .

  IF sy-subrc NE 0 .
    MESSAGE i398 WITH 'Error while creating OLE Object'(028).
    LEAVE LIST-PROCESSING .
  ENDIF .

* Setting object's visibility property
  SET PROPERTY OF l_word 'Visible' = '1' .

* Opening a new document
  GET PROPERTY OF l_word 'Documents' = l_documents .

  CALL METHOD OF l_documents 'Add' .

* Getting active document handle
  GET PROPERTY OF l_word 'ActiveDocument' = l_actdoc.

* Getting applications handle
  GET PROPERTY OF l_actdoc 'Application' = l_application .

* Getting handle for the selection which is here the character at the
* cursor position
  GET PROPERTY OF l_application 'Selection' = l_selection .

* Set font style and size
  GET PROPERTY OF l_selection 'Font' = l_font.

  SET PROPERTY OF l_font 'Size' = p_font_s.                 "'10'.
  SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.

  LOOP AT l_i_table INTO l_wa_table.
*   Get the details of a table
    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = l_wa_table-tab
        langu          = sy-langu
      IMPORTING
        x030l_wa       = l_wa_x030l
        ddobjtype      = l_obj
      TABLES
        dfies_tab      = l_i_dfies
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.
    IF sy-subrc = 0.
*     Create header and footer
*      PERFORM sub_populate_header_footer USING l_actdoc
*                                               l_view.

*     To populate header name table
      PERFORM sub_populate_header_name USING l_actdoc
                                             l_selection.
*     For 1 line gap
      CALL METHOD OF l_selection 'TypeParagraph' .

*     To populate table description
      PERFORM sub_populate_table_desc USING l_actdoc
                                            l_selection.
*     For 1 line gap
      CALL METHOD OF l_selection 'TypeParagraph' .

*     To populate Table definition details
      PERFORM sub_populate_table_def USING l_actdoc
                                           l_selection
                                           l_obj
                                           l_wa_table-tab
                                  CHANGING l_appl
                                           l_sele.

*     For 1 line gap
      CALL METHOD OF l_selection 'TypeParagraph' .
*     Populate one text

*     Getting the range handle to write the value
      GET PROPERTY OF l_selection 'Font' = l_font.
      SET PROPERTY OF l_font 'Bold' = '1'.
      SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.
      SET PROPERTY OF l_font 'Size' = p_font_s.
      CALL METHOD OF l_selection 'TypeText'
        EXPORTING
        #1 = 'Table/Structure Layout'(103).

      CALL METHOD OF l_selection 'TypeParagraph'.
      CALL METHOD OF l_selection 'TypeParagraph'.

*     Populate table body
      PERFORM sub_populate_tab_body TABLES l_i_dfies
                                    USING  l_actdoc
                                           l_selection
                                           l_wa_table-tab
                                           l_appl
                                           l_sele.

*     For 1 line gap
      CALL METHOD OF l_selection 'TypeParagraph' .

*     Populate header of table detail info
      PERFORM sub_populate_detail_header USING l_actdoc
                                               l_selection.
*     For 1 line gap
      CALL METHOD OF l_selection 'TypeParagraph' .

*     Populate table detailed information
      PERFORM sub_populate_detail_info TABLES l_i_lockobj
                                              l_i_tabcat
                                       USING  l_wa_x030l
                                              l_actdoc
                                              l_selection
                                              l_wa_table-tab.

*     For 3 line gap
      CALL METHOD OF l_selection 'TypeParagraph'.
      CALL METHOD OF l_selection 'TypeParagraph'.
      CALL METHOD OF l_selection 'TypeParagraph'.

    ENDIF.
  ENDLOOP.
ENDFORM.                    " SUB_POPULATE_TAB_DTLS
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_HEADER_NAME
*&---------------------------------------------------------------------*
*       Populate header table name
*----------------------------------------------------------------------*
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_header_name  USING    p_l_actdoc TYPE ole2_object
                                        p_l_selection TYPE ole2_object.

  DATA: l_tables       TYPE ole2_object , "Tables
        l_range        TYPE ole2_object ,"Range handle for various
"ranges
        l_table        TYPE ole2_object , "One table
        l_table_border TYPE ole2_object , "Table border
        l_shd(1)       TYPE c,            "Shading
        l_cntr(1)      TYPE c,            "centre
        l_pos          TYPE ole2_object.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .

  GET PROPERTY OF p_l_selection 'Range' = l_range .

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '1'      "Number of rows
  #3 = '1'.     "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .
  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With
*  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '10'. "With

* Output column headings to active word document
  l_shd = c_check.
  l_cntr = c_check.
  PERFORM sub_fill_cell USING 1 1 1
        'Table/Structure/View Definition'(039) l_table l_range
        l_shd l_cntr.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_pos .
  SET PROPERTY OF l_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range 'Select' .

ENDFORM.                    " SUB_POPULATE_HEADER_NAME
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_TABLE_DESC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_table_desc  USING    p_l_actdoc
                                       p_l_selection.
  DATA:
    l_tables       TYPE ole2_object , "Tables
    l_range        TYPE ole2_object , "Range handle for various ranges
    l_table        TYPE ole2_object , "One table
    l_table_border TYPE ole2_object , "Table border
    l_shd          TYPE char1,        "Shading
    l_cntr         TYPE char1,        "centre
    l_pos          TYPE ole2_object.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .

  GET PROPERTY OF p_l_selection 'Range' = l_range .

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '1'      "Number of rows
  #3 = '1'.     "Number of columns

*--Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .
  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

* Output column headings to active word document
  l_shd = space.
  l_cntr = space.
  PERFORM sub_fill_cell USING 1 1 1
        'Table/Structure/View Description'(040) l_table l_range
        l_shd l_cntr .

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_pos .
  SET PROPERTY OF l_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range 'Select' .
ENDFORM.                    " SUB_POPULATE_TABLE_DESC

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_TABLE_DEF
*&---------------------------------------------------------------------*
*       Populate table definition details
*----------------------------------------------------------------------*
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*      -->P_L_OBJ  text
*----------------------------------------------------------------------*
FORM sub_populate_table_def  USING    p_l_actdoc
                                      p_l_selection
                                      p_l_obj
                                      p_l_tab
                          CHANGING    p_appl
                                      p_sele.

  TYPES : BEGIN OF l_x_bold_vals,
        f1 TYPE i,
        f2 TYPE i,
        f3 TYPE i,
        f4 TYPE i,
        END OF  l_x_bold_vals.

  DATA:   l_tables       TYPE ole2_object , "Tables
          l_range        TYPE ole2_object ,"Range handle for various
                                           "ranges
          l_table        TYPE ole2_object , "One table
          l_table_border TYPE ole2_object , "Table border
          l_sele         TYPE ole2_object,
          l_appl         TYPE ole2_object,
          l_def(120)     TYPE c,            "Value of each row in table
                                            "def
          l_count        TYPE i,
          l_desc         TYPE as4text,      "Description of table
          l_type(20)     TYPE c,
          l_pos          TYPE ole2_object,
          l_font         TYPE ole2_object,
          l_bold_val     TYPE l_x_bold_vals,
          l_rc           TYPE i.

  FIELD-SYMBOLS : <fs> TYPE ANY.

* Retrieve description of table
  SELECT SINGLE ddtext FROM dd02t
  INTO l_desc
  WHERE tabname = p_l_tab
  AND   ddlanguage = 'EN'
  AND   as4local = 'A'.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .

  GET PROPERTY OF p_l_selection 'Range' = l_range .

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '4'      "Number of rows
  #3 = '1'.     "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .

  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

  CLEAR : wa_clipbrd, i_clipbrd[].

* Population of each row in table definition
* 1st row
  CONCATENATE 'Table Name:'(041)
              p_l_tab
       INTO   l_def SEPARATED BY space.
  l_bold_val-f1 = '11'.
  wa_clipbrd = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

* 2nd row
  CASE p_l_obj.
    WHEN 'INTTAB'.
      l_type = 'Structure'(042).
    WHEN 'TRANSP'.
      l_type = 'Transparent table'(043).
    WHEN 'VIEW'.
      l_type = 'View'(044).
  ENDCASE.
  CONCATENATE 'Table Type:'(045)
              l_type
       INTO   l_def SEPARATED BY space.
  l_bold_val-f2 = '11'.
  wa_clipbrd = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

* 3rd row
  CONCATENATE 'Table Description:'(046)
              l_desc
       INTO   l_def SEPARATED BY space.
  l_bold_val-f3 = '18'.
  wa_clipbrd = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

* 4th row
  CONCATENATE 'Type of Development:'(047)
              'New object'(048)
       INTO   l_def SEPARATED BY space.
  l_bold_val-f4 = '20'.
  wa_clipbrd = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

  PERFORM sub_paste_from_clipboard USING l_table.

* Making partial bold
  GET PROPERTY OF p_l_actdoc 'Application' = l_appl.
  GET PROPERTY OF l_appl 'Selection' = l_sele.
  p_appl = l_appl.
  p_sele = l_sele.
  DO 4 TIMES.
    l_count = sy-index.
*   Press Home key
    CALL METHOD OF l_sele 'HomeKey' = l_rc
      EXPORTING
      #1 = '5'.
    ASSIGN COMPONENT l_count OF STRUCTURE l_bold_val TO <fs>.
    IF sy-subrc = 0.
      CALL METHOD OF l_sele 'MoveRight' = l_rc
        EXPORTING
        #1 = '1'
        #2 = <fs>
        #3 = '1'.
      GET PROPERTY OF l_sele 'Font' = l_font.
      SET PROPERTY OF l_font 'Bold' = '1'.
    ENDIF.
    CALL METHOD OF l_sele 'MoveDown' = l_rc
      EXPORTING
      #1 = '5'
      #2 = '1'.
  ENDDO.
  FREE OBJECT : l_sele, l_appl, l_font.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_pos .
  SET PROPERTY OF l_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range 'Select' .

ENDFORM.                    " SUB_POPULATE_TABLE_DEF

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_TAB_BODY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_I_DFIES  text
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_tab_body  TABLES   p_l_i_dfies STRUCTURE dfies
                            USING    p_l_actdoc  TYPE ole2_object
                                     p_l_selection TYPE ole2_object
                                     p_wa_table_tab
                                     p_appl
                                     p_sele.

* Types declaration
  TYPES: BEGIN OF x_foreign_key,
          forkey TYPE forkey,         "Names of Foreign Key Fields
         END OF x_foreign_key.

  DATA:   l_tables       TYPE ole2_object , "Tables
          l_range        TYPE ole2_object ,"Range handle for various
                                           "ranges
          l_table        TYPE ole2_object , "One table
          l_table_border TYPE ole2_object , "Table border
          l_pos          TYPE i, " ole2_object,
          l_font         TYPE ole2_object,
          l_sele         TYPE ole2_object,
          l_appl         TYPE ole2_object,
          l_shad         TYPE ole2_object,
          l_range_cur    TYPE ole2_object,
          l_gs_pformat   TYPE ole2_object,
          l_rc           TYPE i,
          l_shd(1)       TYPE c,            "Shading
          l_line         TYPE i,
          l_wa_dfies     TYPE dfies,
          l_wa_fields    TYPE x_fields,
          l_i_fields     TYPE STANDARD TABLE OF x_fields,
          l_i_fkey       TYPE STANDARD TABLE OF x_foreign_key,
          l_wa_fkey      TYPE x_foreign_key.

* Get the total records in the table
*  l_line = LINES( p_l_i_dfies ) + 1.
  DESCRIBE TABLE p_l_i_dfies LINES l_line.

* Retrieve foreign key details
  SELECT forkey          "Names of Foreign Key Fields
  FROM dd05s INTO TABLE l_i_fkey
  WHERE tabname = p_wa_table_tab.

* Populate the table structure
  LOOP AT p_l_i_dfies INTO l_wa_dfies.
    l_wa_fields-fieldname = l_wa_dfies-fieldname.
    l_wa_fields-description = l_wa_dfies-fieldtext.
    l_wa_fields-dataelmt = l_wa_dfies-rollname.
    l_wa_fields-datatype = l_wa_dfies-datatype.
    l_wa_fields-length   = l_wa_dfies-leng.
    IF l_wa_dfies-keyflag = c_check.
      l_wa_fields-key   = c_y.
    ELSE.
      l_wa_fields-key   = c_n.
    ENDIF.

* Retrieve check table name
    READ TABLE l_i_fkey INTO l_wa_fkey
               WITH KEY forkey = l_wa_dfies-fieldname.
    IF sy-subrc = 0.
      l_wa_fields-chktable = l_wa_dfies-checktable.
    ELSE.
      l_wa_fields-chktable = 'N/A'.
    ENDIF.


    l_wa_fields-comment = c_na.
    APPEND l_wa_fields TO l_i_fields.
    CLEAR l_wa_fields.
  ENDLOOP.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .
  GET PROPERTY OF p_l_selection 'Range' = l_range .
  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = l_line      "Number of rows
  #3 = '8'.     "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .
  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

  CLEAR : l_shd, wa_clipbrd, i_clipbrd[].
  CONCATENATE 'Field Name'(049)
              'Field Description'(050)
              'Data Element'(051)
              'Type(CHAR,NUMC)'(052)
              'Length'(053)
              'Key Field(Y/N)'(054)
              'Foreign Key(Table Name)'(055)
              'Comments'(056)
              INTO wa_clipbrd-line SEPARATED BY c_separator.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

* Output column headings to active word document
  LOOP AT l_i_fields INTO l_wa_fields.
*   Delete leading zeros from length
    SHIFT l_wa_fields-length LEFT DELETING LEADING '0'.
    CONCATENATE l_wa_fields-fieldname
                l_wa_fields-description
                l_wa_fields-dataelmt
                l_wa_fields-datatype
                l_wa_fields-length
                l_wa_fields-key
                l_wa_fields-chktable
                l_wa_fields-comment
                INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.
  ENDLOOP.

  PERFORM sub_paste_from_clipboard USING l_table.

  PERFORM sub_make_header_shad USING p_l_actdoc
                                     '18'.

*  GET PROPERTY OF p_l_actdoc 'Application' = l_appl.
*  GET PROPERTY OF l_appl 'Selection' = l_sele.
*  l_appl = p_appl.
*  l_sele = p_sele.
*  CALL METHOD OF l_sele 'MoveRight' = l_rc
*    EXPORTING
*    #1 = '1'
*    #2 = '18'
*    #3 = '1'.
*
*  GET PROPERTY OF l_sele 'Font' = l_font.
*  SET PROPERTY OF l_font 'Bold' = '1' .

** Shading
*  GET PROPERTY OF l_sele 'Shading' = l_shad.
*  SET PROPERTY OF l_shad 'Texture' = '0' .
*  SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216'.
*  SET PROPERTY OF l_shad 'BackgroundPatternColor' = '14277081'.
*
** Centre allignment
*  GET PROPERTY OF l_sele 'ParagraphFormat' = l_gs_pformat.
*  SET PROPERTY OF l_gs_pformat 'Alignment' = '1'.
*  FREE OBJECT : l_sele, l_appl, l_font, l_gs_pformat, l_shad.
*
*  FREE OBJECT : l_range.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range_cur. "l_range.
  GET PROPERTY OF l_range_cur 'End' = l_pos .
  SET PROPERTY OF l_range_cur 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range_cur 'Select' .

ENDFORM.                    " SUB_POPULATE_TAB_BODY
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_DETAIL_HEADER
*&---------------------------------------------------------------------*
*       Populate table detail header
*----------------------------------------------------------------------*
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_detail_header  USING    p_l_actdoc
                                          p_l_selection.
  DATA:     l_tables       TYPE ole2_object , "Tables
            l_range        TYPE ole2_object ,"Range handle for various
                                             "ranges
            l_table        TYPE ole2_object , "One table
            l_table_border TYPE ole2_object , "Table border
            l_pos          TYPE ole2_object,
            l_shd(1)       TYPE c,            "Shading
            l_cntr(1)      TYPE c.            "centre

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .

  GET PROPERTY OF p_l_selection 'Range' = l_range .

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '1'      "Number of rows
  #3 = '1'.     "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .
  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

* Output column headings to active word document
  l_shd = space.
  l_cntr = space.
  PERFORM sub_fill_cell USING 1 1 1
        'Table/Structure Detailed Information'(057) l_table l_range
        l_shd l_cntr .

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_pos .
  SET PROPERTY OF l_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range 'Select' .

ENDFORM.                    " SUB_POPULATE_DETAIL_HEADER
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_DETAIL_INFO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_X030L  text
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_detail_info TABLES l_i_lockobj STRUCTURE dd25l
                                     l_i_tabcat  STRUCTURE dd09l
                               USING p_l_wa_x030l TYPE x030l
                                     p_l_actdoc TYPE ole2_object
                                     p_l_selection TYPE ole2_object
                                     p_wa_table_tab.

  DATA:     l_tables       TYPE ole2_object , "Tables
            l_range        TYPE ole2_object ,"Range handle for various
                                             "ranges
            l_table        TYPE ole2_object , "One table
            l_table_border TYPE ole2_object , "Table border
            l_pos          TYPE ole2_object,
            l_font         TYPE ole2_object,
            l_sele         TYPE ole2_object,
            l_appl         TYPE ole2_object,
            l_tablen       TYPE char8,
            l_low          TYPE char8,
            l_high         TYPE char8,
            l_rc           TYPE i,
            l_size_cat(30) TYPE c,
            l_i_det        TYPE STANDARD TABLE OF x_tab_det_info,
                                              "detail info table
            l_i_ddnmb      TYPE STANDARD TABLE OF ddnmb INITIAL SIZE 0,
            l_wa_det       TYPE x_tab_det_info, "detail info WA
            l_wa_lockobj   TYPE dd25l,        "Lock object
            l_wa_tabcat    TYPE dd09l.        "Size Category

* Populate table details to print
  l_wa_det-desc = 'Buffering:'(024).
  IF p_l_wa_x030l-bufstate = 'G'.
    l_wa_det-data = ' Buffering allowed'(025).
  ELSE.
    l_wa_det-data = ' Buffering not allowed'(026).
  ENDIF.
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Space Allocation:'(027).
  l_wa_det-data = c_na.
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Table Logging:'(029).
  l_wa_det-data = c_na.
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Method of Maintenance:'(030).
  l_wa_det-data = ' Online or Batch'(031).
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Delete constraints:'(032).
  l_wa_det-data = c_na.
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Security Requirements:'(033).
  l_wa_det-data = c_na.
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Historical data requirements:'(034).
  l_wa_det-data = c_na.
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Estimated number of records:'(035).
  READ TABLE l_i_tabcat INTO l_wa_tabcat
      WITH KEY tabname = p_wa_table_tab
      BINARY SEARCH.
  IF sy-subrc = 0.
    PERFORM sub_get_high_low TABLES l_i_ddnmb
                             USING  l_wa_tabcat
                                    p_l_wa_x030l
                                    p_wa_table_tab
                             CHANGING l_size_cat.
    MOVE l_size_cat TO l_wa_det-data.
  ELSE.
    l_wa_det-data = c_na.
  ENDIF.
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Retention period:'(036).
  l_wa_det-data = c_na.
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Table Archiving Strategy:'(037).
  l_wa_det-data = c_na.
  APPEND l_wa_det TO l_i_det.

  l_wa_det-desc = 'Lock Objects:'(038).
  READ TABLE l_i_lockobj INTO l_wa_lockobj
            WITH KEY roottab = p_wa_table_tab
            BINARY SEARCH.
  IF sy-subrc = 0.
    l_wa_det-data = l_wa_lockobj-viewname.
  ELSE.
    l_wa_det-data = c_na.
  ENDIF.
  APPEND l_wa_det TO l_i_det.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .
  GET PROPERTY OF p_l_selection 'Range' = l_range .

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '11'     "Number of rows
  #3 = '2'.     "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .
  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

  CLEAR : wa_clipbrd, i_clipbrd[].
* Output column headings to active word document
  LOOP AT l_i_det INTO l_wa_det.
    IF l_wa_det-data IS INITIAL.
      l_wa_det-data = c_na.
    ENDIF.
    CONCATENATE l_wa_det-desc
                l_wa_det-data
                INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.
  ENDLOOP.

  PERFORM sub_paste_from_clipboard USING l_table.

  GET PROPERTY OF p_l_actdoc 'Application' = l_appl.
  GET PROPERTY OF l_appl 'Selection' = l_sele.
  CALL METHOD OF l_sele 'MoveDown' = l_rc
    EXPORTING
    #1 = '5'
    #2 = '10'
    #3 = '1'.

  GET PROPERTY OF l_sele 'Font' = l_font.
  SET PROPERTY OF l_font 'Bold' = '1' .
  FREE OBJECT : l_sele, l_appl, l_font.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_pos .
  SET PROPERTY OF l_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range 'Select' .

ENDFORM.                    " SUB_POPULATE_DETAIL_INFO
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_MSG_DTLS
*&---------------------------------------------------------------------*
*       Subroutine for populating message details
*----------------------------------------------------------------------*
*    -->P_V_ACTDOC  text
*    -->P_V_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_msg_dtls USING p_v_actdoc    TYPE ole2_object
                                 p_v_selection TYPE ole2_object.
  DATA : l_v_tables TYPE ole2_object,
         l_v_range  TYPE ole2_object,
         l_v_table  TYPE ole2_object,
         l_v_table_border TYPE ole2_object,
         l_v_line   TYPE i,
         l_v_count(3) TYPE n,
         l_pos      TYPE i,
         l_in_p_prog TYPE progname,
         l_in_start_index TYPE sytabix,
         l_in_end_index TYPE sytabix,
         l_ep_msg_info TYPE x_zmsg_info_ty,
         l_wa_msg_info TYPE x_zmsg_info.

  l_in_p_prog = p_scr2.
  l_in_start_index = p_from2.
  l_in_end_index = p_to2.

  PERFORM sub_z_get_prog_msg_info
                USING
                   l_in_p_prog
                   l_in_start_index
                   l_in_end_index
                   ''
                CHANGING
                   l_ep_msg_info.

  SORT l_ep_msg_info BY msg_type DESCENDING.
* Count the no of lines
*  l_v_line = LINES( l_ep_msg_info ).
  DESCRIBE TABLE l_ep_msg_info LINES l_v_line.

*  Populate one text
  CALL METHOD OF p_v_selection 'TypeText'
    EXPORTING
    #1 = 'Message details:'(079).
  CALL METHOD OF p_v_selection 'TypeParagraph'.
  CALL METHOD OF p_v_selection 'TypeParagraph'.

* Inserting table for header details
* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_v_actdoc 'Tables' = l_v_tables.

  GET PROPERTY OF p_v_selection 'Range' = l_v_range .

  l_v_line = l_v_line + 1.

*--Adding a table with rows = no of records+ header row
*and 4 columns(no of columns may also be a variable)
  CALL METHOD OF l_v_tables 'Add' = l_v_table
  EXPORTING
  #1 = l_v_range
  #2 = l_v_line  "Number of rows
  #3 = '3'.    "Number of columns

*--Setting border attribute for the table
  GET PROPERTY OF l_v_table 'Borders' = l_v_table_border.
  SET PROPERTY OF l_v_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_v_table_border 'OutsideLineWidth' = '12'. "With

  CLEAR : wa_clipbrd, i_clipbrd[].

  CONCATENATE 'Message type'(126)
              'Message number'(127)
              'Message'(015)
              INTO wa_clipbrd-line SEPARATED BY c_separator.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

  LOOP AT l_ep_msg_info INTO l_wa_msg_info.
    l_v_count = sy-tabix .
    CONCATENATE l_wa_msg_info-msg_type
                l_v_count
                l_wa_msg_info-msg
                INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.
  ENDLOOP.

  PERFORM sub_paste_from_clipboard USING l_v_table.

  PERFORM sub_make_header_shad USING p_v_actdoc
                                     '15'.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_v_table 'Range' = l_v_range.
  GET PROPERTY OF l_v_range 'End' = l_pos .
  SET PROPERTY OF l_v_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_v_range 'Select' .

* For 1 line gap
  CALL METHOD OF p_v_selection 'TypeParagraph'.

ENDFORM.                    " SUB_POPULATE_MSG_DTLS
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_BDC_DTLS
*&---------------------------------------------------------------------*
*       Subroutine for populating BDC details
*----------------------------------------------------------------------*
*      -->P_V_ACTDOC  text
*      -->P_V_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_bdc_dtls  USING p_v_actdoc    TYPE ole2_object
                                  p_v_selection TYPE ole2_object.

  DATA : l_i_final  TYPE x_zauto_recodng_tab_ty,
         l_v_tran TYPE char20,
         l_job    TYPE apq_grpn,
         l_v_tran_nam TYPE char40,
        l_wa_temp        TYPE x_zauto_field_str,"temp WA for fields
        l_wa_final       TYPE x_zauto_recrdng_str,"Final table WA
        l_tot_line       TYPE i,"total no of lines in Field table
        l_v_line         TYPE i,"Total no of lines in final tab
        l_v_line1        TYPE i,
        l_pos(5)         TYPE n,"Poition
        l_i              TYPE i,"constant
        l_rc             TYPE i,"constant
        l_len            TYPE i,
        l_len_c          TYPE char4,
        l_mvdown         TYPE i,"No of rows control has to move down
        l_string         TYPE char120,"Temporary string
        l_find           TYPE ole2_object,
        l_replacement    TYPE ole2_object,
        l_bol            TYPE boolean,
        l_v_application  TYPE ole2_object , "Tables
        l_v_tables       TYPE ole2_object , "Tables
        l_v_table        TYPE ole2_object , "Tables
        l_v_range1       TYPE ole2_object , "Tables
        l_v_range        TYPE ole2_object ,"Range handle
        l_v_font         TYPE ole2_object , "OLE object handle
        l_sele           TYPE ole2_object, "Selection object
        l_v_table_border TYPE ole2_object , "Table border
        l_v_pgsetup      TYPE ole2_object.  "page setup

  l_job = p_bdcrec.

  PERFORM sub_get_info_recording TABLES l_i_final
                                 USING l_job
                                 CHANGING l_v_tran
                                          l_v_tran_nam.

  IF l_i_final IS INITIAL.
    MESSAGE i398 WITH 'Error in fetching Recording details'(076).
  ENDIF.

** Setting the new document as landscape
*  GET PROPERTY OF p_v_actdoc 'PageSetup' = l_v_pgsetup.
*  SET PROPERTY OF l_v_pgsetup 'Orientation' = '1'.
*  SET PROPERTY OF l_v_pgsetup 'SectionStart' = '2'.

  DATA: l_empty TYPE char1.
  CALL FUNCTION 'AC_IS_QUEUE_EMPTY'
    CHANGING
      is_queue_empty = l_empty.


* Populate one text
  CALL METHOD OF p_v_selection 'TypeText'
    EXPORTING
    #1 = 'BDC Recording Details:'(092).
  CALL METHOD OF p_v_selection 'TypeParagraph'.
  CALL METHOD OF p_v_selection 'TypeParagraph'.

* Set font style and size
  GET PROPERTY OF p_v_selection 'Font' = l_v_font.
  SET PROPERTY OF l_v_font 'Size' = '1'.
  SET PROPERTY OF l_v_font 'Name' = p_font_n."'Arial'.

* Inserting table for header details
* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_v_actdoc 'Tables' = l_v_tables.
  GET PROPERTY OF p_v_selection 'Range' = l_v_range .

  l_v_line1 = 6.
  CALL METHOD OF l_v_tables 'Add' = l_v_table
  EXPORTING
  #1 = l_v_range
  #2 = l_v_line1     "Number of rows
  #3 = '7'.    "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_v_table 'Borders' = l_v_table_border.
  SET PROPERTY OF l_v_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_v_table_border 'OutsideLineWidth' = '12'. "With

* To genate one block of the BDC recording population table
  PERFORM sub_fill_bdc_screen USING l_v_table
                                    l_v_range.

  PERFORM sub_fill_bdc_field USING l_v_table
                                   l_v_range
                                   p_v_actdoc.

  PERFORM sub_fill_bdc_action USING l_v_table
                                    l_v_range.

*  l_v_line = LINES( l_i_final ).
  DESCRIBE TABLE l_i_final LINES l_v_line.

  l_v_line = l_v_line - 2.

  FREE OBJECT : l_v_range.
* Advancing the cursor to the end of the table
  GET PROPERTY OF  l_v_table 'Range' = l_v_range.
  CALL METHOD OF l_v_table 'Select'.
  CALL METHOD OF l_v_range 'Copy'.

  GET PROPERTY OF l_v_range 'End' = l_pos .
  SET PROPERTY OF l_v_range 'Start' = l_pos .
  CALL METHOD OF l_v_range 'PasteAndFormat'
    EXPORTING
    #1 = '0'.

  DO l_v_line TIMES.

*   Advancing the cursor to the end of the table
    GET PROPERTY OF l_v_table 'Range' = l_v_range1.
    GET PROPERTY OF l_v_range1 'End' = l_pos .
    SET PROPERTY OF l_v_range1 'Start' = l_pos .

*   Selects the specified object
    CALL METHOD OF l_v_range1 'Select' .

    CALL METHOD OF l_v_range1 'PasteAndFormat'
      EXPORTING
      #1 = '0'.

  ENDDO.

  FREE OBJECT : l_v_range.

  GET PROPERTY OF  l_v_table 'Range' = l_v_range.
  CALL METHOD OF l_v_table 'Select'.

* For creating one row above.
  CALL METHOD OF p_v_selection 'InsertRowsAbove'
    EXPORTING
    #1 = '1'.

* To populate the transaction name and description
  PERFORM sub_fill_bdc_tran_nam USING l_v_table
                                      l_v_range
                                      l_v_tran
                                      l_v_tran_nam.

  l_row = 3.
  l_mvdown = 4.

* To Populate the texts in the BDC recording block thus prepared
  LOOP AT l_i_final INTO l_wa_final.

*   Fill the Screen name and corresponding program
    PERFORM sub_fill_bdc_scr_txt USING l_v_table
                                   l_v_range
                                   l_wa_final.

    l_row = l_row + 2."Row count

*   Number of fields modified in this particular screen in the record
*    l_tot_line = LINES( l_wa_final-zztab ) - 1.
    DESCRIBE TABLE l_wa_final-zztab LINES l_tot_line.
    l_tot_line = l_tot_line - 1.

*   Move the cursor to the row after which rows are to be appended
    CALL METHOD OF p_v_selection 'MoveDown' = l_i
    EXPORTING
      #1 = '5'  "wdLine
      #2 = l_mvdown.

    l_mvdown = 6 + l_tot_line.
    DO l_tot_line TIMES.
*      for creating one row below.
      CALL METHOD OF p_v_selection 'InsertRowsBelow'
        EXPORTING
        #1 = '1'.
    ENDDO.
*   Move the selection to go up by l_tot_line lines
    CALL METHOD OF p_v_selection 'MoveUp' = l_i
    EXPORTING
      #1 = '5'  "wdLine
      #2 = l_tot_line.

    CLEAR i_clipbrd[].
    LOOP AT l_wa_final-zztab INTO l_wa_temp.
      REPLACE FIRST OCCURRENCE OF c_dash IN l_wa_temp-fnam WITH '@Z&'.
      l_len = l_wa_temp-leng.
      l_len_c = l_len.
      CONCATENATE space
            l_wa_temp-fnam
            l_wa_temp-fieldtext
            l_wa_temp-type
            l_len_c
            l_wa_temp-fval
            INTO wa_clipbrd-line SEPARATED BY c_dash.
      APPEND wa_clipbrd TO i_clipbrd.
      CLEAR wa_clipbrd.


      l_row = l_row + 1.

      IF l_tot_line = 0.
        EXIT.
      ENDIF."IF l_tot_line = 0.

    ENDLOOP." LOOP AT l_wa_bdcdata-ZZTAB INTO l_wa_temp.


    IF l_wa_final-zzcursor CA '-'.
      REPLACE FIRST OCCURRENCE OF '-'
      IN l_wa_final-zzcursor WITH '@Z&'.
    ENDIF.

    CONCATENATE space 'BDC_CURSOR'(089)  'Position of cursor'(090)
                ' ' ' ' l_wa_final-zzcursor
                 INTO wa_clipbrd-line
                SEPARATED BY c_dash.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.

    CALL METHOD cl_gui_frontend_services=>clipboard_export
      IMPORTING
        data       = i_clipbrd
      CHANGING
        rc         = l_rc
      EXCEPTIONS
        cntl_error = 1
        OTHERS     = 4.

    GET PROPERTY OF p_v_actdoc 'Application' = l_v_application.
    GET PROPERTY OF l_v_application 'Selection' = l_sele.
*    l_rc = LINES( i_clipbrd ).
    DESCRIBE TABLE i_clipbrd LINES l_rc.

    CALL METHOD OF l_sele 'MoveRight' = l_i
      EXPORTING
        #1 = '1' "wdCharacter
        #2 = '6'
        #3 = '1'. "wdExtend
    l_tot_line = l_tot_line + 1.

    CALL METHOD OF l_sele 'MoveDown' = l_i
      EXPORTING
        #1 = '5'  "wdLine
        #2 = l_tot_line
        #3 = '1'. "wdExtend

    CALL METHOD OF l_sele 'Paste'.

    CALL METHOD OF l_sele 'MoveRight' = l_i
      EXPORTING
        #1 = '1' "wdCharacter
        #2 = '6'
        #3 = '1'. "wdExtend

    CALL METHOD OF l_sele 'MoveDown' = l_i
      EXPORTING
        #1 = '5'  "wdLine
        #2 = l_tot_line
        #3 = '1'. "wdExtend

* Set font style and size
    GET PROPERTY OF l_sele 'Font' = l_v_font.
    SET PROPERTY OF l_v_font 'Size' = '1'.
    SET PROPERTY OF l_v_font 'Name' = p_font_n."'Arial'.

    CALL METHOD OF l_sele 'MoveUp' = l_i
      EXPORTING
        #1 = '5'  "wdLine
        #2 = l_tot_line
        #3 = '1'. "wdExtend

    IF l_wa_final-zztab IS INITIAL.
      l_row = l_row + 1.
    ENDIF.
    l_row = l_row + 1.

*   Fill the BDC_OKCODE deatils
    CONCATENATE 'BDC_OKCODE = ' '''' l_wa_final-zzokcode ''''
                 INTO l_string SEPARATED BY space.

    PERFORM sub_fill_cell_txt USING l_row 2 l_string
      l_v_table l_v_range .

    l_row = l_row + 2.
  ENDLOOP." LOOP AT l_i_final INTO l_wa_final.

  GET PROPERTY OF p_v_actdoc 'Application' = l_v_application.
  GET PROPERTY OF l_v_application 'Selection' = l_sele.
  GET PROPERTY OF l_sele 'Find' = l_find.
  CALL METHOD OF l_sele 'ClearFormatting'.
  SET PROPERTY OF l_find 'Text' = '@Z&'.
  GET PROPERTY OF l_find 'Replacement' = l_replacement.
  CALL METHOD OF l_replacement 'ClearFormatting'.
  SET PROPERTY OF l_replacement 'Text' = '-'.
  CALL METHOD OF l_find 'Execute' = l_bol
    EXPORTING
      #1  = '@Z&'
      #2  = '0'
      #3  = '0'
      #4  = '0'
      #5  = '0'
      #6  = '0'
      #7  = '1'
      #8  = '2' "wdFindAsk
      #9  = '0'
      #10 = '-'
      #11 = '2'. "wdReplaceAll

  FREE OBJECT : l_v_range , l_v_font.
  GET PROPERTY OF  l_v_table 'Range' = l_v_range.
  CALL METHOD OF l_v_table 'Select'.

  GET PROPERTY OF l_v_range 'Font' = l_v_font.
  SET PROPERTY OF l_v_font 'Size' = p_font_s.               "'10'.
  SET PROPERTY OF l_v_font 'Name' = p_font_n."'Arial'.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_v_table 'Range' = l_v_range.
  GET PROPERTY OF l_v_range 'End' = l_pos .
  SET PROPERTY OF l_v_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_v_range 'Select' .

* For 1 line gap
  CALL METHOD OF p_v_selection 'TypeParagraph'.
ENDFORM.                    " SUB_POPULATE_BDC_DTLS
*&---------------------------------------------------------------------*
*&      Form  SUB_FILL_BDC_SCREEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_V_TABLE  text
*      -->P_L_V_RANGE  text
*      -->P_L_WA_BDCDATA  text
*      -->P_L_WA_BDCDATA2  text
*----------------------------------------------------------------------*
FORM sub_fill_bdc_screen USING p_v_table TYPE ole2_object
                               p_v_range TYPE ole2_object.

  PERFORM sub_merge USING p_v_table 1 3 1 7.

  PERFORM sub_fill_cell_txt
    USING 1 1 'Program'(084)
          p_v_table p_v_range.

  PERFORM sub_fill_cell_txt
    USING 1 2 'Screen'(085)
          p_v_table p_v_range.

  PERFORM sub_merge USING p_v_table 2 3 2 7.

ENDFORM.                    " SUB_FILL_BDC_SCREEN
*&---------------------------------------------------------------------*
*&      Form  SUB_FILL_BDC_ACTION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_V_TABLE  text
*      -->P_L_V_RANGE  text
*      -->P_L_WA_BDCDATA  text
*      -->P_L_WA_BDCDATA2  text
*----------------------------------------------------------------------*
FORM sub_fill_bdc_action USING p_v_table TYPE ole2_object
                               p_v_range TYPE ole2_object.

  PERFORM sub_fill_cell_bdc
     USING 6 1 1 'Access Path/Next Action'(091)
           p_v_table p_v_range 'X'  'X' 1  1  3.

  PERFORM sub_merge USING p_v_table 6 2 6 5.

*  PERFORM sub_fill_cell_bdc
*     USING 6 2 0 '   '
*           p_v_table p_v_range ' '  '  ' 0  2  5.

ENDFORM.                    " SUB_FILL_BDC_ACTION
*&---------------------------------------------------------------------*
*&      Form  SUB_FILL_BDC_FIELD
*&---------------------------------------------------------------------*
*       Fill Field Cells
*----------------------------------------------------------------------*
*      -->P_L_V_TABLE  text
*      -->P_L_V_RANGE  text
*      -->P_L_WA_BDCDATA  text
*      -->P_L_WA_BDCDATA2  text
*----------------------------------------------------------------------*
FORM sub_fill_bdc_field USING p_v_table TYPE ole2_object
                              p_v_range TYPE ole2_object
                              p_v_actdoc TYPE ole2_object.

  DATA : l_application TYPE ole2_object,
         l_sele TYPE ole2_object,
         l_font TYPE ole2_object,
         l_shad TYPE ole2_object,
         l_cell TYPE ole2_object,
         l_range TYPE ole2_object,
         l_rc TYPE i.

  PERFORM sub_merge USING p_v_table 3 1 3 2.

  CLEAR : wa_clipbrd, i_clipbrd[].
  CONCATENATE space
      'Screen Field Name'(086)
      'Description'(070)
      'Type'(087)
      'Length'(053)
      'Default Data/Data Source/Comment'(088)
      INTO wa_clipbrd-line SEPARATED BY '-'. "c_separator.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

  GET PROPERTY OF p_v_actdoc 'Application' = l_application.
  GET PROPERTY OF l_application 'Selection' = l_sele.
  CALL METHOD OF l_sele 'MoveDown' = l_rc
    EXPORTING
    #1 = '5'  "wdLine
    #2 = '2'.
  CALL METHOD OF l_sele 'MoveRight' = l_rc
    EXPORTING
    #1 = '1'  "wdCharacter
    #2 = '6'
    #3 = '1'. "wdExtend

  CALL METHOD cl_gui_frontend_services=>clipboard_export
    IMPORTING
      data       = i_clipbrd
    CHANGING
      rc         = l_rc
    EXCEPTIONS
      cntl_error = 1
      OTHERS     = 4.

  CALL METHOD OF l_sele 'Paste'.

  CALL METHOD OF l_sele 'MoveDown' = l_rc
    EXPORTING
    #1 = '5'  "wdLine
    #2 = '2'
    #3 = '1'. "wdExtend

  GET PROPERTY OF l_sele 'Shading' = l_shad.
  SET PROPERTY OF l_shad 'Texture' = '0' .
  SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216' .
  SET PROPERTY OF l_shad 'BackgroundPatternColor' = '14277081' .

  CALL METHOD OF l_sele 'MoveUp' = l_rc
    EXPORTING
    #1 = '5'  "wdLine
    #2 = '2'.

  GET PROPERTY OF p_v_actdoc 'Application' = l_application.
  GET PROPERTY OF l_application 'Selection' = l_sele.
  CALL METHOD OF l_sele 'MoveDown' = l_rc
    EXPORTING
    #1 = '5'  "wdLine
    #2 = '2'
    #3 = '1'.  "wdExtend
  CALL METHOD OF l_sele 'MoveRight' = l_rc
    EXPORTING
    #1 = '1'  "wdCharacter
    #2 = '5'
    #3 = '1'. "wdExtend

  GET PROPERTY OF l_sele 'Font' = l_font.
  SET PROPERTY OF l_font 'Bold' = '1'.
  SET PROPERTY OF l_font 'Italic' = '1'.
  SET PROPERTY OF l_font 'Size' = '1'.
  SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.
  GET PROPERTY OF l_sele 'Shading' = l_shad.
  SET PROPERTY OF l_shad 'Texture' = '0' .
  SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216' .
  SET PROPERTY OF l_shad 'BackgroundPatternColor' = '14277081' .

  CALL METHOD OF p_v_table 'Cell' = l_cell
    EXPORTING #1 = 2 #2 = 1.
  GET PROPERTY OF l_cell 'Range' = l_range .
  GET PROPERTY OF l_range 'Font' = l_font.
  SET PROPERTY OF l_font 'Bold' = '0'.
  SET PROPERTY OF l_font 'Italic' = '0'.
  GET PROPERTY OF l_range 'Shading' = l_shad.
  SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216'.
  SET PROPERTY OF l_shad 'BackgroundPatternColor' = '-16777216'.

  CALL METHOD OF p_v_table 'Cell' = l_cell
    EXPORTING #1 = 2 #2 = 2.
  GET PROPERTY OF l_cell 'Range' = l_range .
  GET PROPERTY OF l_range 'Font' = l_font.
  SET PROPERTY OF l_font 'Bold' = '0'.
  SET PROPERTY OF l_font 'Italic' = '0'.
  GET PROPERTY OF l_range 'Shading' = l_shad.
  SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216'.
  SET PROPERTY OF l_shad 'BackgroundPatternColor' = '-16777216'.

  PERFORM sub_merge USING p_v_table 4 1 4 2.
  PERFORM sub_merge USING p_v_table 5 1 5 2.

ENDFORM.                    " SUB_FILL_BDC_FIELD
*&---------------------------------------------------------------------*
*&      Form  SUB_FILL_CELL_BDC
*&---------------------------------------------------------------------*
*       Fill cells
*----------------------------------------------------------------------*
*      -->P_1        Row
*      -->P_1        Coloumn
*      -->P_0926     Bold
*      -->P_1        Value
*      -->P_L_TABLE  Tbale
*      -->P_L_RANGE  Range
*      -->P_1        Shading
*      -->P_1        Center
*      -->P_1        Italic
*      -->P_1        Merge start cell
*      -->P_1        Merge end cell
*----------------------------------------------------------------------*
FORM sub_fill_cell_bdc  USING    p_i       TYPE i
                                 p_j       TYPE i
                                 p_bold
                                 p_val
                                 p_l_table TYPE ole2_object
                                 p_l_range TYPE ole2_object
                                 p_l_shad  TYPE c
                                 p_l_cntr  TYPE c
                                 p_italic
                                 p_start   TYPE i
                                 p_end     TYPE i.

  DATA : l_cell       TYPE ole2_object ,"One cell of a table
         l_range      TYPE ole2_object ,"range
         l_font       TYPE ole2_object ,"Font
         l_shad       TYPE ole2_object, "Shading
         l_gs_pformat TYPE ole2_object. "Format

* To merge two cells
  IF p_start <> 0 AND p_end <> 0.
    PERFORM sub_merge USING p_l_table
                            p_i
                            p_start
                            p_i
                            p_end.

  ENDIF.

* Getting cell coordinates
  CALL METHOD OF p_l_table 'Cell' = l_cell
    EXPORTING #1 = p_i #2 = p_j.

*--Getting the range handle to write the value
  GET PROPERTY OF l_cell 'Range' = l_range .

*--Filling the cell
  SET PROPERTY OF l_range 'Text' = p_val .
  GET PROPERTY OF l_range 'Font' = l_font.
  IF p_bold EQ '1'.
    SET PROPERTY OF l_font 'Bold' = p_bold .
  ENDIF.
  IF p_italic EQ '1'.
    SET PROPERTY OF l_font 'Italic' = p_italic.
  ENDIF.

*** For shading
  IF p_l_shad EQ c_check.
    GET PROPERTY OF l_range 'Shading' = l_shad.
    SET PROPERTY OF l_shad 'Texture' = '0' .
    SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216'.
    SET PROPERTY OF l_shad 'BackgroundPatternColor' = '14277081'.
  ELSEIF p_l_shad EQ space .
    GET PROPERTY OF l_range 'Shading' = l_shad.
    SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216'.
    SET PROPERTY OF l_shad 'BackgroundPatternColor' = '-16777216'.
  ENDIF.

****Centre allignment
  IF p_l_cntr = c_check.
    GET PROPERTY OF l_range 'ParagraphFormat' = l_gs_pformat.
    SET PROPERTY OF l_gs_pformat 'Alignment' = '1'.
  ENDIF.


ENDFORM.                    " SUB_FILL_CELL_BDC
*&---------------------------------------------------------------------*
*&      Form  SUB_MERGE
*&---------------------------------------------------------------------*
*       To merge cells
*----------------------------------------------------------------------*
*      -->P_P_I  Row
*      -->P_P_START  Strart Coloumn
*      -->P_P_I  Row
*      -->P_P_END  End Coloumn
*----------------------------------------------------------------------*
FORM sub_merge  USING    p_l_table TYPE ole2_object
                         p_i1
                         p_start1
                         p_i2
                         p_end1.

  DATA :  l_cell1   TYPE ole2_object ,  "One cell of a table
          l_cell2   TYPE ole2_object .  "One cell of a table

  CALL METHOD OF p_l_table 'Cell' = l_cell1
    EXPORTING #1 = p_i1 #2 = p_start1.

  CALL METHOD OF p_l_table 'Cell' = l_cell2
    EXPORTING #1 = p_i2 #2 = p_end1.

  CALL METHOD OF l_cell1 'Merge'
    EXPORTING #1 = l_cell2.

ENDFORM.                    " SUB_MERGE
*&---------------------------------------------------------------------*
*&      Form  SUB_FILL_CELL_TXT
*&---------------------------------------------------------------------*
*       Fill cells
*----------------------------------------------------------------------*
*      -->P_1        Row
*      -->P_1        Coloumn
*      -->P_1        Value
*      -->P_L_TABLE  Tbale
*      -->P_L_RANGE  Range
*----------------------------------------------------------------------*
FORM sub_fill_cell_txt  USING p_i
                              p_j
                              p_val
                              p_l_table TYPE ole2_object
                              p_l_range TYPE ole2_object.

  DATA : l_cell   TYPE ole2_object ,  "One cell of a table
         l_range  TYPE ole2_object .  "Range

*Getting cell coordinates
  CALL METHOD OF p_l_table 'Cell' = l_cell
    EXPORTING #1 = p_i #2 = p_j.

*--Getting the range handle to write the value
  GET PROPERTY OF l_cell 'Range' = l_range .

*--Filling the cell
  SET PROPERTY OF l_range 'Text' = p_val .

ENDFORM.                    " SUB_FILL_CELL_TXT

*&---------------------------------------------------------------------*
*&      Form  SUB_FILL_BDC_SCR_TXT
*&---------------------------------------------------------------------*
*   Fill the Screen name and corresponding program
*----------------------------------------------------------------------*
*      -->P_L_V_TABLE  Tble
*      -->P_L_V_RANGE  Range
*      -->P_L_WA_FINAL  Final WA
*----------------------------------------------------------------------*
FORM sub_fill_bdc_scr_txt USING p_l_v_table TYPE ole2_object
                                p_l_v_range TYPE ole2_object
                                p_l_wa_final TYPE x_zauto_recrdng_str.


  PERFORM sub_fill_cell_txt
     USING l_row 1  p_l_wa_final-program
           p_l_v_table p_l_v_range .

  PERFORM sub_fill_cell_txt
    USING l_row 2  p_l_wa_final-dynpro
          p_l_v_table p_l_v_range .

ENDFORM.                    " SUB_FILL_BDC_SCR_TXT
*&---------------------------------------------------------------------*
*&      Form  sub_fill_tran_nam
*&---------------------------------------------------------------------*
*To populate the transaction name and description
*----------------------------------------------------------------------*
*      -->P_L_V_TABLE  Table
*      -->P_L_V_RANGE  Range
*----------------------------------------------------------------------*
FORM sub_fill_bdc_tran_nam USING p_v_table TYPE ole2_object
                                 p_v_range TYPE ole2_object
                                 p_v_tran
                                 p_v_tran_nam.


  DATA : l_cell TYPE ole2_object ."Cell

  PERFORM sub_fill_cell_bdc
    USING 1 1 1 'Transaction'(082)
          p_v_table p_v_range 'X'  ' ' 1  0  0.

  PERFORM sub_fill_cell_bdc
    USING 1 2 0  p_v_tran
          p_v_table  p_v_range ' '  ' ' 0  0  0.

  PERFORM sub_fill_cell_bdc
    USING 1 3 1 'Transaction Name'(083)
          p_v_table  p_v_range 'X'  ' ' 1  0  0.

* Split Cells
  CALL METHOD OF p_v_table 'Cell' = l_cell
    EXPORTING #1 = '1' #2 = '3'.

  CALL METHOD OF l_cell 'Split'
    EXPORTING
    #1 = '1'
    #2 = '5'.

  PERFORM sub_fill_cell_bdc
    USING 1 4 0 p_v_tran_nam
          p_v_table  p_v_range ' '  ' ' 0  4  7.


ENDFORM.                    " SUB_FILL_BDC_TRAN_NAM
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_SEL_DTLS
*&---------------------------------------------------------------------*
*       Subroutine for populating message details
*----------------------------------------------------------------------*
*    -->P_V_ACTDOC  text
*    -->P_V_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_sel_dtls USING p_v_actdoc    TYPE ole2_object
                                 p_v_selection TYPE ole2_object.
  TYPES: BEGIN OF x_selscr,
        zzfldnme(8)  TYPE c,  "Field Name
        zzfldtyp(30) TYPE c,  "Field Type
        zzseltyp1(1) TYPE c,  "Selection Field Type(P:Para/S:Sel Opt)
        zzflddes(60) TYPE c,  "Field Description
        zzselcmt(50) TYPE c,  "Comments
        zzdefval(20) TYPE c,  "Default Value
      END OF x_selscr.

  DATA : l_v_tables TYPE ole2_object,
         l_v_range  TYPE ole2_object,
         l_v_table  TYPE ole2_object,
         l_v_table_border TYPE ole2_object,
         l_v_application TYPE ole2_object,
         l_sele     TYPE ole2_object,
         l_find     TYPE ole2_object,
         l_replacement TYPE ole2_object,
         l_v_line   TYPE i,
         l_pos      TYPE i,
         l_bol      TYPE boolean,
         l_sel_dtls TYPE char100,
         l_font     TYPE ole2_object,
*         i_selection TYPE STANDARD TABLE OF x_zreport_sel_info,
         l_wa_selscr_det TYPE x_zreport_sel_info.

  PERFORM sub_get_sel_info.

  IF NOT i_selection[] IS INITIAL.

*   Count the no of lines
*    l_v_line = LINES( i_selection ).
    DESCRIBE TABLE i_selection LINES l_v_line.

*     Populate one text
    CALL METHOD OF p_v_selection 'TypeText'
      EXPORTING
      #1 = 'Selection screen information:'(080).
    CALL METHOD OF p_v_selection 'TypeParagraph'.
    CALL METHOD OF p_v_selection 'TypeParagraph'.

*   Inserting table for header details
*   Inserting a table and filling some of its cells.
    GET PROPERTY OF p_v_actdoc 'Tables' = l_v_tables.

    GET PROPERTY OF p_v_selection 'Range' = l_v_range .

    l_v_line = l_v_line + 1.

    CALL METHOD OF l_v_tables 'Add' = l_v_table
    EXPORTING
    #1 = l_v_range
    #2 = l_v_line  "Number of rows
    #3 = '5'.    "Number of columns

*   Setting border attribute for the table
    GET PROPERTY OF l_v_table 'Borders' = l_v_table_border.
    SET PROPERTY OF l_v_table_border 'Enable' = '1' . "With border
    SET PROPERTY OF l_v_table_border 'OutsideLineWidth' = '12'. "With

    CLEAR : wa_clipbrd, i_clipbrd[].

    CONCATENATE 'Comments (Range, Single/Multiple Selection,'(131)
    'Patterns, Mandatory, etc.)'(145)
    INTO wa_clipbrd-line SEPARATED BY space.

    CONCATENATE 'Name'(128)
       'Table Field/ Check box/ Radio button  - (with group)'(129)
              'Select-option (S) or Parameter (P)'(130)
              wa_clipbrd-line
*'Comments (Range, Single/Multiple Selection, Patterns,'&
*' Mandatory, etc.)'(131)
              'Default Value'(074)
              INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.

    LOOP AT i_selection INTO l_wa_selscr_det.

      CONCATENATE l_wa_selscr_det-zzfldnme '('
                  l_wa_selscr_det-zzflddes ')'
                  INTO l_sel_dtls SEPARATED BY space.
      IF l_wa_selscr_det-zzfldtyp CS c_dash.
        REPLACE ALL OCCURRENCES OF c_dash IN l_wa_selscr_det-zzfldtyp
                    WITH '@Z&'.
      ENDIF.
      IF l_wa_selscr_det-zzselcmt CS c_dash.
        REPLACE ALL OCCURRENCES OF c_dash IN l_wa_selscr_det-zzselcmt
                    WITH '@Z&'.
      ENDIF.
      CONCATENATE l_sel_dtls
                  l_wa_selscr_det-zzfldtyp
                  l_wa_selscr_det-zzseltyp1
                  l_wa_selscr_det-zzselcmt
                  l_wa_selscr_det-zzdefval
                  INTO wa_clipbrd-line SEPARATED BY c_separator.
      APPEND wa_clipbrd TO i_clipbrd.
      CLEAR wa_clipbrd.
    ENDLOOP.

    PERFORM sub_paste_from_clipboard USING l_v_table.

    GET PROPERTY OF p_v_actdoc 'Application' = l_v_application.
    GET PROPERTY OF l_v_application 'Selection' = l_sele.
    GET PROPERTY OF l_sele 'Find' = l_find.
    CALL METHOD OF l_sele 'ClearFormatting'.
    SET PROPERTY OF l_find 'Text' = '@Z&'.
    GET PROPERTY OF l_find 'Replacement' = l_replacement.
    CALL METHOD OF l_replacement 'ClearFormatting'.
    SET PROPERTY OF l_replacement 'Text' = '-'.
    CALL METHOD OF l_find 'Execute' = l_bol
      EXPORTING
        #1  = '@Z&'
        #2  = '0'
        #3  = '0'
        #4  = '0'
        #5  = '0'
        #6  = '0'
        #7  = '1'
        #8  = '2' "wdFindAsk
        #9  = '0'
        #10 = '-'
        #11 = '2'. "wdReplaceAll

*   Advancing the cursor to the end of the table
    GET PROPERTY OF l_v_table 'Range' = l_v_range.
    GET PROPERTY OF l_v_range 'Font' = l_font.
    SET PROPERTY OF l_font 'Size' = p_font_s.               "'10'.
    SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.

    PERFORM sub_make_header_shad USING p_v_actdoc
                                       '9'.

    GET PROPERTY OF l_v_range 'End' = l_pos .
    SET PROPERTY OF l_v_range 'Start' = l_pos .

*   Selects the specified object
    CALL METHOD OF l_v_range 'Select' .

*   For 1 line gap
    CALL METHOD OF p_v_selection 'TypeParagraph'.
  ENDIF.
ENDFORM.                    " SUB_POPULATE_SEL_DTLS
*&---------------------------------------------------------------------*
*&      Form  SUB_CHECK_SEARCHHELP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_check_searchhelp .
  IF s_help[] IS INITIAL.
    MESSAGE e398
        WITH 'Search help name is mandatory'(060).
  ELSE.

    SELECT COUNT(*) UP TO 1 ROWS
      FROM dd30l " Search helps
      WHERE shlpname IN s_help .

*   If no records found
    IF sy-subrc NE 0.

*     Set the cursor on that Select option
      SET CURSOR FIELD 'S_HELP-LOW'.

*     Display an error message
      MESSAGE e398 WITH 'Invalid Search Help'(195).
    ENDIF.

  ENDIF.
ENDFORM.                    " SUB_CHECK_SEARCHHELP

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_SEARCH_HELP
*&---------------------------------------------------------------------*
*       Populate search help details
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_populate_search_help .

  DATA : l_word        TYPE ole2_object, "OLE object handle
         l_documents   TYPE ole2_object, "Documents
         l_actdoc      TYPE ole2_object , "Active document
         l_application TYPE ole2_object , "Applicationx
         l_selection   TYPE ole2_object , "Selection
         l_font        TYPE ole2_object,
         l_view        TYPE ole2_object,
         l_i_range     TYPE RANGE OF shlpname,
         l_wa_tab      LIKE LINE OF l_i_range,
         l_wa_table    TYPE x_search,
         l_i_table     TYPE STANDARD TABLE OF x_search,
         l_wa_desc     TYPE x_help_desc,
         l_i_param     TYPE STANDARD TABLE OF x_help_info.

* BOC Chandrani 07/31/2009
  TYPES:
  BEGIN OF x_dd31s,
   shlpname  TYPE shlpname,   "Name of a Search Help
   subshlp   TYPE subshlp,    "Search help included in a collective
                              "search help
  END OF x_dd31s.
  DATA: l_i_dd31s        TYPE STANDARD TABLE OF x_dd31s,
        l_wa_dd31s       TYPE x_dd31s,
        l_tabix          TYPE sy-tabix,
        l_flag           TYPE char1.
* EOC Chandrani 07/31/2009

* Get all table names
  LOOP AT s_help INTO l_wa_tab.
    l_wa_table-srchhelp = l_wa_tab-low.
    APPEND l_wa_table TO l_i_table.
    CLEAR l_wa_table.
  ENDLOOP.

* Creating ole object handle variable
  CREATE OBJECT l_word 'WORD.APPLICATION' .

  IF sy-subrc NE 0 .
    MESSAGE i398 WITH 'Error while creating OLE Object'(028).
    LEAVE LIST-PROCESSING .
  ENDIF .

* Setting object's visibility property
  SET PROPERTY OF l_word 'Visible' = '1' .

* Opening a new document
  GET PROPERTY OF l_word 'Documents' = l_documents .

  CALL METHOD OF l_documents 'Add' .

* Getting active document handle
  GET PROPERTY OF l_word 'ActiveDocument' = l_actdoc.

* Getting applications handle
  GET PROPERTY OF l_actdoc 'Application' = l_application .

* Getting handle for the selection which is here the character at the
* cursor position
  GET PROPERTY OF l_application 'Selection' = l_selection .

* Set font style and size
  GET PROPERTY OF l_selection 'Font' = l_font.

  SET PROPERTY OF l_font 'Size' = p_font_s.                 "'10'.
  SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.

* BOC Chandrani 07/31/2009
* Retrieve from table DD31S
  SELECT shlpname        "Name of a Search Help
         subshlp       "Search help included in a collective search
                       "help
  FROM dd31s INTO TABLE l_i_dd31s
  FOR ALL ENTRIES IN l_i_table
  WHERE shlpname = l_i_table-srchhelp
  AND   as4local = 'A'.

  IF sy-subrc = 0.
    SORT l_i_dd31s BY shlpname.
  ENDIF.

* EOC Chandrani 07/31/2009
  LOOP AT l_i_table INTO l_wa_table.

    CLEAR : l_i_param[], l_wa_desc.

* BOC Chandrani 07/31/2009
    READ TABLE l_i_dd31s INTO l_wa_dd31s
         WITH KEY shlpname = l_wa_table-srchhelp.
    IF sy-subrc = 0.
      l_tabix = sy-tabix.

      LOOP AT l_i_dd31s INTO l_wa_dd31s FROM l_tabix.
        IF l_wa_dd31s-shlpname NE l_wa_table-srchhelp.
          EXIT.
        ENDIF.
* EOC Chandrani 07/31/2009
        PERFORM sub_get_search_help_info TABLES l_i_param
                                      USING l_wa_dd31s-subshlp
                                      CHANGING l_wa_desc.

**   Create header and footer
*    PERFORM sub_populate_header_footer USING l_actdoc
*                                    CHANGING l_view.
* BOC Chandrani 07/31/2009
        IF l_flag NE 'X'.
*   To populate header name table
          PERFORM sub_pop_header_name USING l_actdoc
                                            l_selection.
        ENDIF.

*   For 1 line gap
        CALL METHOD OF l_selection 'TypeParagraph'.

*   To populate table description
        PERFORM sub_pop_table_desc USING l_actdoc
                                         l_selection.
*   For 1 line gap
        CALL METHOD OF l_selection 'TypeParagraph'.

*   To populate Table definition details
        PERFORM sub_populate_srchelp_def USING l_actdoc
                                               l_selection
                                               l_wa_desc.
*   For 1 line gap
        CALL METHOD OF l_selection 'TypeParagraph'.

*   Populate table detailed information
        PERFORM sub_pop_shlp_body TABLES l_i_param
                                  USING  l_actdoc
                                         l_selection.

* BOC Chandrani 07/31/2009
        l_flag = 'X'.
        REFRESH: l_i_param.
        CLEAR: l_wa_desc.
      ENDLOOP.
    ENDIF.
    CLEAR: l_tabix,
           l_flag.
* EOC Chandrani 07/31/2009
*   For 3 line gap
    CALL METHOD OF l_selection 'TypeParagraph'.
    CALL METHOD OF l_selection 'TypeParagraph'.
    CALL METHOD OF l_selection 'TypeParagraph'.

  ENDLOOP.
ENDFORM.                    " SUB_POPULATE_SEARCH_HELP

*&---------------------------------------------------------------------*
*&      Form  SUB_POP_HEADER_NAME
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_pop_header_name  USING    p_l_actdoc TYPE ole2_object
                                   p_l_selection TYPE ole2_object.

  DATA: l_tables       TYPE ole2_object , "Tables
          l_range        TYPE ole2_object ,"Range handle for various
  "ranges
          l_table        TYPE ole2_object , "One table
          l_table_border TYPE ole2_object , "Table border
          l_shd(1)       TYPE c,            "Shading
          l_cntr(1)      TYPE c,            "centre
          l_pos          TYPE ole2_object.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .

  GET PROPERTY OF p_l_selection 'Range' = l_range .

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '1'      "Number of rows
  #3 = '1'.     "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .
  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

* Output column headings to active word document
  l_shd = c_check.
  l_cntr = c_check.
  PERFORM sub_fill_cell USING 1 1 1
        'Search Help Definition'(061) l_table l_range
        l_shd l_cntr.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_pos .
  SET PROPERTY OF l_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range 'Select' .

ENDFORM.                    " SUB_POP_HEADER_NAME

*&---------------------------------------------------------------------*
*&      Form  SUB_POP_TABLE_DESC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_pop_table_desc  USING    p_l_actdoc
                                  p_l_selection.

  DATA:
      l_tables       TYPE ole2_object , "Tables
      l_range        TYPE ole2_object , "Range handle for various ranges
      l_table        TYPE ole2_object , "One table
      l_table_border TYPE ole2_object , "Table border
      l_shd          TYPE char1,        "Shading
      l_cntr         TYPE char1,        "centre
      l_pos          TYPE ole2_object.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .

  GET PROPERTY OF p_l_selection 'Range' = l_range .

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '1'      "Number of rows
  #3 = '1'.     "Number of columns

*--Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .
  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

* Output column headings to active word document
  l_shd = space.
  l_cntr = space.
  PERFORM sub_fill_cell USING 1 1 1
        'Search Help Description'(062) l_table l_range
        l_shd l_cntr .

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_pos .
  SET PROPERTY OF l_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range 'Select' .

ENDFORM.                    " SUB_POP_TABLE_DESC

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_SRCHELP_DEF
*&---------------------------------------------------------------------*
*       Populate search help definition details
*----------------------------------------------------------------------*
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*      -->P_L_WA_DESC  text
*----------------------------------------------------------------------*
FORM sub_populate_srchelp_def  USING    p_l_actdoc TYPE ole2_object
                                        p_l_selection TYPE ole2_object
                                    p_l_wa_desc TYPE
x_zsearch_help_desc.
  TYPES : BEGIN OF l_x_bold_vals,
          f1 TYPE i,
          f2 TYPE i,
          f3 TYPE i,
          f4 TYPE i,
          f5 TYPE i,
          f6 TYPE i,
          f7 TYPE i,
          END OF  l_x_bold_vals.

  DATA:     l_tables       TYPE ole2_object , "Tables
            l_range        TYPE ole2_object ,"Range handle for various
                                             "ranges
            l_table        TYPE ole2_object , "One table
            l_font         TYPE ole2_object,
            l_appl         TYPE ole2_object,
            l_sele         TYPE ole2_object,
            l_table_border TYPE ole2_object , "Table border
            l_def(120)     TYPE c,  "Value of each row in table def
            l_count        TYPE i,
            l_rc           TYPE i,
            l_bold_val     TYPE l_x_bold_vals,
            l_pos          TYPE ole2_object.

  FIELD-SYMBOLS : <fs> TYPE ANY.

** Retrieve description of table
*  SELECT SINGLE ddtext FROM dd02t
*  INTO l_desc
*  WHERE tabname = p_l_tab
*  AND   ddlanguage = 'EN'
*  AND   as4local = 'A'.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .

  GET PROPERTY OF p_l_selection 'Range' = l_range .

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '7'      "Number of rows
  #3 = '1'.     "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .

  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

  CLEAR : wa_clipbrd, i_clipbrd[].
* Population of each row in table definition
* 1st row
  CONCATENATE 'Search Help Name:'(063)
              p_l_wa_desc-shlpname
       INTO   l_def SEPARATED BY space.
  l_bold_val-f1 = '17'.
  wa_clipbrd-line = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

  CONCATENATE 'Description:'(064)
              p_l_wa_desc-description
       INTO   l_def SEPARATED BY space.
  l_bold_val-f2 = '12'.
  wa_clipbrd-line = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

* 3rd row
  CONCATENATE 'Hot key:'(065)
              p_l_wa_desc-hotkey
       INTO   l_def SEPARATED BY space.
  l_bold_val-f3 = '8'.
  wa_clipbrd-line = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

* 4th row
  CONCATENATE 'Short text:'(066)
              p_l_wa_desc-text
       INTO   l_def SEPARATED BY space.
  l_bold_val-f4 = '11'.
  wa_clipbrd-line = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

* 5th row
  CONCATENATE 'Selection Method (Search Help Exit ):'(067)
              p_l_wa_desc-sel_method
       INTO   l_def SEPARATED BY space.
  l_bold_val-f5 = '37'.
  wa_clipbrd-line = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

* 6th row
  CONCATENATE 'Dialog Type:'(068)
              p_l_wa_desc-dialogtype
       INTO   l_def SEPARATED BY space.
  l_bold_val-f6 = '12'.
  wa_clipbrd-line = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

* 7th row
  CONCATENATE 'Type of Development:'(047)
              'New object'(048)
       INTO   l_def SEPARATED BY space.
  l_bold_val-f7 = '20'.
  wa_clipbrd-line = l_def.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

  PERFORM sub_paste_from_clipboard USING l_table.

* Making partial bold
  GET PROPERTY OF p_l_actdoc 'Application' = l_appl.
  GET PROPERTY OF l_appl 'Selection' = l_sele.

  DO 7 TIMES.
    l_count = sy-index.
*   Press Home key
    CALL METHOD OF l_sele 'HomeKey' = l_rc
      EXPORTING
      #1 = '5'.
    ASSIGN COMPONENT l_count OF STRUCTURE l_bold_val TO <fs>.
    IF sy-subrc = 0.
      CALL METHOD OF l_sele 'MoveRight' = l_rc
        EXPORTING
        #1 = '1'
        #2 = <fs>
        #3 = '1'.
      GET PROPERTY OF l_sele 'Font' = l_font.
      SET PROPERTY OF l_font 'Bold' = '1'.
    ENDIF.
    CALL METHOD OF l_sele 'MoveDown' = l_rc
      EXPORTING
      #1 = '5'
      #2 = '1'.
  ENDDO.
  FREE OBJECT : l_sele, l_appl, l_font.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_pos .
  SET PROPERTY OF l_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range 'Select' .

ENDFORM.                    " SUB_POPULATE_SRCHELP_DEF
*&---------------------------------------------------------------------*
*&      Form  SUB_POP_SHLP_BODY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_I_PARAM  text
*      -->P_L_ACTDOC  text
*      -->P_L_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_pop_shlp_body TABLES p_l_i_param STRUCTURE wa_zsearch_help_info
                        USING p_l_actdoc  TYPE ole2_object
                              p_l_selection TYPE ole2_object.

  DATA:     l_tables       TYPE ole2_object, "Tables
            l_range        TYPE ole2_object, "Range handle for various
                                             "ranges
            l_table        TYPE ole2_object, "One table
            l_table_border TYPE ole2_object, "Table border
            l_pos          TYPE ole2_object,
            l_appl         TYPE ole2_object,
            l_sele         TYPE ole2_object,
            l_gs_pformat   TYPE ole2_object,
            l_shad         TYPE ole2_object,
            l_font         TYPE ole2_object,
            l_line         TYPE i,
            l_wa_param     TYPE x_zsearch_help_info,
            l_rc           TYPE i.

* Get the total records in the table
*  l_line = LINES( p_l_i_param ) + 1.
  DESCRIBE TABLE p_l_i_param LINES l_line.
  l_line = l_line + 1.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_l_actdoc 'Tables' = l_tables .
  GET PROPERTY OF p_l_selection 'Range' = l_range .
  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = l_line   "Number of rows
  #3 = '8'.     "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border .
  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

  CLEAR : wa_clipbrd, i_clipbrd[].
  CONCATENATE 'Field Name/Parameter'(069)
            'Description'(070)
            'Import/Export(I/E)'(071)
            'KeyField(Y/N)'(072)
            'Data Element'(051)
            'Type (CHAR, NUMC)'(073)
            'Length'(053)
            'Default Value'(074)
            INTO wa_clipbrd-line SEPARATED BY c_separator.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.

  LOOP AT p_l_i_param INTO l_wa_param.
    IF l_wa_param-key IS NOT INITIAL.
      l_wa_param-key = 'Y'.
    ELSE.
      l_wa_param-key = 'N'.
    ENDIF.
    CONCATENATE l_wa_param-fieldname
                l_wa_param-description
                l_wa_param-import_export
                l_wa_param-key
                l_wa_param-dataelement
                l_wa_param-datatype
                l_wa_param-length
                l_wa_param-default_value
                INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.
  ENDLOOP.

  PERFORM sub_paste_from_clipboard USING l_table.

  PERFORM sub_make_header_shad USING p_l_actdoc
                                     '28'.

*  GET PROPERTY OF p_l_actdoc 'Application' = l_appl.
*  GET PROPERTY OF l_appl 'Selection' = l_sele.
*  CALL METHOD OF l_sele 'MoveRight' = l_rc
*    EXPORTING
*    #1 = '1'
*    #2 = '28'
*    #3 = '1'.
*
*  GET PROPERTY OF l_sele 'Font' = l_font.
*  SET PROPERTY OF l_font 'Bold' = '1' .
*
** Shading
*  GET PROPERTY OF l_sele 'Shading' = l_shad.
*  SET PROPERTY OF l_shad 'Texture' = '0' .
*  SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216' .
*  SET PROPERTY OF l_shad 'BackgroundPatternColor' = '14277081' .
*
** Centre allignment
*  GET PROPERTY OF l_sele 'ParagraphFormat' = l_gs_pformat.
*  SET PROPERTY OF l_gs_pformat 'Alignment' = '1'.
*  FREE OBJECT : l_sele, l_appl, l_font, l_gs_pformat, l_shad.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_pos .
  SET PROPERTY OF l_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_range 'Select' .

ENDFORM.                    " SUB_POP_SHLP_BODY
*&---------------------------------------------------------------------*
*&      Form  SUB_TAD
*&---------------------------------------------------------------------*
*       Create Table Access Diagram
*----------------------------------------------------------------------*
*       No parameter passed
*----------------------------------------------------------------------*
FORM sub_tad USING p_actdoc    TYPE ole2_object
                   p_selection TYPE ole2_object
          CHANGING p_fm_info   TYPE x_zfm_call_info_ty.

  DATA: l_ep_select_info  TYPE x_zselect_info_ty,
        l_ep_table_fields TYPE x_ztable_field_name_ty,
        l_ep_table_desc   TYPE x_zdbtab_text_ty,
        l_ep_field_desc   TYPE x_zfield_desc_ty,
        l_ep_sub_call_info TYPE x_zperform_call_info_ty.

  PERFORM sub_tad_get_data CHANGING l_ep_select_info
                                    l_ep_table_fields
                                    l_ep_table_desc
                                    l_ep_field_desc
                                    l_ep_sub_call_info
                                    p_fm_info.

  PERFORM sub_tad_populate_excell USING l_ep_select_info
                                        l_ep_table_fields
                                        l_ep_table_desc
                                        l_ep_field_desc.

  IF p_code IS NOT INITIAL.
    PERFORM sub_pcd_get_pseudo_code USING l_ep_select_info
                                          l_ep_table_fields
                                          l_ep_table_desc
                                          l_ep_field_desc
                                          p_fm_info
                                          l_ep_sub_call_info
                                          p_actdoc
                                          p_selection.
  ENDIF.
ENDFORM.                    " SUB_TAD
*&---------------------------------------------------------------------*
*&      Form  SUB_GET_DATA
*&---------------------------------------------------------------------*
*       Subroutine for getting Table Access Diagram data
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_tad_get_data CHANGING
                      l_ep_select_info   TYPE x_zselect_info_ty
                      l_ep_table_fields  TYPE x_ztable_field_name_ty
                      l_ep_table_desc    TYPE x_zdbtab_text_ty
                      l_ep_field_desc    TYPE x_zfield_desc_ty
                      l_ep_sub_call_info TYPE x_zperform_call_info_ty
                      p_fm_info          TYPE x_zfm_call_info_ty.

  DATA : l_prog TYPE progname,
       l_from TYPE sytabix,
       l_to   TYPE sytabix,
       l_fname TYPE rs38l_fnam,
       l_proctype TYPE char1,
       l_sub_flg  TYPE char1.

  IF p_scr2 IS NOT INITIAL AND p_prog IS NOT INITIAL.
    l_prog = p_scr2.
    l_from = p_from2.
    l_to = p_to2.
    l_proctype = ''.

  ELSEIF p_func IS NOT INITIAL AND p_fname1 IS NOT INITIAL.
    l_from = p_from1.
    l_to = p_to1.
    l_proctype = 'F'.
    PERFORM sub_get_program_name USING p_fname1
                              CHANGING l_prog.

  ELSEIF p_form IS NOT INITIAL AND p_sname1 IS NOT INITIAL.
    CLEAR : l_from, l_to.
    l_proctype = 'F'.
    CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
      EXPORTING
        formname           = p_sname1
        variant            = ' '
        direct_call        = ' '
      IMPORTING
        fm_name            = l_fname
      EXCEPTIONS
        no_form            = 1
        no_function_module = 2
        OTHERS             = 3.
    IF sy-subrc = 0.
      PERFORM sub_get_program_name USING l_fname
                                CHANGING l_prog.
    ENDIF.
  ENDIF.


**  IF p_pc_sub = 'X'.
*    l_sub_flg = 'X'.
*  ELSE.
*    l_sub_flg = space.
*  ENDIF.

  PERFORM sub_z_get_prog_info
            USING
               l_prog
               l_from
               l_to
               l_proctype
               'X'
            CHANGING
               l_ep_select_info
               l_ep_table_fields
               l_ep_table_desc
               l_ep_field_desc
               p_fm_info
               l_ep_sub_call_info.
ENDFORM.                    " SUB_GET_DATA
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_EXCELL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_tad_populate_excell USING
                          l_ep_select_info  TYPE x_zselect_info_ty
                          l_ep_table_fields TYPE x_ztable_field_name_ty
                          l_ep_table_desc   TYPE x_zdbtab_text_ty
                          l_ep_field_desc   TYPE x_zfield_desc_ty.

  TYPES:
        BEGIN OF x_draw_line,
          r_from  TYPE i,
          c_from  TYPE i,
          r_to    TYPE i,
          c_to    TYPE i,
          x_from  TYPE p DECIMALS 2,
          y_from  TYPE p DECIMALS 2,
          x_to    TYPE p DECIMALS 2,
          y_to    TYPE p DECIMALS 2,
       END OF x_draw_line,
       BEGIN OF x_xy_val,
          row     TYPE i,
          column  TYPE i,
          val     TYPE char100,
          bold    TYPE char1,
          yellow  TYPE char1,
          box     TYPE char1,
       END OF x_xy_val,
       BEGIN OF x_box,
          r_from  TYPE i,
          c_from  TYPE i,
          r_to    TYPE i,
          c_to    TYPE i,
       END OF x_box,
       BEGIN OF x_bold,
          r_from  TYPE i,
          c_from  TYPE i,
          r_to    TYPE i,
          c_to    TYPE i,
       END OF x_bold,
       BEGIN OF x_yellow,
          r_from  TYPE i,
          c_from  TYPE i,
          r_to    TYPE i,
          c_to    TYPE i,
       END OF x_yellow,
       BEGIN OF x_sel_cells,
         sel_cells TYPE char2000,
       END OF x_sel_cells.

  DATA:
  l_gs_excel                TYPE ole2_object ,
  l_gs_wbooklist            TYPE ole2_object ,
  l_gs_application          TYPE ole2_object ,
  l_gs_wbook                TYPE ole2_object ,
  l_gs_activesheet          TYPE ole2_object ,
  l_gs_font                 TYPE ole2_object ,
  l_gs_s_cells              TYPE ole2_object,
  l_gv_sheet_name           TYPE char20 .

  DATA:
      l_tabname             TYPE string,
      l_tab_row             TYPE i,
      l_fld_row             TYPE i,
      l_fld_desc_row        TYPE i,
      l_fld_info_row        TYPE i,
      l_fld_wh_row          TYPE i,
      l_col                 TYPE i,
      l_fld                 TYPE x_zselect_info,
      l_i_db_tab            TYPE x_zdbtab_name_ty,
      l_wa_db_tab           TYPE x_zdbtab_name,
      l_wa_zdbtab_text      TYPE x_zdbtab_text,
      l_wa_fld              TYPE x_zfield_name,
      l_wa_table_field_name TYPE x_ztable_field_name,
      l_wa_field_desc       TYPE x_zfield_desc,
      l_alias               TYPE char30,
      l_count               TYPE i,
      l_leng                TYPE char6,
      l_dec                 TYPE char6,
      l_wa_where_fld        TYPE x_zwhere_field_name,
      l_wa_join_fld         TYPE x_zfield_name,
      l_count_wh            TYPE i,
      l_x                   TYPE c,
      l_bold_upto           TYPE i,
      l_const_row           TYPE i,
      l_wa_operands         TYPE x_zoperands,
      l_constant            TYPE char100.

  DATA:
       l_i_draw  TYPE STANDARD TABLE OF x_draw_line INITIAL SIZE 0,
       l_wa_draw TYPE x_draw_line,
       l_i_xy_val TYPE STANDARD TABLE OF x_xy_val INITIAL SIZE 0,
       l_wa_xy_val TYPE x_xy_val,
       l_i_box TYPE STANDARD TABLE OF x_box INITIAL SIZE 0,
       l_wa_box TYPE x_box,
       l_i_bold TYPE STANDARD TABLE OF x_bold INITIAL SIZE 0,
       l_wa_bold TYPE x_bold,
       l_i_yellow TYPE STANDARD TABLE OF x_yellow INITIAL SIZE 0,
       l_wa_yellow TYPE x_yellow,
       l_i_sel_cells TYPE STANDARD TABLE OF x_sel_cells,
       l_wa_sel_cells TYPE x_sel_cells,
       l_fld1     TYPE x_zselect_info,
       l_check    TYPE char1,
       l_old_col  TYPE i,
       l_x1       TYPE p DECIMALS 2,
       l_x2       TYPE p DECIMALS 2.

  DEFINE pop_val_xl.
    l_wa_xy_val-row = &1.
    l_wa_xy_val-column = &2.
    l_wa_xy_val-val = &3.
    append l_wa_xy_val to l_i_xy_val.
    clear l_wa_xy_val.
  END-OF-DEFINITION.
  DEFINE pop_box.
    l_wa_box-r_from = &1.
    l_wa_box-c_from = &2.
    l_wa_box-r_to = &3.
    l_wa_box-c_to = &4.
    append l_wa_box to l_i_box.
    clear l_wa_box.
  END-OF-DEFINITION.
  DEFINE pop_yellow.
    l_wa_yellow-r_from = &1.
    l_wa_yellow-c_from = &2.
    l_wa_yellow-r_to = &3.
    l_wa_yellow-c_to = &4.
    append l_wa_yellow to l_i_yellow.
    clear l_wa_yellow.
  END-OF-DEFINITION.
  DEFINE pop_bold.
    l_wa_bold-r_from = &1.
    l_wa_bold-c_from = &2.
    l_wa_bold-r_to = &3.
    l_wa_bold-c_to = &4.
    append l_wa_bold to l_i_bold.
    clear l_wa_bold.
  END-OF-DEFINITION.
  l_x1 = '45.75'.
  l_x2 = '22.87'.

  CONCATENATE 'Excel Sheet #' '1' INTO l_gv_sheet_name .

  l_tab_row = 1.

  LOOP AT l_ep_select_info INTO l_fld .

    l_i_db_tab  = l_fld-i_dbtab.

    LOOP AT l_i_db_tab INTO l_wa_db_tab.

      IF l_wa_db_tab-alias IS NOT INITIAL.
        l_alias = l_wa_db_tab-alias.
      ELSE.
        l_alias = l_wa_db_tab-dbtab_name.
      ENDIF.

*      l_count = LINES( l_i_db_tab ).
      DESCRIBE TABLE l_i_db_tab LINES l_count.

      IF l_count EQ 1.
        CLEAR: l_alias.
      ENDIF.

*------------------------------------------------------------*
** Populating POSITION into WHERE fields
*------------------------------------------------------------*
      LOOP AT l_fld-i_where_fld INTO  l_wa_where_fld
        WHERE alias = l_alias.

        l_x = 'X'.

        READ TABLE l_ep_table_fields INTO l_wa_table_field_name
        WITH KEY tabname = l_wa_db_tab-dbtab_name
                 fieldname = l_wa_where_fld-field_name.

        IF sy-subrc = 0.
          l_wa_where_fld-position = l_wa_table_field_name-position.

          MODIFY l_fld-i_where_fld FROM l_wa_where_fld
          TRANSPORTING position .

        ENDIF.

      ENDLOOP.

      IF l_x = 'X'.

        SORT l_fld-i_where_fld BY alias position.
        DELETE ADJACENT DUPLICATES FROM l_fld-i_where_fld
        COMPARING alias position.

        CLEAR: l_x.

      ENDIF.

*      l_count_wh = LINES( l_fld-i_where_fld[] ) +
*      LINES( l_fld-i_join_fld[] ).

      DATA:
            l_count_wh_tmp TYPE i.

      DESCRIBE TABLE l_fld-i_where_fld[] LINES l_count_wh.
      DESCRIBE TABLE l_fld-i_join_fld[] LINES l_count_wh_tmp.
      l_count_wh = l_count_wh + l_count_wh_tmp.
      CLEAR:l_count_wh_tmp.


      l_count_wh = l_count_wh - 3.

*------------------------------------------------------------*
*** Populating Table name and description
*------------------------------------------------------------*
      READ TABLE l_ep_table_desc INTO l_wa_zdbtab_text
      WITH KEY tabname = l_wa_db_tab-dbtab_name.

      IF sy-subrc = 0.
        CONCATENATE l_wa_db_tab-dbtab_name '-' l_wa_zdbtab_text-ddtext
        INTO l_tabname SEPARATED BY space.
      ELSE.
        l_tabname =  l_wa_db_tab-dbtab_name.
      ENDIF.
      l_col = 1.

      pop_val_xl l_tab_row l_col l_tabname.
      pop_box l_tab_row l_col l_tab_row l_col.
      pop_bold   l_tab_row l_col l_tab_row l_col.

      l_fld_wh_row = l_tab_row + 1.
      l_fld_row = l_tab_row.
      l_tab_row = l_tab_row + 6.

      IF l_count_wh GT 0.
        l_tab_row = l_tab_row + l_count_wh.
      ENDIF.

*------------------------------------------------------------*
*** Populating Field name
*------------------------------------------------------------*

      l_fld_row = l_fld_row + 1.

*      l_count = LINES( l_i_db_tab ).
      DESCRIBE TABLE l_i_db_tab LINES l_count.

      IF l_count EQ 1.
        CLEAR: l_alias.
      ENDIF.

      l_col = 0.

      LOOP AT l_fld-i_fld[] INTO l_wa_fld
        WHERE alias = l_alias.

        l_col = l_col + 1.
        l_wa_fld-row = l_fld_row.
        l_wa_fld-column = l_col.

        MODIFY l_fld-i_fld[] FROM l_wa_fld
        TRANSPORTING row column.

        CLEAR l_tabname.

        READ TABLE l_ep_table_fields INTO l_wa_table_field_name
        WITH KEY tabname = l_wa_db_tab-dbtab_name
                 fieldname = l_wa_fld-fieldname.

        IF sy-subrc = 0.

          READ TABLE l_ep_field_desc INTO l_wa_field_desc
          WITH KEY rollname = l_wa_table_field_name-rollname.

          IF sy-subrc = 0.

          ELSE.

          ENDIF.
        ENDIF.

        IF l_wa_table_field_name-keyflag = 'X'.
          CONCATENATE '*' l_wa_fld-fieldname INTO l_tabname.
          l_bold_upto = l_col.
        ELSE.
          l_tabname = l_wa_fld-fieldname.
        ENDIF.
        pop_val_xl l_fld_row l_col l_tabname.

*------------------------------------------------------------*
** Description
*------------------------------------------------------------*
        l_fld_desc_row = l_fld_row + 1.
        l_tabname = l_wa_field_desc-ddtext.
        pop_val_xl l_fld_desc_row l_col l_tabname.

*------------------------------------------------------------*
** Field length and type
*------------------------------------------------------------*

        l_fld_info_row = l_fld_desc_row + 1.

        CLEAR: l_tabname.
        l_leng = l_wa_table_field_name-leng.
        SHIFT l_leng LEFT DELETING LEADING '0'.
        IF l_wa_table_field_name-decimals IS INITIAL.
          CONCATENATE l_wa_table_field_name-datatype l_leng
          INTO l_tabname.
        ELSE.
          l_dec = l_wa_table_field_name-decimals.
          SHIFT l_dec LEFT DELETING LEADING '0'.
          CONCATENATE l_wa_table_field_name-datatype
                      '('
                      l_leng
                      ','
                      l_dec
                      ')'
          INTO l_tabname.
        ENDIF.
        pop_val_xl l_fld_info_row l_col l_tabname.

*------------------------------------------------------------*
** Constant's in where clause
*------------------------------------------------------------*

        READ TABLE l_fld-i_where_fld INTO l_wa_where_fld
        WITH KEY field_name = l_wa_fld-fieldname.

        IF  sy-subrc = 0
        AND l_wa_where_fld-operand IS NOT INITIAL.

          l_const_row  = l_fld_info_row + 1.
          CLEAR l_constant.
          LOOP AT l_wa_where_fld-operand INTO l_wa_operands.

            IF l_wa_operands-op+0(1) = ''''
            OR l_wa_operands-op+0(2) = 'SY' .
              IF l_wa_operands-op+0(2) = 'SY'.
                CONCATENATE '''' l_wa_operands-op ''''
                            INTO l_wa_operands-op.
              ENDIF.
              CONCATENATE l_constant
                          l_wa_operands-op
                    INTO  l_constant
                SEPARATED BY ', '.

            ENDIF.
          ENDLOOP.
          IF l_constant IS NOT INITIAL.
            REPLACE FIRST OCCURRENCE OF ',' IN l_constant
            WITH '= '.
            pop_val_xl l_const_row l_col l_constant.
            pop_box l_const_row l_col l_const_row l_col.
          ENDIF.
        ENDIF.

*------------------------------------------------------------*

      ENDLOOP.
      IF l_bold_upto IS NOT INITIAL.
        pop_bold   l_fld_row 1 l_fld_row l_bold_upto.
      ENDIF.
      CLEAR l_bold_upto.
      DATA:
           l_row_from   TYPE i,
           l_col_from TYPE i,
           l_row_to TYPE i,
           l_col_to  TYPE i,
           l_wh_fill_flg TYPE c.

      l_row_from = l_fld_row.
      l_col_from = 1.
      l_row_to   = l_fld_row.
      l_col_to   = l_col.

      pop_yellow l_fld_row 1 l_fld_row l_col.

      l_row_to = l_fld_row + 2.
      pop_box l_fld_row 1 l_row_to l_col.

*------------------------------------------------------------*
** WHERE clause
*------------------------------------------------------------*
      l_col = l_col + 1.

      CLEAR: l_fld_info_row, l_wh_fill_flg.

      LOOP AT l_fld-i_where_fld INTO  l_wa_where_fld
        WHERE alias = l_alias.
        l_wh_fill_flg = 'X'.

        l_wa_where_fld-row = l_fld_wh_row.
        l_wa_where_fld-column = l_col.
        MODIFY l_fld-i_where_fld FROM l_wa_where_fld
        TRANSPORTING row column.

        CLEAR: l_tabname.
        l_tabname = l_wa_where_fld-field_name.

        pop_val_xl l_fld_wh_row l_col l_tabname.
        l_fld_wh_row = l_fld_wh_row + 1.
      ENDLOOP.

*------------------------------------------------------------*
** Populating INNER JOIN fields in WHERE clause
*------------------------------------------------------------*
      LOOP AT l_fld-i_join_fld INTO  l_wa_join_fld
        WHERE alias = l_alias.
        l_wh_fill_flg = 'X'.

        l_wa_join_fld-row = l_fld_wh_row.
        l_wa_join_fld-column = l_col.
        MODIFY l_fld-i_join_fld FROM l_wa_join_fld
        TRANSPORTING row column.

        CLEAR: l_tabname.
        l_tabname = l_wa_join_fld-fieldname.

        pop_val_xl l_fld_wh_row l_col l_tabname.
        l_fld_wh_row = l_fld_wh_row + 1.
      ENDLOOP.

      IF l_wh_fill_flg = 'X'.

        l_row_to = l_fld_wh_row - 1.

        l_col_from = l_col_to + 1.
        l_col_to = l_col_from.

        pop_box l_row_from l_col_from l_row_to l_col_to.
      ENDIF.
    ENDLOOP.

    MODIFY l_ep_select_info FROM l_fld
    TRANSPORTING i_fld i_where_fld i_join_fld.
  ENDLOOP.

* generate clipboard format
* Get TAB-sign for separation of fields
  CLASS cl_abap_char_utilities DEFINITION LOAD.
  DATA : ld_separator TYPE char1,
         l_rc TYPE i,
         l_rw_blnk1 TYPE i,
         l_rw_blnk TYPE i,
         l_times TYPE i,
         l_wa_xy_val_1 TYPE x_xy_val.

  ld_separator = cl_abap_char_utilities=>horizontal_tab.
  CLEAR : wa_clipbrd, i_clipbrd[].
  SORT l_i_xy_val BY row column.
  LOOP AT l_i_xy_val INTO l_wa_xy_val.
    l_wa_xy_val_1 = l_wa_xy_val.
    AT NEW row.
      l_rw_blnk1 = l_wa_xy_val_1-row - l_rw_blnk - 1.
      IF l_rw_blnk1 GT 0.
        DO l_rw_blnk1 TIMES.
          APPEND INITIAL LINE TO i_clipbrd.
        ENDDO.
      ENDIF.
      l_old_col = l_wa_xy_val_1-column.
      l_times = l_wa_xy_val_1-column - 1.

      IF l_wa_xy_val_1-column = 1.
        l_check = 'X'.
      ENDIF.

      DO l_times TIMES.
        l_check = 'X'.
        CONCATENATE wa_clipbrd-line ld_separator
        INTO wa_clipbrd-line.
      ENDDO.
    ENDAT.

    IF l_check = 'X'.
      l_times = l_wa_xy_val-column - l_old_col - 1.
      DO l_times TIMES.
        CONCATENATE wa_clipbrd-line ld_separator
        INTO wa_clipbrd-line.
      ENDDO.
    ENDIF.
    l_old_col = l_wa_xy_val_1-column.

    CONCATENATE wa_clipbrd-line l_wa_xy_val-val
                INTO wa_clipbrd-line SEPARATED BY ld_separator.

    AT END OF row.
      l_rw_blnk = l_wa_xy_val_1-row.
      IF wa_clipbrd+0(1) = ld_separator.
        SHIFT wa_clipbrd LEFT BY 1 PLACES.
      ENDIF.
      APPEND wa_clipbrd TO i_clipbrd.
      CLEAR : wa_clipbrd, l_check.
    ENDAT.
  ENDLOOP.

  CALL METHOD cl_gui_frontend_services=>clipboard_export
    IMPORTING
      data       = i_clipbrd
    CHANGING
      rc         = l_rc
    EXCEPTIONS
      cntl_error = 1
      OTHERS     = 4.
  IF sy-subrc = 0.
    PERFORM sub_tad_populate_sheet USING l_gv_sheet_name
                               CHANGING l_gs_excel
                                 l_gs_wbooklist
                                 l_gs_application
                                 l_gs_wbook
                                 l_gs_activesheet.

    CALL METHOD OF l_gs_activesheet 'PASTE'.
  ENDIF.
  DATA : l_sel_cells TYPE char2000,
         l_coltab TYPE i.
* Bold
  PERFORM sub_tad_modify_cells_mul USING 1 1 1 1 l_gs_excel
                                  CHANGING l_gs_s_cells.
  LOOP AT l_i_bold INTO l_wa_bold.
    l_coltab = sy-tabix MOD 20.
    PERFORM sub_tad_create_cells_range USING l_wa_bold-r_from
                                        l_wa_bold-c_from
                                        l_wa_bold-r_to
                                        l_wa_bold-c_to
                               CHANGING l_sel_cells.
    IF l_coltab IS INITIAL .
      l_wa_sel_cells-sel_cells = l_sel_cells.
      APPEND l_wa_sel_cells TO l_i_sel_cells.
      CLEAR : l_wa_sel_cells, l_sel_cells.
    ENDIF.
  ENDLOOP.

  IF l_sel_cells IS NOT INITIAL.
    l_wa_sel_cells-sel_cells = l_sel_cells.
    APPEND l_wa_sel_cells TO l_i_sel_cells.
    CLEAR : l_wa_sel_cells, l_sel_cells.
  ENDIF.

  LOOP AT l_i_sel_cells INTO l_wa_sel_cells.
    PERFORM sub_tab_select_cells USING l_gs_excel
                              CHANGING l_wa_sel_cells-sel_cells
                                       l_gs_s_cells.

    GET PROPERTY OF l_gs_s_cells 'Font' = l_gs_font.
    SET PROPERTY OF l_gs_font 'Bold' = 1.
    CLEAR l_sel_cells.
    FREE OBJECT : l_gs_font, l_gs_s_cells.
  ENDLOOP.

* Draw Box
  CLEAR : l_wa_sel_cells, l_sel_cells, l_i_sel_cells[], l_coltab.
  PERFORM sub_tad_modify_cells_mul USING 1 1 1 1 l_gs_excel
                                  CHANGING l_gs_s_cells.
  LOOP AT l_i_box INTO l_wa_box.
    l_coltab = sy-tabix MOD 20.
    PERFORM sub_tad_create_cells_range USING l_wa_box-r_from
                                             l_wa_box-c_from
                                             l_wa_box-r_to
                                             l_wa_box-c_to
                                    CHANGING l_sel_cells.
    IF l_coltab IS INITIAL.
      l_wa_sel_cells-sel_cells = l_sel_cells.
      APPEND l_wa_sel_cells TO l_i_sel_cells.
      CLEAR : l_wa_sel_cells, l_sel_cells.
    ENDIF.
  ENDLOOP.
  IF l_sel_cells IS NOT INITIAL.
    l_wa_sel_cells-sel_cells = l_sel_cells.
    APPEND l_wa_sel_cells TO l_i_sel_cells.
    CLEAR : l_wa_sel_cells, l_sel_cells.
  ENDIF.
  LOOP AT l_i_sel_cells INTO l_wa_sel_cells.
    PERFORM sub_tab_select_cells USING l_gs_excel
                            CHANGING l_wa_sel_cells-sel_cells
                                     l_gs_s_cells.
    PERFORM sub_tad_box USING l_gs_s_cells.
    CLEAR l_sel_cells.
    FREE OBJECT : l_gs_s_cells.
  ENDLOOP.


* yellow color
  CLEAR : l_wa_sel_cells, l_sel_cells, l_i_sel_cells[], l_coltab.
  PERFORM sub_tad_modify_cells_mul USING 1 1 1 1 l_gs_excel
                                  CHANGING l_gs_s_cells.
  LOOP AT l_i_yellow INTO l_wa_yellow.
    l_coltab = sy-tabix MOD 20.
    PERFORM sub_tad_create_cells_range USING l_wa_yellow-r_from
                                             l_wa_yellow-c_from
                                             l_wa_yellow-r_to
                                             l_wa_yellow-c_to
                                    CHANGING l_sel_cells.
    IF l_coltab IS INITIAL.
      l_wa_sel_cells-sel_cells = l_sel_cells.
      APPEND l_wa_sel_cells TO l_i_sel_cells.
      CLEAR : l_wa_sel_cells, l_sel_cells.
    ENDIF.
  ENDLOOP.
  IF l_sel_cells IS NOT INITIAL.
    l_wa_sel_cells-sel_cells = l_sel_cells.
    APPEND l_wa_sel_cells TO l_i_sel_cells.
    CLEAR : l_wa_sel_cells, l_sel_cells.
  ENDIF.
  LOOP AT l_i_sel_cells INTO l_wa_sel_cells.
    PERFORM sub_tab_select_cells USING l_gs_excel
                              CHANGING l_wa_sel_cells-sel_cells
                                       l_gs_s_cells.
    PERFORM sub_tad_color USING l_gs_s_cells.
    CLEAR l_sel_cells.
    FREE OBJECT : l_gs_s_cells.
  ENDLOOP.


* Line draw
  DATA:
       l_wa_link_fld TYPE x_zwhere_field_name,
       l_wa_zfield_name TYPE x_zfield_name,
       l_wa_zwhere_field_name TYPE x_zwhere_field_name,
       l_tabix TYPE sytabix.

  LOOP AT l_ep_select_info INTO l_fld .

    l_tabix = sy-tabix + 1.

    LOOP AT l_ep_select_info INTO l_fld1 FROM l_tabix
                              WHERE v_foe_tab = l_fld-v_int_tab.

      LOOP AT l_fld1-i_link_fld INTO l_wa_link_fld.

        LOOP AT l_fld-i_fld INTO l_wa_zfield_name
                            WHERE fieldname = l_wa_link_fld-field_link.

          l_wa_draw-r_from = l_wa_zfield_name-row.
          l_wa_draw-c_from = l_wa_zfield_name-column.
          l_wa_draw-y_from = ( l_wa_zfield_name-column - 1 ) * l_x1 +
  l_x2.
          l_wa_draw-x_from = ( l_wa_zfield_name-row - 1 ) * 12 + 12.

          CLEAR: l_wa_zfield_name.

        ENDLOOP.

        LOOP AT l_fld1-i_fld INTO l_wa_zfield_name
                            WHERE fieldname = l_wa_link_fld-field_name.

          l_wa_draw-r_to = l_wa_zfield_name-row.
          l_wa_draw-c_to = l_wa_zfield_name-column.
          l_wa_draw-y_to = ( l_wa_zfield_name-column - 1 ) * l_x1 +
  l_x2.
          l_wa_draw-x_to = ( l_wa_zfield_name-row - 1 ) * 12 .

          CLEAR: l_wa_zfield_name.
        ENDLOOP.

        IF  l_wa_draw-r_to IS INITIAL
        AND l_wa_draw-c_to IS INITIAL.

          LOOP AT l_fld1-i_where_fld INTO l_wa_zwhere_field_name
           WHERE field_name = l_wa_link_fld-field_name.

            l_wa_draw-r_to = l_wa_zwhere_field_name-row.
            l_wa_draw-c_to = l_wa_zwhere_field_name-column.

            l_wa_draw-y_to = ( l_wa_zwhere_field_name-column - 1 ) *
l_x1 + l_x2.
            l_wa_draw-x_to = ( l_wa_zwhere_field_name-row - 1 ) * 12 .

            CLEAR: l_wa_zwhere_field_name.

          ENDLOOP.

        ENDIF.
        IF l_wa_draw-r_from IS NOT INITIAL AND
           l_wa_draw-c_from IS NOT INITIAL AND
           l_wa_draw-r_to IS NOT INITIAL AND
           l_wa_draw-c_to IS NOT INITIAL.
          APPEND l_wa_draw TO l_i_draw.
          CLEAR l_wa_draw.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDLOOP.

  DATA:
      l_wa_join_name TYPE x_zfield_name,
      l_mod TYPE sytabix.

  LOOP AT l_ep_select_info INTO l_fld.
    LOOP AT l_fld-i_join_fld INTO l_wa_join_name .

      l_mod = sy-tabix MOD 2 .

      IF l_mod = 1 .

        l_wa_draw-r_from = l_wa_join_name-row.
        l_wa_draw-c_from = l_wa_join_name-column.
        l_wa_draw-y_from = ( l_wa_join_name-column - 1 ) * l_x1 +
  l_x2.
        l_wa_draw-x_from = ( l_wa_join_name-row - 1 ) * 12 + 12.


      ELSEIF l_mod = 0 .

        l_wa_draw-r_to = l_wa_join_name-row.
        l_wa_draw-c_to = l_wa_join_name-column.
        l_wa_draw-y_to = ( l_wa_join_name-column - 1 ) * l_x1 +
  l_x2.
        l_wa_draw-x_to = ( l_wa_join_name-row - 1 ) * 12 .
        APPEND l_wa_draw TO l_i_draw.
        CLEAR: l_wa_draw.

      ENDIF.

    ENDLOOP.
  ENDLOOP.

  DATA : l_shapes TYPE ole2_object,
         l_shape TYPE ole2_object,
         l_lineformat TYPE ole2_object,
         l_colorformat TYPE ole2_object,
         l_shpr TYPE ole2_object,
         l_gs_selection TYPE ole2_object.

  LOOP AT l_i_draw INTO l_wa_draw.
    l_coltab = sy-tabix MOD 10.
    GET PROPERTY OF l_gs_activesheet 'Shapes' = l_shapes.
    CALL METHOD OF l_shapes 'AddLine' = l_shape
      EXPORTING
      #1 = l_wa_draw-y_from
      #2 = l_wa_draw-x_from
      #3 = l_wa_draw-y_to
      #4 = l_wa_draw-x_to.

    CALL METHOD OF l_shape 'Select'.
    GET PROPERTY OF l_shape 'Line' = l_lineformat.
    GET PROPERTY OF l_lineformat 'ForeColor' = l_colorformat.
    IF l_coltab = 0.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 64.
    ELSEIF l_coltab = 1.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 10.
    ELSEIF l_coltab = 2.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 12.
    ELSEIF l_coltab = 3.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 17.
    ELSEIF l_coltab = 4.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 37.
    ELSEIF l_coltab = 5.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 29.
    ELSEIF l_coltab = 6.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 53.
    ELSEIF l_coltab = 7.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 23.
    ELSEIF l_coltab = 8.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 49.
    ELSEIF l_coltab = 9.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 46.
    ELSE.
      SET PROPERTY OF l_colorformat 'SchemeColor' = 64.
    ENDIF.

  ENDLOOP.

  CALL METHOD OF l_shapes 'SelectAll'.

  GET PROPERTY OF l_gs_application 'Selection' = l_gs_selection.
  GET PROPERTY OF l_gs_selection 'ShapeRange' = l_shpr.
  GET PROPERTY OF l_shpr 'Line' = l_lineformat.
  SET PROPERTY OF l_lineformat 'EndArrowheadStyle' = 2.
  SET PROPERTY OF l_lineformat 'EndArrowheadLength' = 3.
  SET PROPERTY OF l_lineformat 'EndArrowheadWidth' = 3.
  SET PROPERTY OF l_lineformat 'Weight' = '1.5'.

ENDFORM.                    " SUB_POPULATE_EXCELL
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_SHEET
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM sub_tad_populate_sheet USING p_gv_sheet_name TYPE char20
                         CHANGING l_gs_excel TYPE ole2_object
                                  l_gs_wbooklist TYPE ole2_object
                                  l_gs_application TYPE ole2_object
                                  l_gs_wbook TYPE ole2_object
                                  l_gs_activesheet TYPE ole2_object.

  DATA : l_range TYPE ole2_object.

  CREATE OBJECT l_gs_excel 'EXCEL.APPLICATION'.
  SET PROPERTY OF l_gs_excel 'Visible' = 1.
  GET PROPERTY OF l_gs_excel 'Workbooks' = l_gs_wbooklist.
  GET PROPERTY OF l_gs_wbooklist 'Application' = l_gs_application.
  SET PROPERTY OF l_gs_application 'SheetsInNewWorkbook' = 1.
  CALL METHOD OF l_gs_wbooklist 'Add' = l_gs_wbook.

  GET PROPERTY OF l_gs_application 'ActiveSheet' = l_gs_activesheet.
  SET PROPERTY OF l_gs_activesheet 'Name' = p_gv_sheet_name.

  GET PROPERTY OF l_gs_application 'Cells' = l_range.
  SET PROPERTY OF l_range 'RowHeight' = 12.
  SET PROPERTY OF l_range 'ColumnWidth' = 8.

ENDFORM.                    " SUB_POPULATE_SHEET
*&---------------------------------------------------------------------*
*&      Form  SUB_TAD_MODIFY_CELLS_MUL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM sub_tad_modify_cells_mul  USING    p_l_row_from TYPE i
                                        p_l_col_from TYPE i
                                        p_l_row_to TYPE i
                                        p_l_col_to TYPE i
                                        p_gs_excel TYPE ole2_object
                               CHANGING p_gs_cells TYPE ole2_object.

  DATA : l_gs_cell1 TYPE ole2_object,
         l_gs_cell2 TYPE ole2_object.

  CALL METHOD OF p_gs_excel 'Cells' = l_gs_cell1
    EXPORTING
    #1 = p_l_row_from
    #2 = p_l_col_from.
  CALL METHOD OF p_gs_excel 'Cells' = l_gs_cell2
    EXPORTING
    #1 = p_l_row_to
    #2 = p_l_col_to.
  CALL METHOD OF p_gs_excel 'Range' = p_gs_cells
    EXPORTING
    #1 = l_gs_cell1
    #2 = l_gs_cell2.
  CALL METHOD OF p_gs_cells 'Select' .
ENDFORM.                    " SUB_TAD_MODIFY_CELLS_MUL
*&---------------------------------------------------------------------*
*&      Form  SUB_TAD_COLOR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_GS_S_CELLS  text
*----------------------------------------------------------------------*
FORM sub_tad_color USING p_l_gs_s_cells TYPE ole2_object.
  DATA: l_gs_interior TYPE ole2_object.

  GET PROPERTY OF p_l_gs_s_cells 'Interior' = l_gs_interior .
  SET PROPERTY OF l_gs_interior 'ColorIndex' = 6.
  FREE OBJECT l_gs_interior.
ENDFORM.                    " SUB_TAD_COLOR
*&---------------------------------------------------------------------*
*&      Form  SUB_TAD_BOX
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_GS_S_CELLS  text
*----------------------------------------------------------------------*
FORM sub_tad_box USING p_l_gs_s_cells TYPE ole2_object.
  DATA: l_gs_borders TYPE ole2_object.

  GET PROPERTY OF p_l_gs_s_cells 'Borders' = l_gs_borders.
  SET PROPERTY OF l_gs_borders 'LineStyle' = 1.
  FREE OBJECT l_gs_borders.
ENDFORM.                    " SUB_TAD_BOX
*&---------------------------------------------------------------------*
*&      Form  sub_tad_create_cells_range
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_BOLD_R_FROM  text
*      -->P_L_WA_BOLD_C_FROM  text
*      -->P_L_WA_BOLD_R_TO    text
*      -->P_L_WA_BOLD_C_TO    text
*      <--P_L_SEL_CELLS       text
*----------------------------------------------------------------------*
FORM sub_tad_create_cells_range USING p_l_wa_bold_r_from TYPE i
                                      p_l_wa_bold_c_from TYPE i
                                      p_l_wa_bold_r_to   TYPE i
                                      p_l_wa_bold_c_to   TYPE i
                             CHANGING p_l_sel_cells TYPE char2000.
  DATA : l_str TYPE char27 VALUE '0ABCDEFGHIJKLMNOPQRSTUVWXYZ',
         l_col_char_f TYPE char2,
         l_row_char_f TYPE char5,
         l_col_char_t TYPE char5,
         l_row_char_t TYPE char5,
         l_mod        TYPE i,
         l_quot       TYPE p DECIMALS 2,
         l_quot_i     TYPE i,
         l_quot_c     TYPE char10,
         l_to         TYPE i.

  IF NOT p_l_wa_bold_c_to IS INITIAL.

    IF p_l_wa_bold_c_to GT 256.
      l_to = 256.
    ENDIF.

    l_mod  = p_l_wa_bold_c_from MOD 26.
    l_quot = p_l_wa_bold_c_from / 26.
    l_quot_c = l_quot.
    CONDENSE l_quot_c.
    l_quot_i = l_quot_c+0(1).
    IF l_quot_i GT 0.
      CONCATENATE l_str+l_quot_i(1) l_str+l_mod(1) INTO l_col_char_f.
    ELSE.
      l_col_char_f = l_str+p_l_wa_bold_c_from(1).
    ENDIF.

    l_row_char_f = p_l_wa_bold_r_from.
    CONDENSE l_row_char_f.

    l_mod  = p_l_wa_bold_c_to MOD 26.
    l_quot = p_l_wa_bold_c_to / 26.
    l_quot_c = l_quot.
    CONDENSE l_quot_c.
    l_quot_i = l_quot_c+0(1).

    IF l_quot_i GT 0.
      CONCATENATE l_str+l_quot_i(1) l_str+l_mod(1) INTO l_col_char_t.
    ELSE.
      l_col_char_t = l_str+p_l_wa_bold_c_to(1).
    ENDIF.

    l_row_char_t = p_l_wa_bold_r_to.
    CONDENSE l_row_char_t.
    CONCATENATE p_l_sel_cells l_col_char_f l_row_char_f ':'
                              l_col_char_t l_row_char_t ','
                              INTO p_l_sel_cells.

  ENDIF.
ENDFORM.                    " sub_tad_create_cells_range
*&---------------------------------------------------------------------*
*&      Form  SUB_TAB_SELECT_CELLS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_SEL_CELLS  text
*      <--P_L_GS_S_CELLS  text
*----------------------------------------------------------------------*
FORM sub_tab_select_cells USING p_gs_excel  TYPE ole2_object
                       CHANGING p_sel_cells TYPE char2000
                                p_gs_s_cells TYPE ole2_object.
  DATA : l_len TYPE i.

  l_len = STRLEN( p_sel_cells ) - 1.
  p_sel_cells = p_sel_cells+0(l_len).
  CALL METHOD OF p_gs_excel 'Range' = p_gs_s_cells
    EXPORTING
    #1 = p_sel_cells.
  CALL METHOD OF p_gs_s_cells 'Select' .
ENDFORM.                    " SUB_TAB_SELECT_CELLS
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_FM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_populate_fm USING p_fm_info     TYPE x_zfm_call_info_ty
                           p_v_actdoc    TYPE ole2_object
                           p_v_selection TYPE ole2_object.

  DATA : l_v_tables TYPE ole2_object,
         l_v_range  TYPE ole2_object,
         l_v_table  TYPE ole2_object,
         l_v_table_border TYPE ole2_object,
         l_v_line   TYPE i,
         l_pos      TYPE i,
         l_wa_fm_info TYPE x_zfm_call_info,
         l_prog TYPE progname,
         l_from TYPE sytabix,
         l_to   TYPE sytabix,
         l_fname TYPE rs38l_fnam,
         l_proctype TYPE char1.

  DATA:
  l_i_ep_select_info    TYPE   x_zselect_info_ty ,
  l_i_ep_table_fields   TYPE   x_ztable_field_name_ty,
  l_i_ep_table_desc     TYPE   x_zdbtab_text_ty,
  l_i_ep_field_desc     TYPE   x_zfield_desc_ty,
  l_i_ep_sub_call_info  TYPE   x_zperform_call_info_ty.
  IF p_fm_info[] IS NOT INITIAL.
*   Nothing to do
  ELSE.
    IF p_scr2 IS NOT INITIAL AND p_prog IS NOT INITIAL.
      l_prog = p_scr2.
      l_from = p_from2.
      l_to = p_to2.
      l_proctype = ''.
    ELSEIF p_func IS NOT INITIAL AND p_fname1 IS NOT INITIAL.
      l_from = p_from1.
      l_to = p_to1.
      l_proctype = 'F'.
      PERFORM sub_get_program_name USING p_fname1
                                CHANGING l_prog.

    ELSEIF p_form IS NOT INITIAL AND p_sname1 IS NOT INITIAL.
      CLEAR : l_from, l_to.
      l_proctype = 'F'.
      CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
        EXPORTING
          formname           = p_sname1
          variant            = ' '
          direct_call        = ' '
        IMPORTING
          fm_name            = l_fname
        EXCEPTIONS
          no_form            = 1
          no_function_module = 2
          OTHERS             = 3.
      IF sy-subrc = 0.
        PERFORM sub_get_program_name USING l_fname
                                  CHANGING l_prog.
      ENDIF.
    ENDIF.
    PERFORM sub_z_get_prog_info
                    USING
                       l_prog
                       l_from
                       l_to
                       l_proctype
                       'X'
                    CHANGING
                       l_i_ep_select_info
                       l_i_ep_table_fields
                       l_i_ep_table_desc
                       l_i_ep_field_desc
                       p_fm_info
                       l_i_ep_sub_call_info.
  ENDIF.
  SORT p_fm_info BY funcname stext.
  DELETE ADJACENT DUPLICATES FROM p_fm_info COMPARING funcname stext.
  IF p_fm_info[] IS NOT INITIAL..
*   Count the no of lines
*    l_v_line = LINES( p_fm_info ).
    DESCRIBE TABLE p_fm_info LINES l_v_line.

*  Populate one text
    CALL METHOD OF p_v_selection 'TypeText'
      EXPORTING
      #1 = 'Relevant function modules:'(081).
    CALL METHOD OF p_v_selection 'TypeParagraph'.
    CALL METHOD OF p_v_selection 'TypeParagraph'.

*   Inserting table for header details
*   Inserting a table and filling some of its cells.
    GET PROPERTY OF p_v_actdoc 'Tables' = l_v_tables.

    GET PROPERTY OF p_v_selection 'Range' = l_v_range .

*   Get the total no. of rows
    l_v_line = l_v_line + 1.

    CALL METHOD OF l_v_tables 'Add' = l_v_table
    EXPORTING
    #1 = l_v_range
    #2 = l_v_line  "Number of rows
    #3 = '2'.    "Number of columns

*   Setting border attribute for the table
    GET PROPERTY OF l_v_table 'Borders' = l_v_table_border.
    SET PROPERTY OF l_v_table_border 'Enable' = '1' . "With border
    SET PROPERTY OF l_v_table_border 'OutsideLineWidth' = '12'. "With

    CLEAR : wa_clipbrd, i_clipbrd[].

    CONCATENATE 'Function Module name'(132)
              'Description'(070)
              INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.

    LOOP AT p_fm_info INTO l_wa_fm_info.
      IF l_wa_fm_info-stext IS INITIAL.
        l_wa_fm_info-stext = 'Not Available'(149).
      ENDIF.
      CONCATENATE l_wa_fm_info-funcname
                  l_wa_fm_info-stext
                  INTO wa_clipbrd-line SEPARATED BY c_separator.
      APPEND wa_clipbrd TO i_clipbrd.
      CLEAR wa_clipbrd.
    ENDLOOP.

    PERFORM sub_paste_from_clipboard USING l_v_table.

    PERFORM sub_make_header_shad USING p_v_actdoc
                                       '22'.

*   Advancing the cursor to the end of the table
    GET PROPERTY OF l_v_table 'Range' = l_v_range.
    GET PROPERTY OF l_v_range 'End' = l_pos .
    SET PROPERTY OF l_v_range 'Start' = l_pos .

*   Selects the specified object
    CALL METHOD OF l_v_range 'Select' .

*   For 1 line gap
    CALL METHOD OF p_v_selection 'TypeParagraph'.
  ENDIF.
ENDFORM.                    " SUB_POPULATE_FM
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_HEADER_FOOTER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_ACTDOC  text
*----------------------------------------------------------------------*
FORM sub_populate_header_footer USING p_actdoc TYPE ole2_object
                                CHANGING p_view TYPE ole2_object.

  DATA : l_application TYPE ole2_object,
         l_actwindow   TYPE ole2_object,
         l_pane        TYPE ole2_object,
         l_view        TYPE ole2_object,
         l_selection   TYPE ole2_object,
         l_font        TYPE ole2_object,
         l_tables      TYPE ole2_object,
         l_table       TYPE ole2_object,
         l_range       TYPE ole2_object,
         l_range1      TYPE ole2_object,
         l_cell        TYPE ole2_object,
         l_pformat     TYPE ole2_object,
         l_fields      TYPE ole2_object,
         l_field       TYPE ole2_object,
         l_sele        TYPE ole2_object,
         l_template    TYPE ole2_object,
         l_autotexts   TYPE ole2_object,
         l_autotext    TYPE ole2_object,
         l_temp        TYPE ole2_object,
         l_rc          TYPE i.

* Getting applications handle
  GET PROPERTY OF p_actdoc 'Application' = l_application .
  GET PROPERTY OF l_application 'ActiveWindow' = l_actwindow.
  GET PROPERTY OF l_actwindow 'ActivePane' = l_pane.
  GET PROPERTY OF l_pane 'View' = l_view.
  SET PROPERTY OF l_view 'SeekView' = '9'.

  GET PROPERTY OF l_application 'Selection' = l_selection.
  GET PROPERTY OF l_selection 'Font' = l_font.
  SET PROPERTY OF l_font 'Size' = p_font_s.                 "'10'.
  SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.
  GET PROPERTY OF l_selection 'Tables' = l_tables.
  GET PROPERTY OF l_selection 'Range' = l_range.

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '1'   "Number of rows
  #3 = '2'   "Number of columns
  #4 = '1'   "wdWord9TableBehavior
  #5 = '0'.  "wdAutoFitFixed

  CALL METHOD OF l_table 'Cell' = l_cell
    EXPORTING #1 = '1' #2 = '1'.
  GET PROPERTY OF l_cell 'Range' = l_range.
  SET PROPERTY OF l_range 'Text' =
         'Custom Dictionary Object Technical Design Specification'(104)
 .
  FREE OBJECT : l_cell, l_range.
  CALL METHOD OF l_table 'Cell' = l_cell
    EXPORTING #1 = '1' #2 = '2'.
  GET PROPERTY OF l_cell 'Range' = l_range .
  SET PROPERTY OF l_range 'Text' =
           'IBM - Solution Delivery Center'(150).
  GET PROPERTY OF l_range 'ParagraphFormat' = l_pformat.
  SET PROPERTY OF l_pformat 'Alignment' = '2'.

  FREE OBJECT : l_selection, l_tables, l_table,
                l_range, l_cell.
  SET PROPERTY OF l_view 'SeekView' = '10'.
  GET PROPERTY OF l_application 'Selection' = l_selection .
  GET PROPERTY OF l_selection 'Font' = l_font.
  SET PROPERTY OF l_font 'Size' = p_font_s.                 "'10'.
  SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.
  GET PROPERTY OF l_selection 'Tables' = l_tables .
  GET PROPERTY OF l_selection 'Range' = l_range .

  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '1'   "Number of rows
  #3 = '2'   "Number of columns
  #4 = '1'   "wdWord9TableBehavior
  #5 = '0'.  "wdAutoFitFixed

  CALL METHOD OF l_table 'Cell' = l_cell
    EXPORTING #1 = '1' #2 = '1'.
  GET PROPERTY OF l_cell 'Range' = l_range.
  SET PROPERTY OF l_range 'Text' = 'Last Update :'(151) .

  GET PROPERTY OF p_actdoc 'Application' = l_application.
  GET PROPERTY OF l_application 'Selection' = l_sele.
  CALL METHOD OF l_sele 'EndKey' = l_rc
    EXPORTING
    #1 = '5'.
  GET PROPERTY OF l_sele 'Range' = l_range1.
  GET PROPERTY OF l_sele 'Fields' = l_fields.
  CALL METHOD OF l_fields 'Add' = l_field
    EXPORTING
    #1 = l_range1
    #2 = '32'.

  CALL METHOD OF l_sele 'TypeText'
    EXPORTING
    #1 = ' '.

  CALL METHOD OF l_fields 'Add' = l_field
    EXPORTING
    #1 = l_range1
    #2 = '31'.

  CALL METHOD OF l_sele 'MoveRight'
    EXPORTING
    #1 = 12.
  CALL METHOD OF l_table 'Cell' = l_cell
    EXPORTING #1 = '1' #2 = '2'.
  GET PROPERTY OF l_cell 'Range' = l_range.
  GET PROPERTY OF l_sele 'ParagraphFormat' = l_pformat.
  SET PROPERTY OF l_pformat 'Alignment' = '2'.

  FREE OBJECT : l_sele, l_range1.
  GET PROPERTY OF p_actdoc 'Application' = l_application.
  GET PROPERTY OF l_application 'Selection' = l_sele.
  GET PROPERTY OF l_sele 'Range' = l_range1.
  GET PROPERTY OF l_application 'NormalTemplate' = l_template.
  GET PROPERTY OF l_template 'AutoTextEntries' = l_autotexts.
  CALL METHOD OF l_autotexts 'Add' = l_autotext
    EXPORTING
    #1 = 'Page X of Y'
    #2 = l_range.
  CALL METHOD OF l_autotext 'Insert' = l_range
    EXPORTING
    #1 = l_range1
    #2 = 'True'.

  SET PROPERTY OF l_view 'SeekView' = '0'.
  p_view = l_view.

ENDFORM.                    " SUB_POPULATE_HEADER_FOOTER
*&---------------------------------------------------------------------*
*&      Form  SUB_PASTE_FROM_CLIPBOARD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_V_TABLE  text
*----------------------------------------------------------------------*
FORM sub_paste_from_clipboard USING p_table TYPE ole2_object.

  DATA : l_rc      TYPE i,
         l_range   TYPE ole2_object,
         l_font    TYPE ole2_object.

  CALL METHOD cl_gui_frontend_services=>clipboard_export
    IMPORTING
      data       = i_clipbrd
    CHANGING
      rc         = l_rc
    EXCEPTIONS
      cntl_error = 1
      OTHERS     = 4.
  IF sy-subrc = 0.
    GET PROPERTY OF p_table 'Range' = l_range.
    CALL METHOD OF l_range 'Paste'.
*   Set font style and size
    GET PROPERTY OF l_range 'Font' = l_font.
    SET PROPERTY OF l_font 'Size' = p_font_s.               "'10'.
    SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.
    FREE OBJECT : l_range, l_font.
  ENDIF.
  CLEAR : i_clipbrd[], wa_clipbrd.
ENDFORM.                    " SUB_PASTE_FROM_CLIPBOARD
*&---------------------------------------------------------------------*
*&      Form  SUB_SELECT_ALL_CHCKBOX
*&---------------------------------------------------------------------*
* Select all the checkboxes in the Selection Screen
*----------------------------------------------------------------------*
* No Parameters
*----------------------------------------------------------------------*
FORM sub_select_all_chckbox .

  p_cts = c_check.
  p_bdc = c_check.
  p_sel = c_check.
  p_tad = c_check.
  p_code = c_check.
  p_tab = c_check.
  p_msg = c_check.
  p_srch = c_check.
  p_fm = c_check.
  p_opp = c_check.
  p_opxl = c_check.
  p_utp = c_check.

ENDFORM.                    " SUB_SELECT_ALL_CHCKBOX
*&---------------------------------------------------------------------*
*&      Form  SUB_DESELECT_CHKBOX
*&---------------------------------------------------------------------*
* Deselect all the checkboxes
*----------------------------------------------------------------------*
*  No Parameters
*----------------------------------------------------------------------*
FORM sub_deselect_chkbox .

  CLEAR : p_cts, p_bdc, p_sel, p_tad, p_code, p_tab, p_msg,
          p_srch, p_fm, p_opp, p_opxl, p_utp.

ENDFORM.                    " SUB_DESELECT_CHKBOX
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_OP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_V_ACTDOC  text
*      -->P_V_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_op USING p_v_actdoc    TYPE ole2_object
                           p_v_selection TYPE ole2_object.

  DATA : l_in_p_prog  TYPE progname,
         l_in_i_itabs TYPE x_zitab_ty,
         l_wa_itabs   TYPE x_zitab,
         l_itab_info  TYPE x_zitab_info_ty,
         l_wa_itab_info TYPE x_zitab_info,
         l_wa_ztabinfo TYPE x_ztabinfo.

  DATA : l_v_tables TYPE ole2_object,
         l_v_range  TYPE ole2_object,
         l_v_table  TYPE ole2_object,
         l_v_table_border TYPE ole2_object,
         l_dtype    TYPE char15,
         l_dec      TYPE char10,
         l_v_line   TYPE i,
         l_pos      TYPE i.

  l_in_p_prog = p_scr2.
  l_wa_itabs-itab = p_itab.
  APPEND l_wa_itabs TO l_in_i_itabs.

  PERFORM sub_z_get_prog_tab_info
            USING
               l_in_p_prog
               l_in_i_itabs
               ''
            CHANGING
               l_itab_info.

  IF l_itab_info[] IS NOT INITIAL.

    READ TABLE l_itab_info INTO l_wa_itab_info INDEX 1.
*    l_v_line = LINES( l_wa_itab_info-tabinfo ).
    DESCRIBE TABLE l_wa_itab_info-tabinfo LINES l_v_line.

*   Populate one text
    CALL METHOD OF p_v_selection 'TypeText'
      EXPORTING
      #1 = 'Output information:'(102).
    CALL METHOD OF p_v_selection 'TypeParagraph'.
    CALL METHOD OF p_v_selection 'TypeParagraph'.

*   Get the total no. of rows
    l_v_line = l_v_line + 1.

*   Inserting table for header details
*   Inserting a table and filling some of its cells.
    GET PROPERTY OF p_v_actdoc 'Tables' = l_v_tables.
    GET PROPERTY OF p_v_selection 'Range' = l_v_range .
    CALL METHOD OF l_v_tables 'Add' = l_v_table
    EXPORTING
    #1 = l_v_range
    #2 = l_v_line  "Number of rows
    #3 = '6'.      "Number of columns

*   Setting border attribute for the table
    GET PROPERTY OF l_v_table 'Borders' = l_v_table_border.
    SET PROPERTY OF l_v_table_border 'Enable' = '1' . "With border
    SET PROPERTY OF l_v_table_border 'OutsideLineWidth' = '12'. "With
    CLEAR : wa_clipbrd, i_clipbrd[].

*   For the heading:
    CONCATENATE 'Field # - Label'(133)
                'SAP Table Name'(134)
                'SAP Field Name'(135)
                'Format/ Display Length/ Data Length'(136)
                'Field Calculations'(137)
                'Comments'(056)
                INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.

    READ TABLE l_itab_info INTO l_wa_itab_info INDEX 1.

    LOOP AT l_wa_itab_info-tabinfo INTO l_wa_ztabinfo.

      l_pos = l_wa_ztabinfo-leng.
      l_dtype = l_pos.
      SHIFT l_dtype LEFT DELETING LEADING space.
      l_pos = l_wa_ztabinfo-decimals.
      l_dec = l_pos.
      SHIFT l_dec LEFT DELETING LEADING space.
      IF l_wa_ztabinfo-decimals IS NOT INITIAL.
        CONCATENATE l_wa_ztabinfo-datatype '(' l_dtype ',' l_dec ')'
                    INTO l_dtype.
      ELSE.
        CONCATENATE l_wa_ztabinfo-datatype l_dtype
                    INTO l_dtype.
      ENDIF.
      CONCATENATE l_wa_ztabinfo-fld_label
                  l_wa_ztabinfo-tab_name
                  l_wa_ztabinfo-fld_name
                  l_dtype
                  c_na
                  l_wa_ztabinfo-fld_desc
                  INTO wa_clipbrd-line SEPARATED BY c_separator.
      APPEND wa_clipbrd TO i_clipbrd.
      CLEAR : wa_clipbrd, l_pos, l_dtype, l_v_line.
    ENDLOOP.

    PERFORM sub_paste_from_clipboard USING l_v_table.

    PERFORM sub_make_header_shad USING p_v_actdoc
                                       '21'.

*   Advancing the cursor to the end of the table
    GET PROPERTY OF l_v_table 'Range' = l_v_range.
    GET PROPERTY OF l_v_range 'End' = l_pos .
    SET PROPERTY OF l_v_range 'Start' = l_pos .

*   Selects the specified object
    CALL METHOD OF l_v_range 'Select' .

*   For 1 line gap
    CALL METHOD OF p_v_selection 'TypeParagraph'.
  ENDIF.
ENDFORM.                    " SUB_POPULATE_OP
*&---------------------------------------------------------------------*
*&      Form  SUB_CHECK_EXCEL
*&---------------------------------------------------------------------*
* Check for Excel File Upload
*----------------------------------------------------------------------*
*  No Parameters
*----------------------------------------------------------------------*
FORM sub_check_excel .

  IF p_fname IS INITIAL.
    MESSAGE e398 WITH 'Please select a PC file'(099).
  ENDIF.

ENDFORM.                    " SUB_CHECK_EXCEL
*&---------------------------------------------------------------------*
*&      Form  SUB_EXCEL_FILE_F4
*&---------------------------------------------------------------------*
* Provide a F4 help for PC file
*----------------------------------------------------------------------*
*  No Parameters
*----------------------------------------------------------------------*
FORM sub_excel_file_f4 .

* F4 help for the excel file
  CALL FUNCTION 'KD_GET_FILENAME_ON_F4'
    CHANGING
      file_name     = p_fname
    EXCEPTIONS
      mask_too_long = 1
      OTHERS        = 2.

* If the help funtion has an error, display a message.
  IF sy-subrc <> 0.

    MESSAGE i398 WITH 'Unable to find filepath'(100).
    LEAVE LIST-PROCESSING.

  ENDIF.

ENDFORM.                    " SUB_EXCEL_FILE_F4
*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_OPXL
*&---------------------------------------------------------------------*
* Upload from Excel
*----------------------------------------------------------------------*
*  No Parameters
*----------------------------------------------------------------------*
FORM sub_populate_opxl USING p_v_actdoc    TYPE ole2_object
                             p_v_selection TYPE ole2_object.

  TYPES:
* Line type of sender table
        BEGIN OF l_x_senderline,
           line(4096)               TYPE c,
         END OF l_x_senderline,

* Final Internal table structure
         BEGIN OF l_x_final,
           tabname   TYPE ddobjname,   " Table Name
           fldname   TYPE fieldname,   " Field name
           text      TYPE as4text,     " Text as in Excel
           datatype  TYPE dynptype,    " Data Type in table
           length    TYPE ddleng,      " Data Length
           decimals  TYPE i,           " DECIMALS
           fieldtext TYPE as4text,     " Short Description of the field
        END OF l_x_final.

  DATA:
* Internal tab to hold the excel records in hash seperated form
       l_i_excel_tab     TYPE STANDARD TABLE OF l_x_senderline
                         INITIAL SIZE 0,
* Internal table to hold the final records
       l_i_final         TYPE STANDARD TABLE OF l_x_final
                         INITIAL SIZE 0,
* Internal table to hold the details
       l_i_details       TYPE STANDARD TABLE OF dfies INITIAL SIZE 0,
       i_clipbrd_1       TYPE STANDARD TABLE OF x_clipbrd,
       l_i_xl_tab        TYPE STANDARD TABLE OF char30,
* Work Areas
       l_wa_excel_tab    TYPE l_x_senderline,
       l_wa_final        TYPE l_x_final,
       l_wa_details      TYPE dfies,
       l_wa_xl_tab       TYPE char30.

  DATA:   l_begin_col    TYPE  i,  " Begin Column
          l_begin_row    TYPE  i,  " Begin Row
          l_end_col      TYPE  i,  " End Column
          l_end_row      TYPE  i,  " End Row
          l_index        TYPE sy-tabix, " To catch the index
          l_tabix        TYPE sytabix.

  DATA: application   TYPE  ole2_object,
        workbook      TYPE  ole2_object,
        range         TYPE  ole2_object,
        worksheet     TYPE  ole2_object.
  DATA: h_cell        TYPE  ole2_object,
        h_cell1       TYPE  ole2_object.

  DATA : l_v_tables TYPE ole2_object,
         l_v_range  TYPE ole2_object,
         l_v_table  TYPE ole2_object,
         l_v_table_border TYPE ole2_object,
         l_dtype    TYPE char15,
         l_dec      TYPE char10,
         l_v_line   TYPE i,
         l_pos      TYPE i.

* Giving the row and column numbers
  l_begin_col  = '1'.
  l_begin_row  = '1'.
  l_end_col    = '3'.
  l_end_row    = '500'.

* check parameters
  IF l_begin_row > l_end_row. RAISE inconsistent_parameters. ENDIF.
  IF l_begin_col > l_end_col. RAISE inconsistent_parameters. ENDIF.

* open file in Excel
  IF application-header = space OR application-handle = -1.
    CREATE OBJECT application 'Excel.Application'.

  ENDIF.
  CALL METHOD OF application 'Workbooks' = workbook.

  CALL METHOD OF workbook 'Open'
    EXPORTING
    #1 = p_fname.

  SET PROPERTY OF application 'Visible' = 1.

  GET PROPERTY OF  application 'ACTIVESHEET' = worksheet.

* mark whole spread sheet
  CALL METHOD OF worksheet 'Cells' = h_cell
    EXPORTING
    #1 = l_begin_row
    #2 = l_begin_col.

  CALL METHOD OF worksheet 'Cells' = h_cell1
    EXPORTING
    #1 = l_end_row
    #2 = l_end_col.


  CALL METHOD OF worksheet 'RANGE' = range
    EXPORTING
    #1 = h_cell
    #2 = h_cell1.

  CALL METHOD OF range 'SELECT'.

* copy marked area (whole spread sheet) into Clippboard
  CALL METHOD OF range 'COPY'.

* read clipboard into ABAP
  CALL METHOD cl_gui_frontend_services=>clipboard_import
    IMPORTING
      data       = l_i_excel_tab
    EXCEPTIONS
      cntl_error = 1
      OTHERS     = 4.
  IF sy-subrc <> 0.
    MESSAGE a037(alsmex).
  ENDIF.

  FREE OBJECT h_cell.
  FREE OBJECT h_cell1.
  FREE OBJECT range.

  LOOP AT l_i_excel_tab INTO l_wa_excel_tab.

    SPLIT l_wa_excel_tab-line AT c_separator INTO
          l_wa_final-tabname    " Table Name
          l_wa_final-fldname    " Field Name
          l_wa_final-text.      " Text given in Excel

    IF l_wa_final-tabname CA '-'
    AND l_wa_final-fldname IS INITIAL.

      SPLIT l_wa_final-tabname AT '-'
      INTO TABLE l_i_xl_tab.

*      l_tabix = LINES( l_i_xl_tab ).
      DESCRIBE TABLE l_i_xl_tab LINES l_tabix.

      READ TABLE l_i_xl_tab INTO l_wa_xl_tab INDEX l_tabix.
      IF sy-subrc = 0.
        l_wa_final-fldname = l_wa_xl_tab.
        l_tabix = l_tabix - 1.
        READ TABLE l_i_xl_tab INTO l_wa_xl_tab INDEX l_tabix.
        IF sy-subrc = 0.
          l_wa_final-tabname = l_wa_xl_tab.
          CLEAR: l_tabix.
        ENDIF.
      ENDIF.
    ENDIF.

    APPEND l_wa_final TO l_i_final.
    CLEAR l_wa_final.

  ENDLOOP.

  LOOP AT l_i_final INTO l_wa_final.

    l_index = sy-tabix.

    CLEAR : l_i_details[].

    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = l_wa_final-tabname
        fieldname      = l_wa_final-fldname
      TABLES
        dfies_tab      = l_i_details
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.

    IF sy-subrc = 0.

      READ TABLE l_i_details INTO l_wa_details INDEX 1.

      l_wa_final-length    = l_wa_details-leng.
      l_wa_final-datatype  = l_wa_details-datatype.
      l_wa_final-decimals  = l_wa_details-decimals.
      l_wa_final-fieldtext = l_wa_details-fieldtext.
      MODIFY l_i_final FROM l_wa_final INDEX l_index.
      CLEAR l_wa_final.
    ENDIF.
  ENDLOOP.

  IF l_i_final[] IS NOT INITIAL.

*    l_v_line = LINES( l_i_final ) + 1.
    DESCRIBE TABLE l_i_final LINES l_v_line.
    l_v_line = l_v_line + 1.

*   Populate one text
    CALL METHOD OF p_v_selection 'TypeText'
      EXPORTING
      #1 = 'Output information from XL input:'(101).
    CALL METHOD OF p_v_selection 'TypeParagraph'.
    CALL METHOD OF p_v_selection 'TypeParagraph'.

*   Inserting table for header details
*   Inserting a table and filling some of its cells.
    GET PROPERTY OF p_v_actdoc 'Tables' = l_v_tables.
    GET PROPERTY OF p_v_selection 'Range' = l_v_range .
    CALL METHOD OF l_v_tables 'Add' = l_v_table
    EXPORTING
    #1 = l_v_range
    #2 = l_v_line  "Number of rows
    #3 = '6'.      "Number of columns

*   Setting border attribute for the table
    GET PROPERTY OF l_v_table 'Borders' = l_v_table_border.
    SET PROPERTY OF l_v_table_border 'Enable' = '1' . "With border
    SET PROPERTY OF l_v_table_border 'OutsideLineWidth' = '12'. "With
    CLEAR : wa_clipbrd, i_clipbrd[].

*   For the heading:
    CONCATENATE 'Field # - Label'(133)
                'SAP Table Name'(134)
                'SAP Field Name'(135)
                'Format/ Display Length/ Data Length'(136)
                'Field Calculations'(137)
                'Description'(070)
                INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.

    LOOP AT l_i_final INTO l_wa_final.

      l_pos = l_wa_final-length.
      l_dtype = l_pos.
      SHIFT l_dtype LEFT DELETING LEADING space.
      l_pos = l_wa_final-decimals.
      l_dec = l_pos.
      SHIFT l_dec LEFT DELETING LEADING space.
      IF l_wa_final-decimals IS NOT INITIAL.
        CONCATENATE l_wa_final-datatype '(' l_dtype ',' l_dec ')'
                    INTO l_dtype.
      ELSE.
        CONCATENATE l_wa_final-datatype l_dtype
                    INTO l_dtype.
      ENDIF.
      TRANSLATE l_wa_final-tabname TO UPPER CASE.
      TRANSLATE l_wa_final-fldname TO UPPER CASE.
      CONCATENATE l_wa_final-text
                  l_wa_final-tabname
                  l_wa_final-fldname
                  l_dtype
                  c_na
                  l_wa_final-fieldtext
                  INTO wa_clipbrd-line SEPARATED BY c_separator.
      APPEND wa_clipbrd TO i_clipbrd.

      CONCATENATE l_wa_final-tabname
                  l_wa_final-fldname
                  l_wa_final-text
                  l_wa_final-datatype
                  l_wa_final-length
                  l_dec
                  l_wa_final-fieldtext
                  INTO wa_clipbrd SEPARATED BY c_separator.
      APPEND wa_clipbrd TO i_clipbrd_1.
      CLEAR : wa_clipbrd, l_pos, l_dtype, l_v_line.
    ENDLOOP.

    PERFORM sub_paste_from_clipboard USING l_v_table.

    PERFORM sub_make_header_shad USING p_v_actdoc
                                       '21'.

*   Advancing the cursor to the end of the table
    GET PROPERTY OF l_v_table 'Range' = l_v_range.
    GET PROPERTY OF l_v_range 'End' = l_pos .
    SET PROPERTY OF l_v_range 'Start' = l_pos .

*   Selects the specified object
    CALL METHOD OF l_v_range 'Select' .

*   For 1 line gap
    CALL METHOD OF p_v_selection 'TypeParagraph'.

*   Paste in the Excel
    CALL METHOD cl_gui_frontend_services=>clipboard_export
      IMPORTING
        data       = i_clipbrd_1
      CHANGING
        rc         = l_pos
      EXCEPTIONS
        cntl_error = 1
        OTHERS     = 4.

    DATA: l_cell TYPE ole2_object,
          l_range TYPE ole2_object.

    CALL METHOD OF worksheet 'Cells' = l_cell
      EXPORTING
      #1 = 1
      #2 = 1.

    CALL METHOD OF worksheet 'RANGE' = range
      EXPORTING
      #1 = l_cell
      #2 = l_cell.

    CALL METHOD OF range 'SELECT'.
    CALL METHOD OF worksheet 'PASTE'.
  ENDIF.
ENDFORM.                    " SUB_POPULATE_OPXL
*&---------------------------------------------------------------------*
*&      Form  SUB_PCD_GET_PSEUDO_CODE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_EP_SELECT_INFO   text
*      -->P_L_EP_TABLE_FIELDS  text
*      -->P_L_EP_TABLE_DESC    text
*      -->P_L_EP_FIELD_DESC    text
*      -->P_L_EP_FM_CALL_INFO  text
*----------------------------------------------------------------------*
FORM sub_pcd_get_pseudo_code USING
               l_ep_select_info   TYPE x_zselect_info_ty
               l_ep_table_fields  TYPE x_ztable_field_name_ty
               l_ep_table_desc    TYPE x_zdbtab_text_ty
               l_ep_field_desc    TYPE x_zfield_desc_ty
               l_ep_fm_call_info  TYPE x_zfm_call_info_ty
               l_ep_sub_call_info TYPE x_zperform_call_info_ty
               p_actdoc           TYPE ole2_object
               p_selection        TYPE ole2_object.

  DATA:
       l_i_pseudo_cd_tab  TYPE STANDARD TABLE OF x_clipbrd
       INITIAL SIZE 0,
       l_wa_pseudo_cd_tab TYPE x_clipbrd,
       l_wa_select_info   TYPE x_zselect_info,
       l_wa_select_info1  TYPE x_zselect_info,
       l_wa_fm_call_info  TYPE x_zfm_call_info,
       l_gs_word          TYPE ole2_object , "OLE object handle
       l_gs_documents     TYPE ole2_object , "Documents
       l_gs_actdoc        TYPE ole2_object , "Active document
       l_ref_step         TYPE char10,
       l_rc               TYPE i,
       l_gs_application   TYPE ole2_object , "Application
       l_sele_pcode       TYPE ole2_object,
       l_tabix            TYPE numc4,
       l_wa_sub_call_info TYPE x_zperform_call_info,
       l_ev_code          TYPE char2.

  DATA : l_tables TYPE ole2_object,
         l_table  TYPE ole2_object,
         l_range  TYPE ole2_object,
         l_table_border TYPE ole2_object,
         l_font   TYPE ole2_object,
         l_cell   TYPE ole2_object.

  DATA:
      l_i_bold_tab  TYPE STANDARD TABLE OF x_clipbrd,
      l_wa_bold_tab TYPE x_clipbrd.

* Populate one text
  CALL METHOD OF p_selection 'TypeText'
    EXPORTING
    #1 = 'Pseudo Code:'.
  CALL METHOD OF p_selection 'TypeParagraph'.

  DO.

    CLEAR: l_wa_select_info.

    l_tabix = sy-index.

    READ TABLE l_ep_select_info INTO l_wa_select_info
    WITH KEY sub_seq = l_tabix.

    IF sy-subrc = 0.

*     For event
      IF l_ev_code NE l_wa_select_info-event_code.

        l_ev_code = l_wa_select_info-event_code.

        PERFORM sub_pcode_get_event TABLES l_i_pseudo_cd_tab[]
                                           l_i_bold_tab[]
                                    USING  l_ev_code.

      ENDIF.

      CLEAR: v_pseudo_code,l_wa_select_info1,l_ref_step.

      IF l_wa_select_info-v_foe_tab IS NOT INITIAL.
        READ TABLE l_ep_select_info INTO l_wa_select_info1
        WITH KEY v_int_tab = l_wa_select_info-v_foe_tab.

        IF sy-subrc = 0.
          l_ref_step = l_wa_select_info1-sequence.
        ELSE.
          READ TABLE l_ep_select_info INTO l_wa_select_info1
          WITH KEY v_int_struc = l_wa_select_info-v_foe_struc.

          IF sy-subrc = 0.
            l_ref_step = l_wa_select_info1-sequence.
          ENDIF.
        ENDIF.
      ENDIF.

      CONDENSE l_tabix.

      CONCATENATE 'Step:'
                  '-'
                  l_wa_select_info-sequence
             INTO l_wa_pseudo_cd_tab
             SEPARATED BY space.

      APPEND l_wa_pseudo_cd_tab TO l_i_pseudo_cd_tab.
      CLEAR:l_wa_pseudo_cd_tab .

      PERFORM sub_pcode_for_simple_select TABLES l_i_pseudo_cd_tab[]
                                           USING l_wa_select_info
                                                 l_ep_table_fields[]
                                                 l_ep_field_desc
                                                 l_ep_table_desc
                                                 l_ref_step
                                                 l_wa_select_info1.
      CONCATENATE v_pseudo_code
                 '.'
             INTO v_pseudo_code.

      APPEND INITIAL LINE TO l_i_pseudo_cd_tab[].

      PERFORM sub_pcode_word_wrap TABLES l_i_pseudo_cd_tab[].

    ELSE.

      READ TABLE l_ep_fm_call_info INTO l_wa_fm_call_info
        WITH KEY sub_seq = l_tabix.

      IF sy-subrc = 0.

*       For event
        IF l_ev_code NE l_wa_fm_call_info-event_code.

          l_ev_code = l_wa_fm_call_info-event_code.

          PERFORM sub_pcode_get_event TABLES l_i_pseudo_cd_tab[]
                                             l_i_bold_tab[]
                                      USING  l_ev_code.

        ENDIF.

        CONCATENATE 'Step:'
                          '-'
                          l_wa_fm_call_info-sequence
                     INTO l_wa_pseudo_cd_tab
                     SEPARATED BY space.

        APPEND l_wa_pseudo_cd_tab TO l_i_pseudo_cd_tab[].
        APPEND INITIAL LINE TO l_i_pseudo_cd_tab[].

        PERFORM sub_pcode_pop_fm_info TABLES l_i_pseudo_cd_tab[]
                                      USING  l_ep_fm_call_info
                                             l_wa_fm_call_info.

      ELSE.

        READ TABLE l_ep_sub_call_info INTO l_wa_sub_call_info
         WITH KEY sub_seq = l_tabix.

        IF sy-subrc = 0.

*         For event
          IF l_ev_code NE l_wa_sub_call_info-event_code.

            l_ev_code = l_wa_sub_call_info-event_code.

            PERFORM sub_pcode_get_event TABLES l_i_pseudo_cd_tab[]
                                               l_i_bold_tab[]
                                        USING  l_ev_code.

          ENDIF.

          IF p_pc_sub = 'X'.

            PERFORM sub_pcode_pop_sub_info TABLES l_i_pseudo_cd_tab[]
                                            USING l_ep_sub_call_info
                                                  l_wa_sub_call_info.

          ENDIF.

        ELSE.
          EXIT.
        ENDIF.

      ENDIF.
    ENDIF.
  ENDDO.

* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_actdoc 'Tables' = l_tables.
  GET PROPERTY OF p_selection 'Range' = l_range.

* Adding a table with rows = 1 and column = 1
  CALL METHOD OF l_tables 'Add' = l_table
  EXPORTING
  #1 = l_range
  #2 = '1'     "Number of rows
  #3 = '1'.    "Number of columns

* Setting border attribute for the table
  GET PROPERTY OF l_table 'Borders' = l_table_border.
  SET PROPERTY OF l_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_table_border 'OutsideLineWidth' = '12'. "With

  CALL METHOD cl_gui_frontend_services=>clipboard_export
    IMPORTING
      data       = l_i_pseudo_cd_tab[]
    CHANGING
      rc         = l_rc
    EXCEPTIONS
      cntl_error = 1
      OTHERS     = 4.

* GET PROPERTY OF l_table 'Range' = l_range.
  CALL METHOD OF l_table 'Cell' = l_cell
    EXPORTING #1 = '1' #2 = '1'.

*--Getting the range handle to write the value
  GET PROPERTY OF l_cell 'Range' = l_range .

  CALL METHOD OF l_range 'Paste'.

* Set font style and size
  GET PROPERTY OF l_range 'Font' = l_font.
  SET PROPERTY OF l_font 'Size' = p_font_s.                 "'10'.
  SET PROPERTY OF l_font 'Name' = p_font_n."'Arial'.

  DATA:
      l_v_application TYPE ole2_object,
      l_sele          TYPE ole2_object,
      l_find          TYPE ole2_object,
      l_replacement   TYPE ole2_object,
      l_bol           TYPE ole2_object.

  LOOP AT l_i_bold_tab INTO l_wa_bold_tab.

    GET PROPERTY OF p_actdoc 'Application' = l_v_application.
    GET PROPERTY OF l_v_application 'Selection' = l_sele.
    GET PROPERTY OF l_sele 'Find' = l_find.
    SET PROPERTY OF l_find 'Text' = l_wa_bold_tab-line.

    CALL METHOD OF l_find 'Execute' = l_bol
      EXPORTING
        #1 = l_wa_bold_tab-line
        #2 = '0'
        #3 = '0'
        #4 = '0'
        #5 = '0'
        #6 = '0'
        #7 = '1'
        #8 = '2' "wdFindAsk
        #9 = '0'.

    FREE OBJECT l_font.

    GET PROPERTY OF l_sele 'Font' = l_font.
    SET PROPERTY OF l_font 'Bold' = 1.
    IF l_wa_bold_tab-flg = 'X'.
      SET PROPERTY OF l_font 'Underline' = 1.
    ENDIF.

  ENDLOOP.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_table 'Range' = l_range.
  GET PROPERTY OF l_range 'End' = l_rc.
  SET PROPERTY OF l_range 'Start' = l_rc.

* Selects the specified object
  CALL METHOD OF l_range 'Select' .
* For 1 line gap
  CALL METHOD OF p_selection 'TypeParagraph'.
ENDFORM.                    " SUB_PCD_GET_PSEUDO_CODE
*&---------------------------------------------------------------------*
*&      Form  SUB_PCODE_FOR_SIMPLE_SELECT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->L_I_PSEUDO_CD_TAB
*      -->L_WA_SELECT_INFO
*      -->L_EP_TABLE_FIELDS
*      -->L_EP_FIELD_DESC
*      -->L_EP_TABLE_DESC
*----------------------------------------------------------------------*
FORM sub_pcode_for_simple_select
                    TABLES l_i_pseudo_cd_tab
                     USING l_wa_select_info  TYPE x_zselect_info
                           l_ep_table_fields TYPE x_ztable_field_name_ty
                           l_ep_field_desc   TYPE x_zfield_desc_ty
                           l_ep_table_desc   TYPE x_zdbtab_text_ty
                           l_ref_step        TYPE char10
                           l_wa_select_info1 TYPE x_zselect_info.

  DATA:
      l_wa_dbtab_name       TYPE x_zdbtab_name,
      l_wa_link_fld         TYPE x_zfield_name,
      l_wa_field_name       TYPE x_zfield_name,
      l_wa_field_name1      TYPE x_zfield_name,
      l_wa_table_fields     TYPE x_ztable_field_name,
      l_wa_field_desc       TYPE x_zfield_desc,
      l_wa_pseudo_cd_tab    TYPE x_clipbrd,
      l_wa_pseudo_cd_tab1   TYPE x_clipbrd,
      l_wa_pseudo_cd_tab2   TYPE x_clipbrd,
      l_wa_table_desc       TYPE x_zdbtab_text,
      l_line_size1          TYPE i,
      l_line_size           TYPE i,
      l_wa_where_fld        TYPE x_zwhere_field_name,
      l_wa_where_fld1       TYPE x_zwhere_field_name,
      l_wa_operands         TYPE x_zoperands,
      l_tab_size            TYPE i,
      l_tabix               TYPE sytabix,
      l_tabix1              TYPE sytabix,
      l_fld_nm              TYPE char100,
      l_operator            TYPE char10,
      l_where_tab_size      TYPE i,
      l_x                   TYPE char1,
      l_operand             TYPE char100,
      l_flag                TYPE char1,
      l_operand_fae         TYPE char30.

*&---------------------------------------------------------------------*
*&         JOIN SELECT
*&---------------------------------------------------------------------*
***Check

  DATA: l_tab_size1 TYPE sytabix,
        l_str1      TYPE char10.

*  l_tab_size = LINES( l_wa_select_info-i_fld ).
  DESCRIBE TABLE l_wa_select_info-i_fld LINES l_tab_size.

  l_tab_size1 = l_tab_size - 1.

  l_str1 = 'The fields'(152).

  DATA: l_comma TYPE char1.

  SORT l_wa_select_info-i_fld STABLE BY tablename.

  LOOP AT l_wa_select_info-i_fld INTO l_wa_field_name.

    l_comma = ','.

    AT NEW alias.
      CLEAR l_comma.
    ENDAT.

    l_tabix = sy-tabix.
    l_wa_field_name1 = l_wa_field_name.

*   Getting the table field name
    READ TABLE l_ep_table_fields INTO l_wa_table_fields
    WITH KEY fieldname = l_wa_field_name-fieldname.

    IF sy-subrc = 0.

      CONDENSE l_comma.

*     Getting table field description
      READ TABLE l_ep_field_desc INTO l_wa_field_desc
      WITH KEY rollname = l_wa_table_fields-rollname.

      CONCATENATE '('
                  l_wa_field_desc-ddtext
                  ')'
               INTO l_wa_pseudo_cd_tab1-line.

      IF l_tabix = l_tab_size1.

        IF l_comma IS NOT INITIAL.
          CONCATENATE l_str1
                  l_comma INTO l_wa_pseudo_cd_tab-line.
          CONCATENATE l_wa_pseudo_cd_tab-line
                  l_wa_field_name-fieldname
                          l_wa_pseudo_cd_tab1-line
                    INTO l_wa_pseudo_cd_tab-line
                  SEPARATED BY space.
        ELSE.
          CONCATENATE l_str1
                l_wa_field_name-fieldname
                        l_wa_pseudo_cd_tab1-line
                  INTO l_wa_pseudo_cd_tab-line
                SEPARATED BY space.
        ENDIF.


      ELSEIF l_tabix NE l_tab_size.

        IF l_comma IS NOT INITIAL.
          CONCATENATE l_str1
          l_comma INTO l_wa_pseudo_cd_tab-line.
          CONCATENATE l_wa_pseudo_cd_tab-line
          l_wa_field_name-fieldname
                  l_wa_pseudo_cd_tab1-line
            INTO l_wa_pseudo_cd_tab-line
          SEPARATED BY space.
        ELSE.
          CONCATENATE l_str1
          l_wa_field_name-fieldname
                  l_wa_pseudo_cd_tab1-line
            INTO l_wa_pseudo_cd_tab-line
          SEPARATED BY space.
        ENDIF.

      ELSE.

        IF l_comma IS NOT INITIAL.
          CONCATENATE l_str1
          l_comma INTO l_wa_pseudo_cd_tab-line.
          CONCATENATE l_wa_pseudo_cd_tab-line
          l_wa_field_name-fieldname
          l_wa_pseudo_cd_tab1-line
          INTO l_wa_pseudo_cd_tab-line
          SEPARATED BY space.
        ELSE.
          CONCATENATE l_str1
          l_wa_field_name-fieldname
          l_wa_pseudo_cd_tab1-line
          INTO l_wa_pseudo_cd_tab-line
          SEPARATED BY space.
        ENDIF.

      ENDIF.

      CONCATENATE v_pseudo_code l_wa_pseudo_cd_tab
      INTO v_pseudo_code.

      CLEAR: l_str1.

    ENDIF.

    AT END OF alias.

      CLEAR l_flag.
      READ TABLE l_wa_select_info-i_dbtab INTO l_wa_dbtab_name
      WITH KEY alias = l_wa_field_name1-alias+0(30).

      IF  sy-subrc = 0.
        l_flag = 'X'.
      ELSE.
        READ TABLE l_wa_select_info-i_dbtab INTO l_wa_dbtab_name
              WITH KEY dbtab_name = l_wa_field_name1-alias.
        IF sy-subrc = 0.
          l_flag = 'X'.
        ENDIF.
      ENDIF.

      IF l_flag = 'X'.
        READ TABLE l_ep_table_desc INTO l_wa_table_desc
        WITH KEY tabname = l_wa_dbtab_name-dbtab_name.

        IF sy-subrc = 0.

          CONCATENATE '('
                  l_wa_table_desc-ddtext
                  ')'
               INTO l_wa_pseudo_cd_tab1-line.

          CONCATENATE 'are retrieved from table'
                      l_wa_dbtab_name-dbtab_name
                      l_wa_pseudo_cd_tab1-line
                      'and the fields '
                 INTO l_wa_pseudo_cd_tab
               SEPARATED BY space.

          SHIFT l_wa_pseudo_cd_tab LEFT DELETING LEADING space.
          CONCATENATE v_pseudo_code l_wa_pseudo_cd_tab
          INTO v_pseudo_code SEPARATED BY space.
        ENDIF.
      ENDIF.
    ENDAT.

  ENDLOOP.

  l_tabix = STRLEN( v_pseudo_code ).
  IF l_tabix GE 15.
    l_tabix = l_tabix - 15.
    v_pseudo_code+l_tabix(15) = space.
  ENDIF.

  IF NOT l_wa_select_info-i_join_fld IS INITIAL.

***Check

    l_wa_pseudo_cd_tab1-line =  'by joining'.

*    l_line_size = LINES( l_wa_select_info-i_dbtab ).
    DESCRIBE TABLE l_wa_select_info-i_dbtab LINES l_line_size.

    LOOP AT l_wa_select_info-i_dbtab INTO l_wa_dbtab_name.

      IF sy-tabix = 1.
        CONCATENATE l_wa_pseudo_cd_tab1
                    l_wa_dbtab_name-dbtab_name
                    'and'
                 INTO l_wa_pseudo_cd_tab
                 SEPARATED BY space.

      ELSE.

        IF sy-tabix NE l_line_size.

          CONCATENATE l_wa_pseudo_cd_tab
                      l_wa_dbtab_name-dbtab_name
                      'and'
                  INTO l_wa_pseudo_cd_tab.


        ELSE.

          CONCATENATE l_wa_pseudo_cd_tab
                      l_wa_dbtab_name-dbtab_name
                  INTO l_wa_pseudo_cd_tab
                SEPARATED BY space.

          SHIFT l_wa_pseudo_cd_tab LEFT DELETING LEADING space.
          CONCATENATE v_pseudo_code l_wa_pseudo_cd_tab
          INTO v_pseudo_code SEPARATED BY space.

        ENDIF.
      ENDIF.

    ENDLOOP.

***Check

*    l_line_size = LINES( l_wa_select_info-i_join_fld ).
    DESCRIBE TABLE l_wa_select_info-i_join_fld LINES l_line_size.

    l_wa_pseudo_cd_tab-line = 'on'.

    LOOP AT l_wa_select_info-i_join_fld INTO l_wa_field_name .
      IF sy-tabix NE l_line_size.

        CONCATENATE l_wa_pseudo_cd_tab-line
                  l_wa_field_name-fieldname
                  'of'
                  l_wa_field_name-tablename
                  'and'
               INTO l_wa_pseudo_cd_tab-line
               SEPARATED BY space.

        SHIFT l_wa_pseudo_cd_tab LEFT DELETING LEADING space.
        CONCATENATE v_pseudo_code l_wa_pseudo_cd_tab
        INTO v_pseudo_code SEPARATED BY space.
        CLEAR:l_wa_pseudo_cd_tab .
      ELSE.
        CONCATENATE l_wa_pseudo_cd_tab-line
                  l_wa_field_name-fieldname
                  'of'
                  l_wa_field_name-tablename
               INTO l_wa_pseudo_cd_tab-line
               SEPARATED BY space.

        SHIFT l_wa_pseudo_cd_tab LEFT DELETING LEADING space.
        CONCATENATE v_pseudo_code l_wa_pseudo_cd_tab
        INTO v_pseudo_code SEPARATED BY space.
        CLEAR:l_wa_pseudo_cd_tab .

      ENDIF.

    ENDLOOP.

  ENDIF.

*&---------------------------------------------------------------------*
*&         FOR ALL ENTRIES
*&---------------------------------------------------------------------*
***Check
  DATA: l_str TYPE string.

  IF NOT l_wa_select_info-v_foe_tab IS INITIAL.
*    l_tab_size = LINES( l_wa_select_info1-i_dbtab ).
    DESCRIBE TABLE l_wa_select_info1-i_dbtab LINES l_tab_size.

    l_tab_size1 = l_tab_size - 1.
    LOOP AT l_wa_select_info1-i_dbtab INTO l_wa_dbtab_name.
      l_tabix = sy-tabix.
      IF l_tabix = l_tab_size1.
        CONCATENATE l_str l_wa_dbtab_name-dbtab_name 'and' INTO
        l_str SEPARATED BY space.
      ELSEIF l_tabix LT l_tab_size.
        CONCATENATE l_str l_wa_dbtab_name-dbtab_name INTO
        l_str SEPARATED BY space.

        CONCATENATE l_str ',' INTO l_str.
      ELSE.
        CONCATENATE l_str l_wa_dbtab_name-dbtab_name INTO
        l_str SEPARATED BY space.
      ENDIF.
    ENDLOOP.

    SHIFT l_str LEFT DELETING LEADING space.
    CONCATENATE 'for all entries obtained from table'
     l_str
     '( populated in step :-' l_ref_step ')'
    INTO l_wa_pseudo_cd_tab-line
    SEPARATED BY space.

    SHIFT l_wa_pseudo_cd_tab LEFT DELETING LEADING space.
    CONCATENATE v_pseudo_code l_wa_pseudo_cd_tab
    INTO v_pseudo_code SEPARATED BY space.
    CLEAR: l_wa_pseudo_cd_tab.
  ENDIF.

*&---------------------------------------------------------------------*
*&         WHERE CLAUSE
*&---------------------------------------------------------------------*
***Check

  IF NOT l_wa_select_info-i_where_fld IS INITIAL.

    l_wa_pseudo_cd_tab-line = 'where'.

    CLEAR: l_wa_pseudo_cd_tab1.

*    l_tab_size = LINES( l_wa_select_info-i_where_fld ).
    DESCRIBE TABLE l_wa_select_info-i_where_fld LINES l_tab_size.

    l_tab_size1 = l_tab_size - 1.

    LOOP AT l_wa_select_info-i_where_fld INTO l_wa_where_fld.

      DATA:
           l_operator1 TYPE char22.

      PERFORM sub_pcod_get_operator USING l_wa_where_fld-operator
                                    CHANGING l_operator1.

      l_tabix = sy-tabix.

*----------------------------------------------------------------------*
*   WHERE CLAUSE FOR 'JOIN'
*----------------------------------------------------------------------*
      CLEAR: l_wa_operands,l_wa_where_fld1,l_wa_link_fld,
             l_wa_dbtab_name.
      READ TABLE l_wa_where_fld-operand INTO l_wa_operands
      INDEX 1.

      READ TABLE l_wa_select_info-i_link_fld INTO l_wa_where_fld1
      WITH KEY field_name = l_wa_where_fld-field_name.

      IF sy-subrc = 0 AND l_wa_operands-op CS
                           l_wa_select_info-v_foe_tab.


        READ TABLE l_wa_select_info1-i_fld INTO l_wa_link_fld
        WITH KEY fieldname = l_wa_where_fld1-field_link.

        IF sy-subrc = 0.
          IF l_wa_link_fld-alias IS INITIAL.

            READ TABLE l_wa_select_info1-i_dbtab INTO l_wa_dbtab_name
            INDEX 1.
          ELSE.

            READ TABLE l_wa_select_info1-i_dbtab INTO l_wa_dbtab_name
            WITH KEY alias = l_wa_link_fld-alias.

            IF sy-subrc <> 0.

              READ TABLE l_wa_select_info1-i_dbtab INTO l_wa_dbtab_name
              WITH KEY dbtab_name = l_wa_link_fld-alias.
            ENDIF.
          ENDIF.
        ENDIF.

        CASE  l_wa_where_fld-operator.
          WHEN 'LE' OR '<='.
            l_operand_fae = 'less than equals to'.
          WHEN 'GE' OR '>='.
            l_operand_fae = 'greater than equals to'.
          WHEN 'NOT IN'.
            l_operand_fae = 'not equals to'.
          WHEN OTHERS.
            l_operand_fae = 'equals to'.
        ENDCASE.

        CONCATENATE l_wa_pseudo_cd_tab-line
      l_wa_where_fld1-field_name
*      'equals to'
      l_operand_fae
      l_wa_where_fld1-field_link
      'of table'
      l_wa_dbtab_name-dbtab_name
      l_wa_where_fld-andor
      INTO l_wa_pseudo_cd_tab-line
      SEPARATED BY space.

        SHIFT l_wa_pseudo_cd_tab LEFT DELETING LEADING space.
        CONCATENATE v_pseudo_code l_wa_pseudo_cd_tab
        INTO v_pseudo_code SEPARATED BY space.
        CLEAR: l_wa_pseudo_cd_tab.

*----------------------------------------------------------------------*
*   WHERE CLAUSE FOR 'FOR ALL ENTRIES'
*----------------------------------------------------------------------*
      ELSE.

*        l_where_tab_size = LINES( l_wa_where_fld-operand ).
        DESCRIBE TABLE l_wa_where_fld-operand LINES l_where_tab_size.

        LOOP AT l_wa_where_fld-operand INTO l_wa_operands.

          l_tabix1 = sy-tabix.

          PERFORM sub_pcode_get_where USING l_wa_operands-op
                                            l_wa_operands-type
                                   CHANGING l_operand.

          IF l_wa_where_fld-operator = 'IN'.

            l_x = 'X'.

            IF l_fld_nm = l_wa_where_fld-field_name.
              CLEAR l_wa_where_fld-field_name.
            ENDIF.

            l_operator = 'equals to'.

            PERFORM sub_pcode_get_operand USING l_wa_operands-op
                                         l_wa_where_fld-field_name
                                          CHANGING l_operand.


            IF l_operand IS INITIAL.
              l_operand = l_wa_operands-op.
            ELSE.
              IF ( l_wa_operands-op+0(2) EQ p_param "'P_'
                  OR l_wa_operands-op+0(2) EQ p_sel_op )"'S_' )
              AND l_wa_operands-type = 'OPD'.
                CONCATENATE l_wa_operands-op l_operand
                INTO l_operand
                SEPARATED BY space.
                IF l_wa_operands-op+0(2) EQ p_sel_op." 'S_'.
                  CLEAR: l_operator.
                  l_operator = 'in'.
                ENDIF.

              ELSE.
                CLEAR: l_operator.
              ENDIF.
            ENDIF.

            IF l_tabix1 LT l_where_tab_size.

              CONCATENATE l_wa_pseudo_cd_tab
                  l_wa_where_fld-field_name
                  l_operator
                  l_operand
                  'OR'
              INTO l_wa_pseudo_cd_tab
              SEPARATED BY space.
            ELSE.
              CONCATENATE l_wa_pseudo_cd_tab
                l_wa_where_fld-field_name
                l_operator
                l_operand
                l_wa_where_fld-andor
            INTO l_wa_pseudo_cd_tab
            SEPARATED BY space.

            ENDIF.

            SHIFT l_wa_pseudo_cd_tab-line LEFT DELETING LEADING space.

            l_fld_nm = l_wa_where_fld-field_name.

          ELSE.

            CONCATENATE l_wa_pseudo_cd_tab
                l_wa_where_fld-field_name
                l_operator1
                l_wa_operands-op
                l_operand
                l_wa_where_fld-andor
            INTO l_wa_pseudo_cd_tab
            SEPARATED BY space.

            SHIFT l_wa_pseudo_cd_tab LEFT DELETING LEADING space.

          ENDIF.

          IF l_wa_pseudo_cd_tab2 IS NOT INITIAL.

            SHIFT l_wa_pseudo_cd_tab LEFT DELETING LEADING space.
            CONCATENATE v_pseudo_code l_wa_pseudo_cd_tab
            INTO v_pseudo_code SEPARATED BY space.
            CLEAR l_wa_pseudo_cd_tab2 .

            l_wa_pseudo_cd_tab1 = l_wa_pseudo_cd_tab.

          ELSE.

            SHIFT l_wa_pseudo_cd_tab LEFT DELETING LEADING space.

            CONCATENATE v_pseudo_code l_wa_pseudo_cd_tab
            INTO v_pseudo_code SEPARATED BY space.
            CLEAR l_wa_pseudo_cd_tab .

          ENDIF.

          l_wa_pseudo_cd_tab1 = l_wa_pseudo_cd_tab.
          CLEAR: l_wa_pseudo_cd_tab, l_operand,
          l_wa_where_fld-field_name, l_operator1.

        ENDLOOP.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                    " SUB_PCODE_FOR_SIMPLE_SELECT
*&---------------------------------------------------------------------*
*&      Form  SUB_PCODE_GET_OPERAND
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_OPERANDS_OP  text
*      <--P_L_OPERAND  text
*----------------------------------------------------------------------*
FORM sub_pcode_get_operand USING    l_wa_operands_op TYPE char100
                                    l_fld_nm         TYPE char100
                           CHANGING l_operand        TYPE char100.

  IF l_operand+0(5) NE '(from'.

    CLEAR:l_operand.
    IF l_wa_operands_op+0(2) EQ p_range  "'R_'
    OR l_wa_operands_op+2(2) EQ p_range  "'R_'
    OR l_wa_operands_op+4(2) EQ p_range. "'R_'.
      CONCATENATE 'in the definite range of'
                  l_fld_nm
             INTO l_operand
            SEPARATED BY space.

    ENDIF.

  ENDIF.

ENDFORM.                    " SUB_PCODE_GET_OPERAND

*&---------------------------------------------------------------------*
*&      Form  SUB_PCODE_WORD_WRAP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_I_PSEUDO_CD_TAB[]  text
*----------------------------------------------------------------------*
FORM sub_pcode_word_wrap TABLES p_i_pseudo_cd_tab.

  DATA: l_i_pseudo_cd_tab TYPE STANDARD TABLE OF x_clipbrd.

  APPEND v_pseudo_code TO p_i_pseudo_cd_tab..
  APPEND INITIAL LINE TO p_i_pseudo_cd_tab.

ENDFORM.                    " SUB_PCODE_WORD_WRAP
*&---------------------------------------------------------------------*
*&      Form  SUB_PCODE_POP_FM_INFO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_I_PSEUDO_CD_TAB[] text
*      -->P_L_EP_FM_CALL_INFO   text
*      -->P_L_WA_FM_CALL_INFO   text
*----------------------------------------------------------------------*
FORM sub_pcode_pop_fm_info TABLES l_i_pseudo_cd_tab
                   USING  l_ep_fm_call_info TYPE x_zfm_call_info_ty
                          l_wa_fm_call_info TYPE x_zfm_call_info.

  DATA:
      l_wa_fm_call TYPE x_zfm_call.

  APPEND LINES OF l_wa_fm_call_info-fm_call_code TO l_i_pseudo_cd_tab.
  APPEND INITIAL LINE TO l_i_pseudo_cd_tab.

ENDFORM.                    " SUB_PCODE_POP_FM_INFO
*&---------------------------------------------------------------------*
*&      Form  SUB_PCOD_GET_OPERATOR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_OPERANDS_OP  text
*      <--P_L_OPERATOR1  text
*----------------------------------------------------------------------*
FORM sub_pcod_get_operator USING    l_wa_operands_op TYPE char10
                           CHANGING l_operator1 TYPE char22.


  CASE  l_wa_operands_op.
    WHEN '=' OR 'EQ'.
      l_operator1 = 'equals to'(153).
    WHEN '<>' OR 'NE' .
      l_operator1 = 'not equals to'(154).
    WHEN '<' OR 'LT' .
      l_operator1 = 'less than'(155).
    WHEN '>' OR 'GT' .
      l_operator1 = 'greater than'(156).
    WHEN '<=' OR 'LE' OR '=<'.
      l_operator1 = 'less than equals to'(157).
    WHEN '=>' OR 'GE' OR '>='.
      l_operator1 = 'greater than equals to'(158).
    WHEN 'LIKE'.
      l_operator1 = 'like pattern'(159).
    WHEN 'IN'.
      l_operator1 = 'in'.
    WHEN 'NOT IN'.
      l_operator1 = 'not in'.
*  WHEN OTHERS.
  ENDCASE.

ENDFORM.                    " SUB_PCOD_GET_OPERATOR
*&---------------------------------------------------------------------*
*&      Form  SUB_PCODE_GET_WHERE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_OPERANDS_OP  text
*      <--P_L_OPERAND  text
*----------------------------------------------------------------------*
FORM sub_pcode_get_where USING    l_wa_operands_op    TYPE char100
                                  l_wa_operands_type  TYPE seu_type
                         CHANGING l_operand           TYPE char100.

  IF ( l_wa_operands_op+0(2) = p_param "'P_'
  OR l_wa_operands_op+0(2) = p_sel_op )"'S_' )
  AND l_wa_operands_type = 'OPD'.

    l_operand = '(from selection screen)'.

  ENDIF.

ENDFORM.                    " SUB_PCODE_GET_WHERE
*&---------------------------------------------------------------------*
*&      Form  SUB_POP_PSEUDO_CODE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*    -->P_ACTDOC    OLE2 object
*    -->P_SELECTION OLE2 object
*----------------------------------------------------------------------*
FORM sub_pop_pseudo_code  USING    p_actdoc    TYPE ole2_object
                                   p_selection TYPE ole2_object.

  DATA l_ep_select_info   TYPE x_zselect_info_ty.
  DATA l_ep_table_fields  TYPE x_ztable_field_name_ty.
  DATA l_ep_table_desc    TYPE x_zdbtab_text_ty.
  DATA l_ep_field_desc    TYPE x_zfield_desc_ty.
  DATA l_ep_fm_call_info  TYPE x_zfm_call_info_ty.
  DATA l_ep_sub_call_info TYPE x_zperform_call_info_ty.

  PERFORM sub_tad_get_data CHANGING l_ep_select_info
                                    l_ep_table_fields
                                    l_ep_table_desc
                                    l_ep_field_desc
                                    l_ep_sub_call_info
                                    l_ep_fm_call_info.

  PERFORM sub_pcd_get_pseudo_code USING l_ep_select_info
                                        l_ep_table_fields
                                        l_ep_table_desc
                                        l_ep_field_desc
                                        l_ep_fm_call_info
                                        l_ep_sub_call_info
                                        p_actdoc
                                        p_selection.
ENDFORM.                    " SUB_POP_PSEUDO_CODE
*&---------------------------------------------------------------------*
*& Form  SUB_GET_HIGH_LOW
*&---------------------------------------------------------------------*
*  Get the number of record
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM sub_get_high_low TABLES    p_l_i_ddnmb  STRUCTURE ddnmb
                      USING     p_l_wa_tabcat  STRUCTURE dd09l
                                p_l_wa_x030l STRUCTURE x030l
                                p_wa_table_tab
                      CHANGING  p_l_size_cat.
  DATA: BEGIN OF value_text,
         datenart(60),
         kategorie(60),
         pufferart(60),
        END OF value_text.

  DATA: l_datalen TYPE i,
        l_line_nr TYPE syst-tabix,
        l_database TYPE sy-dbsys,
        l_n_actkat(2) TYPE n,
        l_n_maxkat(2) TYPE n,
        l_wa_ddnmb TYPE ddnmb,
        l_border_low TYPE tabkat,
        l_border_high TYPE tabkat,
        l_posnr TYPE i,
        l_posnr_chr(10) TYPE n,
        l_x TYPE f,
        l_y TYPE f,
        l_datasetnumb TYPE i,
        l_low(13),
        l_high(13).
  PERFORM sub_pop_ddnmb TABLES p_l_i_ddnmb
                        USING  p_l_wa_x030l
                               ''
                               p_wa_table_tab.

  DESCRIBE TABLE p_l_i_ddnmb LINES l_line_nr.
  IF l_line_nr = 0.
    PERFORM sub_pop_ddnmb TABLES p_l_i_ddnmb
                          USING  p_l_wa_x030l
                                 'ORACLE'
                                 p_wa_table_tab.
    DESCRIBE TABLE p_l_i_ddnmb LINES l_line_nr.
  ENDIF.
  READ TABLE p_l_i_ddnmb INTO l_wa_ddnmb INDEX l_line_nr.
  IF sy-subrc = 0.
    l_n_actkat = p_l_wa_tabcat-tabkat.
    l_n_maxkat = l_wa_ddnmb-kategorie.
  ENDIF.
  IF p_l_wa_tabcat-tabkat = 0.
    l_border_low = l_border_high = p_l_wa_tabcat-tabkat + 1.
  ELSEIF l_n_actkat > 0  AND l_n_actkat <= l_n_maxkat.
    l_border_low = p_l_wa_tabcat-tabkat.
    l_border_high = p_l_wa_tabcat-tabkat + 1.
  ELSEIF l_n_actkat > l_n_maxkat AND l_wa_ddnmb-kategorie <> ''.
    value_text-kategorie = text-005.
    REPLACE '&' WITH l_wa_ddnmb-kategorie INTO value_text-kategorie.
  ENDIF.
  LOOP AT p_l_i_ddnmb INTO l_wa_ddnmb
                      FROM l_border_low TO l_border_high.
    l_posnr = l_wa_ddnmb-dsetnbmax DIV 10.
    WRITE l_posnr TO l_posnr_chr LEFT-JUSTIFIED
                                  USING EDIT MASK '__________'.
    l_posnr = STRLEN( l_posnr_chr ).
    l_posnr = l_posnr - 1.
    l_posnr = 10 ** l_posnr.
    l_x = l_wa_ddnmb-dsetnbmax / l_posnr.
    l_x = TRUNC( l_x ).
    l_x = l_x * l_posnr.
    l_y = 2147483647.
    IF l_x < l_y.
      l_datasetnumb = l_x.
    ENDIF.
    IF syst-tabix = 1.
      l_low = 0.
      WRITE l_datasetnumb TO l_high.
    ELSE.
      WRITE l_high TO l_low.
      IF l_x < l_y.
        WRITE l_datasetnumb TO l_high.
      ELSE.
        WRITE l_x TO l_high.
      ENDIF.
    ENDIF.
    IF l_wa_ddnmb-kategorie = p_l_wa_tabcat-tabkat.
      SHIFT l_low LEFT DELETING LEADING ' '.
      SHIFT l_high LEFT DELETING LEADING ' '.
      CONCATENATE l_low text-008 l_high
                  INTO p_l_size_cat
                  SEPARATED BY ' '.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " SUB_GET_HIGH_LOW
*&---------------------------------------------------------------------*
*&      Form  SUB_POP_DDNMB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_L_I_DDNMB  text
*      -->P_P_L_WA_X030L  text
*      -->P_4594   text
*      -->P_P_WA_TABLE_TAB  text
*----------------------------------------------------------------------*
FORM sub_pop_ddnmb  TABLES   p_l_i_ddnmb  STRUCTURE ddnmb
                    USING    p_l_wa_x030l STRUCTURE x030l
                             p_l_database
                             p_wa_table_tab.
  DATA: l_datalen TYPE i.
  l_datalen = p_l_wa_x030l-tablen.
  CALL FUNCTION 'DB_CMP_TABENTRIES'
    EXPORTING
      datasetlen = l_datalen
      tabname    = p_wa_table_tab
      database   = p_l_database
    TABLES
      datasetnb  = p_l_i_ddnmb.
  SORT p_l_i_ddnmb BY dspace.
ENDFORM.                    " SUB_POP_DDNMB
*&---------------------------------------------------------------------*
*&      Form  SUB_PCODE_POP_SUB_INFO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_I_PSEUDO_CD_TAB[]  text
*      -->P_L_EP_SUB_CALL_INFO  text
*      -->P_L_WA_SUB_CALL_INFO  text
*----------------------------------------------------------------------*
FORM sub_pcode_pop_sub_info TABLES l_i_pseudo_cd_tab
                  USING  p_l_ep_sub_call_info TYPE
x_zperform_call_info_ty
                         p_l_wa_sub_call_info TYPE x_zperform_call_info.

  DATA:
      l_wa_pseudo_cd_tab   TYPE x_clipbrd.

  IF p_l_wa_sub_call_info-seq_flag = 'S'.

    IF NOT p_l_wa_sub_call_info-subroutine_name IS INITIAL.
      CONCATENATE l_wa_pseudo_cd_tab 'Start of subroutine'(187)
      p_l_wa_sub_call_info-subroutine_name
      INTO l_wa_pseudo_cd_tab-line SEPARATED BY space.
    ELSE.
      CONCATENATE l_wa_pseudo_cd_tab
                  'Start of method'(188)
                  p_l_wa_sub_call_info-method_name
                  'of class'(189)
                  p_l_wa_sub_call_info-class_name
      INTO l_wa_pseudo_cd_tab-line SEPARATED BY space.

    ENDIF.

    SHIFT l_wa_pseudo_cd_tab-line LEFT DELETING LEADING space.

    APPEND l_wa_pseudo_cd_tab TO l_i_pseudo_cd_tab.

  ELSEIF p_l_wa_sub_call_info-seq_flag = 'E'.

    IF NOT p_l_wa_sub_call_info-subroutine_name IS INITIAL.
      CONCATENATE l_wa_pseudo_cd_tab 'End of subroutine'(190)
      p_l_wa_sub_call_info-subroutine_name
      INTO l_wa_pseudo_cd_tab-line SEPARATED BY space.
    ELSE.
      CONCATENATE l_wa_pseudo_cd_tab
                  'End of method'(191)
                  p_l_wa_sub_call_info-method_name
                  'of class'(189)
                  p_l_wa_sub_call_info-class_name
      INTO l_wa_pseudo_cd_tab-line SEPARATED BY space.

    ENDIF.

    SHIFT l_wa_pseudo_cd_tab-line LEFT DELETING LEADING space.

    APPEND l_wa_pseudo_cd_tab TO l_i_pseudo_cd_tab.

  ENDIF.

  APPEND INITIAL LINE TO l_i_pseudo_cd_tab[].

ENDFORM.                    " SUB_PCODE_POP_SUB_INFO
*&---------------------------------------------------------------------*
*&      Form  SUB_GET_INFO_RECORDING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_I_FINAL  text
*      -->P_L_JOB  text
*      <--P_L_V_TRAN  text
*      <--P_L_V_TRAN_NAM  text
*----------------------------------------------------------------------*
FORM sub_get_info_recording
                  TABLES   p_i_final
                  USING    p_l_job TYPE apq_grpn
                  CHANGING p_l_v_tran TYPE char20
                           p_l_v_tran_nam TYPE char40.

  DATA : l_wa_bdcdata TYPE bdcdata,
         l_flag TYPE char1,
         l_pos1 TYPE i,
         l_wa_final TYPE x_zauto_recrdng_str,
         l_wa_temp TYPE x_zauto_field_str,
         l_i_temp TYPE x_zauto_field_str_ty,
         l_tabname TYPE ddobjname,
         l_fieldname TYPE dfies-fieldname,
         l_langu TYPE sy-langu,
         i_dfies_tab TYPE STANDARD TABLE OF dfies,
         wa_dfies_tab LIKE LINE OF i_dfies_tab.

  DATA : l_wa_apqi TYPE x_apqi,"for BDC ID info
         i_bdcdata TYPE STANDARD TABLE OF bdcdata INITIAL SIZE 0.

  CONSTANTS : c_chk TYPE char1 VALUE 'X'.
  l_langu = 'EN'.
  REFRESH : i_bdcdata, p_i_final.
* Get the Queue identification number for the job given
  PERFORM sub_get_queue_id USING p_l_job
                        CHANGING l_wa_apqi.

* Get recording details
  PERFORM sub_get_recording_details TABLES i_bdcdata
                                     USING l_wa_apqi.

  READ TABLE i_bdcdata INTO l_wa_bdcdata INDEX 1.
  IF sy-subrc = 0.
    p_l_v_tran = l_wa_bdcdata-fnam+0(20) .
    SELECT SINGLE ttext "Transaction text
      FROM tstct
      INTO p_l_v_tran_nam(36)
      WHERE sprsl = 'E'
      AND   tcode = p_l_v_tran.
    IF sy-subrc = 0.
*     do nothing
    ENDIF.
  ENDIF.
  DELETE i_bdcdata INDEX 1.

* Get the total records in the table
  LOOP AT i_bdcdata INTO l_wa_bdcdata.
    IF l_wa_bdcdata-dynbegin ='X'.
      IF l_flag = c_chk.

        APPEND l_wa_final TO p_i_final.
        CLEAR l_wa_final.
      ENDIF.
      l_wa_final-dynpro = l_wa_bdcdata-dynpro.
      l_wa_final-program = l_wa_bdcdata-program.
      l_flag = c_chk.

    ELSE.

      CASE l_wa_bdcdata-fnam.
        WHEN 'BDC_OKCODE'.

          l_wa_final-zzokcode = l_wa_bdcdata-fval.

        WHEN 'BDC_CURSOR'.

          l_wa_final-zzcursor = l_wa_bdcdata-fval.

        WHEN OTHERS.
          l_wa_temp-fnam = l_wa_bdcdata-fnam .
          l_wa_temp-fval = l_wa_bdcdata-fval.

          SPLIT l_wa_bdcdata-fnam AT '-' INTO l_tabname l_fieldname.
          SEARCH l_fieldname FOR '('.
          IF sy-subrc = 0.
            l_pos1 = sy-fdpos.
            SEARCH l_fieldname FOR '('.
            IF sy-subrc = 0.
              l_fieldname = l_fieldname+0(l_pos1).
            ENDIF.
          ENDIF.
          CALL FUNCTION 'DDIF_FIELDINFO_GET'
            EXPORTING
              tabname        = l_tabname
              fieldname      = l_fieldname
              langu          = l_langu
            TABLES
              dfies_tab      = i_dfies_tab
            EXCEPTIONS
              not_found      = 1
              internal_error = 2
              OTHERS         = 3.
          IF sy-subrc = 0.
            READ TABLE i_dfies_tab INTO wa_dfies_tab INDEX 1.
            IF sy-subrc = 0.
              l_wa_temp-type = wa_dfies_tab-datatype.
              l_wa_temp-leng = wa_dfies_tab-leng.
              l_wa_temp-fieldtext = wa_dfies_tab-fieldtext.
            ENDIF.
          ENDIF.
          APPEND l_wa_temp TO l_wa_final-zztab.
      ENDCASE.
    ENDIF.
  ENDLOOP.

  APPEND l_wa_final TO p_i_final.

ENDFORM.                    " SUB_GET_INFO_RECORDING
*&---------------------------------------------------------------------*
*&      Form  SUB_GET_QUEUE_ID
*&---------------------------------------------------------------------*
*      Get the Queue identification number for the job given
*----------------------------------------------------------------------*
*      -->P_V_JOB  Job name
*----------------------------------------------------------------------*
FORM sub_get_queue_id USING p_v_job
                   CHANGING p_wa_apqi TYPE x_apqi.

  SELECT SINGLE   datatyp
                  groupid
                  qid
      INTO p_wa_apqi
      FROM apqi
      WHERE (  datatyp = '%BDC'
            OR datatyp = 'BDC' )
        AND groupid = p_v_job.
  IF sy-subrc <> 0.
    MESSAGE i398 WITH 'Recording doesnot Exist'(141).
  ENDIF.

ENDFORM.                    " SUB_GET_QUEUE_ID
*&---------------------------------------------------------------------*
*&      Form  SUB_GET_RECORDING_DETAILS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_I_BDCDATA  text
*----------------------------------------------------------------------*
FORM sub_get_recording_details TABLES p_i_bdcdata STRUCTURE bdcdata
                                USING p_wa_apqi TYPE x_apqi.
  DATA:
    l_wa_bdcdata TYPE bdcdata,
    l_i_bdctab TYPE STANDARD TABLE OF bdcdata INITIAL SIZE 0,
    l_tabix TYPE sytabix,
    l_size  TYPE i.

  CALL FUNCTION 'BDC_OBJECT_READ'
    EXPORTING
      queue_id         = p_wa_apqi-qid
      datatype         = p_wa_apqi-datatyp
    TABLES
      dynprotab        = p_i_bdcdata
    EXCEPTIONS
      not_found        = 1
      system_failure   = 2
      invalid_datatype = 3
      OTHERS           = 4.
  IF sy-subrc <> 0.

  ENDIF.

  DELETE p_i_bdcdata WHERE fnam = 'BDC_SUBSCR'.

  IF p_wa_apqi-datatyp = 'BDC'.
    l_i_bdctab[] = p_i_bdcdata[].
    READ TABLE l_i_bdctab INTO l_wa_bdcdata INDEX 1.
    DELETE l_i_bdctab INDEX 1.

    READ TABLE l_i_bdctab TRANSPORTING NO FIELDS
    WITH KEY dynbegin = 'T'.

    IF sy-subrc = 0.

      l_tabix = sy-tabix.
*      l_size = LINES( l_i_bdctab ).
      DESCRIBE TABLE l_i_bdctab LINES l_size.

      DELETE l_i_bdctab FROM l_tabix TO l_size.
      REFRESH: p_i_bdcdata.

      APPEND l_wa_bdcdata TO p_i_bdcdata.
      APPEND LINES OF l_i_bdctab TO p_i_bdcdata.
    ENDIF.
  ENDIF.
ENDFORM.                    " SUB_GET_RECORDING_DETAILS
*&---------------------------------------------------------------------*
*&      Form  SUB_GET_SEL_INFO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM sub_get_sel_info.
* Type Declaration.
  TYPES:
* For Key Search
        BEGIN OF x_keywords,
          line(20)  TYPE c,
        END OF x_keywords,
        BEGIN OF x_source_code,
          line(200) TYPE c,
        END OF x_source_code,
* For Include Program
        BEGIN OF x_include_name,
          repname   TYPE sy-repid,
        END OF x_include_name.


  DATA: l_i_include_name TYPE STANDARD TABLE OF x_include_name
                                                        INITIAL SIZE 0,
        l_i_includes     TYPE STANDARD TABLE OF x_zinclude_name
                                                        INITIAL SIZE 0,
        l_i_keywords     TYPE STANDARD TABLE OF x_keywords
                                                        INITIAL SIZE 0,
        l_i_keywords_sel TYPE STANDARD TABLE OF x_keywords
                                                        INITIAL SIZE 0,
        l_i_desc         TYPE STANDARD TABLE OF dfies    INITIAL SIZE 0,
        l_i_source_top   TYPE STANDARD TABLE OF x_source_code
                                                        INITIAL SIZE 0,
        l_i_source_code  TYPE STANDARD TABLE OF x_source_code
                                                        INITIAL SIZE 0,
        l_i_statement_source  TYPE STANDARD TABLE OF sstmnt
                                                        INITIAL SIZE 0,
        l_i_token_source TYPE STANDARD TABLE OF stoken   INITIAL SIZE 0,
        l_i_selscr_det   TYPE STANDARD TABLE OF x_zreport_sel_info
                                                        INITIAL SIZE 0,
        l_i_prog_texts   TYPE STANDARD TABLE OF textpool INITIAL SIZE 0,
        l_i_tokens       TYPE STANDARD TABLE OF stoken   INITIAL SIZE 0,
        l_i_statements   TYPE STANDARD TABLE OF sstmnt   INITIAL SIZE 0.


* Work-Area Declaration
  DATA: ls_desc           TYPE dfies,
        ls_tokens_source  TYPE stoken,
        ls_tokens         TYPE stoken,
        ls_token          TYPE stoken,
        ls_selection      TYPE x_zreport_sel_info,
        ls_includes       TYPE x_zinclude_name,
        ls_keywords       TYPE x_keywords,
        ls_statements     TYPE sstmnt,
        ls_prog_texts     TYPE textpool,
        ls_include_name   TYPE x_include_name.

* Local Variables Declaration.
  DATA: l_tabix         TYPE sy-tabix,
        l_tabix_1       TYPE sytabix,
        l_tabix_2       TYPE sytabix,
        l_tabix_type    TYPE sytabix,
        l_tabname       TYPE ddobjname,
        l_fname         TYPE dfies-fieldname,
        l_index_s       TYPE sy-tabix,
        l_index_t       TYPE sy-tabix,
        l_string        TYPE string,
        l_str3          TYPE char30,
        l_include_name  TYPE syst-cprog,
        l_counter       TYPE i,
        l_desc          TYPE as4text,
        l_index_inc     TYPE sy-tabix,
        l_start_row     TYPE token_row,
        l_end_row       TYPE token_row,
        l_prog_index    TYPE sy-tabix,
        l_sinmulsel     TYPE char1,
        l_extension     TYPE char1,
        l_in_prog_name TYPE sy-repid,
        l_mandate       TYPE char1.

  CONSTANTS:
        c_z             TYPE char1 VALUE 'Z',
        c_na            TYPE char3 VALUE 'N/A'.

  l_in_prog_name = p_scr2.

* Check whether the program is Executable and Active program
  SELECT COUNT(*)
  UP TO 1 ROWS
  FROM reposrc
  WHERE progname = l_in_prog_name " Input Program name
    AND r3state = 'A'           "Active Program Name
    AND subc = '1'.             "For executable program
  IF sy-subrc <> 0.
* Other then executable program no further processing will be done
*    RAISE no_data.
    MESSAGE i398 WITH 'No data found'(118).
    LEAVE LIST-PROCESSING.
  ENDIF.

* Get all the include of the given program
  CALL FUNCTION 'GET_INCLUDES'
    EXPORTING
      progname = l_in_prog_name
    TABLES
      incltab  = l_i_include_name.

* Get the custom includes
  DELETE l_i_include_name WHERE repname+0(1) NE c_z.

* Populate the internal tbale with the given program name
  ls_includes-zzincludes = l_in_prog_name.
  ls_include_name-repname = l_in_prog_name.
*  APPEND ls_include_name TO l_i_include_name.
  APPEND ls_include_name TO l_i_include_name.
  CLEAR ls_include_name.

* Populate the internal table with all the required program name
  APPEND LINES OF l_i_include_name[] TO l_i_includes[].

* Populate the internal table for the data
  ls_keywords-line = 'DATA'.
  APPEND ls_keywords TO l_i_keywords.
  ls_keywords-line = 'TYPES'.
  APPEND ls_keywords TO l_i_keywords.

* Refresh The Internal Table
  REFRESH l_i_keywords_sel.
* Populate the internal table
  ls_keywords-line = 'PARAMETERS'.
  APPEND ls_keywords TO l_i_keywords_sel.
  ls_keywords-line = 'PARAMETER'.
  APPEND ls_keywords TO l_i_keywords_sel.
  ls_keywords-line = 'SELECT-OPTIONS'.
  APPEND ls_keywords TO l_i_keywords_sel.

  LOOP AT l_i_include_name INTO ls_include_name.
    l_prog_index = sy-tabix.

* Read the contents of the Report ls_include_name-repname into the Table
* l_i_SOURCE_CODE
    READ REPORT  ls_include_name-repname INTO l_i_source_code.

* Breaks down the ABAP sorc code in the source code tab l_i_source_code
* into tokens l_i_tokens according to the rules of the ABAP scanner.
    SCAN ABAP-SOURCE  l_i_source_code
                      STATEMENTS INTO l_i_statements
                      TOKENS     INTO l_i_tokens
                      KEYWORDS   FROM l_i_keywords_sel.

* Clear The Local Variables.
    CLEAR: l_start_row ,
           l_end_row.
* Initialize the start index
    l_index_s  = 1.
* Loop on the token internal table to poputae the internal table with
* all the selection screen details
    LOOP AT l_i_tokens INTO ls_token.
* CASE-ENDCASE.
      CASE ls_token-str.
* For select option
        WHEN 'SELECT-OPTIONS'.
* Populate the tabix value for further use
          l_tabix_1 = sy-tabix + 1.
          l_index_t = l_tabix_1.
* Read The Internal Table l_i_statements from Index L_INDEX_S.
          READ TABLE l_i_statements INTO ls_statements
                                   INDEX l_index_s .
          IF sy-subrc <> 0.
* Clear The Local Variables, when no data found.
            CLEAR : l_start_row,
                    l_end_row.
            EXIT.
          ELSE.
            l_start_row = ls_statements-from.
            l_end_row =  ls_statements-to.
            l_index_s =  l_index_s + 1.
          ENDIF.

* Read The Internal Table l_i_tokens Using Index L_TABIX_1.
          READ TABLE l_i_tokens INTO ls_tokens INDEX l_tabix_1.
* Get the field name and field type
          IF sy-subrc EQ 0.
            ls_selection-zzfldnme = ls_tokens-str.
            ls_selection-zzseltyp1 = 'S'.
* Modify the start row value for further use
            l_start_row = l_start_row + 1.
          ENDIF.
* Mofidy the line of the token internal table to get the field type
          l_tabix_2 =  l_tabix_1 + 2.
* Read The Internal Table l_i_tokens Using Index l_TABIX_2.
          READ TABLE l_i_tokens INTO ls_tokens INDEX l_tabix_2.
* Populate the field type
          IF sy-subrc EQ 0.
            ls_selection-zzfldtyp = ls_tokens-str.
* When there is '-' in between field and table or work area
            IF ls_selection-zzfldtyp CP '*-*'.
* Split the field
              SPLIT ls_selection-zzfldtyp AT '-' INTO l_tabname l_fname.
* Read the description of field
              CALL FUNCTION 'DDIF_FIELDINFO_GET'
                EXPORTING
                  tabname        = l_tabname
                  fieldname      = l_fname
                  langu          = sy-langu
                TABLES
                  dfies_tab      = l_i_desc
                EXCEPTIONS
                  not_found      = 1
                  internal_error = 2
                  OTHERS         = 3.
              IF sy-subrc <> 0.
* For the extension of system fields
                IF l_tabname = 'SY' OR l_tabname = 'SYST'.
* Do nothing
                ELSE.
                  CLEAR ls_selection-zzfldtyp.
                  l_str3 = l_tabname.
                  l_index_inc = l_prog_index.
* base on the include index supplied do the looping
                  WHILE ( l_index_inc GT 0 ).
*   Clear the work-area ls_includes.
                    CLEAR ls_includes.
* Read The Internal Table iT_INCLUDES Using Index l_INDEX_INC.
                    READ TABLE l_i_includes INTO ls_includes
                                          INDEX l_index_inc.
                    IF sy-subrc = 0.
* When read successfull
                      l_index_inc = l_index_inc - 1.
                      l_include_name = ls_includes-zzincludes.
* Read The Source Text in l_INCLUDE_NAME and Copy its Rows In internal
* table l_i_source_top.
                      READ REPORT  l_include_name INTO l_i_source_top.
* Breaks down the ABAP source code in the source code tab l_i_source_top
* into token l_i_token_source according to the rules of the ABAP scanner
                      SCAN ABAP-SOURCE l_i_source_top
                        STATEMENTS INTO l_i_statement_source
                        TOKENS INTO l_i_token_source
                        KEYWORDS   FROM l_i_keywords.  "For data declar
* Read The Internal Table l_i_token_source in Accordance with the field
* token sequence.
                      READ TABLE l_i_token_source
                           WITH KEY str = l_str3
                           TRANSPORTING NO FIELDS.
                      IF sy-subrc = 0.
                        l_tabix = sy-tabix.
                        l_tabix = l_tabix - 1.
* Clear the work-area ls_tokens_source.
                        CLEAR ls_tokens_source.
* Read The Internal Table l_i_token_source Using index l_tabix.
                        READ TABLE l_i_token_source
                        INTO ls_tokens_source
                                                  INDEX l_tabix.
                        IF sy-subrc = 0.
* Get the field extension from the data declaration
                          IF ls_tokens_source-str EQ 'DATA'.
                            l_tabix = l_tabix + 2.
* Clear the work-area ls_tokens_source.
                            CLEAR ls_tokens_source.

* Read The Internal Table l_i_token_source Using index l_tabix.
                            READ TABLE l_i_token_source
                                  INTO ls_tokens_source INDEX l_tabix.
                            IF sy-subrc = 0.
* Get from type declaration
                              IF ls_tokens_source-str EQ 'TYPE'.
                                l_tabix = l_tabix + 1.
* Read The Internal Table l_i_token_source Using Index l_TABIX.
                                READ TABLE l_i_token_source
                                    INTO ls_tokens_source INDEX l_tabix.
                                IF sy-subrc = 0.
                                  ls_selection-zzfldtyp
                                  = ls_tokens_source-str.
                                  READ TABLE l_i_token_source
                                        INTO ls_tokens_source
                                        WITH KEY str = l_fname.
                                  IF sy-subrc = 0.
                                    l_tabix_type = sy-tabix.
                                    l_tabix_type = l_tabix_type + 2.
                                    READ TABLE l_i_token_source
                                        INTO ls_tokens_source
                                        INDEX l_tabix_type.
                                    IF sy-subrc = 0.
                                      ls_selection-zzfldtyp
                                        = ls_tokens_source-str.
                                    ENDIF.
                                  ENDIF.
                                ENDIF.
                              ENDIF.
                            ENDIF.
                          ENDIF.
                        ENDIF.
                      ENDIF.
                    ENDIF.
                  ENDWHILE.
                ENDIF.
              ENDIF.
            ELSE.
              l_str3 = ls_tokens-str.
              l_index_inc = l_prog_index.
* base on the include index supplied do the looping
              WHILE ( l_index_inc GT 0 ).
* Clear the work-area ls_includes.
                CLEAR ls_includes.
* Read The Internal Table iT_INCLUDES Using Index l_INDEX_INC.
                READ TABLE l_i_includes INTO ls_includes
                                      INDEX l_index_inc.
                IF sy-subrc = 0.
* When read successfull
                  l_index_inc = l_index_inc - 1.
                  l_include_name = ls_includes-zzincludes.
* Read The Source Text in l_INCLUDE_NAME and Copy its Rows In internal
* table l_i_source_top.
                  READ REPORT  l_include_name INTO l_i_source_top.
* Breaks down the ABAP source code in the source code tab l_i_source_top
* into token l_i_token_source according to the rules of the ABAP scanner
                  SCAN ABAP-SOURCE l_i_source_top
                    STATEMENTS INTO l_i_statement_source
                    TOKENS INTO l_i_token_source
                    KEYWORDS   FROM l_i_keywords.  "For data declaration
* Read The Internal Table l_i_token_source in Accordance with the field
* token sequence.
                  READ TABLE l_i_token_source
                       WITH KEY str = l_str3
                       TRANSPORTING NO FIELDS.
                  IF sy-subrc = 0.
                    l_tabix = sy-tabix.
                    l_tabix = l_tabix - 1.
* Clear the work-area ls_tokens_source.
                    CLEAR ls_tokens_source.
* Read The Internal Table l_i_token_source Using index l_tabix.
                    READ TABLE l_i_token_source INTO ls_tokens_source
                                              INDEX l_tabix.
                    IF sy-subrc = 0.
* Get the field extension from the data declaration
                      IF ls_tokens_source-str EQ 'DATA'.
                        l_tabix = l_tabix + 2.
* Clear the work-area ls_tokens_source.
                        CLEAR ls_tokens_source.

* Read The Internal Table l_i_token_source Using index l_tabix.
                        READ TABLE l_i_token_source
                        INTO ls_tokens_source
                                                  INDEX l_tabix.
                        IF sy-subrc = 0.
* Get from type declaration
                          IF ls_tokens_source-str EQ 'TYPE'.
                            l_tabix = l_tabix + 1.
* Clear the work-area ls_tokens_source.
                            CLEAR ls_tokens_source.
* Read The Internal Table l_i_token_source Using Index l_TABIX.
                            READ TABLE l_i_token_source
                                  INTO ls_tokens_source INDEX l_tabix.
* Get the field name and table name
                            IF sy-subrc = 0.
                              IF ls_tokens_source-str CP '*-*'.
                                SPLIT ls_tokens_source-str AT '-'
                                                    INTO l_tabname
                                                         l_fname.
* Read the description of field
                                CALL FUNCTION 'DDIF_FIELDINFO_GET'
                                  EXPORTING
                                    tabname        = l_tabname
                                    fieldname      = l_fname
                                    langu          = sy-langu
                                  TABLES
                                    dfies_tab      = l_i_desc
                                  EXCEPTIONS
                                    not_found      = 1
                                    internal_error = 2
                                    OTHERS         = 3.
                                IF sy-subrc = 0.
* Clear The Local Work-Area Ls_DESC.
                                  CLEAR ls_desc.
* Read The Internal Table l_i_DESC
                                  READ TABLE l_i_desc INTO ls_desc
                                  INDEX 1.
                                  IF sy-subrc = 0.
                                    ls_selection-zzfldtyp = l_fname.
                                    l_string = ls_desc-fieldtext.
                                  ENDIF.
                                ENDIF.
                              ELSE.
                                ls_selection-zzfldtyp =
 ls_tokens_source-str.
                              ENDIF.
                            ENDIF.
                          ENDIF.
                        ENDIF.
                      ENDIF.
                    ENDIF.
                  ENDIF.
                ELSE.
                  l_index_inc = l_index_inc - 1.
                ENDIF.
              ENDWHILE.
            ENDIF.
          ENDIF.
* For Obligatory
          WHILE ( l_start_row LT l_end_row ).
            l_index_t = l_index_t + 1.
* Read The Internal Table l_i_tokens Using Index l_INDEX_T.
            READ TABLE l_i_tokens INTO ls_tokens INDEX l_index_t.
            IF sy-subrc EQ 0.
              IF ls_tokens-str = 'OBLIGATORY'.
                l_mandate = 'X'.
                ls_selection-zzselcmt = 'Mandatory'(007).
* For Default
              ELSEIF ls_tokens-str = 'DEFAULT'.
                l_tabix_1 = sy-tabix + 1.
* Read The Internal Table Table l_i_tokens Using Index l_TABIX_1.
                READ TABLE l_i_tokens INTO ls_tokens INDEX l_tabix_1.
                IF sy-subrc EQ 0.
                  ls_selection-zzdefval = ls_tokens-str.
                ENDIF.
* For no intervals
              ELSEIF ls_tokens-str = 'INTERVALS'.
                l_sinmulsel = 'X'.
* For no extension
              ELSEIF ls_tokens-str = 'NO-EXTENSION'.
                l_extension = 'X'.
* When a field is commented with NO-DISPLAY, the field will be hidden
              ELSEIF ls_tokens-str = 'NO-DISPLAY'.
                CLEAR ls_selection.
                EXIT.
              ENDIF.
            ENDIF.
            l_start_row = l_start_row + 1.
          ENDWHILE.
* If the field Zdefault doesnt contain any value.
          IF ls_selection-zzdefval IS INITIAL
            AND NOT ls_selection IS INITIAL.
            ls_selection-zzdefval = c_na.
          ENDIF.
          IF NOT ls_selection IS INITIAL.
* For optional
            IF l_mandate = space.
              ls_selection-zzselcmt = 'Optional'(023).
              CLEAR l_mandate.
            ENDIF.
* Populate the comment field
            IF l_sinmulsel = 'X'
              AND l_extension = 'X'.
              IF NOT ls_selection-zzselcmt IS INITIAL.
                CONCATENATE ls_selection-zzselcmt
                            'Single Selection'(105)
                       INTO ls_selection-zzselcmt
                       SEPARATED BY '-'.
                CLEAR: l_sinmulsel, l_extension.
              ELSE.
                ls_selection-zzselcmt = 'Single Selection'(105).
                CLEAR: l_sinmulsel, l_extension.
              ENDIF.
            ELSE.
              IF NOT ls_selection-zzselcmt IS INITIAL.
                CONCATENATE ls_selection-zzselcmt
                            'Range/Multiple Selection'(106)
                       INTO ls_selection-zzselcmt
                       SEPARATED BY '-'.
                CLEAR: l_sinmulsel, l_extension.
              ELSE.
                ls_selection-zzselcmt = 'Range/Multiple Selection'(106).
              ENDIF.
            ENDIF.
          ENDIF.
* When the work area for selection screen details contains field value
          IF NOT ls_selection IS INITIAL.
            APPEND ls_selection TO l_i_selscr_det.
            l_counter = l_counter - 1.
* Clear The Work Area ls_selection.
            CLEAR ls_selection.
* Clear The Local Variables l_STRING.
            CLEAR : l_string.
          ENDIF.
* Parameters
        WHEN 'PARAMETERS' OR 'PARAMETER'.
          l_tabix_1 = sy-tabix + 1.
          l_index_t = l_tabix_1.

* Read Table T_STATEMENTS Using Index l_INDEX_S.
          READ TABLE l_i_statements INTO ls_statements
                                   INDEX l_index_s .
          IF sy-subrc <> 0.
* Clear The Local Variables.
            CLEAR : l_start_row,
                    l_end_row.
            EXIT.
          ELSE.
            l_start_row = ls_statements-from.
            l_end_row =  ls_statements-to.
            l_index_s =  l_index_s + 1.
          ENDIF.

* Read Table l_i_tokens Using Index l_TABIX_1.
          READ TABLE l_i_tokens INTO ls_tokens INDEX l_tabix_1.
          IF sy-subrc EQ 0.
            ls_selection-zzfldnme = ls_tokens-str.
            ls_selection-zzseltyp1 = 'P'.
          ENDIF.
          l_tabix_2 =  l_tabix_1 + 2.
* Read Table l_i_tokens Using Index l_TABIX_2.
          READ TABLE l_i_tokens INTO ls_tokens INDEX l_tabix_2.
          IF sy-subrc EQ 0.
            ls_selection-zzfldtyp = ls_tokens-str.
            IF ls_selection-zzfldtyp CP '*-*'.
              SPLIT ls_selection-zzfldtyp AT '-' INTO l_tabname
                                                      l_fname.
* Read the description of field
              CALL FUNCTION 'DDIF_FIELDINFO_GET'
                EXPORTING
                  tabname        = l_tabname
                  fieldname      = l_fname
                  langu          = sy-langu
                TABLES
                  dfies_tab      = l_i_desc
                EXCEPTIONS
                  not_found      = 1
                  internal_error = 2
                  OTHERS         = 3.
              IF sy-subrc <> 0.
                IF l_tabname = 'SY' OR l_tabname = 'SYST'.
* Do Nothing
                ELSE.
                  CLEAR ls_selection-zzfldtyp.
                  l_str3 = l_tabname.
                  l_index_inc = l_prog_index.
* base on the include index supplied do the looping
                  WHILE ( l_index_inc GT 0 ).
*   Clear the work-area ls_includes.
                    CLEAR ls_includes.
* Read The Internal Table iT_INCLUDES Using Index l_INDEX_INC.
                    READ TABLE l_i_includes INTO ls_includes
                                          INDEX l_index_inc.
                    IF sy-subrc = 0.
* When read successfull
                      l_index_inc = l_index_inc - 1.
                      l_include_name = ls_includes-zzincludes.
* Read The Source Text in l_INCLUDE_NAME and Copy its Rows In internal
* table l_i_source_top.
                      READ REPORT  l_include_name INTO l_i_source_top.
* Breaks down the ABAP source code in the source code tab l_i_source_top
* into token l_i_token_source according to the rules of the ABAP scanner
                      SCAN ABAP-SOURCE l_i_source_top
                        STATEMENTS INTO l_i_statement_source
                        TOKENS INTO l_i_token_source
                        KEYWORDS   FROM l_i_keywords.  "For data declar
* Read The Internal Table l_i_token_source in Accordance with the field
* token sequence.
                      READ TABLE l_i_token_source
                           WITH KEY str = l_str3
                           TRANSPORTING NO FIELDS.
                      IF sy-subrc = 0.
                        l_tabix = sy-tabix.
                        l_tabix = l_tabix - 1.
* Clear the work-area ls_tokens_source.
                        CLEAR ls_tokens_source.
* Read The Internal Table l_i_token_source Using index l_tabix.
                        READ TABLE l_i_token_source
                        INTO ls_tokens_source
                                                  INDEX l_tabix.
                        IF sy-subrc = 0.
* Get the field extension from the data declaration
                          IF ls_tokens_source-str EQ 'DATA'.
                            l_tabix = l_tabix + 2.
* Clear the work-area ls_tokens_source.
                            CLEAR ls_tokens_source.

* Read The Internal Table l_i_token_source Using index l_tabix.
                            READ TABLE l_i_token_source
                                  INTO ls_tokens_source INDEX l_tabix.
                            IF sy-subrc = 0.
* Get from type declaration
                              IF ls_tokens_source-str EQ 'TYPE'.
                                l_tabix = l_tabix + 1.
* Read The Internal Table l_i_token_source Using Index l_TABIX.
                                READ TABLE l_i_token_source
                                    INTO ls_tokens_source INDEX l_tabix.
                                IF sy-subrc = 0.
                                  ls_selection-zzfldtyp
                                  = ls_tokens_source-str.
                                  READ TABLE l_i_token_source
                                        INTO ls_tokens_source
                                        WITH KEY str = l_fname.
                                  IF sy-subrc = 0.
                                    l_tabix_type = sy-tabix.
                                    l_tabix_type = l_tabix_type + 2.
                                    READ TABLE l_i_token_source
                                        INTO ls_tokens_source
                                        INDEX l_tabix_type.
                                    IF sy-subrc = 0.
                                      ls_selection-zzfldtyp
                                        = ls_tokens_source-str.
                                    ENDIF.
                                  ENDIF.
                                ENDIF.
                              ENDIF.
                            ENDIF.
                          ENDIF.
                        ENDIF.
                      ENDIF.
                    ENDIF.
                  ENDWHILE.
                ENDIF.
              ELSE.
                READ TABLE l_i_desc INTO ls_desc INDEX 1.
                IF sy-subrc = 0.
                  l_string  = ls_desc-fieldtext.
                ENDIF.
              ENDIF.
            ELSE.
              l_str3 = ls_tokens-str.
              l_index_inc = l_prog_index.
              WHILE ( l_index_inc GT 0 ).
* Clear the Work Area ls_includes.
                CLEAR ls_includes.
* Read  Internal Table iT_INCLUDES Using Index l_INDEX_INC.
                READ TABLE l_i_includes INTO ls_includes
                                      INDEX l_index_inc.
                IF sy-subrc = 0.
                  l_index_inc = l_index_inc - 1.
                  l_include_name = ls_includes-zzincludes.
* Read The Source Text in L_INCLUDE and Copy its Rows In internal table
* l_i_source_top.
                  READ REPORT  l_include_name INTO l_i_source_top.
* Breaks down the ABAP source code in the source code tab l_i_source_top
* into token l_i_token_source according to the rules of the ABAP scanner
                  SCAN ABAP-SOURCE l_i_source_top
                       STATEMENTS INTO l_i_statement_source
                       TOKENS INTO   l_i_token_source
                       KEYWORDS   FROM l_i_keywords.
* Read Internal Tab l_i_token_source in Accordance with Field token seq.
                  READ TABLE l_i_token_source
                                            WITH KEY str = l_str3
                                            TRANSPORTING NO FIELDS.
                  IF sy-subrc = 0.
                    l_tabix = sy-tabix.
                    l_tabix = l_tabix - 1.
* Clear the Work Area ls_tokens_source
                    CLEAR ls_tokens_source.
* Read Internal Table l_i_token_source Using Index L_TABIX.
                    READ TABLE l_i_token_source INTO ls_tokens_source
                                              INDEX l_tabix.
                    IF sy-subrc = 0.
                      IF ls_tokens_source-str EQ 'DATA'.
                        l_tabix = l_tabix + 2.
* Clear the Work Area ls_tokens_source
                        CLEAR ls_tokens_source.
* Read The Internal Table l_i_token_source Using Index  l_tabix.
                        READ TABLE l_i_token_source INTO
ls_tokens_source
                             INDEX l_tabix.
                        IF sy-subrc = 0.
                          IF ls_tokens_source-str EQ 'TYPE'.
                            l_tabix = l_tabix + 1.
* Clear the Work Area ls_tokens_source.
                            CLEAR ls_tokens_source.

* Read The Internal Table l_i_token_source Using Index l_TABIX.
                            READ TABLE l_i_token_source
                                  INTO ls_tokens_source INDEX l_tabix.
                            IF sy-subrc = 0.
                              IF ls_tokens_source-str CP '*-*'.
                                SPLIT ls_tokens_source-str AT '-'
                                                    INTO l_tabname
                                                         l_fname.
* Read the description of field
                                CALL FUNCTION 'DDIF_FIELDINFO_GET'
                                  EXPORTING
                                    tabname        = l_tabname
                                    fieldname      = l_fname
                                    langu          = sy-langu
                                  TABLES
                                    dfies_tab      = l_i_desc
                                  EXCEPTIONS
                                    not_found      = 1
                                    internal_error = 2
                                    OTHERS         = 3.
                                IF sy-subrc = 0.
* Clear the Local Work Area Ls_DESC.
                                  CLEAR ls_desc.
* Read The Internal Table l_i_DESC.
                                  READ TABLE l_i_desc INTO ls_desc
                                  INDEX 1.
                                  IF sy-subrc = 0.
                                    ls_selection-zzfldtyp = l_fname.
                                  ENDIF.
                                ENDIF.
                              ELSE.
                                ls_selection-zzfldtyp
                                               = ls_tokens_source-str.
                              ENDIF.
                            ENDIF.
                          ENDIF.
                        ENDIF.
                      ENDIF.
                    ENDIF.
                  ENDIF.
                ELSE.
                  l_index_inc = l_index_inc - 1.
                ENDIF.
              ENDWHILE.
            ENDIF.
          ENDIF.
* For Obligatory
          WHILE ( l_start_row LT l_end_row ).
            l_index_t = l_index_t + 1.
* Read Table l_i_tokens Using l_INDEX_T.
            READ TABLE l_i_tokens INTO ls_tokens INDEX l_index_t.
            IF sy-subrc EQ 0 .
* For Obligatory
              IF ls_tokens-str = 'OBLIGATORY'.
                l_mandate = 'X'.
                ls_selection-zzselcmt = 'Mandatory'.
* For Default
              ELSEIF ls_tokens-str = 'DEFAULT'.
                l_tabix_1 = sy-tabix + 1.
* Read Table l_i_tokens Using l_TABIX_1.
                READ TABLE l_i_tokens INTO ls_tokens INDEX l_tabix_1.
                IF sy-subrc EQ 0.
                  ls_selection-zzdefval = ls_tokens-str.
                ENDIF.
              ELSEIF ls_tokens-str = 'RADIOBUTTON'.
                ls_selection-zzfldtyp = 'Radio-Button'(107).
              ELSEIF ls_tokens-str = 'CHECKBOX'.
                ls_selection-zzfldtyp = 'Check-Box'(108).
* When a field is commented with NO-DISPLAY, the field will be hidden
              ELSEIF ls_tokens-str = 'NO-DISPLAY'.
                CLEAR ls_selection.
                EXIT.
              ENDIF.
            ENDIF.
            l_start_row = l_start_row + 1.
          ENDWHILE.

          IF NOT ls_selection IS INITIAL.
* For optional
            IF l_mandate = space.
              ls_selection-zzselcmt = 'Optional'(023).
              CLEAR l_mandate.
            ENDIF.
* Populate the comment field
            IF NOT ls_selection-zzselcmt IS INITIAL.
              CONCATENATE ls_selection-zzselcmt
                          'Single Selection'(105)
                     INTO ls_selection-zzselcmt
                     SEPARATED BY '-'.
            ELSE.
              ls_selection-zzselcmt = 'Single Selection'(105).
            ENDIF.
          ENDIF.
* For default value
          IF ls_selection-zzdefval IS INITIAL
            AND NOT ls_selection IS INITIAL.
* For default value
            ls_selection-zzdefval = c_na.
          ENDIF.
* When ls_selection Contain Records.
          IF NOT ls_selection IS INITIAL.
            APPEND ls_selection TO l_i_selscr_det.
            l_counter = l_counter - 1.
* Clear Work Area ls_selection.
            CLEAR ls_selection.
          ENDIF.
      ENDCASE.
    ENDLOOP.
* Populate the final internal table
    IF NOT l_i_selscr_det[] IS INITIAL.
      APPEND LINES OF l_i_selscr_det TO i_selection.
      REFRESH l_i_selscr_det.
    ENDIF.
* End of Main Loop
  ENDLOOP.
* Get the selection field description from the textpool
  READ TEXTPOOL l_in_prog_name
                  INTO l_i_prog_texts.
  DELETE l_i_prog_texts WHERE id <> 'S'.
  SORT l_i_prog_texts BY key.

* Populate the field description
  LOOP AT i_selection INTO ls_selection.
    READ TABLE l_i_prog_texts INTO ls_prog_texts
                WITH KEY key = ls_selection-zzfldnme
                BINARY SEARCH.
    IF sy-subrc = 0.
      IF ls_prog_texts-entry IS NOT INITIAL.
        SHIFT ls_prog_texts-entry LEFT DELETING LEADING space.
        ls_selection-zzflddes = ls_prog_texts-entry+0(60).
        SHIFT ls_selection-zzflddes LEFT DELETING LEADING space.
        MODIFY i_selection FROM ls_selection.
      ELSE.
        ls_selection-zzflddes = 'Not Maintained in Selection Text'(109).
        MODIFY i_selection FROM ls_selection.
      ENDIF.
    ELSE.
      ls_selection-zzflddes = 'Not Maintained in Selection Text'(109).
      MODIFY i_selection FROM ls_selection.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " SUB_GET_SEL_INFO
*&---------------------------------------------------------------------*
*&      Form  SUB_PCODE_GET_EVENT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_I_PSEUDO_CD_TAB[]  text
*      -->P_L_EV_CODE  text
*----------------------------------------------------------------------*
FORM sub_pcode_get_event TABLES l_i_pseudo_cd_tab
                                l_i_bold_tab
                          USING l_ev_code TYPE char2.

  DATA:
       l_wa_pseudo_cd TYPE x_clipbrd.

  CASE l_ev_code.
    WHEN 01.
      l_wa_pseudo_cd-line = 'INITIALIZATION'.
    WHEN 02.
      l_wa_pseudo_cd-line = 'START-OF-SELECTION'.
    WHEN 03.
      l_wa_pseudo_cd-line = 'AT SELECTION-SCREEN'.
    WHEN 04.
      l_wa_pseudo_cd-line = 'END-OF-SELECTION'.
    WHEN 05.
      l_wa_pseudo_cd-line = 'AT SELECTION-SCREEN OUTPUT'.
    WHEN 06.
      l_wa_pseudo_cd-line = 'TOP-OF-PAGE'.
    WHEN 07.
      l_wa_pseudo_cd-line = 'END-OF-PAGE'.
    WHEN 08.
      l_wa_pseudo_cd-line = 'AT LINE-SELECTION'.
    WHEN 09.
      l_wa_pseudo_cd-line = 'AT PF-STATUS'.
    WHEN 10.
      l_wa_pseudo_cd-line = 'AT USER-COMMAND'.
  ENDCASE.

  APPEND l_wa_pseudo_cd TO l_i_pseudo_cd_tab[].
  APPEND INITIAL LINE TO l_i_pseudo_cd_tab[].

  l_wa_pseudo_cd-flg = 'X'.

  APPEND l_wa_pseudo_cd TO l_i_bold_tab.

ENDFORM.                    " SUB_PCODE_GET_EVENT
*&---------------------------------------------------------------------*
*&      Form  SUB_GET_SEARCH_HELP_INFO
*&---------------------------------------------------------------------*
*       Subroutine for populating Search Help Info
*----------------------------------------------------------------------*
*      -->P_I_PARAM   Table for details
*      -->P__SRCHHELP Search Help Name
*      <--P_WA_DESC   Description of the search help
*----------------------------------------------------------------------*
FORM sub_get_search_help_info TABLES p_i_param STRUCTURE wa_help_info
                               USING p_srchhelp TYPE shlpname
                            CHANGING p_wa_desc TYPE x_help_desc.

  TYPES :
  BEGIN OF x_dd30l_dd30t,
    shlpname  TYPE shlpname,    "Name of search help
    ddtext    TYPE ddtext,      "Description
    hotkey    TYPE ddshhotkey,  "Hot key
    selmethod TYPE selmethod,   "Selection method
* BOC Chandrani 07/31/2009
   selmexit  TYPE ddshselext,  "Search help exit
* EOC Chandrani 07/31/2009
    dialogtype TYPE ddshdiatyp, "Dialog type
  END OF x_dd30l_dd30t,

  BEGIN OF x_dd32s,
    fieldname  TYPE shlpfield,  "Name of a search help parameter
    flposition TYPE sfposition, "Position of a search help field
    shlpinput  TYPE shlpinput,  " IMPORT Parameters for Search Help
    shlpoutput TYPE shlpoutput, " EXPORT Parameters
    rollname   TYPE shlpsparde, "Assigned data element
    defaultval TYPE ddshdefval, "Default value for a search help
                                "parameter
    datatype   TYPE datatype_d, "Data Type in ABAP Dictionary
    leng       TYPE ddleng,     "Length (No. of Characters)
  END OF x_dd32s.

  DATA: l_wa_dd30l_dd30t TYPE x_dd30l_dd30t,
        l_wa_dd32s       TYPE x_dd32s,
        l_i_dd32s        TYPE STANDARD TABLE OF x_dd32s,
        l_wa_parameter   TYPE x_help_info,
        l_i_tab          TYPE STANDARD TABLE OF dfies,
        wa_dfies_tab     LIKE LINE OF l_i_tab.

* Retrieve description details
  SELECT SINGLE a1~shlpname    "Search help name
                a2~ddtext      "text
                a1~hotkey      "Hot key
                a1~selmethod   "Selection method
* BOC Chandrani 07/31/2009
                a1~selmexit     "Search help exit
* EOC Chandrani 07/31/2009
                a1~dialogtype  "Dialog type
   FROM dd30l AS a1 INNER JOIN dd30t AS a2
   ON a1~shlpname =  a2~shlpname
   INTO l_wa_dd30l_dd30t
   WHERE a1~shlpname = p_srchhelp
   AND   a1~as4local = 'A'
   AND   a2~ddlanguage = 'E'.

* Retrieve data from DD32S
  SELECT fieldname      "Name of a search help parameter
         flposition     "Position of a search help field
         shlpinput      "Import parameter
         shlpoutput     "EXPORT Parameters
         rollname       "Assigned data element
         defaultval     "Default value
         datatype       "Data Type
         leng           "Length
  FROM dd32s
  INTO TABLE l_i_dd32s
  WHERE shlpname = p_srchhelp
  AND   as4local = 'A'.

* Sort the table accprding to the position of fields
  SORT l_i_dd32s BY flposition.

* Populate into the structure
  p_wa_desc-shlpname = l_wa_dd30l_dd30t-shlpname.
  p_wa_desc-description = l_wa_dd30l_dd30t-ddtext.
  p_wa_desc-hotkey = l_wa_dd30l_dd30t-hotkey.
  p_wa_desc-text = l_wa_dd30l_dd30t-ddtext.
  p_wa_desc-sel_method = l_wa_dd30l_dd30t-selmexit.
  p_wa_desc-dialogtype = l_wa_dd30l_dd30t-dialogtype.
  p_wa_desc-dev_type = 'New object'(048).

* Populate the table
  LOOP AT l_i_dd32s INTO l_wa_dd32s.
    l_wa_parameter-fieldname = l_wa_dd32s-fieldname.
*   For import
    IF l_wa_dd32s-shlpinput = 'X'.
      l_wa_parameter-import_export = 'I'.
    ENDIF.
    IF l_wa_dd32s-shlpoutput = 'X'.
      IF l_wa_dd32s-shlpinput = 'X'.
        CONCATENATE l_wa_parameter-import_export
                  ','
                  'E'
        INTO l_wa_parameter-import_export.
      ELSE.
        l_wa_parameter-import_export = 'E'.
      ENDIF.
    ENDIF.

    l_wa_parameter-dataelement = l_wa_dd32s-rollname.
    l_wa_parameter-datatype = l_wa_dd32s-datatype.
    l_wa_parameter-length = l_wa_dd32s-leng.
    SHIFT l_wa_parameter-length LEFT DELETING LEADING '0'.
    l_wa_parameter-default_value = l_wa_dd32s-defaultval.

*   Get the description and key field
    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = l_wa_dd30l_dd30t-selmethod
        fieldname      = l_wa_dd32s-fieldname
        langu          = sy-langu
      TABLES
        dfies_tab      = l_i_tab
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.
    IF sy-subrc = 0.
*     get the description
      READ TABLE l_i_tab INTO wa_dfies_tab INDEX 1.
      IF sy-subrc = 0.
        l_wa_parameter-description = wa_dfies_tab-fieldtext.
        IF wa_dfies_tab-keyflag = 'X'.
          l_wa_parameter-key = 'Y'.
        ELSE.
          l_wa_parameter-key = 'N'.
        ENDIF.
      ENDIF.
    ENDIF.
    APPEND l_wa_parameter TO p_i_param.
    CLEAR l_wa_parameter.
  ENDLOOP.
ENDFORM.                    " SUB_GET_SEARCH_HELP_INFO
*&---------------------------------------------------------------------*
*&      Form  SUB_MAKE_HEADER_SHAD
*&---------------------------------------------------------------------*
*       Subroutine for table header shading
*----------------------------------------------------------------------*
*      -->P_ACTDOC  OLE Activ object
*      -->P_len     length for shading
*----------------------------------------------------------------------*
FORM sub_make_header_shad USING p_actdoc     TYPE ole2_object
                                value(p_len) TYPE c.
  DATA :
  l_appl         TYPE ole2_object,
  l_sele         TYPE ole2_object,
  l_gs_pformat   TYPE ole2_object,
  l_shad         TYPE ole2_object,
  l_font         TYPE ole2_object,
  l_rc           TYPE i.


  GET PROPERTY OF p_actdoc 'Application' = l_appl.
  GET PROPERTY OF l_appl 'Selection' = l_sele.
  CALL METHOD OF l_sele 'MoveRight' = l_rc
    EXPORTING
    #1 = '1'
    #2 = p_len
    #3 = '1'.

  GET PROPERTY OF l_sele 'Font' = l_font.
  SET PROPERTY OF l_font 'Bold' = '1'.
  SET PROPERTY OF l_font 'Italic' = '1'.

  PERFORM sub_do_shading USING l_sele.
** Shading
*  GET PROPERTY OF l_sele 'Shading' = l_shad.
*  SET PROPERTY OF l_shad 'Texture' = '0' .
*  SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216' .
*  SET PROPERTY OF l_shad 'BackgroundPatternColor' = '14277081' .

* Centre allignment
  GET PROPERTY OF l_sele 'ParagraphFormat' = l_gs_pformat.
  SET PROPERTY OF l_gs_pformat 'Alignment' = '1'.
  FREE OBJECT : l_sele, l_appl, l_font, l_gs_pformat, l_shad.
ENDFORM.                    " SUB_MAKE_HEADER_SHAD

*&---------------------------------------------------------------------*
*&      Form  sub_populate_settings_screen
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_populate_settings_screen .

  CALL SELECTION-SCREEN 2000 STARTING AT 2 2 ENDING AT 90 15.

ENDFORM.                    " sub_populate_settings_screen
*&---------------------------------------------------------------------*
*&      Form  sub_populate_utp
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_V_ACTDOC  text
*      -->P_V_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_populate_utp  USING  p_v_actdoc TYPE ole2_object
                              p_v_selection TYPE ole2_object.

  TYPES :  BEGIN OF x_source_code,
             line       TYPE char200,
           END OF x_source_code,
           BEGIN OF x_code,
             line(1000) TYPE c,
           END OF x_code.

  DATA:
        l_in_p_prog TYPE progname,
        l_in_end_index TYPE sytabix,
        l_in_start_index TYPE sytabix.


* Get report deatils
  READ REPORT p_scr2 INTO i_source.
* Get the the program flow
  PERFORM logical_flow_program.

  l_in_p_prog      = p_scr2.
  l_in_start_index = p_from2.
  l_in_end_index   = p_to2.

  IF i_selection[] IS INITIAL.
    PERFORM sub_get_sel_info.
  ENDIF.

  IF p_msg IS INITIAL.
    PERFORM sub_z_get_prog_msg_info
                    USING
                       l_in_p_prog
                       l_in_start_index
                       l_in_end_index
                       ''
                    CHANGING
                       i_errmsg.
  ELSE.
    i_errmsg[] = i_msg_info[].
  ENDIF.


* Get Program transaction
  SELECT SINGLE tcode
  INTO v_transaction
  FROM tstc
  WHERE pgmna = l_in_p_prog.
  IF sy-subrc = 0.
    CONCATENATE 'Execute the transaction:'(185) v_transaction
            INTO v_execute SEPARATED BY space.
  ELSE.
    CONCATENATE 'Execute the program:'(186) l_in_p_prog
            INTO v_execute SEPARATED BY space.
  ENDIF.
* Get executor details
  SELECT SINGLE *
  INTO wa_usrdtl
  FROM user_addr
  WHERE bname = sy-uname.
  IF sy-subrc = 0.
    l_datum = sy-datum.
    CONCATENATE l_datum+4(2) '/' l_datum+6(2) '/' l_datum+0(4)
           INTO l_datum.
    CONCATENATE wa_usrdtl-name_first wa_usrdtl-name_last l_datum
    INTO v_exeby SEPARATED BY space.
  ENDIF.


* Populate the internal table for the UTP
  PERFORM sub_utp_details.

  DATA:
       l_v_tables TYPE ole2_object,
       l_v_range  TYPE ole2_object,
       l_v_table  TYPE ole2_object,
       l_v_table_border TYPE ole2_object,
       l_pos      TYPE ole2_object,
       l_v_line   TYPE i,

*************
       l_v_pgsetup TYPE ole2_object,
       l_v_font    TYPE ole2_object.

* Populate one text
  CALL METHOD OF p_v_selection 'TypeText'
    EXPORTING
    #1 = 'Unit Test Plan'(142).
  CALL METHOD OF p_v_selection 'TypeParagraph'.
  CALL METHOD OF p_v_selection 'TypeParagraph'.


* Set font style and size
  GET PROPERTY OF p_v_selection 'Font' = l_v_font.
  SET PROPERTY OF l_v_font 'Size' = p_font_s.               "'10'.
  SET PROPERTY OF l_v_font 'Name' = p_font_n."'Arial'.

* Inserting table for header details
* Inserting a table and filling some of its cells.
  GET PROPERTY OF p_v_actdoc 'Tables' = l_v_tables.
  GET PROPERTY OF p_v_selection 'Range' = l_v_range .

*  l_v_line = LINES( i_errmsg_utp ).
  DESCRIBE TABLE i_errmsg_utp LINES l_v_line.

  l_v_line = l_v_line + 1.

  CALL METHOD OF l_v_tables 'Add' = l_v_table
  EXPORTING
  #1 = l_v_range
  #2 = l_v_line     "Number of rows
  #3 = '8'.    "Number of columns

*--Setting border attribute for the table
  GET PROPERTY OF l_v_table 'Borders' = l_v_table_border.
  SET PROPERTY OF l_v_table_border 'Enable' = '1' . "With border
  SET PROPERTY OF l_v_table_border 'OutsideLineWidth' = '12'. "With
  CLEAR : wa_clipbrd, i_clipbrd[].

  CONCATENATE 'Test Condition'(177)
              'Step'(178)
              'Step Description'(179)
              'Test Data'(180)
              'Expected Result'(181)
              'Actual Result'(182)
              'Executed By/Date'(183)
              'Remarks'(184)
              INTO wa_clipbrd-line SEPARATED BY c_separator.
  APPEND wa_clipbrd TO i_clipbrd.
  CLEAR wa_clipbrd.


  LOOP AT i_errmsg_utp INTO wa_errmsg_utp.

    CONCATENATE wa_errmsg_utp-condition
                wa_errmsg_utp-steps
                wa_errmsg_utp-stepdsc
                wa_errmsg_utp-tstdata
                wa_errmsg_utp-orgmsg
                wa_errmsg_utp-expresult
                wa_errmsg_utp-exebydt
                wa_errmsg_utp-remarks
                INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.
  ENDLOOP.

  PERFORM sub_paste_from_clipboard USING l_v_table.

  PERFORM sub_make_header_shad USING p_v_actdoc
                                     '22'.

* Advancing the cursor to the end of the table
  GET PROPERTY OF l_v_table 'Range' = l_v_range.
  GET PROPERTY OF l_v_range 'End' = l_pos .
  SET PROPERTY OF l_v_range 'Start' = l_pos .

* Selects the specified object
  CALL METHOD OF l_v_range 'Select' .

* For 1 line gap
  CALL METHOD OF p_v_selection 'TypeParagraph'.


ENDFORM.                    " sub_populate_utp
*&---------------------------------------------------------------------*
*&      Form  LOGICAL_FLOW_PROGRAM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM logical_flow_program .
  TYPES: BEGIN OF x_keywords1,
             line(20),
         END OF x_keywords1.
  DATA: l_i_keywords1 TYPE STANDARD TABLE OF x_keywords1 INITIAL SIZE 0,
        ls_keywords1 TYPE x_keywords1.
  DATA incl_flag.
  DATA: BEGIN OF i_subroutine OCCURS 0,
            form(30) TYPE c,
        END OF i_subroutine.

  DATA prog LIKE sy-repid.          "Current main program

  DATA: t_tokens     LIKE stoken OCCURS 0 WITH HEADER LINE,
        t_tokens1    LIKE stoken OCCURS 0 WITH HEADER LINE,
        t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE,
        source_temp  LIKE source_main OCCURS 0 WITH HEADER LINE,
        source_incl  LIKE source_main OCCURS 0 WITH HEADER LINE.

  DATA: l_start_row TYPE stoken-row,
        l_end_row   TYPE stoken-row,
        l_str1      TYPE stoken-str,
        l_subrou    TYPE char255,
        l_subrou1   TYPE char255,
        l_line      TYPE i,
        l_text      TYPE char255,
        l_from      TYPE sstmnt-from,
        l_to        TYPE sstmnt-to,
        l_string    TYPE char30,
        l_tabix     TYPE sy-tabix.

  source_main[] = i_source[].
  t_keywords = 'INCLUDE'.       APPEND t_keywords.
  DO.
    SCAN ABAP-SOURCE i_source STATEMENTS INTO t_statements
                         TOKENS INTO t_tokens
                         KEYWORDS   FROM t_keywords .
    READ TABLE t_tokens INDEX 2.
    IF sy-subrc = 0.
      prog = t_tokens-str.
      READ TABLE t_statements WITH KEY FROM = 1.
      REFRESH source_incl.
      READ REPORT t_tokens-str INTO source_incl.
      PERFORM populate_lineno TABLES source_incl.
      IF t_statements-terminator = '.'.
        IF incl_flag NE 'X'.
          APPEND LINES OF source_incl TO source_temp.
          t_tokens-row = t_tokens-row + 1.
          INSERT lines of source_temp
                            INTO i_source INDEX  t_tokens-row.
          INSERT lines of source_temp
                           INTO source_main INDEX  t_tokens-row.
          t_tokens-row = t_tokens-row - 1.
          DELETE i_source INDEX t_tokens-row.
          DELETE source_main INDEX t_tokens-row.
        ELSE.
          APPEND LINES OF source_incl TO source_temp.
          i_source-line = space.
          MODIFY i_source INDEX t_tokens-row TRANSPORTING line.
          source_main-line = space.
          MODIFY source_main INDEX t_tokens-row TRANSPORTING line.
          INSERT lines of source_temp
                            INTO i_source INDEX  t_tokens-row.
          INSERT lines of source_temp
                           INTO source_main INDEX  t_tokens-row.
        ENDIF.
        REFRESH:
          source_temp.
      ELSEIF t_statements-terminator = ','.
        IF incl_flag NE 'X'.
          incl_flag = 'X'.
          l_start_row = t_tokens-row.
        ENDIF.
        APPEND LINES OF source_incl TO source_temp.
        i_source-line = space.
        MODIFY i_source INDEX t_tokens-row TRANSPORTING line.
        source_main-line = space.
        MODIFY source_main INDEX t_tokens-row TRANSPORTING line.
        t_tokens-row = t_tokens-row + 1.
        READ TABLE i_source INDEX t_tokens-row.
        CONCATENATE 'INCLUDE:' i_source-line INTO i_source-line.
        MODIFY i_source INDEX t_tokens-row TRANSPORTING line .
        source_main-line = i_source-line.
        MODIFY source_main INDEX t_tokens-row TRANSPORTING line .
      ENDIF.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.
  source_main-program = p_scr2.
  MODIFY source_main TRANSPORTING program WHERE program IS INITIAL .
  REFRESH t_keywords.
  t_keywords = 'PERFORM'.       APPEND t_keywords.
  ls_keywords1 = 'FORM'.
  APPEND ls_keywords1 TO l_i_keywords1.
  ls_keywords1 = 'ENDFORM'.
  APPEND ls_keywords1 TO l_i_keywords1.
  DO.
    SCAN ABAP-SOURCE i_source STATEMENTS INTO t_statements
                                  TOKENS INTO t_tokens
                                  KEYWORDS FROM t_keywords .
    READ TABLE t_tokens INDEX 2.
    IF sy-subrc = 0.
      l_str1 = t_tokens-str.
      SCAN ABAP-SOURCE i_source
                          STATEMENTS INTO t_statements
                          TOKENS       INTO t_tokens1
                          KEYWORDS   FROM l_i_keywords1.
      READ TABLE t_tokens1 WITH KEY
          str = t_tokens-str.
      CLEAR: l_subrou,
              l_subrou1.
      l_subrou = t_tokens-str.
      l_subrou1 = t_tokens-str.
      l_tabix = sy-tabix - 1.
      READ TABLE t_statements WITH KEY FROM = l_tabix.
      l_from = t_statements-from + 2.
      l_to = t_statements-to.
      IF l_to > l_from.
        LOOP AT t_tokens1 FROM l_from TO l_to.
          l_string = t_tokens1-str.
          CONCATENATE l_subrou l_string INTO l_subrou
                                SEPARATED BY space.
          CLEAR l_string.
        ENDLOOP.
      ENDIF.
      IF sy-subrc = 0.
        l_start_row = t_tokens1-row + 1.
        DELETE t_tokens1 WHERE row <= l_start_row OR
                      str <> 'ENDFORM'.
        READ TABLE t_tokens1 INDEX 1.
        IF sy-subrc = 0.
          l_end_row = t_tokens1-row - 1.
          t_tokens-row = t_tokens-row + 1.
          INSERT lines of source_main FROM l_start_row TO l_end_row
              INTO TABLE source_temp.
          CONCATENATE 'CALL' 'SUBROUTINE' l_subrou '.'
                 INTO l_text SEPARATED BY space.
          READ TABLE source_temp INDEX 1.
          source_temp-line = l_text.
          source_temp-program = source_main-program.
          INSERT source_temp INDEX 1.
          CLEAR l_text.
          DESCRIBE TABLE source_temp LINES l_line.
          READ TABLE source_temp INDEX l_line.
          CONCATENATE 'END' 'SUBROUTINE' l_subrou1 '.'
                 INTO l_text SEPARATED BY space.
          source_temp-line = l_text.
          source_temp-program = source_main-program.
          INSERT table source_temp.
          CLEAR: l_text,
                 l_line.
          LOOP AT source_temp.
            REFRESH i_subroutine.
            TRANSLATE source_temp TO UPPER CASE.
            SPLIT source_temp-line AT space
               INTO TABLE i_subroutine.
            DELETE i_subroutine WHERE form IS INITIAL.
            READ TABLE i_subroutine INDEX 1.
            CONDENSE i_subroutine-form.
            IF i_subroutine-form = 'PERFORM'.
              READ TABLE i_subroutine INDEX 2.
              IF sy-subrc = 0.
                IF i_subroutine-form CA '.'.
                  SPLIT i_subroutine-form AT '.' INTO i_subroutine-form
                                  l_str1.
                ENDIF.
                CONDENSE i_subroutine-form.
                IF i_subroutine-form = t_tokens-str.
                  CLEAR source_temp-line.
                  MODIFY source_temp.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDLOOP.
          INSERT lines of source_temp
                          INTO i_source INDEX  t_tokens-row.
          source_temp-form = t_tokens-str.
          MODIFY source_temp TRANSPORTING form WHERE form = ' '.
          CLEAR source_temp.
          INSERT lines of source_temp
                          INTO source_main INDEX  t_tokens-row.
          t_tokens-row = t_tokens-row - 1.
          DELETE i_source[] INDEX t_tokens-row.
          DELETE source_main INDEX t_tokens-row.
          REFRESH source_temp.
        ENDIF.
      ELSE.
        DELETE i_source[] INDEX t_tokens-row.
        DELETE source_main INDEX t_tokens-row.
      ENDIF.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.
  REFRESH:
    t_tokens1,
    t_statements.
  SCAN ABAP-SOURCE i_source[]
                        STATEMENTS INTO t_statements
                        TOKENS       INTO t_tokens1
                        KEYWORDS   FROM l_i_keywords1.
  READ TABLE t_tokens1 INDEX 1.
  IF sy-subrc = 0.
    l_start_row = t_tokens1-row.
  ENDIF.
  DELETE t_tokens1 WHERE str <> 'ENDFORM' AND str <> 'FORM'.
  LOOP AT t_tokens1.
    IF t_tokens1-str = 'FORM'.
      l_start_row = t_tokens1-row.
    ELSEIF t_tokens1-str = 'ENDFORM'.
      LOOP AT i_source FROM l_start_row TO t_tokens1-row.
        i_source-line = 'X'.
        MODIFY i_source.
      ENDLOOP.
      LOOP AT source_main FROM l_start_row TO t_tokens1-row.
        source_main-line = 'X'.
        MODIFY source_main.
      ENDLOOP.
      CLEAR: l_start_row,
             t_tokens1.
    ENDIF.
  ENDLOOP.
  DELETE i_source[] WHERE LINE = 'X'.
  DELETE source_main WHERE LINE = 'X'.
  i_code[] = i_source[].
ENDFORM.                    " LOGICAL_FLOW_PROGRAM
*&---------------------------------------------------------------------*
*&      Form  POPULATE_LINENO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_SOURCE_INCL  text
*----------------------------------------------------------------------*
FORM populate_lineno  TABLES source_incl STRUCTURE source_main.
  DATA: ls_source_incl LIKE LINE OF source_incl.
  LOOP AT source_incl INTO ls_source_incl.
    ls_source_incl-lineno = sy-tabix.
    MODIFY source_incl FROM ls_source_incl TRANSPORTING lineno.
  ENDLOOP.
  ls_source_incl-program = p_prog.
  MODIFY source_incl FROM ls_source_incl
              TRANSPORTING program WHERE program IS INITIAL.

ENDFORM.                    " POPULATE_LINENO

*&---------------------------------------------------------------------*
*&      Form  sub_utp_details
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM sub_utp_details .


* Structure Declaration.
  TYPES: BEGIN OF x_keywords1,
             line(20),
         END OF x_keywords1.
  DATA: l_i_keywords1 TYPE STANDARD TABLE OF x_keywords1 INITIAL SIZE 0,
        ls_keywords1 TYPE x_keywords1.

* Internal Table declaration.
  DATA:
        l_i_tokens_utp     TYPE STANDARD TABLE OF stoken INITIAL SIZE 0,
        l_i_statements_of  TYPE STANDARD TABLE OF sstmnt INITIAL SIZE 0,
        l_i_statements_utp TYPE STANDARD TABLE OF sstmnt INITIAL SIZE 0,
        l_i_errmsg         TYPE STANDARD TABLE OF x_errmsg
                                                         INITIAL SIZE 0,
        l_i_tokens_of      TYPE STANDARD TABLE OF stokex INITIAL SIZE 0,
        ls_errmsg          TYPE x_errmsg,
        ls_statements_utp  TYPE sstmnt,
        ls_tokens_of       TYPE stokex,
        ls_tokens_utp      TYPE stoken.

* Data declaration
  DATA: l_count       TYPE i,
        l_flag        TYPE c ,
        l_string      TYPE string,
        l_string1     TYPE string,
        l_string_utp  TYPE string,
        l_cond        TYPE string,
        l_from        TYPE sstmnt-from,
        l_to          TYPE sstmnt-to,
        l_tabix       TYPE sy-tabix,
        l_msg_str     TYPE token_str,
        l_fdpos       TYPE syfdpos,
        l_quote       TYPE char1 VALUE '''',
        l_r_msgtyp    TYPE RANGE OF char10 WITH HEADER LINE.

  l_r_msgtyp-sign = 'I'.
  l_r_msgtyp-option = 'EQ'.
  l_r_msgtyp-low = '''I'''.
  APPEND l_r_msgtyp.
  l_r_msgtyp-low = '''E'''.
  APPEND l_r_msgtyp.
  l_r_msgtyp-low = '''W'''.
  APPEND l_r_msgtyp.
  l_r_msgtyp-low = '''S'''.
  APPEND l_r_msgtyp.
  l_r_msgtyp-low = '''A'''.
  APPEND l_r_msgtyp.
  l_r_msgtyp-low = '''X'''.
  APPEND l_r_msgtyp.

* Sort The Internal Table T_ERRMSG by Field ERRNO,ERRMSg.
  l_i_errmsg[] = i_errmsg[].
  SORT l_i_errmsg BY msgno msg.
* Delete Duplicate entries from Internal Table I_ERRMSG Comparing
* ERROR NUMBER and ERRMSG.
  DELETE ADJACENT DUPLICATES FROM l_i_errmsg COMPARING msgno msg.
  ls_keywords1 = 'AT'.
  APPEND ls_keywords1 TO l_i_keywords1.
  ls_keywords1 = 'START-OF-SELECTION'.
  APPEND ls_keywords1 TO l_i_keywords1.
  ls_keywords1 = 'END-OF-SELECTION'.
  APPEND ls_keywords1 TO l_i_keywords1.
  ls_keywords1 = 'MESSAGE'.
  APPEND ls_keywords1 TO l_i_keywords1.
  SCAN ABAP-SOURCE i_code STATEMENTS INTO l_i_statements_utp
                        TOKENS INTO l_i_tokens_utp
                        KEYWORDS FROM l_i_keywords1
                        WITH INCLUDES.
  LOOP AT l_i_tokens_utp INTO ls_tokens_utp.
    l_msg_str = ls_tokens_utp-str.
    IF ls_tokens_utp-str = 'AT'.
      l_count = 1.
      READ TABLE l_i_statements_utp INTO ls_statements_utp
                                WITH KEY FROM = sy-tabix.
      IF sy-subrc = 0.
        l_from = ls_statements_utp-from .
        l_to = ls_statements_utp-to.
        LOOP AT l_i_tokens_utp INTO ls_tokens_utp
           FROM l_from TO l_to.
          IF ls_tokens_utp-str = 'SELECTION-SCREEN'.
            l_flag = 'A'.
            l_tabix = sy-tabix + 1.
            READ TABLE l_i_tokens_utp INTO ls_tokens_utp
                 INDEX l_tabix.
            CLEAR l_tabix.
            IF ls_tokens_utp-str = 'ON'.
              CLEAR l_flag.
              l_flag = 'B'.
              l_tabix = sy-tabix + 1.
              READ TABLE l_i_tokens_utp INTO ls_tokens_utp
                   INDEX l_tabix.
              READ TABLE i_selection
              INTO w_selection WITH KEY name = ls_tokens_utp-str.
              IF sy-subrc = 0.
                l_string_utp = w_selection-desc.
              ELSE.
                l_string_utp = ls_tokens_utp-str.
              ENDIF.
              CONCATENATE 'Check for the Valid'(176)  l_string_utp
                     INTO l_cond SEPARATED BY space.
              CLEAR l_string_utp.
              CLEAR l_tabix.
              wa_errmsg_utp-condition = l_cond.
              CLEAR: l_cond.
            ELSE.
              CLEAR l_string_utp.
              CONCATENATE 'Validation on Selection Screen'(172)
                          l_string_utp INTO l_cond SEPARATED BY space.
              CLEAR l_tabix.
              wa_errmsg_utp-condition = l_cond.
            ENDIF.
          ENDIF.
          IF ls_tokens_utp-str = 'LINE-SELECTION'
            OR ls_tokens_utp-str = 'USER-COMMAND'.
            CLEAR l_flag.
            l_flag = 'Z'.
          ENDIF.
          IF ls_tokens_utp-str = 'OUTPUT'.
            CLEAR l_flag.
            l_flag = 'A'.
          ENDIF.
          IF l_flag = 'Z'.
            l_count = 1.
            CLEAR l_string_utp.
            CONCATENATE 'Interactive list event processing'(175)
                        l_string_utp INTO l_cond SEPARATED BY space.
            CLEAR l_tabix.
            wa_errmsg_utp-condition = l_cond.
          ENDIF.
          IF l_flag = 'A'.
            CLEAR l_string_utp.
            CONCATENATE 'Validation on Selection Screen'(172)
                        l_string_utp INTO l_cond SEPARATED BY space.
            CLEAR l_tabix.
            wa_errmsg_utp-condition = l_cond.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
    IF ls_tokens_utp-str = 'START-OF-SELECTION'.
      CLEAR l_flag.
      l_flag = 'X'.
    ENDIF.
    IF ls_tokens_utp-str = 'END-OF-SELECTION'.
      CLEAR l_flag.
      l_flag = 'Y'.
    ENDIF.

    IF l_flag = 'X'.
      CLEAR l_string_utp.
      l_count = 1.
      CONCATENATE 'Data Processing Error'(174) l_string_utp INTO l_cond
    SEPARATED BY space.
      wa_errmsg_utp-condition = l_cond.
      CLEAR l_cond.
    ENDIF.

    IF l_flag = 'Y'.
      CLEAR l_string_utp.
      l_count = 1.
      CONCATENATE 'Output Processing Error'(173) l_string_utp
             INTO l_cond SEPARATED BY space.
      wa_errmsg_utp-condition = l_cond.
      CLEAR l_cond.
    ENDIF.

    IF l_flag = 'A'.
      CLEAR l_string_utp.
      CONCATENATE 'Validation on Selection Screen'(172)  l_string_utp
             INTO l_cond SEPARATED BY space.
      CLEAR l_tabix.
      wa_errmsg_utp-condition = l_cond.
    ENDIF.

    IF l_msg_str = 'MESSAGE'.
      CLEAR l_count.
      READ TABLE l_i_statements_utp INTO ls_statements_utp
        WITH KEY FROM = sy-tabix.
      IF sy-subrc = 0.
        l_from = ls_statements_utp-from.
        l_to = ls_statements_utp-to.
        LOOP AT l_i_tokens_utp INTO ls_tokens_utp
           FROM l_from TO l_to.
          IF ls_tokens_utp-ovfl = 'X'.
            SCAN ABAP-SOURCE i_code STATEMENTS INTO l_i_statements_of
                                     TOKENS    INTO l_i_tokens_of
                                               FROM ls_tokens_utp-row
                                               TO   ls_tokens_utp-row
                                     WITH ANALYSIS.
            LOOP AT l_i_tokens_of INTO ls_tokens_of
                                 WHERE type = 'S' OR str = 'SPACE'.
              IF ls_tokens_of-ovfl = 'X'.
                READ TABLE i_code INTO w_code INDEX ls_tokens_of-row.
                IF sy-subrc = 0.
                  CLEAR wa_errmsg_utp-orgmsg.
                  REPLACE ALL OCCURRENCES OF '''''' IN w_code WITH '#'.
                  SEARCH w_code FOR l_quote.
                  IF sy-subrc = 0.
                    l_fdpos = sy-fdpos + 1.
                    w_code = w_code+l_fdpos.
                    SEARCH w_code FOR l_quote.
                    IF sy-subrc = 0.
                      l_fdpos = sy-fdpos.
                      w_code =
                              w_code+0(l_fdpos).
                    ENDIF.
                  ENDIF.
                  CONCATENATE l_string w_code
                         INTO l_string SEPARATED BY space.
                  l_string1 = l_string.
                  wa_errmsg_utp-orgmsg = l_string1.
                ENDIF.
              ELSE.
                IF ( ls_tokens_of-str+0(1) = l_quote
                  OR ls_tokens_of-str = 'SPACE' )
                  AND ls_tokens_of-str NOT IN l_r_msgtyp.
                  CLEAR wa_errmsg_utp-orgmsg.
                  SEARCH ls_tokens_of-str FOR l_quote.
                  IF sy-subrc = 0.
                    l_fdpos = sy-fdpos + 1.
                    ls_tokens_of-str = ls_tokens_of-str+l_fdpos.
                    SEARCH ls_tokens_of-str FOR l_quote.
                    IF sy-subrc = 0.
                      l_fdpos = sy-fdpos.
                      ls_tokens_of-str =
                            ls_tokens_of-str+0(l_fdpos).
                    ENDIF.
                  ENDIF.
                  CONCATENATE l_string ls_tokens_of-str
                         INTO l_string SEPARATED BY space.
                  l_string1 = l_string.
                  wa_errmsg_utp-orgmsg = l_string1.
                ENDIF.
              ENDIF.
            ENDLOOP.
            EXIT.
          ELSE.
            IF (  ls_tokens_utp-str+0(1) = l_quote
              OR  ls_tokens_utp-str = 'SPACE' )
              AND ls_tokens_of-str NOT IN l_r_msgtyp.
              CLEAR wa_errmsg_utp-orgmsg.
              SEARCH ls_tokens_utp-str FOR l_quote.
              IF sy-subrc = 0.
                l_fdpos = sy-fdpos + 1.
                ls_tokens_utp-str = ls_tokens_utp-str+l_fdpos.
                SEARCH ls_tokens_utp-str FOR l_quote.
                IF sy-subrc = 0.
                  l_fdpos = sy-fdpos.
                  ls_tokens_utp-str = ls_tokens_utp-str+0(l_fdpos).
                ENDIF.
              ENDIF.
              CONCATENATE l_string ls_tokens_utp-str
                     INTO l_string SEPARATED BY space.
              l_string1 = l_string.
              wa_errmsg_utp-orgmsg = l_string1.
            ENDIF.
          ENDIF.
        ENDLOOP.
        CLEAR l_string.
        CLEAR l_string1.
        IF l_count IS INITIAL .
          SHIFT wa_errmsg_utp-orgmsg LEFT DELETING LEADING space.
          REPLACE ALL OCCURRENCES OF '#' IN wa_errmsg_utp-orgmsg
                                       WITH ''''.
          READ TABLE l_i_errmsg INTO ls_errmsg
                          WITH KEY msg = wa_errmsg_utp-orgmsg.
          IF sy-subrc = 0.
            l_tabix = sy-tabix.
            wa_errmsg_utp-megtype = ls_errmsg-msg_type.
            IF ls_errmsg-msg_type = 'E'.
              CONCATENATE 'Error message like:'(169)
                          l_quote ls_errmsg-msg l_quote
                          ' is displayed.'(170)
              INTO wa_errmsg_utp-expresult.
            ENDIF.
            IF ls_errmsg-msg_type = 'I'.
              CONCATENATE 'Information message like:'(171)
                          l_quote ls_errmsg-msg l_quote
                          ' is displayed.'(170)
              INTO wa_errmsg_utp-expresult.
            ENDIF.
            MOVE v_steps TO wa_errmsg_utp-steps.
            wa_errmsg_utp-stepdsc = v_execute.
            wa_errmsg_utp-exebydt = v_exeby.
            DELETE l_i_errmsg INDEX l_tabix.
            CLEAR: ls_errmsg,
                   l_tabix.
            APPEND wa_errmsg_utp TO i_errmsg_utp.
            CLEAR: wa_errmsg_utp, l_string, l_string1.
            v_steps = v_steps + 1.
          ELSE.
* Do nothing
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " sub_utp_details

*&---------------------------------------------------------------------*
*&      Form  sub_validate_more_settings
*&---------------------------------------------------------------------*
*       Validating More Settings
*----------------------------------------------------------------------*
*       No Parameter
*----------------------------------------------------------------------*
FORM sub_validate_more_settings .

** Internal Table name
*  IF p_itab_d IS INITIAL.
*    MESSAGE e398 WITH
*    'Please enter Internal table starts with'(162)
*    'in More Settings'(199).
*  ENDIF.

** Local Internal Table name
*  IF p_i_loc IS INITIAL.
*    MESSAGE e398 WITH
*  'Please enter Local Internal table starts with'(163)
*  'in More Settings'(199).
*  ENDIF.

* Constant name
  IF p_const IS INITIAL.
    MESSAGE e398 WITH
    'Please enter Constant name starts with'(164)
    'in More Settings'(199).
  ENDIF.

* Range table name
  IF p_range IS INITIAL.
    MESSAGE e398 WITH
    'Please enter Range table starts with'(165)
    'in More Settings'(199).
  ENDIF.

* Select option name
  IF p_sel_op IS INITIAL.
    MESSAGE e398 WITH
    'Please enter Select Options starts with'(166)
    'in More Settings'(199).
  ENDIF.

* Parameter name
  IF p_param IS INITIAL.
    MESSAGE e398 WITH
    'Please enter Parameters starts with'(167)
    'in More Settings'(199).
  ENDIF.

*  IF s_itab_e[] IS INITIAL.
*    MESSAGE e398 WITH
*    'Please enter Internal table ends with'(168)
*    'in More Settings'(199).
*  ENDIF.

ENDFORM.                    " sub_validate_more_settings
*&---------------------------------------------------------------------*
*&      Form  sub_set_default_value_more
*&---------------------------------------------------------------------*
*       Set default values to parameters of More Settings screen
*----------------------------------------------------------------------*
*       No Parameter
*----------------------------------------------------------------------*
FORM sub_set_default_value_more .

  DATA:
       l_wa_itab_e LIKE LINE OF s_itab_e.

  p_font_n = 'Arial'.
  p_font_s = 10.
  p_itab_d = 'I_'.
  p_i_loc  = 'L_'.
  p_const  = 'C_'.
  p_range  = 'R_'.
  p_sel_op = 'S_'.
  p_param  = 'P_'.
  p_form_p = 'P_'.

  l_wa_itab_e-sign   = 'I'.
  l_wa_itab_e-option = 'EQ'  .
  l_wa_itab_e-low    = '_1'.

  APPEND l_wa_itab_e TO s_itab_e[].
  CLEAR:l_wa_itab_e.

  l_wa_itab_e-sign   = 'I'.
  l_wa_itab_e-option = 'EQ'  .
  l_wa_itab_e-low    = '_2'.

  APPEND l_wa_itab_e TO s_itab_e[].
  CLEAR:l_wa_itab_e.

  l_wa_itab_e-sign   = 'I'.
  l_wa_itab_e-option = 'EQ'  .
  l_wa_itab_e-low    = '_TEMP'.

  APPEND l_wa_itab_e TO s_itab_e[].
  CLEAR:l_wa_itab_e.

  l_wa_itab_e-sign   = 'I'.
  l_wa_itab_e-option = 'EQ'  .
  l_wa_itab_e-low    = '_TMP'.

  APPEND l_wa_itab_e TO s_itab_e[].
  CLEAR:l_wa_itab_e.

ENDFORM.                    " sub_set_default_value_more
*&---------------------------------------------------------------------*
*&      Form  sub_restrict_ranges
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*       No Parameter
*----------------------------------------------------------------------*
FORM sub_restrict_ranges .

  DATA:
      l_wa_opt_list   TYPE sscr_opt_list,   "Selection Option List
      l_restrict      TYPE sscr_restrict,   "Selection Option Restrict
      l_wa_ass        TYPE sscr_ass.        "Selection Screen Object

* Assigns value in restrict table
  CLEAR l_wa_opt_list.
  l_wa_opt_list-name = 'OBJECTKEY1'.              "Value 'EQ'

  l_wa_opt_list-options-bt = space.
  l_wa_opt_list-options-cp = space.
  l_wa_opt_list-options-eq = c_check.
  l_wa_opt_list-options-ge = space.
  l_wa_opt_list-options-gt = space.
  l_wa_opt_list-options-le = space.
  l_wa_opt_list-options-lt = space.
  l_wa_opt_list-options-nb = space.
  l_wa_opt_list-options-ne = space.
  l_wa_opt_list-options-np = space.

  APPEND l_wa_opt_list TO l_restrict-opt_list_tab.

  CLEAR l_wa_ass.
  l_wa_ass-kind = 'S'.                   "Value 'S'
  l_wa_ass-name = 'S_ITAB_E'.        "
  l_wa_ass-sg_main = 'I'.                "Value 'I'
  l_wa_ass-sg_addy = space.
  l_wa_ass-op_main = 'OBJECTKEY1'.                "Value 'EQ'

  APPEND l_wa_ass TO l_restrict-ass_tab.

* Calling Function Module to restrict Select-Option
  CALL FUNCTION 'SELECT_OPTIONS_RESTRICT'
    EXPORTING
      program                = sy-repid
      restriction            = l_restrict
    EXCEPTIONS
      too_late               = 1
      repeated               = 2
      selopt_without_options = 3
      selopt_without_signs   = 4
      invalid_sign           = 5
      empty_option_list      = 6
      invalid_kind           = 7
      repeated_kind_a        = 8
      OTHERS                 = 9.

ENDFORM.                    " sub_restrict_ranges

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_WA_STRUC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WORD  text
*      <--P_P_STRUCTURE  text
*----------------------------------------------------------------------*
FORM sub_get_wa_struc  CHANGING    p_word TYPE char255
                                   p_structure TYPE char100.

  DATA: l_wa_nodetab TYPE snodetext,
        l_cursor_line TYPE sytabix,
        l_opd   TYPE char1,
        l_word TYPE char255,
        l_wa_code  TYPE x_code,
        l_found TYPE char1,
        l_in_type TYPE char1,
        l_wa_code_info LIKE x_code_info.

  REPLACE ALL OCCURRENCES OF '.' IN p_word WITH space.
  REPLACE ALL OCCURRENCES OF ',' IN p_word WITH space.

  READ TABLE i_nodetab INTO l_wa_nodetab WITH KEY type = v_op_dd
                                              name = p_word
                                              BINARY SEARCH.

  IF sy-subrc = 0.
    READ TABLE i_code_info INTO l_wa_code_info
     WITH KEY name = l_wa_nodetab-hide.

    IF sy-subrc = 0.
    ELSE.
      READ REPORT l_wa_nodetab-hide INTO l_wa_code_info-code.
      l_wa_code_info-name = l_wa_nodetab-hide.
      INSERT l_wa_code_info INTO TABLE i_code_info.
    ENDIF.

    l_opd = 'D'.

    CALL FUNCTION 'RS_OBJECT_POSITION'
      EXPORTING
        object_name      = p_word  "I_KNVP
        object_type      = l_opd       "D/Y
      IMPORTING
        row              = l_cursor_line
      TABLES
        SOURCE           = l_wa_code_info-code
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.

    LOOP AT l_wa_code_info-code
    INTO l_wa_code FROM l_cursor_line.

      REPLACE ALL OCCURRENCES OF
      cl_abap_char_utilities=>horizontal_tab IN
      l_wa_code WITH '# #'.
      REPLACE ALL OCCURRENCES OF '#' IN l_wa_code WITH space.
      TRANSLATE l_wa_code-line TO UPPER CASE.

      DO.
        CLEAR l_word.
        PERFORM sub_first_word CHANGING l_wa_code
                                        l_word.
        IF l_word = space.
          EXIT.
        ENDIF.

        CASE l_word.
          WHEN 'TYPE'.
            l_in_type = 'X'.
          WHEN p_word.
          WHEN OTHERS.
            CASE 'X'.
              WHEN l_in_type.
                l_found = 'X'.
                p_structure = l_word.
                EXIT.
            ENDCASE.
        ENDCASE.

      ENDDO.

      IF l_found = 'X'.
        EXIT.
      ENDIF.

    ENDLOOP.

  ELSE.  "Its a global structure
    p_structure = p_word.
  ENDIF.

ENDFORM.                    " SUB_GET_WA_STRUC

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_TT_STRUC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_STRUCTURE  text
*      <--P_P_STRUCTURE  text
*----------------------------------------------------------------------*
FORM sub_get_tt_struc  USING    p_i_nodetab TYPE snodetab
                       CHANGING p_tt TYPE char100
                                p_structure TYPE char100.

  DATA: l_wa_nodetab TYPE snodetext,
        l_wa_code_info LIKE x_code_info.

  REPLACE ALL OCCURRENCES OF ',' IN p_tt WITH space.
  REPLACE ALL OCCURRENCES OF '.' IN p_tt WITH space.

  READ TABLE p_i_nodetab INTO l_wa_nodetab
    WITH KEY type = v_op_yy
             name = p_tt.

  IF sy-subrc = 0.
    READ TABLE i_code_info INTO l_wa_code_info
         WITH KEY name = l_wa_nodetab-hide.
  ENDIF.

ENDFORM.                    " SUB_GET_TT_STRUC



*&---------------------------------------------------------------------*
*&  Include           ZIBM_AUTOTS_SUBROUTINES_INCL
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  SUB_CAL_SPACE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*     No Parameter
*----------------------------------------------------------------------*
FORM sub_cal_space .

* Calling this metode a space is assigned to L_V_CHAR
  CALL METHOD cl_abap_char_utilities=>get_simple_spaces_for_cur_cp
    RECEIVING
      s_str = v_space.

ENDFORM.                    " SUB_CAL_SPACE

*&---------------------------------------------------------------------*
*&      Form  SUB_SCAN_CODE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_CODE_INFO_CODE  text
*      -->P_IN_START_INDEX  text
*      -->P_IN_END_INDEX  text
*----------------------------------------------------------------------*
FORM sub_scan_code  USING    p_source_name TYPE any
                             p_i_code      TYPE x_t_code
                             p_start_index TYPE sytabix
                             p_end_index   TYPE sytabix.

*Data Declarations

  DATA:
  l_wa_code         TYPE x_code,
  l_wa_code1        TYPE x_code,
  l_wa_code2        TYPE x_code,
  l_wa_code_caps    TYPE x_code,
  l_word            TYPE char255,
  l_word1           TYPE char255,
  l_tabix           TYPE sytabix,
  l_tabix1          TYPE sytabix,
  l_quote           TYPE char1 VALUE '''',
  l_i_dbtab         TYPE x_zdbtab_name_ty,
  l_wa_dbtab        TYPE x_zdbtab_name,
  l_i_link_fld      TYPE x_zwhere_field_name_ty,
  l_wa_fm_call_code TYPE x_zfm_call,
  l_wa_fm_call_info TYPE x_zfm_call_info,
  l_int_tab         TYPE char30,
  l_foe_tab         TYPE char30,
  l_db_no           TYPE i,
  l_i_code          TYPE x_t_code,
  l_i_fld           TYPE x_zfield_name_ty,
  l_i_join_fld      TYPE x_zfield_name_ty,
  l_i_op            TYPE x_zwhere_field_name_ty,
  l_op              TYPE char100,
  l_wa_method_call  TYPE x_method_call,
  l_form_name_old   TYPE seu_name,
  l_wa_select       TYPE x_zselect,
  l_wa_sub_call_info TYPE x_zperform_call_info,
  l_i_select        TYPE x_zselect_ty,
  l_start_position  TYPE sy-tabix,
  l_end_position    TYPE sy-tabix.

* Flags
  DATA:
  l_in_select       TYPE char1,
  l_in_field        TYPE char1 VALUE 'X',
  l_from            TYPE char1,
  l_in_class        TYPE char1,
  l_method_found    TYPE char1,
  l_in_call         TYPE char1,
  l_in_cstar        TYPE char1,
  l_in_function     TYPE char1,
  l_in_where        TYPE char1,
  l_form_name       TYPE seu_name,
  l_exit_flag       TYPE char1,
  l_source_name     TYPE char100,
*MOD-SN 3rd AUG
  l_class_name      TYPE char30,
  l_method_name(61)     TYPE c.
*MOD-SN 3rd AUG

  STATICS:
  l_level     TYPE i VALUE 1.

*Logic Starts...

  LOOP AT p_i_code INTO l_wa_code FROM p_start_index.

    l_wa_code_caps = l_wa_code.
    TRANSLATE l_wa_code_caps-line TO UPPER CASE.

    REPLACE ALL OCCURRENCES OF
    cl_abap_char_utilities=>horizontal_tab IN
    l_wa_code WITH '# #'.
    REPLACE ALL OCCURRENCES OF '#' IN l_wa_code WITH space.

    l_wa_code1 = l_wa_code.
    l_tabix = sy-tabix.

    IF NOT p_end_index IS INITIAL.
      IF sy-tabix GT p_end_index.
        EXIT.
      ENDIF.
    ENDIF.

    IF l_wa_code-line IS INITIAL OR l_wa_code-line+0(1) = '*'
      OR l_wa_code-line+0(1) = '"'.
      CONTINUE.
    ENDIF.

    IF l_in_class = 'X'.
      IF l_wa_code_caps-line+0(8) = 'ENDCLASS'
        OR l_wa_code_caps-line+0(9) = 'ENDCLASS.'
        OR l_wa_code_caps-line CS 'DEFINITION LOAD'
        OR l_wa_code_caps-line CS 'DEFINITION DEFERRED'.
        CLEAR l_in_class.
        CONTINUE.
      ELSE.
        CONTINUE.
      ENDIF.
    ENDIF.

    IF l_wa_code_caps-line+0(5) = 'FORM ' OR
       l_wa_code_caps-line+0(8) = 'ENDFORM ' or
       l_wa_code_caps-line+0(8) = 'ENDFORM.'.
      EXIT.
    ENDIF.

    IF l_wa_code_caps-line+0(6) = 'CLASS '
     AND NOT l_wa_code_caps-line CS 'DEFINITION LOAD'
     AND NOT l_wa_code_caps-line CS 'DEFINITION DEFERRED'.
      l_in_class = 'X'.
      CONTINUE.
    ENDIF.

    IF l_in_select = 'X'.
      l_wa_select-code = l_wa_code1-line.
      APPEND l_wa_select TO l_i_select.
    ENDIF.

    TRANSLATE l_wa_code-line TO UPPER CASE.

    IF l_in_select = space.
      CLEAR l_word.
      PERFORM sub_first_word CHANGING l_wa_code
                                      l_word.

      IF l_word CA '.'.

        PERFORM sub_dot_end CHANGING l_in_select
                                     l_in_cstar
                                     l_i_select.
      ENDIF.

      IF l_word = 'PERFORM'.

        PERFORM sub_form_name USING l_wa_code
                           CHANGING l_form_name.

        IF ( i_r_perform IS INITIAL ) OR
           ( NOT i_r_perform IS INITIAL AND
             NOT l_form_name IN i_r_perform ).

          wa_r_perform-sign = 'I'.
          wa_r_perform-option = 'EQ'.
          wa_r_perform-low = l_form_name.
          APPEND wa_r_perform TO i_r_perform.

          PERFORM sub_code_position USING l_form_name
                                 CHANGING l_i_code
                                          l_start_position
                                          l_end_position
                                          l_source_name.
          l_level = l_level + 1.

*         MOD-SN 3rd AUG
          CLEAR: l_wa_sub_call_info.
*         MOD-SN 3rd AUG
          l_wa_sub_call_info-subroutine_name = l_form_name.
          l_wa_sub_call_info-event_code      = v_event_code.
          v_sub_seq = v_sub_seq + 1.
          l_wa_sub_call_info-sub_seq         = v_sub_seq.
          l_wa_sub_call_info-seq_flag        = 'S'.
          APPEND l_wa_sub_call_info TO i_sub_call_info.

          PERFORM sub_scan_code USING l_source_name
                                      l_i_code
                                      l_start_position
                                      l_end_position.

*         MOD-SN 3rd AUG
          CLEAR: l_wa_sub_call_info.
*         MOD-SN 3rd AUG
          l_wa_sub_call_info-subroutine_name = l_form_name.
          l_wa_sub_call_info-event_code      = v_event_code.
          v_sub_seq = v_sub_seq + 1.
          l_wa_sub_call_info-sub_seq         = v_sub_seq.
          l_wa_sub_call_info-seq_flag        = 'E'.
          APPEND l_wa_sub_call_info TO i_sub_call_info.

          DELETE i_r_perform WHERE low = l_form_name.

          l_level = l_level - 1.

        ENDIF.

        CONTINUE.

      ENDIF.

      IF l_word = 'CALL'.

        CLEAR l_word.
        PERFORM sub_first_word CHANGING l_wa_code
                                        l_word.

        CASE l_word.
          WHEN 'FUNCTION'.
            IF v_fm = 'X'.
              PERFORM sub_populate_fm_call USING l_tabix
                                           CHANGING l_wa_code
                                                    l_wa_code1
                                                    p_i_code.
            ENDIF.
          WHEN 'METHOD'.

            PERFORM sub_get_method_class USING l_tabix      "Mod - 2
                                      CHANGING l_wa_code
                                               l_method_found
                                               l_start_position
                                               l_end_position
                                               l_i_code
*                                              MOD-SN 3rd AUG
                                               l_class_name
                                               l_method_name.
*                                              MOD-SN 3rd AUG

            IF l_method_found = 'X'.
              l_level = l_level + 1.

              READ TABLE i_method_call WITH KEY
              class_name = l_class_name
              method_name = l_method_name TRANSPORTING NO FIELDS.

              IF sy-subrc <> 0.

*               MOD-SN 3rd AUG
                CLEAR: l_wa_sub_call_info.
                l_wa_sub_call_info-method_name = l_method_name.
                l_wa_sub_call_info-class_name  = l_class_name.
                l_wa_sub_call_info-event_code      = v_event_code.
                v_sub_seq = v_sub_seq + 1.
                l_wa_sub_call_info-sub_seq         = v_sub_seq.
                l_wa_sub_call_info-seq_flag        = 'S'.
                APPEND l_wa_sub_call_info TO i_sub_call_info.

                l_wa_method_call-class_name = l_class_name.
                l_wa_method_call-method_name = l_method_name.
                APPEND l_wa_method_call TO i_method_call.

*               MOD-SN 3rd AUG
                PERFORM sub_scan_code USING space
                                            l_i_code
                                            l_start_position
                                            l_end_position.

*               MOD-SN 3rd AUG
                CLEAR: l_wa_sub_call_info.
                l_wa_sub_call_info-method_name = l_method_name.
                l_wa_sub_call_info-class_name  = l_class_name.
                l_wa_sub_call_info-event_code      = v_event_code.
                v_sub_seq = v_sub_seq + 1.
                l_wa_sub_call_info-sub_seq         = v_sub_seq.
                l_wa_sub_call_info-seq_flag        = 'E'.
                APPEND l_wa_sub_call_info TO i_sub_call_info.

                DELETE i_method_call WHERE class_name = l_class_name
                                       AND method_name = l_method_name.

*               MOD-SN 3rd AUG
                l_level = l_level - 1.
                CONTINUE.

              ENDIF.

            ENDIF.

        ENDCASE.
      ENDIF.

      REPLACE ALL OCCURRENCES OF '.' IN l_word WITH space.
      CASE l_word.
        WHEN 'INITIALIZATION'.  v_event_code = '01'.
        WHEN 'START-OF-SELECTION'. v_event_code = '02'.
        WHEN 'END-OF-SELECTION'. v_event_code = '04'.
        WHEN 'TOP-OF-PAGE'. v_event_code = '06'.
        WHEN 'END-OF-PAGE'. v_event_code = '07'.
        WHEN 'AT'.
          l_wa_code2 = l_wa_code.
          CLEAR l_word1.
          PERFORM sub_first_word CHANGING l_wa_code2
                                          l_word1.
          REPLACE ALL OCCURRENCES OF '.' IN l_word1 WITH space.
          CASE l_word1.
            WHEN 'LINE-SELECTION'. v_event_code = '08'.
            WHEN 'PF-STATUS'. v_event_code = '09'.
            WHEN 'USER-COMMAND'. v_event_code = '10'.
            WHEN 'SELECTION-SCREEN'.
              CLEAR l_word1.
              PERFORM sub_first_word CHANGING l_wa_code2
                                              l_word1.
              REPLACE ALL OCCURRENCES OF '.' IN l_word1 WITH space.
              IF l_word1 = 'OUTPUT'.
                v_event_code = '05'.
              ELSE.
                v_event_code = '03'.
              ENDIF.
          ENDCASE.
      ENDCASE.

    ENDIF.  "IF l_in_select = space.


    IF l_word = 'SELECT' OR l_in_select = 'X'.
      l_in_select = 'X'.

      IF l_word = 'SELECT'.
        l_in_field = 'X'.
        l_wa_select-code = l_wa_code1-line.
        APPEND l_wa_select TO l_i_select.
      ENDIF.

      CLEAR l_exit_flag.
      PERFORM sub_process_select    USING l_tabix
                                          p_i_code
                                          p_source_name
                                 CHANGING l_wa_code
                                          l_in_select
                                          l_from
                                          l_in_where
                                          l_in_field
                                          l_in_cstar
                                          l_i_dbtab
                                          l_i_link_fld
                                          l_i_fld
                                          l_i_join_fld
                                          l_i_op
                                          l_foe_tab
                                          l_int_tab
                                          l_exit_flag
                                          l_i_select.

      IF l_exit_flag = 'X'.
        EXIT.
      ENDIF.

    ENDIF.

    CLEAR l_word.

  ENDLOOP.

ENDFORM.                    " SUB_SCAN_CODE

*&---------------------------------------------------------------------*
*&      Form  SUB_FIRST_WORD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_L_WA_CODE  text
*      <--P_L_WORD  text
*----------------------------------------------------------------------*
FORM sub_first_word  CHANGING p_wa_code TYPE x_code
                              p_word TYPE char255.

  DATA: l_dummy TYPE string,
        l_quote TYPE char1 VALUE ''''.

  SHIFT p_wa_code LEFT DELETING LEADING space.

  SPLIT p_wa_code AT space INTO p_word
  p_wa_code.

  SHIFT p_wa_code LEFT DELETING LEADING space.

  IF NOT p_wa_code IS INITIAL.
    IF p_wa_code+0(1) = '"'.
      CLEAR p_wa_code.
    ENDIF.
  ENDIF.

  IF p_word CA '"'.
    SPLIT p_word AT '"' INTO p_word l_dummy.
  ENDIF.

  IF p_word NA l_quote.
    TRANSLATE p_word TO UPPER CASE.
  ENDIF.

ENDFORM.                    " SUB_FIRST_WORD

*&---------------------------------------------------------------------*
*&      Form  SUB_FORM_NAME
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_CODE  text
*      <--P_L_FORM_NAME  text
*----------------------------------------------------------------------*
FORM sub_form_name  USING    p_wa_code TYPE x_code
                    CHANGING p_form_name TYPE seu_name.

  DATA: l_off TYPE syindex,
        l_form_name TYPE seu_name,
        l_len TYPE i.

  l_len = STRLEN( p_wa_code-line ).

  CLEAR p_form_name.

  DO.
    l_off = sy-index - 1.
    IF l_off = l_len.
      EXIT.
    ENDIF.
    IF p_wa_code-line+l_off(1) = '.'.
      EXIT.
    ENDIF.
    IF NOT p_wa_code-line+l_off(1) IS INITIAL.
      CONCATENATE p_form_name p_wa_code-line+l_off(1)
      INTO p_form_name.
    ELSEIF NOT p_form_name IS INITIAL.
      EXIT.
    ENDIF.
  ENDDO.

ENDFORM.                    " SUB_FORM_NAME

*&---------------------------------------------------------------------*
*&      Form  SUB_CODE_POSITION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_FORM_NAME  text
*      <--P_L_I_CODE  text
*      <--P_L_START_POSITION  text
*----------------------------------------------------------------------*
FORM sub_code_position  USING    p_form_name      TYPE seu_name
                        CHANGING p_i_code         TYPE x_t_code
                                 p_start_position TYPE sytabix
                                 p_end_position   TYPE sytabix
                                 p_source_name    TYPE any.

  DATA:
  l_wa_nodetab   TYPE snodetext,
  l_wa_code_info LIKE x_code_info,
  l_col          TYPE numc10,
  l_row          TYPE numc10.


*********CHANGE
  READ TABLE i_nodetab INTO l_wa_nodetab WITH KEY type = v_op_tt
                                              name = p_form_name
                                              BINARY SEARCH
                                              TRANSPORTING hide.
  IF sy-subrc = 0.
    READ TABLE i_code_info INTO l_wa_code_info
    WITH KEY name = l_wa_nodetab-hide.

    IF sy-subrc = 0.
      p_i_code[] = l_wa_code_info-code[].
    ELSE.
      READ REPORT l_wa_nodetab-hide INTO l_wa_code_info-code.
      l_wa_code_info-name = l_wa_nodetab-hide.

      p_i_code[] = l_wa_code_info-code[].

      INSERT l_wa_code_info INTO TABLE i_code_info.
    ENDIF.

    p_source_name = l_wa_nodetab-hide.

    CALL FUNCTION 'RS_OBJECT_AREA'
      EXPORTING
        object_name               = p_form_name
        object_type               = 'U'
      IMPORTING
        row_beg                   = p_start_position
        row_end                   = p_end_position
      TABLES
        SOURCE                    = p_i_code
      EXCEPTIONS
        object_not_found          = 1
        source_not_correct        = 2
        object_type_not_supported = 3
        OTHERS                    = 4.

    IF sy-subrc = 0.
      p_start_position = p_start_position + 1.
    ENDIF.

  ENDIF.

ENDFORM.                    " SUB_CODE_POSITION

*&---------------------------------------------------------------------*
*&      Form  SUB_PROCESS_SELECT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_process_select    USING p_tabix      TYPE sytabix
                                 p_i_code     TYPE x_t_code
                                 p_source_name TYPE any
                        CHANGING p_wa_code    TYPE x_code
                                 p_in_select  TYPE char1
                                 p_from       TYPE char1
                                 p_in_where   TYPE char1
                                 p_in_field   TYPE char1
                                 p_in_cstar   TYPE char1
                                 p_i_dbtab    TYPE x_zdbtab_name_ty
                                 p_i_link_fld TYPE
x_zwhere_field_name_ty
                                 p_i_fld      TYPE x_zfield_name_ty
                                 p_i_join_fld TYPE x_zfield_name_ty
                                 p_i_op       TYPE
x_zwhere_field_name_ty
                                 p_foe_tab    TYPE char30
                                 p_int_tab    TYPE char30
                                 p_exit_flag  TYPE char1
                                 p_i_select   TYPE x_zselect_ty.

  DATA:
  l_word        TYPE char255,
  l_wa_tk       TYPE stokesx,
  l_wa_dbtab    TYPE x_zdbtab_name,
  l_wa_itab     TYPE x_zitab,
  l_type        TYPE seu_type,
  l_wa_link_fld TYPE x_zwhere_field_name,
  l_wa_op       TYPE x_zwhere_field_name,
  l_op          TYPE char100,
  l_rem         TYPE i,
  l_lines       TYPE i,
  l_wa_operand  TYPE x_zoperands,
  l_wa_operand1 TYPE x_zoperands,
  l_i_operands  TYPE x_zoperands_ty,
  l_db_no       TYPE i,
  l_fdpos       TYPE syfdpos,
  l_wa_fld      TYPE x_zfield_name.

  DATA:
    l_r_i_tabname  TYPE RANGE OF tabname,
    l_r_wa_tabname LIKE LINE OF l_r_i_tabname,
    l_r_i_fieldname  TYPE RANGE OF fieldname,
    l_r_wa_fieldname LIKE LINE OF l_r_i_fieldname.

  FIELD-SYMBOLS:
  <dbtab> TYPE x_zdbtab_name,
  <fld>   TYPE x_zfield_name,
  <where_fld> TYPE x_zwhere_field_name.

  TYPES: BEGIN OF x_dd03l,
           tabname TYPE tabname,
           fieldname TYPE fieldname,
         END OF x_dd03l.

  DATA: l_i_dd03l  TYPE STANDARD TABLE OF x_dd03l,
        l_wa_dd03l TYPE x_dd03l,
        l_tabix    TYPE sytabix.

  STATICS:
  l_count           TYPE i,
    l_tabix_int_tab TYPE sytabix,
    l_tabix_foe_tab TYPE sytabix,
  l_cnt             TYPE sytabix,
  l_in_upto         TYPE char1,
  l_in_in           TYPE char1,
  l_star            TYPE char1,
  l_in_into_table   TYPE char1,
  l_in_join         TYPE char1,
  l_in_on           TYPE char1,
  l_in_foei         TYPE char1,
  l_in_not          TYPE char1,
  l_where_fld_tabix TYPE sytabix,
  l_in_as           TYPE char1.

  DO.
    CLEAR l_word.
    IF NOT p_wa_code IS INITIAL.
      PERFORM sub_first_word CHANGING p_wa_code
                                      l_word.
    ENDIF.
*********END PROCESSING FOR A PARTICULAR SELECT STARTS
    IF l_word CA '.' OR l_word+0(1) = '"' OR l_word IS INITIAL.

      IF l_word CA '.'.

        REPLACE ALL OCCURRENCES OF '.' IN l_word WITH space.

        IF p_in_select = 'X'.

          IF p_in_where = 'X'.
            IF NOT p_foe_tab IS INITIAL.  "select with foe

              IF l_word CS p_foe_tab. "operand contain foe tab

                PERFORM sub_find_link  USING l_op
                             l_word
                             p_foe_tab
                    CHANGING l_wa_link_fld.

                APPEND l_wa_link_fld TO p_i_link_fld.
                l_wa_operand-op = l_word.
                APPEND l_wa_operand TO l_i_operands.
                l_wa_op-operand[] = l_i_operands[].
                MODIFY p_i_op FROM l_wa_op INDEX l_where_fld_tabix
                TRANSPORTING operand.
                REFRESH l_i_operands.
                CLEAR l_wa_op-operand.

              ELSE.  "operand do not contain foe tab

                l_wa_operand-op = l_word.

                IF l_in_in = 'X'. "operator is IN
                  PERFORM sub_process_in_operand USING
                                                   l_where_fld_tabix
                                               CHANGING l_wa_operand
                                                        p_i_op.
                  CLEAR l_in_in.

                ELSE.  "operator is not IN

                  READ TABLE p_i_op INTO l_wa_op INDEX
                  l_where_fld_tabix.
                  IF sy-subrc = 0.
                    PERFORM sub_populate_operand
                                           USING l_where_fld_tabix
                                                 CHANGING l_wa_operand
                                                          l_wa_op
                                                          p_i_op.
                  ENDIF.

                ENDIF.  "IF l_in_in = 'X'.

                CLEAR l_wa_op-operand.

              ENDIF.  "IF l_word CS p_foe_tab

            ELSE. "select without foe

              l_wa_operand-op = l_word.
              IF l_in_in = 'X'.  "operator is IN
                PERFORM sub_process_in_operand USING l_where_fld_tabix
                                            CHANGING l_wa_operand
                                                     p_i_op.
                CLEAR l_in_in.
              ELSE. "operator is not IN
                READ TABLE p_i_op INTO l_wa_op INDEX l_where_fld_tabix.
                IF sy-subrc = 0.
                  PERFORM sub_populate_operand USING l_where_fld_tabix
                                            CHANGING l_wa_operand
                                                     l_wa_op
                                                     p_i_op.
                ENDIF.
              ENDIF.  "IF l_in_in = 'X'.
              CLEAR l_wa_op-operand.

            ENDIF.  "IF NOT p_foe_tab IS INITIAL.

          ENDIF.  "IF p_in_where = 'X'.

          IF p_from = 'X'.  "In FROM
            l_wa_dbtab-dbtab_name = l_word.
            APPEND l_wa_dbtab TO p_i_dbtab.

            IF l_star = 'X'.  "Select * is used
              PERFORM sub_populate_select_star_flds
              USING l_wa_dbtab-dbtab_name
              CHANGING p_i_fld.

              CLEAR l_star.
            ENDIF.

          ENDIF.  "IF p_from = 'X'.

          IF NOT p_foe_tab IS INITIAL.
            IF l_word CS p_foe_tab.
              PERFORM sub_find_link  USING l_op
                                           l_word
                                           p_foe_tab
                                  CHANGING l_wa_link_fld.

              APPEND l_wa_link_fld TO p_i_link_fld.
            ENDIF.
          ENDIF.

          IF l_in_into_table = 'X' AND p_int_tab IS INITIAL.
            p_int_tab = l_word.
          ENDIF.

          CLEAR wa_select_info.
          wa_select_info-i_dbtab[] = p_i_dbtab[].
          REFRESH p_i_dbtab.
          wa_select_info-i_link_fld[] = p_i_link_fld[].
          REFRESH p_i_link_fld.
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
          IF NOT p_int_tab IS INITIAL.
            wa_select_info-v_int_tab = p_int_tab.
            l_wa_itab-itab = p_int_tab.
            PERFORM sub_get_structure USING l_wa_itab
                                            v_op_dd
                                            i_nodetab
                                   CHANGING wa_select_info-v_int_struc
                                            l_type.

            IF wa_select_info-v_int_struc IS INITIAL.
              UNASSIGN <abap_source>.
              PERFORM sub_scan_abap_source USING p_source_name.

              IF <abap_source> IS ASSIGNED.

                READ TABLE <abap_source>-tokens INTO l_wa_tk
                WITH KEY str = l_wa_itab-itab
                         row = l_tabix_int_tab.

                IF sy-subrc = 0.
                  PERFORM sub_get_local_struc USING l_wa_itab
                                                    l_tabix_int_tab
                                                    l_wa_tk-col
                                                    p_i_code
                                                    i_nodetab
                                    CHANGING wa_select_info-v_int_struc
                                              l_type.
                ENDIF.
              ENDIF.
            ENDIF.

            PERFORM sub_delete_itab_offset
            CHANGING wa_select_info-v_int_tab.
            CLEAR p_int_tab.
          ENDIF.
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
          IF NOT p_foe_tab IS INITIAL.
            wa_select_info-v_foe_tab = p_foe_tab.
            l_wa_itab-itab = p_foe_tab.
            PERFORM sub_get_structure USING l_wa_itab
                                            v_op_dd
                                            i_nodetab
                                   CHANGING wa_select_info-v_foe_struc
                                            l_type.

            IF wa_select_info-v_foe_struc IS INITIAL.
              UNASSIGN <abap_source>.
              PERFORM sub_scan_abap_source USING p_source_name.

              IF <abap_source> IS ASSIGNED.

                READ TABLE <abap_source>-tokens INTO l_wa_tk
                WITH KEY str = l_wa_itab-itab
                         row = l_tabix_foe_tab.

                IF sy-subrc = 0.
                  PERFORM sub_get_local_struc USING l_wa_itab
                                                    l_tabix_foe_tab
                                                    l_wa_tk-col
                                                    p_i_code
                                                    i_nodetab
                                    CHANGING wa_select_info-v_foe_struc
                                             l_type.
                ENDIF.
              ENDIF.

              PERFORM sub_delete_itab_offset
              CHANGING wa_select_info-v_foe_tab.
              CLEAR p_foe_tab.

            ENDIF.
          ENDIF.
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
          wa_select_info-i_fld[] = p_i_fld[].
          REFRESH p_i_fld.
          wa_select_info-i_join_fld[] = p_i_join_fld[].
          REFRESH p_i_join_fld.

          wa_select_info-i_where_fld[] = p_i_op[].
          REFRESH p_i_op.

          IF p_in_cstar = space.
            wa_select_info-i_select[] = p_i_select[].
            REFRESH p_i_select.
            v_sequence = v_sequence + 1.
            wa_select_info-sequence = v_sequence.
            v_sub_seq = v_sub_seq + 1.
            wa_select_info-sub_seq = v_sub_seq.
            wa_select_info-event_code = v_event_code.

            APPEND wa_select_info TO i_select_info.
            l_tabix = sy-tabix.
*            l_db_no = LINES( wa_select_info-i_dbtab ).
            DESCRIBE TABLE wa_select_info-i_dbtab LINES l_db_no.

            IF l_db_no = 1.
              READ TABLE wa_select_info-i_dbtab INTO l_wa_dbtab
              INDEX 1.

              wa_table_fields-tabname = l_wa_dbtab-dbtab_name.
              MODIFY i_table_fields FROM wa_table_fields
              TRANSPORTING tabname WHERE tabname IS INITIAL.
            ELSE.  "Join
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
              l_r_wa_tabname-sign = 'I'.
              l_r_wa_tabname-option = 'EQ'.
              l_r_wa_fieldname-sign = 'I'.
              l_r_wa_fieldname-option = 'EQ'.
              LOOP AT wa_select_info-i_dbtab ASSIGNING <dbtab>.
                IF <dbtab>-alias IS INITIAL.
                  <dbtab>-alias = <dbtab>-dbtab_name.
                ENDIF.
                l_r_wa_tabname-low = <dbtab>-dbtab_name.
                APPEND l_r_wa_tabname TO l_r_i_tabname.
              ENDLOOP.
              LOOP AT wa_select_info-i_fld ASSIGNING <fld>
                      WHERE alias = space.
                l_r_wa_fieldname-low = <fld>-fieldname.
                APPEND l_r_wa_fieldname TO l_r_i_fieldname.
              ENDLOOP.

              LOOP AT wa_select_info-i_where_fld ASSIGNING <where_fld>
                      WHERE alias = space.
                l_r_wa_fieldname-low = <where_fld>-field_name.
                APPEND l_r_wa_fieldname TO l_r_i_fieldname.
              ENDLOOP.

              IF NOT l_r_i_fieldname IS INITIAL.
                SELECT tabname fieldname
                INTO TABLE l_i_dd03l
                FROM dd03l
                WHERE tabname IN l_r_i_tabname
                  AND fieldname IN l_r_i_fieldname
                  AND as4local = 'A'.
              ENDIF.

              LOOP AT wa_select_info-i_fld ASSIGNING <fld>
                      WHERE alias = space.
                READ TABLE l_i_dd03l INTO l_wa_dd03l
                WITH KEY fieldname = <fld>-fieldname.

                IF sy-subrc = 0.
                  <fld>-alias = l_wa_dd03l-tabname.
                ENDIF.
              ENDLOOP.

              LOOP AT wa_select_info-i_where_fld ASSIGNING <where_fld>
                      WHERE alias = space.
                READ TABLE l_i_dd03l INTO l_wa_dd03l
                WITH KEY fieldname = <where_fld>-field_name.

                IF sy-subrc = 0.
                  <where_fld>-alias = l_wa_dd03l-tabname.
                ENDIF.
              ENDLOOP.

              MODIFY i_select_info FROM wa_select_info INDEX l_tabix.
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            ENDIF.
          ELSE.
            CLEAR p_in_cstar.
          ENDIF.
          CLEAR: p_in_where,l_in_into_table.

        ENDIF.  "IF p_in_select = 'X'.

        p_in_select = space.

      ENDIF.  "IF l_word CA '.'.

      EXIT.

    ENDIF. "IF l_word CA '.' OR l_word+0(1) = '"' OR l_word IS INITIAL.

*********END PROCESSING FOR A PARTICULAR SELECT ENDS

    IF p_in_where = 'X'.
      l_count = l_count + 1.
    ENDIF.

    IF l_in_upto = space.

      CASE l_word.
        WHEN 'INTO' OR 'APPENDING'.
          p_in_field = space.
          p_from = space.
        WHEN 'COUNT(*)' OR 'COUNT('.
          p_in_cstar = 'X'.
        WHEN 'TABLE'.
          l_in_into_table = 'X'.
        WHEN 'FROM'.
          p_in_field = space.
          p_from = 'X'.
          l_in_into_table = space.
        WHEN 'BYPASSING' OR 'BUFFER'.
        WHEN 'CLIENT' OR 'SPECIFIED'.
        WHEN 'INNER'.
        WHEN 'JOIN'.
          l_in_join = 'X'.
          l_in_on = space.
        WHEN 'ON'.
          l_in_on = 'X'.
          l_count = 0.
        WHEN 'FOR'.
          l_in_foei = 'X'.
          l_in_on = space.
        WHEN 'NOT'.
          l_in_not = 'X'.
          l_count = l_count - 1.
        WHEN '(' OR ')'.
          l_count = 0.
          CLEAR l_in_in.
        WHEN 'OR' OR 'AND'.
          l_count = 0.
          IF p_in_where = 'X'.
            l_wa_op-andor = l_word.
            MODIFY p_i_op FROM l_wa_op INDEX l_where_fld_tabix
            TRANSPORTING andor.
            CLEAR l_wa_op-andor.
            CLEAR l_in_in.
          ENDIF.
        WHEN 'WHERE'.
          p_in_field = space.
          p_from = space.
          p_in_where = 'X'.
          l_count = 0.
          l_in_on = space.
          l_in_into_table = space.
        WHEN 'ENTRIES'.
        WHEN 'ALL'.
        WHEN 'AS'.
          l_in_as = 'X'.
        WHEN 'SINGLE'.
        WHEN 'UP'.
          l_in_upto = 'X'.
        WHEN '*'.
          l_star = 'X'.
        WHEN OTHERS.

          CASE 'X'.
            WHEN p_in_field.
              l_wa_fld-fieldname = l_word.

              PERFORM sub_remove_alias CHANGING l_wa_fld.

***********************************************************
              CLEAR wa_table_fields.
              wa_table_fields-fieldname = l_wa_fld-fieldname.
              wa_table_fields-tabname = l_wa_fld-alias.
              l_wa_fld-tablename      = wa_table_fields-tabname.
              APPEND wa_table_fields TO i_table_fields.
***********************************************************

              APPEND l_wa_fld TO p_i_fld.

            WHEN l_in_into_table.
              p_int_tab = l_word.
              l_in_into_table = space.
              l_tabix_int_tab = p_tabix.
            WHEN l_in_foei.
              IF l_word NE 'IN'.
                p_foe_tab = l_word.
                l_tabix_foe_tab = p_tabix.
                l_in_foei = space.
              ENDIF.
            WHEN p_from.
              IF l_in_as = 'X'.
                PERFORM sub_populate_alias    USING l_word
                                           CHANGING p_i_dbtab.
                CLEAR: l_in_as.
              ELSEIF l_in_on = 'X'.
                l_count = l_count + 1.
                l_rem = l_count MOD 2.
                IF l_rem = 1.
                  l_wa_fld-fieldname = l_word.
                  PERFORM sub_remove_alias CHANGING l_wa_fld.

***********************************************************
                  CLEAR wa_table_fields.
                  wa_table_fields-fieldname = l_wa_fld-fieldname.
                  IF NOT l_wa_fld-alias IS INITIAL.
                    READ TABLE p_i_dbtab INTO l_wa_dbtab
                    WITH KEY dbtab_name = l_wa_fld-alias.
                    IF sy-subrc = 0.
                      wa_table_fields-tabname = l_wa_dbtab-dbtab_name.
                    ELSE.
                      READ TABLE p_i_dbtab INTO l_wa_dbtab
                      WITH KEY alias = l_wa_fld-alias.

                      IF sy-subrc = 0.
                        wa_table_fields-tabname = l_wa_dbtab-dbtab_name.
                      ENDIF.
                    ENDIF.
                  ELSE.
                    READ TABLE p_i_dbtab INTO l_wa_dbtab INDEX 1.
                    IF sy-subrc = 0.
                      wa_table_fields-tabname = l_wa_dbtab-dbtab_name.
                    ENDIF.
                  ENDIF.
                  l_wa_fld-tablename = wa_table_fields-tabname.
                  APPEND wa_table_fields TO i_table_fields.
***********************************************************
                  APPEND l_wa_fld TO p_i_join_fld.
                ENDIF.
              ELSE.
                l_wa_dbtab-dbtab_name = l_word.

                REPLACE ALL OCCURRENCES OF '.'
                IN l_wa_dbtab-dbtab_name WITH space.
                APPEND l_wa_dbtab TO p_i_dbtab.

                IF l_star = 'X'.  "Select *

                  PERFORM sub_populate_select_star_flds
                  USING l_wa_dbtab-dbtab_name
                  CHANGING p_i_fld.

                  CLEAR l_star.
                ENDIF.
              ENDIF.

            WHEN p_in_where.

              CASE l_count.
                WHEN '0'.
                WHEN '1'.

                  PERFORM sub_count_1 USING l_word
                                   CHANGING p_i_op
                                            p_i_dbtab
                                            l_op
                                            l_where_fld_tabix.

                WHEN '2'.

                  l_wa_op-operator = l_word.
                  IF l_in_not = 'X'.
                    CONCATENATE 'NOT' l_wa_op-operator INTO
                    l_wa_op-operator SEPARATED BY space.
                    CLEAR l_in_not.
                  ENDIF.
                  MODIFY p_i_op FROM l_wa_op INDEX l_where_fld_tabix
                    TRANSPORTING operator.
                  IF ( l_wa_op-operator = 'IN' OR
                    l_wa_op-operator = 'NOT IN' )
                    AND l_in_foei = space.
                    l_in_in = 'X'.
                  ENDIF.
                  CLEAR l_wa_op-operator.

                WHEN '3'.

                  PERFORM sub_count_3 USING p_foe_tab
                                            l_word
                                            l_op
                                            l_where_fld_tabix
                                   CHANGING l_i_operands
                                            p_i_op
                                            p_i_link_fld.

                WHEN OTHERS.
                  IF l_in_in = 'X'.
                    PERFORM sub_process_in_operand USING
                                                    l_where_fld_tabix
                                                 CHANGING l_wa_operand
                                                          p_i_op.
                  ENDIF.
              ENDCASE.

          ENDCASE.

      ENDCASE.

    ELSEIF l_word = 'ROWS'.
      l_in_upto = space.
    ENDIF.

  ENDDO.

ENDFORM.                    " SUB_PROCESS_SELECT

*&---------------------------------------------------------------------*
*&      Form  SUB_REMOVE_ALIAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_L_WA_FLD  text
*----------------------------------------------------------------------*
FORM sub_remove_alias  CHANGING p_wa_fld TYPE x_zfield_name.

  DATA:
  l_fdpos TYPE syfdpos.

  SEARCH p_wa_fld-fieldname FOR '~'.
  IF sy-subrc = 0.
    l_fdpos = sy-fdpos.
    l_fdpos = l_fdpos + 1.
    p_wa_fld-alias = p_wa_fld-fieldname+0(sy-fdpos).
    p_wa_fld-fieldname = p_wa_fld-fieldname+l_fdpos.
  ENDIF.

ENDFORM.                    " SUB_REMOVE_ALIAS

*&---------------------------------------------------------------------*
*&      Form  SUB_REMOVE_ALIAS1
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_L_WA_FLD  text
*----------------------------------------------------------------------*
FORM sub_remove_alias1  CHANGING p_wa_fld TYPE x_zwhere_field_name.

  DATA:
  l_fdpos TYPE syfdpos.

  SEARCH p_wa_fld-field_name FOR '~'.
  IF sy-subrc = 0.
    l_fdpos = sy-fdpos.
    l_fdpos = l_fdpos + 1.
    p_wa_fld-alias = p_wa_fld-field_name+0(sy-fdpos).
    p_wa_fld-field_name = p_wa_fld-field_name+l_fdpos.
  ENDIF.

ENDFORM.                    " SUB_REMOVE_ALIAS

*&---------------------------------------------------------------------*
*&      Form  SUB_FIND_LINK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_L_WA_LINK_FLD  text
*----------------------------------------------------------------------*
FORM sub_find_link    USING p_op TYPE char100
                            p_word  TYPE char255
                            p_foe_tab TYPE char30
                   CHANGING p_wa_link_fld TYPE x_zwhere_field_name.

  p_wa_link_fld-field_name = p_op.

  PERFORM sub_remove_alias1 CHANGING p_wa_link_fld.

  p_wa_link_fld-field_link = p_word.

  REPLACE FIRST OCCURRENCE OF p_foe_tab
                IN p_wa_link_fld-field_link WITH space.

  REPLACE FIRST OCCURRENCE OF '-'
  IN p_wa_link_fld-field_link WITH space.

  REPLACE ALL OCCURRENCES OF '.'
  IN p_wa_link_fld-field_link WITH space.

  p_wa_link_fld-table_link = p_foe_tab.

  PERFORM sub_delete_itab_offset CHANGING p_wa_link_fld-table_link.

ENDFORM.                    " SUB_FIND_LINK

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_SELECT_STAR_FLDS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_DBTAB_DBTAB_NAME  text
*      <--P_P_I_FLD  text
*----------------------------------------------------------------------*
FORM sub_populate_select_star_flds  USING    p_dbtab_name TYPE char30
                                CHANGING p_i_fld TYPE x_zfield_name_ty.

  TYPES: BEGIN OF x_fld,
          fieldname TYPE fieldname,
          position  TYPE tabfdpos,
         END OF x_fld.

  DATA: l_i_star_fld TYPE STANDARD TABLE OF x_fld,
        l_wa_star_fld TYPE x_fld,
        l_wa_fld TYPE x_zfield_name.

  SELECT fieldname
         position
  INTO TABLE l_i_star_fld
  FROM dd03l
  WHERE tabname = p_dbtab_name.

  REFRESH p_i_fld.

  IF sy-subrc = 0.
    SORT l_i_star_fld BY position.
    DELETE l_i_star_fld WHERE fieldname+0(1) EQ '.'.
    LOOP AT l_i_star_fld INTO l_wa_star_fld.
      l_wa_fld-fieldname = l_wa_star_fld-fieldname.
      APPEND l_wa_fld TO p_i_fld.
      CLEAR wa_table_fields.
      wa_table_fields-tabname = p_dbtab_name.
      wa_table_fields-fieldname = l_wa_star_fld-fieldname.
      APPEND wa_table_fields TO i_table_fields.
    ENDLOOP.
  ENDIF.

ENDFORM.                    " SUB_POPULATE_SELECT_STAR_FLDS

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_FM_CALL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_populate_fm_call USING p_tabix TYPE sytabix
                          CHANGING p_wa_code  TYPE x_code
                                   p_wa_code1 TYPE x_code
                                   p_i_code TYPE x_t_code.

  DATA: l_word  TYPE char255,
        l_quote TYPE char1 VALUE '''',
        l_wa_fm_call_info TYPE x_zfm_call_info,
        l_wa_fm_call_code TYPE x_zfm_call,
        l_wa_code2 TYPE x_code,
        l_tabix1 TYPE sytabix.

  PERFORM sub_first_word CHANGING p_wa_code
                                  l_word.

  REPLACE ALL OCCURRENCES OF l_quote IN l_word
  WITH space.

  l_wa_fm_call_info-funcname = l_word.

  SELECT SINGLE stext INTO l_wa_fm_call_info-stext
    FROM tftit
   WHERE spras = sy-langu
     AND funcname = l_wa_fm_call_info-funcname.

  l_wa_fm_call_code-code = p_wa_code1-line.
  APPEND l_wa_fm_call_code TO l_wa_fm_call_info-fm_call_code.
  l_tabix1 = p_tabix + 1.
  DO.
    READ TABLE p_i_code INTO l_wa_code2 INDEX l_tabix1.

    IF sy-subrc = 0 AND l_wa_code2-line+0(1) NE '*'
                    AND l_wa_code2-line+0(1) NE '"'.
      l_wa_fm_call_code-code = l_wa_code2-line.
      APPEND l_wa_fm_call_code TO
      l_wa_fm_call_info-fm_call_code.
    ENDIF.
    l_tabix1 = l_tabix1 + 1.

    IF l_wa_code2-line CA '.'.
      EXIT.
    ENDIF.
  ENDDO.
  v_sequence = v_sequence + 1.
  l_wa_fm_call_info-sequence = v_sequence.
  v_sub_seq = v_sub_seq + 1.
  l_wa_fm_call_info-sub_seq = v_sub_seq.
  l_wa_fm_call_info-event_code = v_event_code.
  APPEND l_wa_fm_call_info TO i_fm_info.

ENDFORM.                    " SUB_POPULATE_FM_CALL

*&---------------------------------------------------------------------*
*&      Form  SUB_COUNT_1
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_count_1 USING p_word TYPE char255
                       p_i_op TYPE x_zwhere_field_name_ty
                       p_i_dbtab TYPE x_zdbtab_name_ty
                       p_op TYPE char100
                       p_where_fld_tabix TYPE sytabix.

  DATA: l_wa_op TYPE x_zwhere_field_name,
        l_wa_dbtab TYPE x_zdbtab_name.

  l_wa_op-field_name = p_word.
  PERFORM sub_remove_alias1 CHANGING l_wa_op.

  APPEND l_wa_op TO p_i_op.
  p_where_fld_tabix = sy-tabix.

***********************************************************
  CLEAR wa_table_fields.
  wa_table_fields-fieldname = l_wa_op-field_name.
  IF NOT l_wa_op-alias IS INITIAL.
    READ TABLE p_i_dbtab INTO l_wa_dbtab
    WITH KEY dbtab_name = l_wa_op-alias.
    IF sy-subrc = 0.
      wa_table_fields-tabname = l_wa_dbtab-dbtab_name.
    ELSE.
      READ TABLE p_i_dbtab INTO l_wa_dbtab
      WITH KEY alias = l_wa_op-alias.

      IF sy-subrc = 0.
        wa_table_fields-tabname = l_wa_dbtab-dbtab_name.
      ENDIF.
    ENDIF.
  ELSE.
    READ TABLE p_i_dbtab INTO l_wa_dbtab INDEX 1.
    IF sy-subrc = 0.
      wa_table_fields-tabname = l_wa_dbtab-dbtab_name.
    ENDIF.
  ENDIF.
  APPEND wa_table_fields TO i_table_fields.

*********************************************************************

  p_op = p_word.

ENDFORM.                    " SUB_COUNT_1

*&---------------------------------------------------------------------*
*&      Form  SUB_COUNT_3
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_count_3 USING p_foe_tab TYPE char30
                       p_word TYPE char255
                       p_op TYPE char100
                       p_where_fld_tabix TYPE sytabix
              CHANGING p_i_operands TYPE x_zoperands_ty
                       p_i_op TYPE x_zwhere_field_name_ty
                       p_i_link_fld TYPE x_zwhere_field_name_ty.

  DATA: l_wa_link_fld TYPE x_zwhere_field_name,
        l_wa_operand  TYPE x_zoperands,
        l_wa_op       TYPE x_zwhere_field_name.

  IF NOT p_foe_tab IS INITIAL.
    IF p_word CS p_foe_tab.
      PERFORM sub_find_link  USING p_op
                                   p_word
                                   p_foe_tab
                          CHANGING l_wa_link_fld.

      APPEND l_wa_link_fld TO p_i_link_fld.
      l_wa_operand-op = p_word.
      PERFORM sub_populate_op_type USING l_wa_operand-op
                                CHANGING l_wa_operand-type.
      APPEND l_wa_operand TO p_i_operands.
      l_wa_op-operand[] = p_i_operands[].
      MODIFY p_i_op FROM l_wa_op INDEX p_where_fld_tabix
      TRANSPORTING operand.
      REFRESH p_i_operands.
      CLEAR l_wa_op-operand.
    ELSE.
      l_wa_operand-op = p_word.
      REPLACE ALL OCCURRENCES OF '(' IN l_wa_operand-op WITH space.
      IF l_wa_operand-op CA ','.

        PERFORM sub_process_operand
                    USING
                       p_where_fld_tabix
                    CHANGING
                       l_wa_operand
                       p_i_op.
      ELSE.
        PERFORM sub_analyse_operand CHANGING l_wa_operand-op.
        PERFORM sub_populate_op_type USING l_wa_operand-op
                                  CHANGING l_wa_operand-type.
        APPEND l_wa_operand TO p_i_operands.
        l_wa_op-operand[] = p_i_operands[].
        MODIFY p_i_op FROM l_wa_op INDEX p_where_fld_tabix
        TRANSPORTING operand.
        REFRESH p_i_operands.
        CLEAR l_wa_op-operand.
      ENDIF.

    ENDIF.
  ELSE.
    l_wa_operand-op = p_word.
    REPLACE ALL OCCURRENCES OF '(' IN l_wa_operand-op WITH space.
    IF l_wa_operand-op CA ','.
      PERFORM sub_process_operand
                  USING
                     p_where_fld_tabix
                  CHANGING
                     l_wa_operand
                     p_i_op.
    ELSE.
      PERFORM sub_analyse_operand CHANGING l_wa_operand-op.
      PERFORM sub_populate_op_type USING l_wa_operand-op
                            CHANGING l_wa_operand-type.
      APPEND l_wa_operand TO p_i_operands.
      l_wa_op-operand[] = p_i_operands[].
      MODIFY p_i_op FROM l_wa_op INDEX p_where_fld_tabix
      TRANSPORTING operand.
      REFRESH p_i_operands.
      CLEAR l_wa_op-operand.
    ENDIF.

  ENDIF.

ENDFORM.                    " SUB_COUNT_3

*&---------------------------------------------------------------------*
*&      Form  SUB_PROCESS_OPERAND
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_OPERANDS  text
*      <--P_P_I_OP  text
*----------------------------------------------------------------------*
FORM sub_process_operand  USING    p_where_fld_tabix TYPE sytabix
                          CHANGING p_wa_operands TYPE x_zoperands
                                   p_i_op TYPE x_zwhere_field_name_ty.

  DATA: l_word TYPE char255,
        l_off  TYPE syfdpos,
        l_wa_op TYPE x_zwhere_field_name,
        l_wa_operand TYPE x_zoperands.

  CONDENSE p_wa_operands-op.
  REPLACE ALL OCCURRENCES OF '(' IN p_wa_operands-op WITH space.
  REPLACE ALL OCCURRENCES OF ')' IN p_wa_operands-op WITH space.
  IF p_wa_operands-op+0(1) = ','.
    SHIFT p_wa_operands-op LEFT DELETING LEADING ','.
  ENDIF.
  READ TABLE p_i_op INTO l_wa_op INDEX p_where_fld_tabix.
  DO.
    SEARCH p_wa_operands-op FOR ','.
    IF sy-subrc = 0.
      l_off = sy-fdpos.
      l_word = p_wa_operands-op+0(l_off).
      l_off = l_off + 1.
      p_wa_operands-op = p_wa_operands-op+l_off.
      l_wa_operand-op = l_word.
      PERFORM sub_analyse_operand CHANGING l_wa_operand-op.
      PERFORM sub_populate_op_type USING l_wa_operand-op
                                  CHANGING l_wa_operand-type.
      IF NOT l_wa_operand-op IS INITIAL.
        APPEND l_wa_operand TO l_wa_op-operand.
      ENDIF.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.

  IF NOT p_wa_operands-op IS INITIAL.
    l_wa_operand-op = p_wa_operands-op.
    PERFORM sub_analyse_operand CHANGING l_wa_operand-op.
    PERFORM sub_populate_op_type USING l_wa_operand-op
                              CHANGING l_wa_operand-type.
    APPEND l_wa_operand TO l_wa_op-operand.
  ENDIF.

  MODIFY p_i_op FROM l_wa_op INDEX p_where_fld_tabix
  TRANSPORTING operand.

ENDFORM.                    " SUB_PROCESS_OPERAND

*&---------------------------------------------------------------------*
*&      Form  SUB_ANALYSE_OPERAND
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_L_WA_OPERAND_OP  text
*----------------------------------------------------------------------*
FORM sub_analyse_operand  CHANGING p_op TYPE char100.

  DATA: l_wa_code_info LIKE x_code_info,
        l_col          TYPE sytabix,
        l_row          TYPE sytabix,
        l_len_op       TYPE syfdpos,
        l_wa_nodetab   TYPE snodetext,
        l_wa_code      TYPE x_code,
        l_off          TYPE syfdpos,
        l_quote        TYPE char1 VALUE '''',
        l_i_code       TYPE x_t_code.

  l_len_op = STRLEN( p_op ).

  REPLACE ALL OCCURRENCES OF ')' IN p_op WITH space.
  REPLACE ALL OCCURRENCES OF '(' IN p_op WITH space.

*********CHANGE
  READ TABLE i_nodetab INTO l_wa_nodetab WITH KEY type = v_op_dd
                                              name = p_op
                                              BINARY SEARCH.
  IF sy-subrc = 0.
    READ TABLE i_code_info INTO l_wa_code_info
    WITH KEY name = l_wa_nodetab-hide.

    IF sy-subrc = 0.
      l_i_code[] = l_wa_code_info-code[].
    ELSE.
      READ REPORT l_wa_nodetab-hide INTO l_wa_code_info-code.
      l_wa_code_info-name = l_wa_nodetab-hide.

      l_i_code[] = l_wa_code_info-code[].

      INSERT l_wa_code_info INTO TABLE i_code_info.
    ENDIF.
  ENDIF.

  CALL FUNCTION 'RS_OBJECT_POSITION'
    EXPORTING
      object_name      = p_op
      object_type      = 'D'
    IMPORTING
      col              = l_col
      row              = l_row
    TABLES
      SOURCE           = l_i_code
    EXCEPTIONS
      object_not_found = 1
      OTHERS           = 2.

  READ TABLE l_i_code INTO l_wa_code INDEX l_row.

  IF sy-subrc = 0 AND p_op CA p_const.

    SEARCH l_wa_code FOR p_op.

    IF sy-subrc = 0.
      l_off = sy-fdpos.
      l_off = l_off + l_len_op.
      l_wa_code = l_wa_code+l_off.
      SEARCH l_wa_code FOR 'TYPE'.
      IF sy-subrc = 0.
        l_off = sy-fdpos.
        l_off = l_off + 4.
        l_wa_code = l_wa_code+l_off.
        SHIFT l_wa_code LEFT DELETING LEADING ' '.
*        REPLACE ALL OCCURRENCES OF v_space+0(1) IN l_wa_code
*        WITH '-'.
        SEARCH l_wa_code FOR v_space+0(1).
        IF sy-subrc = 0.
          l_off = sy-fdpos.
          l_wa_code = l_wa_code+l_off.
          SEARCH l_wa_code FOR 'VALUE'.
          IF sy-subrc = 0.
            l_off = sy-fdpos.
            l_off = l_off + 5.
            l_wa_code = l_wa_code+l_off.
            SEARCH l_wa_code FOR l_quote.
            IF sy-subrc = 0.
              l_off = sy-fdpos.
              l_off = l_off + 1.
              l_wa_code = l_wa_code+l_off.
              SEARCH l_wa_code FOR l_quote.
              IF sy-subrc = 0.
                l_off = sy-fdpos.
                IF l_off = 0.
                  CONCATENATE l_quote l_quote INTO p_op.
                ELSE.
                  CONCATENATE l_quote l_wa_code+0(l_off) l_quote
                                  INTO p_op.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
        SEARCH l_wa_code FOR 'LIKE'.
        IF sy-subrc = 0.
          l_off = sy-fdpos.
          l_off = l_off + 4.
          l_wa_code = l_wa_code+l_off.
          SHIFT l_wa_code LEFT DELETING LEADING ' '.
          REPLACE ALL OCCURRENCES OF v_space+0(1) IN l_wa_code
          WITH '-'.
          SEARCH l_wa_code FOR '-'.
          IF sy-subrc = 0.
            l_off = sy-fdpos.
            l_wa_code = l_wa_code+l_off.
            SEARCH l_wa_code FOR 'VALUE'.
            IF sy-subrc = 0.
              l_off = sy-fdpos.
              l_off = l_off + 5.
              l_wa_code = l_wa_code+l_off.
              SEARCH l_wa_code FOR l_quote.
              IF sy-subrc = 0.
                l_off = sy-fdpos.
                l_off = l_off + 1.
                l_wa_code = l_wa_code+l_off.
                SEARCH l_wa_code FOR l_quote.
                IF sy-subrc = 0.
                  l_off = sy-fdpos.
                  CONCATENATE l_quote l_wa_code+0(l_off) l_quote
                  INTO p_op.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

    ENDIF.

  ENDIF.

ENDFORM.                    " SUB_ANALYSE_OPERAND

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_METHOD_CLASS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_CODE  text
*      <--P_L_METHOD_FOUND  text
*      <--P_L_START_POSITION  text
*      <--P_L_END_POSITION  text
*----------------------------------------------------------------------*
FORM sub_get_method_class     USING p_line_no        TYPE sytabix
                           CHANGING p_wa_code        TYPE x_code
                                    p_method_found   TYPE char1
                                    p_start_position TYPE sy-tabix
                                    p_end_position   TYPE sy-tabix
                                    p_i_code         TYPE x_t_code
*                                   mod-SN 3rd AUG
                                    p_class_name     TYPE char30
                                    p_method_name    TYPE any.
*                                   mod-SN 3rd AUG

  DATA:
  l_off          TYPE syfdpos,
  l_wa_nodetab   TYPE snodetext,
  l_row          TYPE i,
  l_i_tk1          TYPE sedi_tk WITH HEADER LINE,
  l_wa_tk        TYPE stokesx,
  l_col          TYPE i,
  l_obj_name     TYPE char30,
  l_len          TYPE sytabix,
* mod-SN 3rd AUG
  l_method_name(61)  TYPE c,
* mod-SN 3rd AUG
  l_i_code       TYPE x_t_code,
  l_wa_code_info LIKE x_code_info,
  l_class_name   TYPE char30.

  CLEAR p_method_found.

  SEARCH p_wa_code-line FOR '->'.

  IF sy-subrc = 0.
    l_off = sy-fdpos.
    l_obj_name = p_wa_code-line+0(l_off).
    l_off = l_off + 2.
    p_wa_code = p_wa_code+l_off.

********CHANGE
    READ TABLE i_nodetab INTO l_wa_nodetab WITH KEY type = v_op_dd
                                                name = l_obj_name.

    IF sy-subrc = 0.

      READ TABLE i_code_info INTO l_wa_code_info
      WITH KEY name = l_wa_nodetab-hide.

      IF sy-subrc = 0.
        l_i_code[] = l_wa_code_info-code[].
      ELSE.
        READ REPORT l_wa_nodetab-hide INTO l_wa_code_info-code.
        l_wa_code_info-name = l_wa_nodetab-hide.

        l_i_code[] = l_wa_code_info-code[].

        INSERT l_wa_code_info INTO TABLE i_code_info.
      ENDIF.

      p_i_code[] = l_i_code[].

      CALL FUNCTION 'RS_OBJECT_POSITION'
        EXPORTING
          object_name      = l_obj_name
          object_type      = 'D'
        IMPORTING
          col              = l_col
          row              = l_row
        TABLES
          SOURCE           = l_i_code
        EXCEPTIONS
          object_not_found = 1
          OTHERS           = 2.

      PERFORM sub_determine_class
                  TABLES l_i_code
                   USING l_wa_nodetab-hide
                         l_obj_name
                         l_row
                         l_col
                CHANGING l_class_name.

      l_len = STRLEN( p_wa_code-line ).

      DO.
        l_off = sy-index - 1.
        IF l_off GE l_len.
          EXIT.
        ENDIF.
        IF p_wa_code-line+l_off(1) = '.' OR
           p_wa_code-line+l_off(1) = v_space+0(1).
          EXIT.
        ELSE.
          CONCATENATE l_method_name p_wa_code-line+l_off(1)
          INTO l_method_name.
        ENDIF.
      ENDDO.

      IF <abap_source> IS ASSIGNED.
        l_i_tk1[] = <abap_source>-tokens.

        DELETE <abap_source>-tokens WHERE str NE 'IMPLEMENTATION' AND
                                          str NE l_class_name.

        READ TABLE <abap_source>-tokens INTO l_wa_tk
        WITH KEY str = 'IMPLEMENTATION'.

        IF sy-subrc = 0.
          CLEAR p_start_position.
          READ TABLE l_i_tk1 WITH KEY row = l_wa_tk-row.
          LOOP AT l_i_tk1 FROM sy-tabix.
            IF l_i_tk1-str = l_method_name AND
               p_start_position IS INITIAL.
              p_start_position = l_i_tk1-row.
            ENDIF.
            IF NOT p_start_position IS INITIAL
            AND l_i_tk1-str = 'ENDMETHOD'.
              p_end_position = l_i_tk1-row.
              p_method_found = 'X'.
              EXIT.
            ENDIF.
          ENDLOOP.

        ENDIF.
      ENDIF.
    ELSE. "The object is not a global one

    ENDIF.
  ELSE.
    SEARCH p_wa_code-line FOR '=>'.
    IF sy-subrc = 0.
      l_off = sy-fdpos.
      l_class_name = p_wa_code-line+0(l_off).
      l_off = l_off + 2.
      p_wa_code = p_wa_code+l_off.

      l_len = STRLEN( p_wa_code-line ).

      DO.
        l_off = sy-index - 1.
        IF l_off GE l_len.
          EXIT.
        ENDIF.
        IF p_wa_code-line+l_off(1) = '.' OR
           p_wa_code-line+l_off(1) = v_space+0(1).
          EXIT.
        ELSE.
          CONCATENATE l_method_name p_wa_code-line+l_off(1)
          INTO l_method_name.
        ENDIF.
      ENDDO.

      IF <abap_source> IS ASSIGNED.
        l_i_tk1[] = <abap_source>-tokens.

        DELETE <abap_source>-tokens WHERE str NE 'IMPLEMENTATION' AND
                                          str NE l_class_name.

        READ TABLE <abap_source>-tokens INTO l_wa_tk
        WITH KEY str = 'IMPLEMENTATION'.

        IF sy-subrc = 0.
          READ TABLE l_i_tk1 WITH KEY row = l_wa_tk-row.
          LOOP AT l_i_tk1 FROM sy-tabix.
            IF l_i_tk1-str = l_method_name.
              p_start_position = l_i_tk1-row.
            ENDIF.
            IF NOT p_start_position IS INITIAL
            AND l_i_tk1-str = 'ENDMETHOD'.
              p_end_position = l_i_tk1-row.
              p_method_found = 'X'.
              EXIT.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  p_class_name = l_class_name.
  p_method_name = l_method_name.

ENDFORM.                    " SUB_GET_METHOD_CLASS

*&---------------------------------------------------------------------*
*&      Form  SUB_DETERMINE_CLASS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_SOURCE1  text                                              *
*      -->P_O_OBJECTNAME  text                                         *
*      -->P_O_ROW  text                                                *
*      -->P_O_COL  text                                                *
*----------------------------------------------------------------------*
FORM sub_determine_class TABLES   p_source1 TYPE x_t_code
                     USING    p_source_name
                              p_o_objectname
                              p_o_row
                              p_o_col
                     CHANGING p_class.
  FIELD-SYMBOLS: <f>.
  DATA: row LIKE tk-row,
        strucname TYPE ddobjname,
        compname TYPE dfies-fieldname,
        dfies_wa TYPE dfies,
        dfies_tab TYPE STANDARD TABLE OF dfies,
        new_pos TYPE sy-tabix,
        col LIKE tk-col,
        extern_class_flag,
        object_found,
        l_source1 TYPE x_t_code,
        incl LIKE trdir-name,
        l_row LIKE sy-index,
        l_col LIKE sy-index,
        l_incl LIKE trdir-name,
        l_program LIKE sy-repid,
        l_event(62),
        l_eventtype(1),
        l_class(62),
        l_classtype(1),
        l_local,
        l_objectname(60),
        l_objecttype(2),
        l_operation(10),
        wrd(30),
        msg(255),
        l_wa_tokens TYPE stokesx.

  UNASSIGN <abap_source>.
  PERFORM sub_scan_abap_source USING p_source_name.

  IF NOT <abap_source> IS ASSIGNED.
    EXIT.
  ENDIF.

  IF sy-subrc = 0.
    READ TABLE <abap_source>-tokens WITH KEY row = p_o_row
                                             col = p_o_col
                                    INTO l_wa_tokens.

    IF ( l_wa_tokens-str = p_o_objectname AND sy-subrc = 0 )
      OR
       ( p_o_objectname CS l_wa_tokens-str AND sy-subrc = 0 ).

      sy-tabix = sy-tabix + 1.
      READ TABLE <abap_source>-tokens INTO l_wa_tokens INDEX sy-tabix.
      IF l_wa_tokens-str = 'TYPE' OR l_wa_tokens-str = 'LIKE'.
        sy-tabix = sy-tabix + 1.
        READ TABLE <abap_source>-tokens INTO l_wa_tokens INDEX sy-tabix.
        IF l_wa_tokens-str = 'REF'.
          sy-tabix = sy-tabix + 1.
          READ TABLE <abap_source>-tokens INTO l_wa_tokens
          INDEX sy-tabix.
          IF l_wa_tokens-str = 'TO'.
            sy-tabix = sy-tabix + 1.
            READ TABLE <abap_source>-tokens INTO l_wa_tokens
            INDEX sy-tabix.
            p_class = l_wa_tokens-str.
          ENDIF.
        ELSE.
          CALL FUNCTION 'RS_NAVIGATION_PREPARE'
            EXPORTING
              i_col        = l_wa_tokens-col
              i_editor     = 'EDTR'
              i_incl       = o_incl
              i_row        = l_wa_tokens-row
            IMPORTING
              o_col        = l_col
              o_event      = l_event
              o_eventtype  = l_eventtype
              o_class      = l_class
              o_classtype  = l_classtype
              o_incl       = l_incl
              o_local      = l_local
              o_objectname = l_objectname
              o_objecttype = l_objecttype
              o_operation  = l_operation
              o_program    = l_program
              o_row        = l_row
            TABLES
              i_source     = p_source1.

          IF l_operation = 'DEFINITION' AND l_incl NE space.
            IF l_incl NE o_incl.
              READ REPORT l_incl INTO l_source1 STATE 'I'.
              IF sy-subrc NE 0.
                READ REPORT l_incl INTO l_source1.
                o_state = 'A'.
              ELSE.
                o_state = 'I'.
              ENDIF.
            ELSE.
              l_source1[] = p_source1[].
            ENDIF.
            IF p_o_objectname CA '-'.
              ASSIGN p_o_objectname+sy-fdpos(*) TO <f>.
              CONCATENATE l_objectname <f> INTO l_objectname.
            ENDIF.
            CALL FUNCTION 'RS_OBJECT_POSITION'
              EXPORTING
                object_name      = l_objectname
                object_type      = 'Y'
              IMPORTING
                col              = l_col
                row              = l_row
              TABLES
                SOURCE           = l_source1
              EXCEPTIONS
                object_not_found = 1
                OTHERS           = 2.
            IF sy-subrc <> 0.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              PERFORM sub_determine_class
                          TABLES
                             l_source1
                          USING
                             p_source_name
                             l_objectname
                             l_row
                             l_col
                          CHANGING
                             p_class.

            ENDIF.
          ELSE.
            IF o_operation NE space AND l_objecttype = '|'. "#EC *
              IF p_o_objectname CS '-'.
                strucname = l_objectname.
                new_pos = sy-fdpos + 1.
                compname  = p_o_objectname+new_pos(*).
                CALL FUNCTION 'DDIF_FIELDINFO_GET'
                  EXPORTING
                    tabname        = strucname
                    fieldname      = compname
                    all_types      = 'X'
                  IMPORTING
                    dfies_wa       = dfies_wa
                  TABLES
                    dfies_tab      = dfies_tab
                  EXCEPTIONS
                    not_found      = 1
                    internal_error = 2
                    OTHERS         = 3.
                IF sy-subrc <> 0.
                ELSE.
                  READ TABLE dfies_tab INTO dfies_wa INDEX 1 .
                  IF sy-subrc = 0 AND dfies_wa-comptype = 'R'.
                    l_class = dfies_wa-rollname.
                    extern_class_flag = 'X'.
                    l_classtype = 'L'.
                    object_found = 'X'.
                  ENDIF.
                ENDIF.
              ENDIF.
            ELSE.

            ENDIF.
            p_class = l_class.
          ENDIF.
        ENDIF.
      ENDIF.
    ELSEIF o_eventtype = 'F' AND o_local NE space.
      READ TABLE p_source1 INDEX p_o_row.
      IF sy-subrc = 0.
        line_char = p_source1.
        IF p_source1 CS 'TYPE REF TO'.
          ASSIGN line_char+sy-fdpos(*) TO <f>.
          ASSIGN <f>+12(*) TO <f>.
          SHIFT <f> LEFT DELETING LEADING ' '.
          IF <f> CA ' '.
            IF sy-fdpos > 0.
              ASSIGN <f>(sy-fdpos) TO <f>.
              p_class = <f>.
            ENDIF.
          ELSE.
            IF sy-fdpos > 0.
              ASSIGN <f>(sy-fdpos) TO <f>.
            ENDIF.
            p_class = <f>.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    " SUB_DETERMINE_CLASS

*&---------------------------------------------------------------------*
*&      Form  SUB_DOT_END
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_L_IN_SELECT  text
*      <--P_L_IN_CSTAR  text
*      <--P_L_I_SELECT  text
*----------------------------------------------------------------------*
FORM sub_dot_end  CHANGING p_in_select TYPE char1
                           p_in_cstar  TYPE char1
                           p_i_select  TYPE x_zselect_ty.

  DATA: l_wa_select_info TYPE x_zselect_info,
        l_db_no TYPE i,
        l_wa_dbtab TYPE x_zdbtab_name,
        l_wa_table_fields TYPE x_ztable_field_name.

  IF p_in_select = 'X' AND p_in_cstar = space.

    l_wa_select_info-i_select[] = p_i_select[].
    REFRESH p_i_select.
    v_sequence = v_sequence + 1.
    l_wa_select_info-sequence = v_sequence.
    v_sub_seq = v_sub_seq + 1.
    l_wa_select_info-sub_seq = v_sub_seq.
    l_wa_select_info-event_code = v_event_code.
    APPEND l_wa_select_info TO i_select_info.
*    l_db_no = LINES( wa_select_info-i_dbtab ).
    DESCRIBE TABLE wa_select_info-i_dbtab LINES l_db_no.

    IF l_db_no = 1.
      READ TABLE l_wa_select_info-i_dbtab INTO l_wa_dbtab
      INDEX 1.

      l_wa_table_fields-tabname = l_wa_dbtab-dbtab_name.
      MODIFY i_table_fields FROM l_wa_table_fields
      TRANSPORTING tabname WHERE tabname IS INITIAL.
    ENDIF.
  ELSEIF p_in_select = 'X'.
    CLEAR p_in_cstar.
  ENDIF.
  p_in_select = space.

ENDFORM.                    " SUB_DOT_END

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_PROGRAM_COMPO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_IN_P_PROG  text
*      <--P_I_COMPO  text
*----------------------------------------------------------------------*
FORM sub_get_program_compo  USING    p_in_p_prog
                            CHANGING p_i_nodetab TYPE snodetab.

  DATA:
  l_i_cross_ref TYPE STANDARD TABLE OF cross,
  l_treename TYPE eu_t_name,
  l_i_inc       TYPE STANDARD TABLE OF d010inc.

  DATA i_mainprograms TYPE STANDARD TABLE OF char255 .
  DATA wa_mainprograms LIKE LINE OF i_mainprograms.


  CALL FUNCTION 'RS_GET_MAINPROGRAMS'
    EXPORTING
      name         = p_in_p_prog
    TABLES
      mainprograms = i_mainprograms
    EXCEPTIONS
      cancelled    = 1
      OTHERS       = 2.
  IF sy-subrc = 0.

    READ TABLE i_mainprograms INTO wa_mainprograms INDEX 1.

    IF sy-subrc = 0.
      CONCATENATE 'PG_' wa_mainprograms INTO l_treename.
    ELSE.
      CONCATENATE 'PG_' p_in_p_prog INTO l_treename.
    ENDIF.
  ELSE.
    CONCATENATE 'PG_' p_in_p_prog INTO l_treename.
  ENDIF.

  CALL FUNCTION 'WB_TREE_ACTUALIZE'
    EXPORTING
      tree_name = l_treename.

  CALL FUNCTION 'WB_TREE_SELECT'
    EXPORTING
      treename  = l_treename
    TABLES
      nodetab   = p_i_nodetab
    EXCEPTIONS
      not_found = 1
      OTHERS    = 2.

  IF sy-subrc = 0.
    SORT p_i_nodetab BY type name.
  ENDIF.

ENDFORM.                    " SUB_GET_PROGRAM_COMPO

*&---------------------------------------------------------------------*
*&      Form  SUB_GO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_IN_P_PROG  text
*      -->P_0027   text
*----------------------------------------------------------------------*
FORM sub_go  USING    p_prog TYPE char40
                      p_wher TYPE char30.

* Creating message
  PERFORM sub_create_message USING p_prog
                                   p_wher.

* Sending Message
  PERFORM sub_send_message.

ENDFORM.                    " SUB_GO

*&---------------------------------------------------------------------*
*&      Form  create_message
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM sub_create_message USING p_prog TYPE char40
                              p_wher TYPE char30.

**1 Title, Description & Body
  PERFORM sub_create_title_desc_body USING p_prog
                                           p_wher.
**2 Receivers
  PERFORM sub_fill_receivers.

ENDFORM.                    " create_message

*&---------------------------------------------------------------------*
*&      Form  CREATE_TITLE_DESC_BODY
*&---------------------------------------------------------------------*
*       Title, Description and body
*----------------------------------------------------------------------*
FORM sub_create_title_desc_body USING p_prog TYPE char40
                                      p_wher TYPE char30.

*...Title
  wa_docdata-obj_name  = 'Email notification'.

*...Description
  wa_docdata-obj_descr = 'OLE Tool'.

  CONCATENATE 'Program : ' p_prog INTO wa_objtxt-line.
  APPEND wa_objtxt TO t_objtxt.

  CONCATENATE 'Usage : ' p_wher INTO wa_objtxt-line.
  APPEND wa_objtxt TO t_objtxt.

  CONCATENATE 'User : ' sy-uname INTO wa_objtxt-line.
  APPEND wa_objtxt TO t_objtxt.

  CONCATENATE 'Date : ' sy-datum INTO wa_objtxt-line.
  APPEND wa_objtxt TO t_objtxt.
* Document data
  DESCRIBE TABLE t_objtxt      LINES w_tab_lines.
  READ     TABLE t_objtxt      INTO wa_objtxt INDEX w_tab_lines.
  wa_docdata-doc_size =
      ( w_tab_lines - 1 ) * 255 + STRLEN( wa_objtxt ).

* Packing data
  CLEAR wa_objpack-transf_bin.
  wa_objpack-head_start = 1.
  wa_objpack-head_num   = 0.
  wa_objpack-body_start = 1.
  wa_objpack-body_num   = w_tab_lines.
  wa_objpack-doc_type   = 'HTML'.
  APPEND wa_objpack TO t_objpack.

ENDFORM.                    " CREATE_TITLE_DESC_BODY

*&---------------------------------------------------------------------*
*&      Form  fill_receivers
*&---------------------------------------------------------------------*
*       Filling up the Receivers
*----------------------------------------------------------------------*
FORM sub_fill_receivers .

  wa_reclist-rec_type = 'U'.
  wa_reclist-receiver = 'sayak.nandy@in.ibm.com'.
  APPEND wa_reclist TO t_reclist.
  CLEAR  wa_reclist.

ENDFORM.                    " fill_receivers

*&---------------------------------------------------------------------*
*&      Form  send_message
*&---------------------------------------------------------------------*
*       Sending Mail
*----------------------------------------------------------------------*
FORM sub_send_message .

* Send Message to external Internet ID
  CALL FUNCTION 'SO_NEW_DOCUMENT_ATT_SEND_API1'
    EXPORTING
      document_data              = wa_docdata
      put_in_outbox              = 'X'
      commit_work                = 'X'     "used from rel.6.10
    TABLES
      packing_list               = t_objpack
      object_header              = t_objhead
      contents_txt               = t_objtxt
      receivers                  = t_reclist
    EXCEPTIONS
      too_many_receivers         = 1
      document_not_sent          = 2
      document_type_not_exist    = 3
      operation_no_authorization = 4
      parameter_error            = 5
      x_error                    = 6
      enqueue_error              = 7
      OTHERS                     = 8.

ENDFORM.                    " send_message

*&---------------------------------------------------------------------*
*&      Form  SUB_DELETE_ITAB_OFFSET
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_WA_SELECT_INFO_V_INT_TAB  text
*----------------------------------------------------------------------*
FORM sub_delete_itab_offset  CHANGING p_int_tab TYPE any.

  DATA: l_len  TYPE syfdpos,
        l_off  TYPE syfdpos,
        l_flag TYPE char1,
        l_size TYPE syfdpos.

  l_len = STRLEN( p_int_tab ).

  IF p_int_tab+0(2) = p_form_p."'P_'.
    REPLACE FIRST OCCURRENCE OF p_form_p  IN p_int_tab WITH space. "'P_'
  ENDIF.
  IF p_int_tab+0(2) = p_i_loc.
    REPLACE FIRST OCCURRENCE OF p_i_loc   IN p_int_tab WITH space.
  ENDIF.
  IF p_int_tab+0(2) = p_itab_d.
    REPLACE FIRST OCCURRENCE OF p_itab_d  IN p_int_tab WITH space.
  ENDIF.

  LOOP AT s_itab_e.
    l_size = STRLEN( s_itab_e-low ).
    IF l_len GE l_size.
      l_off = l_len - l_size.
      IF p_int_tab+l_off(l_size) = s_itab_e-low.
        p_int_tab+l_off(l_size) = space.
        l_flag = 'X'.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " SUB_DELETE_ITAB_OFFSET

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_OP_TYPE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_OPERAND_OP  text
*      <--P_L_WA_OPERAND_TYPE  text
*----------------------------------------------------------------------*
FORM sub_populate_op_type  USING    p_op   TYPE char100
                           CHANGING p_type TYPE seu_type.

  DATA: l_wa_nodetab  TYPE snodetext.

  READ TABLE i_nodetab INTO l_wa_nodetab
                       WITH KEY name = p_op
                                type = v_op_dd
                                TRANSPORTING type.
  IF sy-subrc = 0.
    p_type = l_wa_nodetab-type.
  ENDIF.

ENDFORM.                    " SUB_POPULATE_OP_TYPE

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_OPERAND
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WHERE_FLD_TABIX  text
*      <--P_L_WA_OPERAND       text
*      <--P_L_WA_OP            text
*      <--P_P_I_OP             text
*----------------------------------------------------------------------*
FORM sub_populate_operand  USING    p_where_fld_tabix TYPE sytabix
                           CHANGING p_wa_operand TYPE x_zoperands
                                    p_wa_op TYPE x_zwhere_field_name
                                    p_i_op  TYPE x_zwhere_field_name_ty.

  PERFORM sub_analyse_operand CHANGING p_wa_operand-op.
  PERFORM sub_populate_op_type USING p_wa_operand-op
                            CHANGING p_wa_operand-type.
  IF NOT p_wa_operand-op IS INITIAL.
    APPEND p_wa_operand TO p_wa_op-operand.
  ENDIF.

  MODIFY p_i_op FROM p_wa_op INDEX p_where_fld_tabix
  TRANSPORTING operand.

ENDFORM.                    " SUB_POPULATE_OPERAND

*&---------------------------------------------------------------------*
*&      Form  SUB_PROCESS_IN_OPERAND
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WHERE_FLD_TABIX  text
*      <--P_L_WA_OPERAND  text
*      <--P_P_I_OP  text
*----------------------------------------------------------------------*
FORM sub_process_in_operand  USING    p_where_fld_tabix TYPE sytabix
                             CHANGING p_wa_operand TYPE x_zoperands
                                      p_i_op TYPE
x_zwhere_field_name_ty.

  DATA: l_wa_op TYPE x_zwhere_field_name.

  READ TABLE p_i_op INTO l_wa_op INDEX p_where_fld_tabix.

  IF sy-subrc = 0.
*   Process operand
    PERFORM sub_process_operand USING p_where_fld_tabix
                             CHANGING p_wa_operand
                                      p_i_op.
  ENDIF.

ENDFORM.                    " SUB_PROCESS_IN_OPERAND

*&---------------------------------------------------------------------*
*&      Form  SUB_POPULATE_ALIAS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WORD  text
*      <--P_P_I_DBTAB  text
*----------------------------------------------------------------------*
FORM sub_populate_alias  USING    p_word    TYPE char255
                         CHANGING p_i_dbtab TYPE x_zdbtab_name_ty.
  DATA:
  l_cnt             TYPE sytabix,
  l_wa_dbtab        TYPE x_zdbtab_name.

*  l_cnt = LINES( p_i_dbtab ).
  DESCRIBE TABLE p_i_dbtab LINES l_cnt.

  l_wa_dbtab-alias = p_word.

  IF l_cnt NE 0.
    MODIFY p_i_dbtab FROM l_wa_dbtab INDEX l_cnt
    TRANSPORTING alias.
  ENDIF.

  READ TABLE p_i_dbtab INTO l_wa_dbtab INDEX l_cnt.
  IF sy-subrc = 0.
    wa_table_fields-tabname = l_wa_dbtab-dbtab_name.
    MODIFY i_table_fields FROM wa_table_fields TRANSPORTING tabname
                         WHERE tabname EQ l_wa_dbtab-alias.
  ENDIF.

ENDFORM.                    " SUB_POPULATE_ALIAS

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_LOCAL_STRUC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_ITAB  text
*      -->P_P_TABIX  text
*----------------------------------------------------------------------*
FORM sub_get_local_struc  USING    p_wa_itab TYPE x_zitab
                                   p_row     TYPE sytabix
                                   p_col     TYPE token_col
                                   p_i_code  TYPE x_t_code
                                   p_i_nodetab TYPE snodetab
                        CHANGING   p_structure TYPE char100
                                   p_type1 TYPE seu_type.

  DATA l_i_changed TYPE c .
  DATA l_i_col TYPE c .
  DATA l_i_editor TYPE c .
  DATA l_i_incl TYPE sy-repid .
  DATA l_i_operation TYPE c .
  DATA l_i_row TYPE c .
  DATA l_i_mainprogram TYPE sy-repid .
  DATA l_i_trdir TYPE trdir .
  DATA l_i_context TYPE REF TO cl_wb_context .
  DATA l_no_dialog TYPE c .
  DATA l_error_navigation TYPE c .
  DATA: l_i_fcode TYPE c ,
        l_wa_code  TYPE x_code,
    l_nav_object      TYPE REF TO cl_abap_compiler,
    l_dynnr           TYPE char4,
    l_class(62)       TYPE c,
    l_classtype       TYPE char1,
    l_state           TYPE char1,
    l_objecttype      TYPE char2,
    l_objectname      TYPE seu_objkey,
    l_ioperation      TYPE char10,
    l_operation       TYPE char10,
    l_row             TYPE i,
    l_col             TYPE i,
    l_word  TYPE char255,
    l_in_type TYPE char1,
    l_in_of TYPE char1,
    l_found  TYPE char1,
    l_wa_itab TYPE x_zitab,
    l_structure TYPE char100,
    l_in_structure TYPE char1,
    l_local           TYPE char1,
    l_incl            TYPE trdir-name,
    l_program         TYPE sy-repid,
    l_messagetext     TYPE edmessage,
    l_event           TYPE seu_objkey,
    l_eventtype       TYPE char2,
    l_fullname        TYPE string.


  CALL FUNCTION 'RS_NAVIGATION_PREPARE'
    EXPORTING
      i_col         = p_col
      i_editor      = 'EDTR'
      i_incl        = l_i_incl
      i_operation   = 'DEFINITION'
      i_row         = p_row
      i_mainprogram = l_i_mainprogram
    IMPORTING
      o_col         = l_col
      o_dynnr       = l_dynnr
      o_event       = l_event
      o_eventtype   = l_eventtype
      o_class       = l_class
      o_classtype   = l_classtype
      o_incl        = l_incl
      o_local       = l_local
      o_objectname  = l_objectname
      o_objecttype  = l_objecttype
      o_operation   = l_operation
      o_program     = l_program
      o_row         = l_row
      o_messagetext = l_messagetext
      o_state       = l_state
    TABLES
      i_source      = p_i_code.

  LOOP AT p_i_code INTO l_wa_code FROM l_row.

    REPLACE ALL OCCURRENCES OF
    cl_abap_char_utilities=>horizontal_tab IN
    l_wa_code WITH '# #'.
    REPLACE ALL OCCURRENCES OF '#' IN l_wa_code WITH space.

    IF l_wa_code-line+0(1) = '*'.
      CONTINUE.
    ENDIF.
    TRANSLATE l_wa_code-line TO UPPER CASE.
    DO.
      CLEAR l_word.
      PERFORM sub_first_word CHANGING l_wa_code
                                      l_word.

      IF l_word = space.
        EXIT.
      ENDIF.

      CASE l_word.
        WHEN 'TYPE'.
          l_in_type = 'X'.
        WHEN 'STANDARD' OR 'TABLE' OR 'HASHED'.
        WHEN 'OF'.
          l_in_of = 'X'.
          l_in_type = space.
        WHEN 'STRUCTURE'.
          l_in_structure = 'X'.
        WHEN p_wa_itab-itab.
        WHEN OTHERS.
          CASE 'X'.
            WHEN l_in_type.
              l_structure = l_word.
*             Here its a table type
              PERFORM sub_get_tt_struc USING p_i_nodetab
                                    CHANGING l_structure
                                             p_structure.
              l_found = 'X'.
              EXIT.
            WHEN l_in_of.
              p_structure = l_word.
              l_found = 'X'.
              EXIT.
            WHEN l_in_structure.
              PERFORM sub_get_wa_struc CHANGING l_word
                                                p_structure.
              l_found = 'X'.
              EXIT.
          ENDCASE.
      ENDCASE.
    ENDDO.
    IF l_found = 'X'.
      EXIT.
    ELSE.
      l_wa_itab-itab = l_structure.
      REPLACE ALL OCCURRENCES OF '.' IN l_wa_itab-itab WITH
      space.
      REPLACE ALL OCCURRENCES OF ',' IN l_wa_itab-itab WITH
      space.
      PERFORM sub_get_structure USING l_wa_itab
                                      'Y'
                                      p_i_nodetab
                                 CHANGING  p_structure
                                           p_type1.

      IF NOT p_structure IS INITIAL.
        EXIT.
      ELSE.
*          BREAK-POINT.
        EXIT.
      ENDIF.
    ENDIF.
  ENDLOOP.

  REPLACE ALL OCCURRENCES OF ',' IN p_structure WITH space.
  REPLACE ALL OCCURRENCES OF '.' IN p_structure WITH space.

ENDFORM.                    " SUB_GET_LOCAL_STRUC

*----------------------------------------------------------------------*
***INCLUDE LZOLE_AUTOF02 .
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  SUB_SCAN_CODE_FOR_MGS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WA_CODE_INFO_CODE  text
*      -->P_IN_START_INDEX  text
*      -->P_IN_END_INDEX  text
*----------------------------------------------------------------------*
FORM sub_scan_code_for_msg  USING    p_i_code TYPE x_t_code
                             p_start_index TYPE sytabix
                             p_end_index TYPE sytabix.

  DATA:
    l_wa_code  TYPE x_code,
    l_wa_code1  TYPE x_code,
    l_wa_code_caps TYPE x_code,
    l_word  TYPE char255,
    l_word1  TYPE char255,
    l_in_msg TYPE char1,
    l_in_report TYPE char1,
    l_str TYPE string,
    l_in_select TYPE char1,
    l_out_report TYPE char1,
    l_in_with TYPE char1,
    l_exit_flag TYPE char1,
    l_form_name TYPE seu_name,
    l_i_code TYPE x_t_code,
    l_start_position TYPE sy-tabix,
    l_end_position TYPE sy-tabix,
    l_message_d    TYPE char1,
    l_source_name TYPE char100.

  STATICS: l_level TYPE i VALUE 1,
           l_msg_class TYPE arbgb.

  IF l_level = 1.

    LOOP AT p_i_code INTO l_wa_code.

      l_wa_code_caps = l_wa_code.
      TRANSLATE l_wa_code_caps-line TO UPPER CASE.

      REPLACE ALL OCCURRENCES OF
      cl_abap_char_utilities=>horizontal_tab IN
      l_wa_code WITH '# #'.
      REPLACE ALL OCCURRENCES OF '#' IN l_wa_code WITH space.

      IF l_wa_code-line IS INITIAL OR
         l_wa_code-line+0(1) = '*' OR l_wa_code-line+0(1) = '"'.
        CONTINUE.
      ENDIF.

      IF l_wa_code_caps+0(6) = 'REPORT'.
        l_in_report = 'X'.
      ENDIF.
      IF l_in_report = 'X'.
        DO.
          CLEAR l_word.
          PERFORM sub_first_word CHANGING l_wa_code
                                          l_word.
          IF l_word CA '.'.
            l_out_report = 'X'.
            EXIT.
          ENDIF.

          IF l_word = space.
            EXIT.
          ENDIF.

          IF l_word = 'MESSAGE-ID'.
            CLEAR l_word.
            PERFORM sub_first_word CHANGING l_wa_code
                                            l_word.
            REPLACE ALL OCCURRENCES OF '.' IN l_word WITH space.

            l_msg_class = l_word.
            TRANSLATE l_msg_class TO UPPER CASE.
            l_out_report = 'X'.
            EXIT.
          ENDIF.
        ENDDO.

        IF l_out_report = 'X'.
          EXIT.
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDIF.

  LOOP AT p_i_code INTO l_wa_code FROM p_start_index.

    l_wa_code_caps = l_wa_code.
    TRANSLATE l_wa_code_caps-line TO UPPER CASE.

    IF NOT p_end_index IS INITIAL.
      IF sy-tabix GT p_end_index.
        EXIT.
      ENDIF.
    ENDIF.

    IF l_wa_code-line IS INITIAL OR l_wa_code-line+0(1) = '*'
      OR l_wa_code-line+0(1) = '"'.
      CONTINUE.
    ENDIF.

    IF l_wa_code_caps-line+0(4) = 'FORM' OR
       l_wa_code_caps-line+0(7) = 'ENDFORM'.
      EXIT.
    ENDIF.

*    TRANSLATE l_wa_code-line TO UPPER CASE.

    IF l_in_msg = space.
      CLEAR l_word.
      PERFORM sub_first_word CHANGING l_wa_code
                                      l_word.

      IF l_word = 'PERFORM'.
        PERFORM sub_form_name USING l_wa_code
                           CHANGING l_form_name.

        TRANSLATE l_form_name TO UPPER CASE.

        IF ( i_r_perform IS INITIAL ) OR
                   ( NOT i_r_perform IS INITIAL AND
                     NOT l_form_name IN i_r_perform ).

          wa_r_perform-sign = 'I'.
          wa_r_perform-option = 'EQ'.
          wa_r_perform-low = l_form_name.
          APPEND wa_r_perform TO i_r_perform.

          PERFORM sub_code_position USING l_form_name
                                 CHANGING l_i_code
                                          l_start_position
                                          l_end_position
                                          l_source_name.

          l_level = l_level + 1.
          PERFORM sub_scan_code_for_msg USING l_i_code
                                      l_start_position
                                      space.

          DELETE i_r_perform WHERE low = l_form_name.

          l_level = l_level - 1.

        ENDIF.

        CONTINUE.

      ENDIF.

    ENDIF.  "IF l_in_msg = space.

    IF l_word = 'MESSAGE' OR l_in_msg = 'X'.
      l_in_msg = 'X'.

      l_wa_code1 = l_wa_code.
      IF l_word1 IS INITIAL.
        PERFORM sub_first_word CHANGING l_wa_code1
                                      l_word1.
      ENDIF.

      IF l_word1+0(1) = ''''
      OR l_word1+0(4) = 'text'
      OR l_word1+0(4) = 'TEXT'
      OR l_message_d = c_check.

        l_message_d = c_check.
        PERFORM sub_process_message_d USING  l_word1
                                    CHANGING l_wa_code
                                             l_in_msg
                                             l_message_d.

        CLEAR:l_word1.

      ELSE.

        CLEAR l_exit_flag.
        PERFORM sub_process_msg   USING  l_msg_class
                                CHANGING l_wa_code
                                         l_in_msg.

        IF l_in_msg = space.
          CLEAR:l_word1.
        ENDIF.
      ENDIF.

    ENDIF.

    CLEAR l_word.

  ENDLOOP.

ENDFORM.                    " SUB_SCAN_CODE_FOR_MGS

*&---------------------------------------------------------------------*
*&      Form  SUB_PROCESS_MSG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_L_WA_CODE  text
*      <--P_L_IN_MSG  text
*----------------------------------------------------------------------*
FORM sub_process_msg   USING   p_msg_class TYPE arbgb
                      CHANGING p_wa_code TYPE x_code
                               p_in_msg TYPE char1.

  DATA:
  l_word  TYPE char255.

  STATICS:
  l_in_with TYPE char1,
*  l_msg_no TYPE numc4 VALUE 0,
  l_count TYPE i,
  l_msg_no TYPE char3,
  l_str1 TYPE string,
  l_str2 TYPE string,
  l_dummy TYPE string,
  l_quote TYPE char1 VALUE '''',
  l_msg_class TYPE arbgb,
  l_msg_type TYPE char1,
  l_fd_pos TYPE syfdpos,
  l_msg1 TYPE char100.

  DO.
    CLEAR l_word.

    IF l_in_with = 'X'.
      IF p_wa_code IS NOT INITIAL.
        PERFORM sub_first_text CHANGING p_wa_code
                                        l_word
                                        l_count.
      ENDIF.
    ELSE.
      IF p_wa_code+0(4) = 'WITH'.
        p_wa_code = p_wa_code+4.
        CONCATENATE 'WITH' p_wa_code INTO p_wa_code
        SEPARATED BY space.
      ENDIF.
      PERFORM sub_first_word CHANGING p_wa_code
                                  l_word.
    ENDIF.

    IF l_word CA '.' OR l_word+0(1) = '"' OR l_word IS INITIAL.
      IF l_word CA '.'.

        IF l_count = 1 OR l_count = 2 OR
           l_count = 3 OR l_count = 4.

          CLEAR wa_msg_info.
          wa_msg_info-msg_type = l_msg_type.
          IF NOT l_msg_no CA sy-abcde.
            wa_msg_info-msgno = l_msg_no.
          ENDIF.
          TRANSLATE wa_msg_info-msg_type TO UPPER CASE.

          IF l_word CA '.' AND STRLEN( l_word ) GT 1.
            SHIFT l_word RIGHT DELETING TRAILING '.'.

            REPLACE ALL OCCURRENCES OF '.' IN l_word WITH space.

            CONCATENATE l_msg1 l_word INTO l_msg1
                        SEPARATED BY space.
            SHIFT l_msg1 LEFT DELETING LEADING space.

          ENDIF.

*          CONCATENATE l_msg1 l_word INTO l_msg1
*                        SEPARATED BY space.
          wa_msg_info-msg = l_msg1.
          wa_msg_info-msg_class = l_msg_class.
          READ TABLE i_msg_info
          WITH KEY msg_type = wa_msg_info-msg_type
                   msg = wa_msg_info-msg
                   msg_class = wa_msg_info-msg_class
                   msgno = wa_msg_info-msgno
                   TRANSPORTING NO FIELDS.
          IF sy-subrc <> 0.
            IF wa_msg_info-msg IS INITIAL.
              CALL FUNCTION 'FORMAT_MESSAGE'
                EXPORTING
                  id        = wa_msg_info-msg_class
                  lang      = sy-langu
                  no        = wa_msg_info-msgno
                  v1        = '&'
                  v2        = '&'
                  v3        = '&'
                  v4        = '&'
                IMPORTING
                  msg       = wa_msg_info-msg
                EXCEPTIONS
                  not_found = 1
                  OTHERS    = 2.

              IF sy-subrc <> 0.
                CLEAR wa_msg_info-msg.
              ENDIF.

            ENDIF.
            APPEND wa_msg_info TO i_msg_info.
            CLEAR wa_msg_info.   "MOD
          ENDIF.

          p_in_msg = space.
          l_in_with = space.

        ENDIF.

      ENDIF.

      EXIT.

    ELSE.
      REPLACE ALL OCCURRENCES OF '#' IN l_word WITH '.'.
    ENDIF.

    CASE l_word.
      WHEN 'WITH'.
        l_in_with = 'X'.
        l_count = 0.
        CLEAR l_msg1.
      WHEN 'DISPLAY'.
        CLEAR p_in_msg.
        EXIT.
      WHEN 'LIKE'.
        CLEAR p_in_msg.
        EXIT.
      WHEN 'RAISING'.
        CLEAR p_in_msg.
        EXIT.
      WHEN 'INTO'.
        CLEAR p_in_msg.
        EXIT.
      WHEN OTHERS.
        IF l_in_with = space.
          l_msg_type = l_word+0(1).
          l_word = l_word+1.
          l_msg_no = l_word+0(3).
          SEARCH l_word FOR '('.
          IF sy-subrc = 0.
            l_fd_pos = sy-fdpos + 1.
            l_word = l_word+l_fd_pos.
            SEARCH l_word FOR ')'.
            IF sy-subrc = 0.
              l_fd_pos = sy-fdpos.
              l_msg_class = l_word+0(l_fd_pos).
              TRANSLATE l_msg_class TO UPPER CASE.
            ENDIF.
          ELSE.
            IF NOT l_word CA sy-abcde.
              l_msg_class = p_msg_class.
            ENDIF.
          ENDIF.
        ELSE.  "IF l_in_with = space.
          l_count = l_count + 1.
          IF l_count = 1 OR l_count = 2 OR
             l_count = 3 OR l_count = 4.

            CONCATENATE l_msg1 l_word INTO l_msg1
                        SEPARATED BY space.
            SHIFT l_msg1 LEFT DELETING LEADING space.
          ENDIF.
        ENDIF.
    ENDCASE.

  ENDDO.

ENDFORM.                    " SUB_PROCESS_MSG

*&---------------------------------------------------------------------*
*&      Form  SUB_FIRST_TEXT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_P_WA_CODE  text
*      <--P_L_WORD  text
*----------------------------------------------------------------------*
FORM sub_first_text  CHANGING p_wa_code TYPE x_code
                              p_word TYPE char255
                              p_count TYPE i.

  DATA: l_quote TYPE char1 VALUE '''',
        l_fdpos TYPE syfdpos,
        l_wa_text_pool TYPE textpool,
        l_word2 TYPE char255,
        l_type TYPE char255,
        l_end_pos TYPE syfdpos,
        l_textno TYPE char8.

  SEARCH p_wa_code FOR '"'.
  IF sy-subrc = 0.
    p_wa_code = p_wa_code+0(sy-fdpos).
  ENDIF.

  SEARCH p_wa_code FOR l_quote.

  IF sy-subrc = 0.

    l_fdpos = sy-fdpos + 1.
    p_wa_code = p_wa_code+l_fdpos.

    PERFORM sub_get_msg
                USING
                   p_wa_code-line
                CHANGING
                   p_word
                   l_end_pos.

    REPLACE ALL OCCURRENCES OF '.' IN p_word WITH '#'.

    l_end_pos = l_end_pos + 1.
    p_wa_code = p_wa_code+l_end_pos.

    SEARCH p_wa_code FOR ')'.
    IF sy-subrc = 0.
      l_fdpos = sy-fdpos + 1.
      p_wa_code = p_wa_code+l_fdpos.
    ENDIF.

  ELSE.
    PERFORM sub_first_word CHANGING p_wa_code
                                    p_word.
    TRANSLATE p_word TO UPPER CASE.
    IF p_word+0(5) = 'TEXT-'.
      l_textno = p_word+5.
      REPLACE ALL OCCURRENCES OF '.' IN l_textno WITH space.
      READ TABLE i_text_pool INTO l_wa_text_pool
      WITH KEY key = l_textno.

      IF sy-subrc = 0.
        p_word = l_wa_text_pool-entry.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    " SUB_FIRST_TEXT

*----------------------------------------------------------------------*
***INCLUDE LZOLE_AUTOF04 .
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  SUB_GET_STRUCTURE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_ITAB  text
*      -->P_L_STRUCTURE  text
*----------------------------------------------------------------------*
FORM sub_get_structure  USING  p_wa_itab   TYPE x_zitab
                               p_type      TYPE seu_type
                               p_i_nodetab TYPE snodetab
                      CHANGING p_structure TYPE char100
                               p_type1     TYPE seu_type.

  DATA: l_wa_nodetab TYPE snodetext,
        l_cursor_line TYPE sytabix,
        l_wa_code  TYPE x_code,
        l_wa_itab TYPE x_zitab,
        l_word  TYPE char255,
        l_opd   TYPE char1,
        l_structure TYPE char100,
        l_found  TYPE char1,
        l_in_type TYPE char1,
        l_in_of TYPE char1,
        l_wa_code_info LIKE x_code_info.

*******CHANGE
  READ TABLE p_i_nodetab INTO l_wa_nodetab
  WITH KEY type = p_type
           name = p_wa_itab-itab.

  IF sy-subrc = 0.

    READ TABLE i_code_info INTO l_wa_code_info
         WITH KEY name = l_wa_nodetab-hide.

    IF sy-subrc = 0.
    ELSE.
      READ REPORT l_wa_nodetab-hide INTO l_wa_code_info-code.
      l_wa_code_info-name = l_wa_nodetab-hide.
      INSERT l_wa_code_info INTO TABLE i_code_info.
    ENDIF.

    IF p_type = v_op_dd.
      l_opd = 'D'.
    ELSEIF p_type = v_op_yy.
      l_opd = 'Y'.
    ENDIF.

    CALL FUNCTION 'RS_OBJECT_POSITION'
      EXPORTING
        object_name      = p_wa_itab-itab  "I_KNVP
        object_type      = l_opd       "D/Y
      IMPORTING
        row              = l_cursor_line
      TABLES
        SOURCE           = l_wa_code_info-code
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.

    LOOP AT l_wa_code_info-code
    INTO l_wa_code FROM l_cursor_line.

      REPLACE ALL OCCURRENCES OF
      cl_abap_char_utilities=>horizontal_tab IN
      l_wa_code WITH '# #'.
      REPLACE ALL OCCURRENCES OF '#' IN l_wa_code WITH space.

      IF l_wa_code-line+0(1) = '*'.
        CONTINUE.
      ENDIF.
      TRANSLATE l_wa_code-line TO UPPER CASE.
      DO.
        CLEAR l_word.
        PERFORM sub_first_word CHANGING l_wa_code
                                        l_word.

        IF l_word = space.
          EXIT.
        ENDIF.

        CASE l_word.
          WHEN 'TYPE' OR 'TYPES'.
            l_in_type = 'X'.
          WHEN 'STANDARD' OR 'TABLE' OR 'HASHED'.
          WHEN 'OF'.
            l_in_of = 'X'.
            l_in_type = space.
          WHEN p_wa_itab-itab.
          WHEN OTHERS.
            CASE 'X'.
              WHEN l_in_type.
                l_structure = l_word.
                EXIT.
              WHEN l_in_of.
                p_structure = l_word.
                l_found = 'X'.
                EXIT.
            ENDCASE.
        ENDCASE.
      ENDDO.
      IF l_found = 'X'.
        EXIT.
      ELSE.
        l_wa_itab-itab = l_structure.
        REPLACE ALL OCCURRENCES OF '.' IN l_wa_itab-itab WITH
        space.
        REPLACE ALL OCCURRENCES OF ',' IN l_wa_itab-itab WITH
        space.
        PERFORM sub_get_structure USING l_wa_itab
                                        v_op_yy
                                        p_i_nodetab
                                   CHANGING  p_structure
                                             p_type1.

        IF NOT p_structure IS INITIAL.
          EXIT.
        ELSE.
*          BREAK-POINT.
          EXIT.
        ENDIF.
      ENDIF.
    ENDLOOP.

  ELSEIF p_type = 'Y'.  "Its a global table type
    p_structure = p_wa_itab-itab.
    p_type1     = 'T'.
  ENDIF.

  REPLACE ALL OCCURRENCES OF ',' IN p_structure WITH space.
  REPLACE ALL OCCURRENCES OF '.' IN p_structure WITH space.

ENDFORM.                    " SUB_GET_STRUCTURE

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_STRUCTURE_FLDS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_STRUCTURE  text
*      <--P_L_WA_ITAB_INFO  text
*----------------------------------------------------------------------*
FORM sub_get_structure_flds
   USING p_wa_itab TYPE x_zitab
         p_structure TYPE char100
         p_type TYPE seu_type
CHANGING p_wa_itab_info TYPE x_zitab_info.

  DATA: l_wa_nodetab  TYPE snodetext,
        l_cursor_line TYPE sytabix,
        l_wa_itab TYPE x_ztabinfo,
        l_tabix TYPE sytabix,
        l_wa_code  TYPE x_code,
        l_wa_code1  TYPE x_code,
        l_wa_code2  TYPE x_code,
        l_word  TYPE char255,
        l_end TYPE char1,
        l_in_fld TYPE char1,
        l_structure TYPE char100,
        l_found  TYPE char1,
        l_struc TYPE char1,
        l_in_type TYPE char1,
        l_in_of TYPE char1,
        l_string TYPE string,
        l_dummy  TYPE string,
        l_wa_code_info LIKE x_code_info.

*  BREAK-POINT.
********CHANGE
  READ TABLE i_nodetab1 INTO l_wa_nodetab
    WITH KEY type = v_op_yy
             name = p_structure.

  IF sy-subrc = 0.

    READ TABLE i_code_info INTO l_wa_code_info
         WITH KEY name = l_wa_nodetab-hide.

    IF sy-subrc = 0.
    ELSE.
      READ REPORT l_wa_nodetab-hide INTO l_wa_code_info-code.
      l_wa_code_info-name = l_wa_nodetab-hide.
      INSERT l_wa_code_info INTO TABLE i_code_info.
    ENDIF.

    CALL FUNCTION 'RS_OBJECT_POSITION'
      EXPORTING
        object_name      = p_structure  "I_KNVP
        object_type      = 'Y'       "D
*        fullname         = l_fullname
      IMPORTING
*        col              = cursor_offset
        row              = l_cursor_line
      TABLES
        SOURCE           = l_wa_code_info-code
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.

    p_wa_itab_info-tab_name = p_wa_itab-itab.

    l_in_fld = 'X'.

    LOOP AT l_wa_code_info-code
    INTO l_wa_code FROM l_cursor_line.
      IF l_wa_code-line+0(1) = '*'.
        CONTINUE.
      ENDIF.
      l_wa_code1 = l_wa_code.
      l_tabix = sy-tabix + 1.
      TRANSLATE l_wa_code-line TO UPPER CASE.
      DO.
        CLEAR l_word.
        PERFORM sub_first_word CHANGING l_wa_code
                                        l_word.

        REPLACE ALL OCCURRENCES OF ',' IN l_word WITH space.

        IF l_word = space OR l_word = ','.
          l_in_fld = 'X'.
          IF l_struc = space.
            READ TABLE l_wa_code_info-code INTO l_wa_code2
            INDEX l_tabix.

            PERFORM sub_get_fld_label USING l_wa_code1
                                   CHANGING l_wa_code2
                                            l_wa_itab-fld_label.

            APPEND l_wa_itab TO p_wa_itab_info-tabinfo.
            CLEAR l_wa_itab.
          ELSE.
            CLEAR l_struc.
          ENDIF.
          EXIT.
        ENDIF.

        IF l_word = p_structure.
          EXIT.
        ENDIF.

        CASE l_word.
          WHEN 'TYPE'.
            l_in_type = 'X'.
          WHEN 'BEGIN' OR 'OF'.
          WHEN 'END'.
            l_end = 'X'.
            EXIT.
          WHEN OTHERS.
            CASE 'X'.
              WHEN l_in_type.
                REPLACE ALL OCCURRENCES OF ',' IN
                l_word WITH space.
                IF l_word CA '-'. "Table-field
                  PERFORM sub_get_tab_fld USING p_wa_itab
                                                l_word
                                       CHANGING l_wa_itab.
                  CLEAR l_in_type.
                ELSEIF l_wa_itab-fld_name CA '('.
                  SPLIT l_wa_itab-fld_name AT '(' INTO
                  l_string l_dummy.
                  CLEAR l_string.
                  SPLIT l_dummy AT ')' INTO l_string l_dummy.
                  SHIFT l_string LEFT DELETING LEADING '0'.
                  SEARCH l_wa_itab-fld_name FOR '('.
                  l_wa_itab-fld_name = l_wa_itab-fld_name+0(sy-fdpos).
                  CASE l_word.
                    WHEN 'C'.
                      l_wa_itab-datatype = 'CHAR'.
                      l_wa_itab-leng = l_string.
                    WHEN 'N'.
                      l_wa_itab-datatype = 'NUMC'.
                      l_wa_itab-leng = l_string.
                    WHEN OTHERS. "Later
                  ENDCASE.
                ELSE.  "Direct data element
                  PERFORM sub_get_del_fld USING p_wa_itab
                                                l_word
                                       CHANGING l_wa_itab
                                                p_wa_itab_info-tabinfo
                                                l_struc.
                  CLEAR l_in_type.
                ENDIF.
              WHEN l_in_fld.
                l_wa_itab-fld_name = l_word.
                CLEAR l_in_fld.
            ENDCASE.
        ENDCASE.
      ENDDO.

      IF l_end = 'X'.
        CLEAR l_end.
        EXIT.
      ENDIF.

    ENDLOOP.

  ELSE.  "Its a global structure
    IF p_type = 'T'.
      PERFORM sub_get_global_tt USING p_structure
                             CHANGING l_wa_itab
                                      p_wa_itab_info-tabinfo
                                      l_struc.
    ELSE.
      PERFORM sub_get_global_struct USING p_structure
                                 CHANGING l_wa_itab
                                          p_wa_itab_info-tabinfo
                                          l_struc.
    ENDIF.
  ENDIF.

ENDFORM.                    " SUB_GET_STRUCTURE_FLDS

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_TAB_FLD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WORD  text
*      <--P_P_WA_ITAB_INFO  text
*----------------------------------------------------------------------*
FORM sub_get_tab_fld  USING    p_wa_itab  TYPE x_zitab
                               p_word     TYPE char255
                      CHANGING p_wa_itab1 TYPE x_ztabinfo.
  DATA:
        l_tab TYPE ddobjname,
        l_fld TYPE ddobjname,
        l_wa_tb_tab_struc TYPE x_zibm_table_structure,
        l_wa_itab TYPE x_ztabinfo,
        l_wa_table_info TYPE x_zibm_table_info,
        l_wa_struc LIKE x_tb_tab_struc.

  SPLIT p_word AT '-' INTO l_tab l_fld.

  READ TABLE i_tb_tab_struc INTO l_wa_struc WITH TABLE KEY
  tabname = l_tab.

  IF sy-subrc <> 0.

    PERFORM sub_z_ibm_get_table_details
                USING l_tab
                CHANGING l_wa_table_info
                   l_wa_struc-i_info.

    IF NOT l_wa_struc-i_info IS INITIAL.
      DELETE l_wa_struc-i_info WHERE fieldname+0(1) = '.'.
      l_wa_struc-tabname = l_tab.
      INSERT l_wa_struc INTO TABLE i_tb_tab_struc.
    ENDIF.

  ENDIF.

  READ TABLE l_wa_struc-i_info INTO l_wa_tb_tab_struc
  WITH KEY fieldname = l_fld.

  IF sy-subrc = 0.

    p_wa_itab1-tab_name = l_tab.
    p_wa_itab1-fld_name = l_wa_tb_tab_struc-fieldname.
    p_wa_itab1-datatype = l_wa_tb_tab_struc-datatype.
    p_wa_itab1-leng     = l_wa_tb_tab_struc-length.
    p_wa_itab1-decimals = l_wa_tb_tab_struc-decimals.
    p_wa_itab1-fld_desc = l_wa_tb_tab_struc-fieldtext.

  ENDIF.

ENDFORM.                    " SUB_GET_TAB_FLD

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_DEL_FLD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_WA_ITAB  text
*      -->P_L_WORD  text
*      <--P_L_WA_ITAB  text
*----------------------------------------------------------------------*
FORM sub_get_del_fld  USING    p_wa_itab  TYPE x_zitab
                               p_word     TYPE char255
                      CHANGING p_wa_itab1 TYPE x_ztabinfo
                               p_i_tab    TYPE x_ztabinfo_ty
                               p_struc    TYPE char1.

  DATA: l_wa_data_ele TYPE x_zibm_dataelement_info,
        l_data_ele TYPE ddobjname.

  l_data_ele = p_word.

  READ TABLE i_data_ele INTO l_wa_data_ele WITH TABLE KEY
  object_id = p_word.

  IF sy-subrc <> 0.

    PERFORM sub_z_ibm_get_dataele_details
                USING l_data_ele
                CHANGING l_wa_data_ele.

    IF NOT l_wa_data_ele IS INITIAL.
      INSERT l_wa_data_ele INTO TABLE i_data_ele.
    ELSE.
      PERFORM sub_get_struct_dtls USING p_word
                               CHANGING p_i_tab.
      p_struc = 'X'.
      EXIT.
    ENDIF.

  ENDIF.

*p_wa_itab1-tab_name = l_wa_data_ele-tabname.
*    p_wa_itab1-fld_name = l_wa_data_ele-fieldname.
  p_wa_itab1-datatype = l_wa_data_ele-datatype.
  p_wa_itab1-leng     = l_wa_data_ele-length.
  p_wa_itab1-decimals = l_wa_data_ele-decimals.
  p_wa_itab1-fld_desc = l_wa_data_ele-object_text.

ENDFORM.                    " SUB_GET_DEL_FLD

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_FLD_LABEL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WA_CODE1  text
*      -->P_L_WA_CODE2  text
*      <--P_L_WA_ITAB_FLD_LABEL  text
*----------------------------------------------------------------------*
FORM sub_get_fld_label  USING    p_wa_code1  TYPE x_code
                     CHANGING    p_wa_code2  TYPE x_code
                                 p_fld_label TYPE char100.

  DATA: l_fdpos TYPE syfdpos.

  SEARCH p_wa_code1-line FOR '"'.

  IF sy-subrc = 0.
    l_fdpos = sy-fdpos + 1.
    p_fld_label = p_wa_code1-line+l_fdpos.
  ENDIF.

  SHIFT p_wa_code2-line LEFT DELETING LEADING space.

  IF p_wa_code2-line+0(1) = '"'.
    CONCATENATE p_fld_label p_wa_code2-line+1 INTO p_fld_label.
  ENDIF.

ENDFORM.                    " SUB_GET_FLD_LABEL

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_STRUCT_DTLS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_WORD  text
*      <--P_P_I_TAB  text
*----------------------------------------------------------------------*
FORM sub_get_struct_dtls  USING    p_word  TYPE char255
                          CHANGING p_i_tab TYPE x_ztabinfo_ty.

  DATA: l_wa_struc LIKE x_tb_tab_struc,
        l_wa_tb_tab_struc TYPE x_zibm_table_structure,
        l_wa_itab  TYPE x_ztabinfo,
        l_wa_ex_struc_info TYPE x_zibm_struc_info,
        l_tabname TYPE tabname.

  l_tabname = p_word.

  READ TABLE i_tb_tab_struc INTO l_wa_struc WITH TABLE KEY
    tabname = l_tabname.

  IF sy-subrc <> 0.

    PERFORM sub_z_ibm_get_struc_details
                USING l_tabname
                CHANGING l_wa_ex_struc_info
                   l_wa_struc-i_info.

    IF NOT l_wa_struc-i_info IS INITIAL.
      DELETE l_wa_struc-i_info WHERE fieldname+0(1) = '.'.

      LOOP AT l_wa_struc-i_info INTO l_wa_tb_tab_struc.
        l_wa_itab-tab_name = l_wa_tb_tab_struc-tabname.
        l_wa_itab-fld_name = l_wa_tb_tab_struc-fieldname.
        l_wa_itab-datatype = l_wa_tb_tab_struc-datatype.
        l_wa_itab-leng     = l_wa_tb_tab_struc-length.
        l_wa_itab-decimals = l_wa_tb_tab_struc-decimals.
        l_wa_itab-fld_desc = l_wa_tb_tab_struc-fieldtext.
        APPEND l_wa_itab TO p_i_tab.
      ENDLOOP.
    ENDIF.

  ENDIF.



ENDFORM.                    " SUB_GET_STRUCT_DTLS

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_GLOBAL_STRUCT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_STRUCTURE  text
*      <--P_L_WA_ITAB  text
*      <--P_P_WA_ITAB_INFO_TABINFO  text
*      <--P_L_STRUC  text
*----------------------------------------------------------------------*
FORM sub_get_global_struct  USING    p_structure TYPE char100
                            CHANGING p_wa_itab   TYPE x_ztabinfo
                                     p_i_tab     TYPE x_ztabinfo_ty
                                     p_struc     TYPE char1.

  DATA l_word TYPE char255.

  l_word = p_structure.
  PERFORM sub_get_struct_dtls USING l_word
                           CHANGING p_i_tab.
  p_struc = 'X'.

ENDFORM.                    " SUB_GET_GLOBAL_STRUCT

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_GLOBAL_TT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_STRUCTURE  text
*      <--P_L_WA_ITAB  text
*      <--P_P_WA_ITAB_INFO_TABINFO  text
*      <--P_L_STRUC  text
*----------------------------------------------------------------------*
FORM sub_get_global_tt USING    p_structure TYPE char100
                            CHANGING p_wa_itab   TYPE x_ztabinfo
                                     p_i_tab     TYPE x_ztabinfo_ty
                                     p_struc     TYPE char1.

  DATA l_word TYPE char255.

  l_word = p_structure.
  PERFORM sub_get_tt_dtls USING l_word
                       CHANGING p_i_tab.
  p_struc = 'X'.

ENDFORM.                    " SUB_GET_GLOBAL_TT

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_TT_DTLS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_WORD  text
*      <--P_P_I_TAB  text
*----------------------------------------------------------------------*
FORM sub_get_tt_dtls  USING    p_word  TYPE char255
                          CHANGING p_i_tab TYPE x_ztabinfo_ty.

  DATA: l_wa_struc LIKE x_tb_tab_struc,
        l_wa_tb_tab_struc TYPE x_zibm_table_structure,
        l_wa_itab  TYPE x_ztabinfo,
        l_wa_tabletype_info TYPE x_zibm_tabletype_info,
        l_wa_ex_struc_info TYPE x_zibm_struc_info,
        l_tabname TYPE tabname.

  l_tabname = p_word.

  PERFORM sub_z_ibm_get_tabtype_details
              USING l_tabname
              CHANGING l_wa_tabletype_info.

  IF NOT l_wa_tabletype_info IS INITIAL.

    READ TABLE i_tb_tab_struc INTO l_wa_struc WITH TABLE KEY
      tabname = l_wa_tabletype_info-rowtype.

    IF sy-subrc <> 0.
      PERFORM sub_z_ibm_get_struc_details
                  USING l_tabname
                  CHANGING l_wa_ex_struc_info
                     l_wa_struc-i_info.

      IF NOT l_wa_struc-i_info IS INITIAL.
        DELETE l_wa_struc-i_info WHERE fieldname+0(1) = '.'.

        LOOP AT l_wa_struc-i_info INTO l_wa_tb_tab_struc.
          l_wa_itab-tab_name = l_wa_tb_tab_struc-tabname.
          l_wa_itab-fld_name = l_wa_tb_tab_struc-fieldname.
          l_wa_itab-datatype = l_wa_tb_tab_struc-datatype.
          l_wa_itab-leng     = l_wa_tb_tab_struc-length.
          l_wa_itab-decimals = l_wa_tb_tab_struc-decimals.
          l_wa_itab-fld_desc = l_wa_tb_tab_struc-fieldtext.
          APPEND l_wa_itab TO p_i_tab.
        ENDLOOP.
      ENDIF.

    ENDIF.

  ENDIF.

ENDFORM.                    " SUB_GET_TT_DTLS

**********************************************************************
* FORM    :  ENDFORM
* Created :  23.07.2009 14:22:55
**********************************************************************
FORM sub_z_get_prog_info USING in_p_prog      TYPE  progname
                               in_start_index TYPE  sytabix
                               in_end_index   TYPE  sytabix
                               in_fm_flag     TYPE  char1
                               in_sub_call     TYPE char1
                    CHANGING ep_select_info TYPE  x_zselect_info_ty
                               ep_table_fields  TYPE
x_ztable_field_name_ty
                               ep_table_desc  TYPE  x_zdbtab_text_ty
                               ep_field_desc  TYPE  x_zfield_desc_ty
                               ep_fm_call_info  TYPE  x_zfm_call_info_ty
                               ep_sub_call_info	TYPE
x_zperform_call_info_ty.


  DATA:
    l_current_treename TYPE dwtree-name,
    l_langu            TYPE sylangu,
    l_i_table          TYPE x_ztable_field_name_ty,
    l_i_table1         TYPE x_ztable_field_name_ty,
    l_start_index      TYPE sytabix.

  IF in_fm_flag = 'F'.
    v_op_tt = 'OFU'.
    v_op_dd = 'OFD'.
    v_op_yy = 'OFY'.
  ELSE.
    v_op_tt = 'OPU'.
    v_op_dd = 'OPD'.
    v_op_yy = 'OPY'.
  ENDIF.

* Get space variable
  PERFORM sub_cal_space.

* Get the code
  REFRESH i_code_info.
  CLEAR wa_code_info.
  wa_code_info-name = in_p_prog.
  READ REPORT in_p_prog INTO wa_code_info-code.
* Insert the code
  INSERT wa_code_info INTO TABLE i_code_info.
* Get the code tree
  PERFORM sub_get_program_compo USING in_p_prog
                             CHANGING i_nodetab.

* refresh program buffers
  REFRESH: i_select_info[],i_table_fields[],i_r_perform[].
  CLEAR: v_sequence.

* set fm call flag
*  IF ep_fm_call_info IS REQUESTED.
  REFRESH i_fm_info[].
  v_fm = 'X'.
*  ENDIF.

  IF in_sub_call = 'X'.
    REFRESH i_sub_call_info[].
  ENDIF.

* scan code and populate info
  PERFORM sub_scan_code USING wa_code_info-name
                              wa_code_info-code
                              in_start_index
                              in_end_index.

  ep_select_info[] = i_select_info[].
  SORT i_table_fields BY tabname.

* Get the other table field infos from database
  IF NOT i_table_fields[] IS INITIAL.

    SELECT tabname
           fieldname
           position
           keyflag
           rollname
           datatype
           leng
           decimals
    INTO TABLE l_i_table
    FROM dd03l
    FOR ALL ENTRIES IN i_table_fields
    WHERE tabname = i_table_fields-tabname
      AND fieldname = i_table_fields-fieldname.

    IF sy-subrc = 0.

      SORT l_i_table BY tabname position.

      ep_table_fields[] = l_i_table[].

      l_i_table1[] = l_i_table[].
      DELETE ADJACENT DUPLICATES FROM l_i_table1 COMPARING tabname.

      SELECT tabname
             ddtext
      INTO TABLE ep_table_desc
      FROM dd02t
      FOR ALL ENTRIES IN l_i_table1
      WHERE tabname = l_i_table1-tabname
        AND ddlanguage = sy-langu.

      l_i_table1[] = l_i_table[].
      DELETE ADJACENT DUPLICATES FROM l_i_table1 COMPARING rollname.

      SELECT rollname
             ddtext
      INTO TABLE ep_field_desc
      FROM dd04t
      FOR ALL ENTRIES IN l_i_table1
      WHERE rollname = l_i_table1-rollname
        AND ddlanguage = sy-langu.

    ENDIF.

  ENDIF.

* Populate fm info
*  IF ep_fm_call_info IS REQUESTED.
  ep_fm_call_info[] = i_fm_info[].
*  ENDIF.

* Populate sub-routine call info
  IF in_sub_call = 'X'.
    ep_sub_call_info[] = i_sub_call_info[].
  ENDIF.

*  perform sub_go using in_p_prog
*                       'Z_GET_PROG_INFO'.


ENDFORM. "ENDFORM

**********************************************************************
* FORM    :  ENDFORM
* Created :  23.07.2009 14:31:16
**********************************************************************
FORM sub_z_get_prog_msg_info USING in_p_prog  TYPE  progname
                                   in_start_index TYPE  sytabix
                                   in_end_index TYPE  sytabix
                                   in_fm_flag TYPE  char1
                     CHANGING ep_msg_info TYPE  x_zmsg_info_ty.

  DATA: l_current_treename TYPE dwtree-name,
          l_langu TYPE sylangu,
          l_start_index TYPE sytabix.

  IF in_fm_flag = 'F'.
    v_op_tt = 'OFU'.
    v_op_dd = 'OFD'.
    v_op_yy = 'OFY'.
  ELSE.
    v_op_tt = 'OPU'.
    v_op_dd = 'OPD'.
    v_op_yy = 'OPY'.
  ENDIF.

  PERFORM sub_cal_space.

  CLEAR wa_code_info.
  wa_code_info-name = in_p_prog.
  READ REPORT in_p_prog INTO wa_code_info-code.

  READ TEXTPOOL in_p_prog INTO i_text_pool LANGUAGE sy-langu.

  INSERT wa_code_info INTO TABLE i_code_info.

  PERFORM sub_get_program_compo USING in_p_prog
                               CHANGING i_nodetab.

  REFRESH: i_msg_info[],i_r_perform[].

  PERFORM sub_scan_code_for_msg USING wa_code_info-code
                              in_start_index
                              in_end_index.

  ep_msg_info[] = i_msg_info[].


ENDFORM. "ENDFORM


**********************************************************************
* FORM    :  ENDFORM
* Created :  23.07.2009 14:33:13
**********************************************************************
FORM sub_z_get_prog_tab_info USING in_p_prog  TYPE  progname
                                   in_i_itabs TYPE  x_zitab_ty
                                   in_fm_flag TYPE  char1
                     CHANGING itab_info TYPE  x_zitab_info_ty.


  DATA: l_current_treename LIKE dwtree-name,
        l_langu            TYPE sylangu,
        l_wa_itab          TYPE x_zitab,
        l_wa_itab_info     TYPE x_zitab_info,
        l_type             TYPE seu_type,
        l_structure        TYPE char100.

  IF in_fm_flag = 'F'.
    v_op_tt = 'OFU'.
    v_op_dd = 'OFD'.
    v_op_yy = 'OFY'.
  ELSE.
    v_op_tt = 'OPU'.
    v_op_dd = 'OPD'.
    v_op_yy = 'OPY'.
  ENDIF.

  REFRESH i_code_info.

* Get code tree
  PERFORM sub_get_program_compo USING in_p_prog
                             CHANGING i_nodetab1.

* For all the tables get the tab info
  LOOP AT in_i_itabs INTO l_wa_itab.

    CLEAR l_type.
*   Get the table structure
    PERFORM sub_get_structure USING l_wa_itab
                                    v_op_dd
                                    i_nodetab1
                           CHANGING l_structure
                                    l_type.

    IF NOT l_structure IS INITIAL.
      REPLACE ALL OCCURRENCES OF '.' IN l_structure WITH space.
      REPLACE ALL OCCURRENCES OF ',' IN l_structure WITH space.
*     Get structure fields
      PERFORM sub_get_structure_flds USING l_wa_itab
                                           l_structure
                                           l_type
                                  CHANGING l_wa_itab_info.

      l_wa_itab_info-tab_name = l_wa_itab-itab.
      APPEND l_wa_itab_info TO itab_info.
    ENDIF.

  ENDLOOP.

ENDFORM. "ENDFORM

**********************************************************************
* FORM    :  endform
* Created :  23.07.2009 14:36:24
**********************************************************************
FORM sub_z_ibm_get_table_details USING  im_object_id  TYPE  ddobjname
         CHANGING p_wa_ex_table_info TYPE  x_zibm_table_info
                  p_i_tb_tab_struc   TYPE  x_zibm_table_structure_ty.


*Local Data Declaration
  DATA :
    l_i_tab_structure TYPE STANDARD TABLE OF dd03p ,
    l_rec_tab_info  TYPE dd02v ,
    l_rec_cust_tab_structure  TYPE x_zibm_table_structure,
    l_v_devclass TYPE devclass,
    l_wa_ex_table_info TYPE x_zibm_table_info.

*Field Symbols declaration
  FIELD-SYMBOLS :
    <l_rec_tab_structure>  TYPE dd03p.

*This FM rtrieves information on table attributes
*and table fields
  CALL FUNCTION 'DDIF_TABL_GET'
    EXPORTING
      name          = im_object_id
      state         = 'A'
      langu         = sy-langu
    IMPORTING
      dd02v_wa      = l_rec_tab_info
    TABLES
      dd03p_tab     = l_i_tab_structure
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.

  IF sy-subrc <> 0.
*    RAISE no_data_found.
    MESSAGE i398 WITH 'No data found'.
    LEAVE LIST-PROCESSING.
  ENDIF.

*Populating export parameters
  p_wa_ex_table_info-object_id     =  l_rec_tab_info-tabname.
  p_wa_ex_table_info-object_text   =  l_rec_tab_info-ddtext.
  p_wa_ex_table_info-tabclass      =  l_rec_tab_info-tabclass.
  p_wa_ex_table_info-clidep        =  l_rec_tab_info-clidep.
  p_wa_ex_table_info-buffered      =  l_rec_tab_info-buffered.
  p_wa_ex_table_info-mainflag      =  l_rec_tab_info-mainflag.
  p_wa_ex_table_info-deliveryclass =  l_rec_tab_info-contflag.

**Retrieves information about the development class
*  SELECT  SINGLE  devclass FROM tadir
*             INTO l_v_devclass
*             WHERE pgmid = 'R3TR' AND
*                   object = c_table_type AND
*                   obj_name = im_object_id.
*  IF sy-subrc = 0.
*    l_wa_ex_table_info-devclass = l_v_devclass.
*  ENDIF.

*Populating table TB_TAB_STRUC with informations on
*basic structure of the tables
  LOOP AT l_i_tab_structure ASSIGNING <l_rec_tab_structure>.
    l_rec_cust_tab_structure-tabname          =
    <l_rec_tab_structure>-tabname.
    l_rec_cust_tab_structure-fieldname        =
    <l_rec_tab_structure>-fieldname.
    l_rec_cust_tab_structure-is_primary_key   =
    <l_rec_tab_structure>-keyflag.
    l_rec_cust_tab_structure-dataelement      =
    <l_rec_tab_structure>-rollname.
    l_rec_cust_tab_structure-checktable       =
    <l_rec_tab_structure>-checktable.
    l_rec_cust_tab_structure-domname          =
    <l_rec_tab_structure>-domname.
    l_rec_cust_tab_structure-length           =
    <l_rec_tab_structure>-leng.
    l_rec_cust_tab_structure-inttype          =
    <l_rec_tab_structure>-inttype.
    l_rec_cust_tab_structure-datatype         =
    <l_rec_tab_structure>-datatype.
    l_rec_cust_tab_structure-decimals         =
    <l_rec_tab_structure>-decimals.
    l_rec_cust_tab_structure-fieldtext        =
    <l_rec_tab_structure>-ddtext.
    APPEND l_rec_cust_tab_structure TO p_i_tb_tab_struc.
    CLEAR l_rec_cust_tab_structure.
  ENDLOOP.

ENDFORM. "endform

**********************************************************************
* FORM    :  endform
* Created :  23.07.2009 14:46:57
**********************************************************************
FORM sub_z_ibm_get_dataele_details USING im_object_id TYPE  ddobjname
      CHANGING p_ex_dataele_info  TYPE x_zibm_dataelement_info.


*Local Data declaration
  DATA :
    l_rec_dataele_info  TYPE  dd04v,
    l_v_devclass TYPE devclass,
    l_wa_ex_dataele_info TYPE x_zibm_dataelement_info.

*The function module retrieves attribute details of the data
*elements whose name is passed as a parameter
  CALL FUNCTION 'DDIF_DTEL_GET'
    EXPORTING
      name          = im_object_id
      state         = 'A'
      langu         = sy-langu
    IMPORTING
      dd04v_wa      = l_rec_dataele_info
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.
  IF sy-subrc <> 0.
*    RAISE no_data_found.
    MESSAGE i398 WITH 'No data found'.
    LEAVE LIST-PROCESSING.
  ENDIF.

*Populating the export parameter
  p_ex_dataele_info-object_id    = l_rec_dataele_info-rollname.
  p_ex_dataele_info-object_text  = l_rec_dataele_info-ddtext.
  p_ex_dataele_info-domname      = l_rec_dataele_info-domname.
  p_ex_dataele_info-shlpname     = l_rec_dataele_info-shlpname.
  p_ex_dataele_info-shlpfield    = l_rec_dataele_info-shlpfield.
  p_ex_dataele_info-datatype     = l_rec_dataele_info-datatype.
  p_ex_dataele_info-length       = l_rec_dataele_info-leng.
  p_ex_dataele_info-decimals     = l_rec_dataele_info-decimals.

**Retrieves the devclass corresponding to the object id
*  SELECT  SINGLE  devclass FROM tadir
*             INTO l_v_devclass
*             WHERE pgmid = 'R3TR' AND
*                   object = c_dataele_type AND
*                   obj_name = im_object_id.
*  IF sy-subrc = 0.
*    p_ex_dataele_info-devclass = l_v_devclass.
*  ENDIF.

ENDFORM. "endform

**********************************************************************
* FORM    :  endform
* Created :  23.07.2009 14:51:38
**********************************************************************
FORM sub_z_ibm_get_struc_details USING im_object_id TYPE  ddobjname
       CHANGING p_wa_ex_struc_info  TYPE x_zibm_struc_info
                p_i_tb_tab_struc  TYPE x_zibm_table_structure_ty.

*Local Data declaration
  DATA :
    l_i_tab_structure TYPE STANDARD TABLE OF dd03p ,
    l_rec_tab_info  TYPE dd02v ,
    l_rec_cust_tab_structure  TYPE x_zibm_table_structure,
    l_v_devclass TYPE devclass,
    l_wa_ex_struc_info TYPE x_zibm_struc_info.

*Field Symbols decalration
  FIELD-SYMBOLS :
    <l_rec_tab_structure>  TYPE dd03p.


*retrieves the attribute details and field details of
*the structure whose name is passed through the input parameter
  CALL FUNCTION 'DDIF_TABL_GET'
    EXPORTING
      name          = im_object_id
      state         = 'A'
      langu         = sy-langu
    IMPORTING
      dd02v_wa      = l_rec_tab_info
    TABLES
      dd03p_tab     = l_i_tab_structure
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.

  IF sy-subrc <> 0.
*    RAISE no_data_found.
    MESSAGE i398 WITH 'No data found'.
    LEAVE LIST-PROCESSING.
  ENDIF.

*populating the export parameter
  p_wa_ex_struc_info-object_id     =  l_rec_tab_info-tabname.
  p_wa_ex_struc_info-object_text   =  l_rec_tab_info-ddtext.
  p_wa_ex_struc_info-tabclass      =  l_rec_tab_info-tabclass.
  p_wa_ex_struc_info-sqltab        =  l_rec_tab_info-sqltab.
  p_wa_ex_struc_info-clidep        =  l_rec_tab_info-clidep.
  p_wa_ex_struc_info-buffered      =  l_rec_tab_info-buffered.
  p_wa_ex_struc_info-mainflag      =  l_rec_tab_info-mainflag.

*Retrieves information about the development class

*  SELECT  SINGLE  devclass FROM tadir
*             INTO l_v_devclass
*             WHERE pgmid = 'R3TR' AND
*                   object = c_table_type AND
*                   obj_name = im_object_id.
*  IF sy-subrc = 0.
*    l_wa_ex_struc_info-devclass = l_v_devclass.
*  ENDIF.

*Populating information on basic structure of fields of the
*structure in the table TB_TAB_STRUC
  LOOP AT l_i_tab_structure ASSIGNING <l_rec_tab_structure>.
    l_rec_cust_tab_structure-tabname          =
    <l_rec_tab_structure>-tabname.
    l_rec_cust_tab_structure-fieldname        =
    <l_rec_tab_structure>-fieldname.
    l_rec_cust_tab_structure-is_primary_key   =
    <l_rec_tab_structure>-keyflag.
    l_rec_cust_tab_structure-dataelement      =
    <l_rec_tab_structure>-rollname.
    l_rec_cust_tab_structure-checktable       =
    <l_rec_tab_structure>-checktable.
    l_rec_cust_tab_structure-domname          =
    <l_rec_tab_structure>-domname.
    l_rec_cust_tab_structure-length           =
    <l_rec_tab_structure>-leng.
    l_rec_cust_tab_structure-inttype          =
    <l_rec_tab_structure>-inttype.
    l_rec_cust_tab_structure-datatype         =
    <l_rec_tab_structure>-datatype.
    l_rec_cust_tab_structure-decimals         =
    <l_rec_tab_structure>-decimals.
    l_rec_cust_tab_structure-fieldtext        =
    <l_rec_tab_structure>-ddtext.
    APPEND l_rec_cust_tab_structure TO p_i_tb_tab_struc.
    CLEAR l_rec_cust_tab_structure.
  ENDLOOP.

ENDFORM. "endform

**********************************************************************
* FORM    :  endform
* Created :  23.07.2009 14:56:18
**********************************************************************
FORM sub_z_ibm_get_tabtype_details USING im_object_id TYPE  ddobjname
        CHANGING p_wa_ex_tabletype_info TYPE x_zibm_tabletype_info.

*Local Data
  DATA :
    l_rec_tabletype_info  TYPE  dd40v,
    l_v_devclass TYPE devclass,
    l_wa_ex_tabletype_info TYPE x_zibm_tabletype_info.

*Retrives table type info of the table whose name is
*passed as a parameter.
  CALL FUNCTION 'DDIF_TTYP_GET'
    EXPORTING
      name                = im_object_id
      state               = 'A'
      langu               = sy-langu
   IMPORTING
      dd40v_wa            = l_rec_tabletype_info
* TABLES
*   DD42V_TAB           =
   EXCEPTIONS
     illegal_input       = 1
     OTHERS              = 2.


  IF sy-subrc <> 0.
*    RAISE no_data_found.
    MESSAGE i398 WITH 'No data found'.
    LEAVE LIST-PROCESSING.
  ENDIF.

*Populaitng export parameters
  p_wa_ex_tabletype_info-object_id    = l_rec_tabletype_info-typename.
  p_wa_ex_tabletype_info-object_text  = l_rec_tabletype_info-ddtext.
  p_wa_ex_tabletype_info-rowtype  = l_rec_tabletype_info-rowtype.
  p_wa_ex_tabletype_info-rowkind  = l_rec_tabletype_info-rowkind.
  p_wa_ex_tabletype_info-datatype     = l_rec_tabletype_info-datatype.
  p_wa_ex_tabletype_info-length       = l_rec_tabletype_info-leng.
  p_wa_ex_tabletype_info-decimals     = l_rec_tabletype_info-decimals.
  p_wa_ex_tabletype_info-accessmode  = l_rec_tabletype_info-accessmode.
  p_wa_ex_tabletype_info-keydef  = l_rec_tabletype_info-keydef.
  p_wa_ex_tabletype_info-keykind  = l_rec_tabletype_info-keykind.
  p_wa_ex_tabletype_info-keyfdcount  = l_rec_tabletype_info-keyfdcount.
  p_wa_ex_tabletype_info-typelen  = l_rec_tabletype_info-typelen.
*  ex_tabletype_info-reftype  = l_rec_tabletype_info-reftype.

**Retrieves information about the development class
*  SELECT  SINGLE  devclass FROM tadir
*             INTO l_v_devclass
*             WHERE pgmid = 'R3TR' AND
*                   object = c_tabletype_type AND
*                   obj_name = im_object_id.
*  IF sy-subrc = 0.
*    l_wa_ex_tabletype_info-devclass = l_v_devclass.
*  ENDIF.

ENDFORM. "endform
*&---------------------------------------------------------------------*
*&      Form  SUB_GET_PROGRAM_NAME
*&---------------------------------------------------------------------*
*       Subroutine to get prog name from fm name
*----------------------------------------------------------------------*
*    <--P_P_FNAME1  text
*----------------------------------------------------------------------*
FORM sub_get_program_name USING p_funcname TYPE rs38l_fnam
                       CHANGING p_prog TYPE progname.

  TYPES:
  BEGIN OF l_x_tfdir,
    funcname TYPE rs38l_fnam , " Name of Function Module
    pname    TYPE pname ,      " Program Name
    appl     TYPE rs38l_appl , " Application to which function module is
                               " assigned
  END OF l_x_tfdir.

  DATA : l_i_nodetab TYPE STANDARD TABLE OF snodetext,
         l_wa_tfdir   TYPE l_x_tfdir,
         l_treename TYPE dirtree-tname,
         l_wa_nodetab TYPE snodetext.

  SELECT SINGLE
         funcname   " Name of Function Module
         pname      " Program Name
         appl       " Application to which function module is assigned
         INTO l_wa_tfdir
         FROM tfdir WHERE funcname = p_funcname.
  IF sy-subrc = 0.
    CONCATENATE l_treename 'PG_' l_wa_tfdir-pname INTO l_treename.

    CALL FUNCTION 'WB_TREE_SELECT'
      EXPORTING
        treename  = l_treename
      TABLES
        nodetab   = l_i_nodetab
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.

    IF sy-subrc = 0.

      READ TABLE l_i_nodetab INTO l_wa_nodetab
      WITH KEY name = p_funcname
               type = 'OFF'.
      IF sy-subrc = 0.
        p_prog = l_wa_nodetab-hide+0(40).
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    " SUB_GET_PROGRAM_NAME
*&---------------------------------------------------------------------*
*&      Form  sub_do_shading
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_SELE  text
*----------------------------------------------------------------------*
FORM sub_do_shading USING p_sele TYPE ole2_object.
  DATA : l_shad TYPE ole2_object.

* Shading
  GET PROPERTY OF p_sele 'Shading' = l_shad.
  IF sy-subrc = 0.

  ENDIF.
  SET PROPERTY OF l_shad 'Texture' = '0' .
  SET PROPERTY OF l_shad 'ForegroundPatternColor' = '16777216' .
  SET PROPERTY OF l_shad 'BackgroundPatternColor' = '14277081' .
  IF sy-subrc = 0.

  ENDIF.
  FREE OBJECT : l_shad.
ENDFORM.                    " sub_do_shading
*&---------------------------------------------------------------------*
*&      Form  sub_populate_f4_help
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_3178   text
*----------------------------------------------------------------------*
FORM sub_populate_f4_help USING p_retfield1 TYPE dynfnam..
  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'NAME'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = p_retfield1
      value_org       = 'S'
    TABLES
      value_tab       = i_font_names
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc <> 0.
    MESSAGE i398 WITH 'Error while displaying F4 help'.
    EXIT.
  ENDIF.
ENDFORM.                    " sub_populate_f4_help
*&---------------------------------------------------------------------*
*&      Form  sub_pop_cts_history
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_V_ACTDOC  text
*      -->P_V_SELECTION  text
*----------------------------------------------------------------------*
FORM sub_pop_cts_history  USING    p_v_actdoc
                                   p_v_selection.
  TYPES:
       BEGIN OF x_cts,
         korrnum TYPE verskorrno,
       END OF x_cts,

       BEGIN OF x_cts_text,
         trkorr TYPE trkorr,
         as4text TYPE as4text,
       END OF x_cts_text.

  DATA:
      l_i_cts TYPE STANDARD TABLE OF x_cts,
      l_i_cts_text TYPE STANDARD TABLE OF x_cts_text,
      l_wa_cts_text TYPE x_cts_text,
      l_v_font        TYPE ole2_object,
      l_v_tables    TYPE ole2_object,
      l_v_table    TYPE ole2_object,
      l_v_range     TYPE ole2_object,
      l_v_line    TYPE i,
      l_v_objname TYPE versobjnam,
      l_v_table_border TYPE ole2_object.

  IF NOT p_prog IS INITIAL.
    l_v_objname = p_scr2.
  ELSEIF NOT p_func IS INITIAL.
    l_v_objname = p_fname1.
  ENDIF.

  SELECT korrnum
    INTO TABLE l_i_cts
    FROM vrsd
    WHERE objname = l_v_objname.

  IF l_i_cts[] IS NOT INITIAL.
    SELECT trkorr
           as4text
      INTO TABLE l_i_cts_text
      FROM e07t
      FOR ALL ENTRIES IN l_i_cts
      WHERE trkorr = l_i_cts-korrnum.

* Set font style and size
    GET PROPERTY OF p_v_selection 'Font' = l_v_font.
    SET PROPERTY OF l_v_font 'Size' = p_font_s.
    SET PROPERTY OF l_v_font 'Name' = p_font_n."'Arial'.

* Populate one text
    CALL METHOD OF p_v_selection 'TypeText'
      EXPORTING
      #1 = 'CTS Version History:'(144).
    CALL METHOD OF p_v_selection 'TypeParagraph'.
    CALL METHOD OF p_v_selection 'TypeParagraph'.

    GET PROPERTY OF p_v_actdoc 'Tables' = l_v_tables.

    GET PROPERTY OF p_v_selection 'Range' = l_v_range .

*  L_V_LINE = lines( L_I_CTS_TEXT ).
    DESCRIBE TABLE l_i_cts_text LINES l_v_line.
    l_v_line = l_v_line + 1.

    CALL METHOD OF l_v_tables 'Add' = l_v_table
    EXPORTING
    #1 = l_v_range
    #2 = l_v_line  "Number of rows
    #3 = '2'.    "Numer of columns

*--Setting border attribute for the table
    GET PROPERTY OF l_v_table 'Borders' = l_v_table_border.
    SET PROPERTY OF l_v_table_border 'Enable' = '1' . "With border
    SET PROPERTY OF l_v_table_border 'OutsideLineWidth' = '12'. "With

    CLEAR : wa_clipbrd, i_clipbrd[].

    CONCATENATE 'Change Request #'(122)
                'Description'(070)
                INTO wa_clipbrd-line SEPARATED BY c_separator.
    APPEND wa_clipbrd TO i_clipbrd.
    CLEAR wa_clipbrd.

    LOOP AT l_i_cts_text INTO l_wa_cts_text.

      CONCATENATE l_wa_cts_text-trkorr
                  l_wa_cts_text-as4text
                  INTO wa_clipbrd-line SEPARATED BY c_separator.
      APPEND wa_clipbrd TO i_clipbrd.
      CLEAR wa_clipbrd.
    ENDLOOP.

    PERFORM sub_paste_from_clipboard USING l_v_table.

    PERFORM sub_make_header_shad USING p_v_actdoc
                                       '18'.

* Advancing the cursor to the end of the table
    GET PROPERTY OF l_v_table 'Range' = l_v_range.
    GET PROPERTY OF l_v_range 'End' = l_v_line.
    SET PROPERTY OF l_v_range 'Start' = l_v_line.

* Selects the specified object
    CALL METHOD OF l_v_range 'Select' .

* For 1 line gap
    CALL METHOD OF p_v_selection 'TypeParagraph'.
  ENDIF.
ENDFORM.                    " sub_pop_cts_history

*&---------------------------------------------------------------------*
*&      Form  SUB_GET_FONT_NAMES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sub_get_font_names .
  DATA : l_word      TYPE ole2_object,
         l_documents TYPE ole2_object,
         l_actdoc    TYPE ole2_object,
         l_application TYPE ole2_object,
         l_fontnames TYPE ole2_object,
         l_str       TYPE char100,
         l           TYPE i.

  IMPORT i_font_names FROM DATABASE dwtree(tr)
  ID 'ZIBM_TS_GENERATOR'.

  IF i_font_names[] IS INITIAL.

*   Create global word application
    CREATE OBJECT l_word 'WORD.APPLICATION'.

*   Opening a new document
    GET PROPERTY OF l_word 'Documents' = l_documents .

    CALL METHOD OF l_documents 'Add' .

*   Getting active document handle
    GET PROPERTY OF l_word 'ActiveDocument' = l_actdoc.

*   Getting applications handle
    GET PROPERTY OF l_actdoc 'Application' = l_application .

    GET PROPERTY OF l_application 'FontNames' = l_fontnames.
    IF sy-subrc = 0.

    ENDIF.
    DO 200 TIMES.
      CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
       EXPORTING
         percentage       = sy-index
         text  =
         'Font loading is going on, this is for first time only'.

      l = sy-index.
      CALL METHOD OF l_fontnames 'Item' = wa_font_names
        EXPORTING
        #1 = l.
      IF sy-subrc = 0. ENDIF.
      APPEND wa_font_names TO i_font_names.
    ENDDO.

    CALL METHOD OF l_actdoc 'Close'.
    CALL METHOD OF l_documents 'Close'.

    EXPORT i_font_names TO DATABASE dwtree(tr)
    ID 'ZIBM_TS_GENERATOR'.
  ENDIF.
ENDFORM.                    " SUB_GET_FONT_NAMES

**********************************************************************
* FORM    :  sub_scan_abap_source
* Created :  01.08.2009 13:33:22
**********************************************************************
FORM sub_scan_abap_source USING p_source_name TYPE any.

  DATA: l_i_code TYPE x_t_code,
        l_wa_abap_source_info TYPE x_abap_source_info.

  READ TABLE i_abap_source_info ASSIGNING <abap_source>
             WITH KEY source_name = p_source_name.

  IF sy-subrc <> 0.
    READ REPORT p_source_name INTO l_i_code.
    SCAN ABAP-SOURCE l_i_code
              TOKENS INTO l_wa_abap_source_info-tokens
          STATEMENTS INTO l_wa_abap_source_info-statements
             MESSAGE INTO l_wa_abap_source_info-message
            WITHOUT TRMAC
                WORD INTO l_wa_abap_source_info-word
             INCLUDE INTO l_wa_abap_source_info-include
                LINE INTO l_wa_abap_source_info-line
              OFFSET INTO l_wa_abap_source_info-offset
           WITH ANALYSIS.

    l_wa_abap_source_info-source_name = p_source_name.
    APPEND l_wa_abap_source_info TO i_abap_source_info.
    READ TABLE i_abap_source_info ASSIGNING <abap_source>
               WITH KEY source_name = p_source_name.
  ENDIF.

ENDFORM. "sub_scan_abap_source
*&---------------------------------------------------------------------*
*&      Form  sub_process_message_d
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_L_WA_CODE  text
*      <--P_L_IN_MSG  text
*----------------------------------------------------------------------*
FORM sub_process_message_d  USING    p_word      TYPE c
                            CHANGING p_wa_code TYPE x_code
                                     p_in_msg  TYPE char1
                                     p_message_d TYPE char1.

  DATA:
      l_msg_no(3) TYPE n,
      l_word  TYPE char255,
      l_word2 TYPE char255,
      l_type  TYPE char255,
      l_wa_text_pool TYPE textpool,
      l_msg_type TYPE char1.

  STATICS:
      l_in_typ    TYPE char1.

  IF p_word+0(4) = 'text' OR p_word+0(4) = 'TEXT'.

    DO.
      CLEAR l_word.
      PERFORM sub_first_word CHANGING p_wa_code
                                      l_word.
      CASE  l_word.
        WHEN 'TYPE' OR 'type'.
          l_in_typ = c_check.
        WHEN '.'.
          APPEND wa_msg_info TO i_msg_info.
          CLEAR : p_in_msg, wa_msg_info.
          EXIT.
        WHEN OTHERS.
          CASE 'X'.
            WHEN l_in_typ.
              IF l_word CA ''''.
                SHIFT l_word LEFT DELETING LEADING ''''.
                SHIFT l_word RIGHT DELETING TRAILING ''''.
                wa_msg_info-msg_type = l_word.
              ELSE.
*               search constant
              ENDIF.
            WHEN OTHERS.
              IF p_word+0(4) = 'text' OR p_word+0(4) = 'TEXT'.

                l_msg_no = l_word+5(3).
                READ TABLE i_text_pool INTO l_wa_text_pool
                WITH KEY key = l_msg_no.

                IF sy-subrc = 0.
                  wa_msg_info-msg = l_wa_text_pool-entry.
                ENDIF.
              ENDIF.

          ENDCASE.

      ENDCASE.
      IF l_word CA '.'.
*        SHIFT wa_msg_info-msg RIGHT DELETING TRAILING '.'.
        APPEND wa_msg_info TO i_msg_info.
        CLEAR : p_in_msg, wa_msg_info,p_message_d.
        EXIT.
      ELSEIF l_word IS INITIAL.
        EXIT.
      ENDIF.
    ENDDO.

  ELSEIF p_word+0(1) = '''' OR p_word CS 'TYPE'
  OR p_word CS 'type'.

    CLEAR l_word.

    PERFORM sub_search_str USING p_wa_code
                        CHANGING l_word2
                                 l_type.

    CONDENSE l_word2.

    IF wa_msg_info-msg IS INITIAL.
      wa_msg_info-msg = l_word2.
    ENDIF.

    IF NOT l_type IS INITIAL.
      wa_msg_info-msg_type = l_type.
      APPEND wa_msg_info TO i_msg_info.
      CLEAR: wa_msg_info, p_in_msg,p_message_d.
    ENDIF.

  ENDIF.

ENDFORM.                    " sub_process_message_d
*&---------------------------------------------------------------------*
*&      Form  sub_search_str
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_WORD  text
*      <--P_L_WORD2  text
*----------------------------------------------------------------------*
FORM sub_search_str  USING    p_word  TYPE x_code
                     CHANGING p_word2 TYPE char255
                              p_type  TYPE char255.

  DATA:
       l_pos_s TYPE i,
       l_pos_l TYPE i,
       l_pos_e TYPE i,
       l_offset TYPE i,
       l_pos_e1(3) TYPE n,
       l_word     TYPE char255,
       l_word1    TYPE char255,
       l_str      TYPE char255,
       l_last_quote TYPE syfdpos.

  STATICS:
        l_msg_find TYPE char1.

  l_word = p_word.

  IF l_msg_find NE c_check.

    FIND '''' IN SECTION OFFSET 0 OF l_word
           MATCH OFFSET l_pos_s
           MATCH LENGTH l_pos_l.

    l_offset = l_pos_s + l_pos_l.
    l_word   = l_word+l_offset.

    PERFORM sub_get_msg USING  l_word
                       CHANGING l_str
                                l_last_quote.

    p_word2    = l_str.
    l_msg_find = c_check.

  ENDIF.

  FIND 'TYPE' IN SECTION OFFSET 0 OF l_word
         MATCH OFFSET l_pos_s
         MATCH LENGTH l_pos_l.

  IF sy-subrc = 0.
    l_word = l_word.
    l_offset = l_pos_s + 1.

    l_word = l_word+l_offset.

    SEARCH l_word FOR ''''.

    l_offset = sy-fdpos + 1.

    p_type = l_word+l_offset(1).
    CLEAR: l_msg_find.

  ELSE.

    FIND 'type' IN SECTION OFFSET 0 OF l_word
             MATCH OFFSET l_pos_s
             MATCH LENGTH l_pos_l.

    IF sy-subrc = 0.

      l_word = l_word.
      l_offset = l_pos_s + 1.

      l_word = l_word+l_offset.

      SEARCH l_word FOR ''''.

      l_offset = sy-fdpos + 1.

      p_type = l_word+l_offset(1).
      CLEAR: l_msg_find.
    ENDIF.
  ENDIF.

ENDFORM.                    " sub_search_str
*&---------------------------------------------------------------------*
*&      Form  sub_get_message
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WORD  text
*      <--P_L_POS_E  text
*----------------------------------------------------------------------*
FORM sub_get_message  USING    p_word  TYPE c
                      CHANGING p_pos_e TYPE numc3.

  DATA:
      l_word     TYPE x_code,
      l_pos_e(3) TYPE n.

  l_word  = p_word.
  l_pos_e = p_pos_e.

  IF l_word+l_pos_e(1) = ''''.

    REPLACE FIRST OCCURRENCE OF '''' IN l_word WITH space.
    SEARCH l_word FOR ''''.
    REPLACE FIRST OCCURRENCE OF '''' IN l_word WITH space.
    SEARCH l_word FOR ''''.
    REPLACE FIRST OCCURRENCE OF '''' IN l_word WITH space.
    SEARCH l_word FOR ''''.
    REPLACE FIRST OCCURRENCE OF '''' IN l_word WITH space.

    l_pos_e = sy-fdpos + 1.
    p_pos_e = l_pos_e.
    p_word = l_word.

  ENDIF.



ENDFORM.                    " sub_get_message

*&---------------------------------------------------------------------*
*&      Form  sub_get_msg
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_WORD  text
*      <--P_L_STR  text
*----------------------------------------------------------------------*
FORM sub_get_msg  USING    p_word TYPE c
                  CHANGING p_str  TYPE c
                           p_last_quote TYPE syfdpos.

  DATA:
      l_pos_s TYPE i,
      l_pos_l TYPE i,
      l_pos_e TYPE i,
      l_offset TYPE i,
      l_len    TYPE i.


  l_offset = 0.
  l_len = STRLEN( p_word ).

  DO .

    FIND '''' IN SECTION OFFSET l_offset OF p_word
             MATCH OFFSET l_pos_s
             MATCH LENGTH l_pos_l.

    IF sy-subrc = 0.
      l_offset = l_pos_s + l_pos_l.
      IF l_offset LE l_len.
        IF p_word+l_offset(1) = ''''.
          l_offset = l_offset + 1.
          CONTINUE.
        ELSE.
          l_pos_e = l_pos_s.
          EXIT.
        ENDIF.
      ENDIF.

    ELSEIF sy-subrc = 4.

    ENDIF.

  ENDDO.

  p_str = p_word+0(l_pos_e).

  REPLACE ALL OCCURRENCES OF '''''' IN p_str WITH ''''.

  p_last_quote = l_pos_e.

ENDFORM.                    " sub_get_msg

*Text symbol text
*001:Transport details
*002:Select reqd. details
*003:Table details
*004:BDC details
*005:Value & is not allowed
*006:Give program / Function Module / smartforms name
*007:Mandatory
*008:to
*009:Table
*010:BDC
*011:Selection screen
*012:Table access diagram
*013:Pseudo code
*014:Transport
*015:Message
*016:Program name:
*017:From
*018:To
*019:CTS/Task is mandatory
*020:Table name is mandatory
*021:BDC recording name is mandatory
*022:Program name is mandatory
*023:Optional
*024:Buffering:
*025: Buffering allowed
*026: Buffering not allowed
*027:Space Allocation:
*028:Error while creating OLE Object
*029:Table Logging:
*030:Method of Maintenance:
*031: Online or Batch
*032:Delete constraints:
*033:Security Requirements:
*034:Historical data requirements:
*035:Estimated number of records:
*036:Retention period:
*037:Table Archiving Strategy:
*038:Lock Objects:
*039:Table/Structure/View Definition
*040:Table/Structure/View Description
*041:Table Name:
*042:Structure
*043:Transparent table
*044:View
*045:Table Type:
*046:Table Description:
*047:Type of Development:
*048:New object
*049:Field Name
*050:Field Description
*051:Data Element
*052:Type(CHAR,NUMC)
*053:Length
*054:Key Field(Y/N)
*055:Foreign Key(Table Name)
*056:Comments
*057:Table/Structure Detailed Information
*058:Invalid Transport Request Number/Task
*059:Search help
*060:Search help name is mandatory
*061:Search Help Definition
*062:Search Help Description
*063:Search Help Name:
*064:Description:
*065:Hot key:
*066:Short text:
*067:Selection Method (Search Help Exit ):
*068:Dialog Type:
*069:Field Name/Parameter
*070:Description
*071:Import/Export(I/E)
*072:KeyField(Y/N)
*073:Type (CHAR, NUMC)
*074:Default Value
*075:No such Transport request/Tasks found
*076:Error in fetching Recording details
*077:Function module
*078:Transport information:
*079:Message details:
*080:Selection screen information:
*081:Relevant function modules:
*082:Transaction
*083:Transaction Name
*084:Program
*085:Screen
*086:Screen Field Name
*087:Type
*088:Default Data/Data Source/Comment
*089:BDC_CURSOR
*090:Position of cursor
*091:Access Path/Next Action
*092:BDC Recording Details:
*093:TS Generation Complete
*094:Output Layout
*095:Output Layout from Excel input
*096:Output Internal Table Name:
*097:Please select atleast one check box
*098:Mapping sheet fields details
*099:Please select a PC file
*100:Unable to find filepath
*101:Output information from XL input:
*102:Output information:
*103:Table/Structure Layout
*104:Custom Dictionary Object Technical Design Specification
*105:Single Selection
*106:Range/Multiple Selection
*107:Radio-Button
*108:Check-Box
*109:Not Maintained in Selection Text
*110:User can enter Transport Number or Task number
*111:User can give Session Name as well as BDC Recording Name
*112:Program
*113:Function Module
*114:Smartform
*115:Function Module Name
*116:Enter a Smartform Name
*117:UTP is only possible with Program Name
*118:No data found
*120:User can give both Elementary & Collective Search Help Name
*121:In Pseudo Code include subroutines calls and method calls
*122:Change Request #
*123:Task #
*124:Object Identifier (Program ID, Layout Set ID, etc)
*125:Object Type(Program, Transaction,  Layout Set)
*126:Message type
*127:Message number
*128:Name
*129:Table Field/ Check box/ Radio button  - (with group)
*130:Select-option (S) or Parameter (P)
*131:Comments (Range, Single/Multiple Selection,
*132:Function Module name
*133:Field # - Label
*134:SAP Table Name
*135:SAP Field Name
*136:Format/ Display Length/ Data Length
*137:Field Calculations
*138:Function Module name is mandatory
*139:Smartform name is mandatory
*140:UTP
*141:Recording doesnot Exist
*142:Unit Test Plan
*143:Include CTS version history
*144:CTS Version History:
*145:Patterns, Mandatory, etc.)
*146:Select All
*147:Deselect All
*148:More settings
*149:Not Available
*150:IBM - Solution Delivery Center
*151:Last Update :
*152:The fields
*153:equals to
*154:not equals to
*155:less than
*156:greater than
*157:less than equals to
*158:greater than equals to
*159:like pattern
*160:Please enter Font Name in More Settings
*161:Please enter Font Size in More Settings
*162:Please enter Internal table starts with
*163:Please enter Local Internal table starts with
*164:Please enter Constant name starts with
*165:Please enter Range table starts with
*166:Please enter Select Options starts with
*167:Please enter Parameters starts with
*168:Please enter Internal table ends with
*169:Error message like:
*170: is displayed.
*171:Information message like:
*172:Validation on Selection Screen
*173:Output Processing Error
*174:Data Processing Error
*175:Interactive list event processing
*176:Check for the Valid
*177:Test Condition
*178:Step
*179:Step Description
*180:Test Data
*181:Expected Result
*182:Actual Result
*183:Executed By/Date
*184:Remarks
*185:Execute the transaction:
*186:Execute the program:
*187:Start of subroutine
*188:Start of method
*189:of class
*190:End of subroutine
*191:End of method
*192:Invalid ABAP Program Name
*193:Invalid Function Module Name
*194:Invalid Smartform name
*195:Invalid Search Help
*196:Local internal table starts with (in case of FOR ALL ENTRIES)
*197:Internal table starts with (in case of FOR ALL ENTRIES)
*198:Internal table ends with (in case of FOR ALL ENTRIES)
*199:in More Settings
*200:Formal Parameter name in Subroutine starts with

*201:Font details
*Selection text
*P_BDC:
*P_BDCREC:        BDC Recording
*P_CODE:
*P_CONST:        Constant starts with
*P_FNAME:        Excel File form PC
*P_FONT_N:        Font Name
*P_FONT_S:        Font Size
*P_FORM_P:        Form Parameter starts with
*P_PARAM:        Sel Scrn Parameter Starts with
*P_RANGE:        Range table starts with
*P_SEL:        For selection screen
*P_SEL_OP:        Select Option starts with
*P_TAB:        For table
*P_TAD:        For table access diagram
*S_CTS:        Transport number:
*S_HELP:        Search help name:
*S_TAB:        Table/Structure/View name:
