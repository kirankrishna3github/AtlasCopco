*&---------------------------------------------------------------------*
*& Report       ZIBM_REPORT_CODEOPTIMIZE_SRM
*& Description  Code Optimizer - Report
*& Owner        IBM India
*& Version      3.2
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  zibm_report_codeoptimize_srm NO STANDARD PAGE HEADING
                               LINE-SIZE 120  .

TABLES:
  sscrfields, " Fields on selection screens
  tadir,
  smp_dyntxt, " Menu Painter
  dd04l,      " Data elements
  trdir.

PARAMETERS: g_pname LIKE sy-repid OBLIGATORY . "Program Name
PARAMETERS  p_status AS CHECKBOX DEFAULT 'X' . "Status ofthe Program
SELECTION-SCREEN BEGIN OF BLOCK chk_parm
                 WITH FRAME TITLE text-001.
PARAMETERS:
           p_glob(4) OBLIGATORY, "Standard Global Variabe declaration
           p_loc(4)  OBLIGATORY, "Standard Local Variabe declaration
           p_const(4)  OBLIGATORY, "Standard Constant declaration
           p_para(4)   OBLIGATORY, "Standard parameter declaration
           p_chkb(4),
           p_radb(4),
           p_opt(4)    OBLIGATORY, "Standard select-options declaration
           p_range(4),             "Standard range table declaration
           p_tabl(4)   OBLIGATORY, "Standard internal table declaration
           p_ltab(10)   OBLIGATORY,              "Standard local itab
           p_struc(10)  OBLIGATORY, "Standard structure declaration
           p_lstr(10)   OBLIGATORY,
           p_type(10),             "Standard for type declaration
           p_wa(10) OBLIGATORY,        "Standard for WA declaration
           p_lwa(10)   OBLIGATORY.
SELECTION-SCREEN END OF BLOCK chk_parm.

SELECTION-SCREEN BEGIN OF BLOCK chk_parm1
                 WITH FRAME TITLE text-002.
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS: sy_sel   AS CHECKBOX DEFAULT 'X'. "SY-SUBRC Check After
"SELECT
SELECTION-SCREEN COMMENT 2(30) text-003 FOR FIELD sy_sel.
SELECTION-SCREEN POSITION 50.
PARAMETERS:  sy_read  AS CHECKBOX DEFAULT 'X'. "SY-SUBRC Check After
"READ
SELECTION-SCREEN COMMENT 55(25) text-004 FOR FIELD sy_read.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : sort_bny AS CHECKBOX DEFAULT 'X'. "Sort before Binary
"Search
SELECTION-SCREEN COMMENT 2(30) text-005 FOR FIELD sort_bny.
SELECTION-SCREEN POSITION 50.
PARAMETERS: read_bny AS CHECKBOX DEFAULT 'X'. "Binary Search In READ
SELECTION-SCREEN COMMENT 55(25) text-006 FOR FIELD read_bny.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : hard_wre AS CHECKBOX DEFAULT 'X'. "Hard coding in WHERE
"clause
SELECTION-SCREEN COMMENT 2(30) text-007 FOR FIELD hard_wre.
SELECTION-SCREEN POSITION 50.
PARAMETERS: half_com AS CHECKBOX DEFAULT 'X'. "Half Line Comment Check
SELECTION-SCREEN COMMENT 55(25) text-008 FOR FIELD half_com.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : no_type AS CHECKBOX DEFAULT 'X'. "No Data Type Specified
SELECTION-SCREEN COMMENT 2(30) text-009 FOR FIELD no_type.
SELECTION-SCREEN POSITION 50.
PARAMETERS: no_len AS CHECKBOX DEFAULT 'X'. "No Length Specified
SELECTION-SCREEN COMMENT 55(25) text-010 FOR FIELD no_len.
SELECTION-SCREEN END OF LINE.


SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : sel_loop AS CHECKBOX DEFAULT 'X'. "SELECT inside a LOOP
SELECTION-SCREEN COMMENT 2(30) text-011 FOR FIELD sel_loop.
SELECTION-SCREEN POSITION 50.
PARAMETERS: no_delm AS CHECKBOX DEFAULT 'X'.
"Data element is not specified
SELECTION-SCREEN COMMENT 55(30) text-012 FOR FIELD no_delm.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : del_ajt AS CHECKBOX DEFAULT 'X'.
"Sort before delete adjacent
SELECTION-SCREEN COMMENT 2(30) text-013 FOR FIELD del_ajt.
SELECTION-SCREEN POSITION 50.

PARAMETERS: sel_star AS CHECKBOX DEFAULT 'X'.
"Check select *
SELECTION-SCREEN COMMENT 55(30) text-014 FOR FIELD sel_star.

SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : move_cor AS CHECKBOX DEFAULT 'X'.
"Move-corresponding
SELECTION-SCREEN COMMENT 2(30) text-015 FOR FIELD move_cor.
SELECTION-SCREEN POSITION 50.

PARAMETERS: into_cor AS CHECKBOX DEFAULT 'X'.
"Into-corresponding
SELECTION-SCREEN COMMENT 55(30) text-016 FOR FIELD into_cor.

SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : tcode AS CHECKBOX DEFAULT 'X'.
"Valid Transaction Code
SELECTION-SCREEN COMMENT 2(32) text-017 FOR FIELD tcode.
SELECTION-SCREEN POSITION 50.

PARAMETERS : sel_clus AS CHECKBOX DEFAULT 'X'.
"Select from Cluster Table
SELECTION-SCREEN COMMENT 55(30) text-018 FOR FIELD sel_clus.


SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : hard_br AS CHECKBOX DEFAULT 'X'.
"User Name and Break Points
SELECTION-SCREEN COMMENT 2(40) text-019 FOR FIELD hard_br.
SELECTION-SCREEN POSITION 50.

PARAMETERS : uname_ck AS CHECKBOX DEFAULT 'X'.
"Select from Cluster Table
SELECTION-SCREEN COMMENT 55(30) text-020 FOR FIELD uname_ck.

SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : view_chk AS CHECKBOX DEFAULT 'X'.
"View Availability for Joined Tables
SELECTION-SCREEN COMMENT 2(40) text-021 FOR FIELD view_chk.
SELECTION-SCREEN POSITION 50.

PARAMETERS : srt_loop AS CHECKBOX DEFAULT 'X'.
"Sort Inside Loop Statement
SELECTION-SCREEN COMMENT 55(30) text-022 FOR FIELD srt_loop.

SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : tabl_upd AS CHECKBOX DEFAULT 'X'.
"Direct Table Entries Update/Insert
SELECTION-SCREEN COMMENT 2(48) text-023 FOR FIELD tabl_upd.
SELECTION-SCREEN POSITION 50.

PARAMETERS : neg_sql AS CHECKBOX DEFAULT 'X'.
"Negative SQL Statements in Where Condition
SELECTION-SCREEN COMMENT 55(45) text-024 FOR FIELD neg_sql.

SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : on_chg AS CHECKBOX DEFAULT 'X'.
"Usage of ON CHANGE OF Statement
SELECTION-SCREEN COMMENT 2(48) text-025 FOR FIELD on_chg.
SELECTION-SCREEN POSITION 50.

PARAMETERS : tabl_cnt AS CHECKBOX  DEFAULT 'X'.
"DB Table Hit Count
SELECTION-SCREEN COMMENT 55(45) text-026 FOR FIELD tabl_cnt.

SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : rang_chk AS CHECKBOX DEFAULT 'X'.
"Constants Value Check
SELECTION-SCREEN COMMENT 2(48) text-027 FOR FIELD rang_chk.
SELECTION-SCREEN POSITION 50.

PARAMETERS : int_ini AS CHECKBOX DEFAULT 'X'.
"check for initial before for all entries
SELECTION-SCREEN COMMENT 55(45) text-028 FOR FIELD int_ini.

SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS : stat_lin AS CHECKBOX DEFAULT 'X'.
"Constants Value Check
SELECTION-SCREEN COMMENT 2(48) text-029 FOR FIELD stat_lin.
SELECTION-SCREEN POSITION 50.

PARAMETERS : srt_hash AS CHECKBOX DEFAULT 'X'.
"Sorting the Hash Table
SELECTION-SCREEN COMMENT 55(45) text-030 FOR FIELD srt_hash.

SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END   OF BLOCK chk_parm1.
SELECTION-SCREEN BEGIN OF BLOCK dwn WITH FRAME TITLE text-t01.
PARAMETERS html_dwn AS CHECKBOX DEFAULT 'X'.
SELECTION-SCREEN END OF BLOCK dwn.
SELECTION-SCREEN FUNCTION KEY 1.
SELECTION-SCREEN FUNCTION KEY 2.

RANGES:
  r_intstc FOR stokex-str,  "Internal table & structure names
  r_work_area FOR stokex-str.
DATA g_status TYPE c.             "State of the Program
DATA prog LIKE sy-repid.          "Current main program
DATA: program LIKE sy-repid.      "Current main program
DATA list_flag.                   "flag for list number

DATA : BEGIN OF dtab OCCURS 100,
         pprog LIKE sy-repid,
         ptxt(75) TYPE c,
       END OF dtab.
DATA : BEGIN OF t_mess OCCURS 0,
          item_no(5),             "Index
          message(100),           "Message
          program(30),            "Program name
          lineno2(10),            "Line Number
          row(10),
       END OF t_mess,
       comment1(100).
DATA: it_mess LIKE t_mess OCCURS 0 WITH HEADER LINE.
DATA: BEGIN OF i_trdirt OCCURS 0,
         name LIKE trdirt-name, "C040 ABAP program name
         text LIKE trdirt-text. "C070 Report title
DATA: END OF i_trdirt.

DATA :  BEGIN OF source OCCURS 1000,
         line(255),         "statements of the program being tested
        END OF source.
DATA :  BEGIN OF source_main OCCURS 1000,
         line(255) TYPE c,   "statements of the program being tested
         program(30),       "progam name
         form(30),
         lineno(10) TYPE c, "line number
        END OF source_main.

DATA: BEGIN OF t_key1_tab OCCURS 0,
          key LIKE stoken-str,
        END OF t_key1_tab.

DATA: hits TYPE i.
DATA: codesize TYPE i,
      row1(4) TYPE c,
      index(10).

DATA:
  t_tokens_main LIKE stokex OCCURS 0 WITH HEADER LINE,
  t_statements_main LIKE sstmnt OCCURS 0 WITH HEADER LINE,
  t_tokens_sub LIKE stokex OCCURS 0 WITH HEADER LINE,
  t_tokens_sub1 LIKE stokex OCCURS 0 WITH HEADER LINE,
  t_statements_sub LIKE sstmnt OCCURS 0 WITH HEADER LINE,
  t_statements_sub1 LIKE sstmnt OCCURS 0 WITH HEADER LINE,
  t_level_main LIKE slevel OCCURS 0 WITH HEADER LINE,
  t_level_sub LIKE slevel OCCURS 0 WITH HEADER LINE,
  t_struc_main LIKE sstruc OCCURS 0 WITH HEADER LINE,
  t_struc_sub LIKE sstruc OCCURS 0 WITH HEADER LINE,
 t_statements1 LIKE sstmnt OCCURS 100 WITH HEADER LINE..

DATA:
  w_ucomm LIKE sy-ucomm,  "user command
  w_var_ctr TYPE i,      "counter for non-standard constant declaration
  w_itab_ctr TYPE i,     "counter for non-standard table declaration
  w_sort_ctr TYPE i,     "counter for no sort before binary search
  w_bny_ctr TYPE i,      "counter for no binary search after read
  w_ini_ctr TYPE i,
  w_half_ctr TYPE i,     "counter for no half-line comment
  w_sysel_ctr TYPE i,    "counter for no sy-subrc check after select
  w_syread_ctr TYPE i,   "counter for no sy-subrc check after read
  w_whr_ctr TYPE i,      "counter for hard-coding in select
  w_lnth_ctr TYPE i,     "
  w_type_ctr TYPE i,
  w_types_ctr TYPE i,
  w_seloop_ctr TYPE i,
  w_dataelm_ctr TYPE i,
  w_deladj_ctr  TYPE i,
  w_mvcrr_ctr      TYPE i,
  w_textelm_ctr    TYPE i,
  w_intocor_ctr    TYPE i,
  w_star_ctr    TYPE i,
  w_tcode_ctr TYPE i,  " Counter for TCODEs
  w_selclus_ctr TYPE i, " Counter for Select from Cluster Tables.
  w_uname_brpnt_ctr TYPE i, " Counter for Breakpoints in the Prog
  w_uname_chk_ctr TYPE i, "Counter for Usr Names in the Prog
  w_view_chk_ctr TYPE i, "Counter for Available View Check in the Prog
  w_sortloop_ctr TYPE i,  "Counter for Sort Inside Loop
  w_tabl_upd_ctr TYPE i, "Counter for Direct Table Update
  w_neg_sql_ctr TYPE i,  "Counter for Negative SQL Statement Usage
  w_on_chg_ctr TYPE i, " Counter For usage of On Change Of Statement
  w_tabl_cnt_ctr TYPE i, "Counter For DB Hits
  w_rang_chk_ctr TYPE i, "Counter FOR Ranges Size limit Check
  w_int_ini_ctr TYPE i, "check for initial before for all entries
  w_stat_lin_ctr TYPE i, "Check for one Statement per line.
  w_srt_hash_ctr TYPE i. " Check for Sort when Hash Table is used

DATA: BEGIN OF i_tcode OCCURS 0,
         tcode LIKE tstc-tcode, "Transaction Code
         name LIKE trdirt-name, "C040 ABAP program name
         ttext LIKE tstct-ttext. " Transaction code text
DATA: END OF i_tcode.

DATA: BEGIN OF t_tabl_cnt OCCURS 0,
        tabname LIKE dd02l-tabname,
        count TYPE i VALUE 1,
        END OF t_tabl_cnt.

DATA: BEGIN OF it_viewname OCCURS 0,
       viewname LIKE dd26s-viewname,
       ftabname LIKE dd26s-fortabname,
       stabname LIKE dd02l-tabname,
       viewclass LIKE dd02l-viewclass,
       ddtext LIKE dd02t-ddtext,
       tabname1 LIKE dd02l-tabname,
       tabname2 LIKE dd02l-tabname,
       tabname3 LIKE dd02l-tabname,
       count TYPE i VALUE 1,
       END OF it_viewname.

*CALL RS_PROGRAM_INDEX. to get the list of items like fields,tables
*events etc.
*
*This program will try to check the following details: all these points
*i have taken from wirrs.
*
* 1. variable naming conventions                    DONE
* 2. sort before binary search                      DONE
* 3. if the code is too long                        DONE
* 4. hard coded values in where clause              DONE
* 5. sy-subrc check after a read table statement    DONE
* 6. check for initial before for all entries       DONE
* 7. check for half line comments                   DONE
* 8. dead codes                               Not Possible
* 9. internal table with initial size declaration   DONE
* 10.at line selection whether it validates any of the fields
* 11.if binary search is not used... suggest that    DONE
* 12.length of the variable must be defined. e.g. do not write data c.
*    write data c(1).                                DONE
*13. during data declaration whether domain has been used or not. DONE
*14. internal table clear refresh             Not possible
*15. select within a loop.                          DONE
*16. parallel cursor for multiple loop.
*17. sy-subrc check after select                    DONE
*18. sort before delete adjacent                    DONE
*19. Constant names are meaningful                  DONE
*20. Transaction Code Availability Check            DONE
*21. Cluster Tables in the select                   DONE
*22. Sort inside Loop                               DONE

INITIALIZATION.
  MOVE '@4B@' TO smp_dyntxt-icon_id .
  MOVE 'Select All' TO smp_dyntxt-quickinfo.
  MOVE smp_dyntxt TO sscrfields-functxt_01.

  MOVE '@4D@' TO smp_dyntxt-icon_id .
  MOVE 'Deselect All' TO smp_dyntxt-quickinfo.
  MOVE smp_dyntxt TO sscrfields-functxt_02.

AT SELECTION-SCREEN.

  w_ucomm = sy-ucomm.

  SELECT * FROM trdir UP TO 1 ROWS WHERE name = g_pname  .
  ENDSELECT.
  IF sy-subrc <> 0.
    MESSAGE e017(ds) WITH g_pname.
  ENDIF.

AT SELECTION-SCREEN OUTPUT.

  IF w_ucomm = 'FC01'.
    sy_sel = 'X'.
    sy_read = 'X'.
    sort_bny = 'X'.
    read_bny = 'X'.
    hard_wre = 'X'.
    half_com = 'X'.
    no_type = 'X'.
    no_len  = 'X'.
    sel_loop = 'X'.
    no_delm  = 'X'.
    del_ajt = 'X'.
    move_cor = 'X'.
    into_cor = 'X'.
    sel_star = 'X'.
    tcode = 'X'.
    sel_clus = 'X'.
    hard_br = 'X'.
    uname_ck = 'X'.
    view_chk = 'X'.
    srt_loop = 'X'.
    tabl_upd = 'X'.
    neg_sql = 'X'.
    on_chg = 'X'.
    tabl_cnt = 'X'.
    rang_chk = 'X'.
    int_ini = 'X'.
    stat_lin = 'X'.
    srt_hash = 'X'.

  ELSEIF w_ucomm = 'FC02'.
    CLEAR:
      sy_sel,
      sy_read,
      sort_bny,
      read_bny,
      hard_wre,
      half_com,
      no_type,
      no_len,
      sel_loop,
      no_delm,
      del_ajt,
      move_cor,
      into_cor,
      sel_star,
      tcode,
      sel_clus,
      hard_br,
      uname_ck,
      view_chk,
      srt_loop,
      tabl_upd,
      neg_sql,
      on_chg,
      rang_chk,
      tabl_cnt,
      int_ini,
      stat_lin,
      srt_hash.

  ENDIF.

START-OF-SELECTION.

  r_intstc-sign = 'I'.
  r_intstc-option = 'EQ'.

  PERFORM get_source.
  SET PARAMETER ID 'RID' FIELD g_pname.

  CALL TRANSACTION 'SLIN'.

  PERFORM logical_flow_of_the_program.

  PERFORM get_mod_app_loop_read.

  PERFORM int_table_checking.

  PERFORM variable_checking .

  PERFORM half_comment.

  PERFORM const_name_check.


  PERFORM del_adja.   " new subroutine

  CLEAR t_key1_tab.
  REFRESH t_key1_tab.

  PERFORM sort_checking .

  PERFORM check_where_clause .
*** Changes 04-11-2009
  PERFORM check_select_endselect.
*** End Changes
  PERFORM select_within_loop.

  PERFORM check_text_symbol.

  PERFORM tcode_check.

  PERFORM select_cluster.

  PERFORM hard_brpnts.

  PERFORM uname_check.

  PERFORM sort_loop.

  PERFORM tabl_update.

  PERFORM neg_sql_statements.

  PERFORM on_change_of.

  PERFORM tabl_hit_cnt.

  PERFORM itab_initial_check.

  PERFORM statement_line_chk.

  PERFORM sort_hash_table.

  PERFORM ranges_size_chk.

  PERFORM  view_chck.

END-OF-SELECTION.
  PERFORM write_overall.
  IF html_dwn = 'X'.
    PERFORM html_download.
  ENDIF.

TOP-OF-PAGE.
  PERFORM print_report_header.

AT LINE-SELECTION.

  PERFORM write_msg.

  PERFORM goto_program.

  PERFORM list_tcodes.

  PERFORM goto_transaction.

  PERFORM view_list.

  PERFORM tabl_cnt_list.

  PERFORM view_display.

*&---------------------------------------------------------------------*
*&      Form  VARIABLE_NAMING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM variable_checking.

* check naming conventions.
  DATA: BEGIN OF t_keywords OCCURS 1,
            line(20),
        END OF t_keywords,
        l_para_fg,
        l_varlen   TYPE i ,
        l_lcllen TYPE i ,
        l_tablen   TYPE i,
        l_conslen TYPE i,
        l_strlen  TYPE i,
        l_paralen TYPE i,
        l_rblen   TYPE i,
        l_cblen TYPE i,
        l_optlen  TYPE i,
        l_glob TYPE i,
        l_loc TYPE i,
****        Changes Shastry
        l_tabl TYPE i,
        l_wa TYPE i,
        l_ltab TYPE i,
        l_lwa TYPE i,
****        End Changes
        l_const_name LIKE stoken-str,
        l_const_name1 LIKE stoken-str,
        l_tabix TYPE i,
        l_tabix1 TYPE i,
        row TYPE i,
        row2 TYPE i,
        flg_1(1) TYPE c,
        var1 LIKE stoken-str,
        l_from TYPE i,
        l_from1 TYPE i,
        l_to TYPE i,
        l_tabname LIKE stoken-str,
        l_line1 TYPE i,
        l_line2 TYPE i,
        l_flag TYPE c,
        count TYPE i,
        l_count TYPE i.

  DATA:  i_compo     LIKE  scompo   OCCURS 0 WITH HEADER LINE,
         i_cross_ref LIKE  cross    OCCURS 0 WITH HEADER LINE,
         i_inc       LIKE  d010inc  OCCURS 0 WITH HEADER LINE.

  DATA l_new_row LIKE sy-tabix.
  DATA: i_dd02l LIKE dd02l OCCURS 0 WITH HEADER LINE.
  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.

  DATA: BEGIN OF t_keywords_p OCCURS 1,
               line(20),
        END OF t_keywords_p.

  DATA: l_sep TYPE c VALUE '-',
        l_sep1 TYPE c VALUE '_'.
  DATA: l_tab TYPE dd02l-tabname,
        l_fld TYPE string.

  DATA: l_types(8), " TYPE ddtypet-typegroup,
        l_fld1 TYPE string.
  DATA: i_ddtypet TYPE ddtypet OCCURS 0 WITH HEADER LINE.


  t_keywords ='PARAMETER'.             APPEND t_keywords.
  t_keywords ='PARAMETERS'.             APPEND t_keywords.


  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens
                          KEYWORDS   FROM t_keywords .


* determining the length of the parameters G_const,G_para,G_opt

  l_conslen = STRLEN( p_const ).
  l_paralen = STRLEN( p_para ).
  l_optlen = STRLEN( p_opt ).
  l_glob = STRLEN( p_glob ).
  l_loc  = STRLEN( p_loc ).
  l_rblen = STRLEN( p_radb ).
  l_cblen = STRLEN( p_chkb ).
  l_tab = STRLEN( p_tabl ).
  l_tabl = STRLEN( p_tabl ).
  l_wa = STRLEN( p_wa ).
  l_ltab = STRLEN( p_ltab ).
  l_lwa = STRLEN( p_lwa ).


  LOOP AT t_tokens_sub.
    l_new_row = sy-tabix.
** Check for move-corresponding.
    IF move_cor = 'X'.
      IF t_tokens_sub-str = 'MOVE-CORRESPONDING'.
        t_mess-message
          = 'Use MOVE instead of MOVE-CORRESPONDING'.

        READ TABLE source_main INDEX t_tokens_sub-row.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '16'.
        READ TABLE t_mess WITH KEY item_no = '16'
                                   lineno2 = t_mess-lineno2.
        IF sy-subrc <> 0.
          w_mvcrr_ctr = w_mvcrr_ctr + 1.
          APPEND t_mess.
        ENDIF.

      ENDIF.
    ENDIF.
** Check for text symbols
    IF t_tokens_sub-str CP 'TEXT-*'.
      DATA selscr LIKE stokex.
      READ TABLE t_statements_sub WITH KEY to = l_new_row.
      IF sy-subrc = 0.
        READ TABLE t_tokens_sub INTO selscr INDEX t_statements_sub-from
.
        IF selscr-str <> 'SELECTION-SCREEN'.
          t_mess-message
            = 'Use text and refer text element, e.g. ''testing''(001)'.

          READ TABLE source_main INDEX t_tokens_sub-row.
          t_mess-lineno2 = source_main-lineno.
          t_mess-program = source_main-program.
          t_mess-item_no = '19'.
          READ TABLE t_mess WITH KEY item_no = '19'
                                     lineno2 = t_mess-lineno2.
          IF sy-subrc <> 0.
            w_textelm_ctr = w_textelm_ctr + 1.
            APPEND t_mess.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

* Checking for CONSTANTS Declaration according to standards
    IF t_tokens_sub-str = 'CONSTANTS'.
      l_tabix = sy-tabix + 1.


      READ TABLE t_tokens_sub INDEX l_tabix.

********************* Under construction
      l_strlen = STRLEN( t_tokens_sub-str ).
      l_strlen = l_strlen - l_conslen.
      IF l_strlen > 0.
        l_const_name = t_tokens_sub-str+l_conslen(l_strlen).
      ENDIF.
      l_const_name1 = t_tokens_sub-str.
      SEARCH l_const_name FOR '('.
      IF sy-subrc = 0.
        CLEAR l_strlen.
        l_strlen = sy-fdpos.
      ENDIF.

      l_tabix = l_tabix + 4.

      READ TABLE t_tokens_sub INDEX l_tabix.

      TRANSLATE t_tokens_sub-str USING ''' '.
      CONDENSE t_tokens_sub-str.
      IF l_strlen > 0.
        IF l_const_name(l_strlen) = t_tokens_sub-str.

          CONCATENATE 'Error: CONSTANT name is not meaningful '
                    l_const_name1
                    INTO t_mess-message
                    SEPARATED BY space.
          READ TABLE source_main INDEX t_tokens_sub-row.
          t_mess-lineno2 = source_main-lineno.
          t_mess-program = source_main-program.
          t_mess-item_no = '1'.
          READ TABLE t_mess WITH KEY item_no = '1'
                                     lineno2 = t_mess-lineno2.
          IF sy-subrc <> 0.
            w_var_ctr = w_var_ctr + 1.
            APPEND t_mess.
          ENDIF.
        ENDIF.
      ENDIF.
********************* Under construction

* Checking for PARAMETER(S) Declaration according to standards
* since parameters can be declared under both PARAMETERS and PARAMETER
* therefore the check is done for both.

    ELSEIF ( t_tokens_sub-str = 'PARAMETERS'
             OR t_tokens_sub-str = 'PARAMETER' ).
      CLEAR l_para_fg.
      l_tabix = sy-tabix - 1.
      READ TABLE t_tokens_sub INDEX l_tabix.
      IF t_tokens_sub-str = 'SET' OR
         t_tokens_sub-str = 'GET' OR
         t_tokens_sub-str = 'ON'.
      ELSE.
        l_tabix = sy-tabix + 3.

        READ TABLE t_tokens_sub INDEX l_tabix.
        IF t_tokens_sub-str = 'AS'.
          IF p_chkb IS INITIAL.
            l_para_fg = 'X'.
          ELSE.
            l_tabix = l_tabix - 1.
            READ TABLE t_tokens_sub INDEX l_tabix.
            IF t_tokens_sub-str(l_cblen) <> p_chkb.

              w_var_ctr = w_var_ctr + 1.
              row1 = t_tokens_sub-row.
              CONCATENATE 'Error: CHECKBOX name is not matching '
                            t_tokens_sub-str
                             INTO t_mess-message
                             SEPARATED BY space.
              READ TABLE source_main INDEX t_tokens_sub-row.
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '1'.
              APPEND t_mess.
            ENDIF.

          ENDIF.
        ELSEIF t_tokens_sub-str = 'RADIOBUTTON'.
          IF p_radb IS INITIAL.
            l_para_fg = 'X'.
          ELSE.
            l_tabix = l_tabix - 1.

            READ TABLE t_tokens_sub INDEX l_tabix.

            IF t_tokens_sub-str(l_rblen) <> p_radb.

              w_var_ctr = w_var_ctr + 1.
              row1 = t_tokens_sub-row.
              CONCATENATE 'Error: RADIOBUTTON name is not matching '
                            t_tokens_sub-str
                             INTO t_mess-message
                             SEPARATED BY space.
              READ TABLE source_main INDEX t_tokens_sub-row.
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '1'.
              APPEND t_mess.
            ENDIF.
          ENDIF.
        ELSE.
          l_para_fg = 'X'.
        ENDIF.
        IF l_para_fg = 'X'.
          l_tabix = l_tabix - 1.
          READ TABLE t_tokens_sub INDEX l_tabix.

          READ TABLE t_tokens WITH KEY str = t_tokens_sub-str.

          IF sy-subrc = 0.

            IF t_tokens_sub-str(l_paralen) <> p_para.

              w_var_ctr = w_var_ctr + 1.
              row1 = t_tokens_sub-row.
              CONCATENATE 'Error: PARAMETER name is not matching '
                            t_tokens_sub-str
                             INTO t_mess-message
                             SEPARATED BY space.
              READ TABLE source_main INDEX t_tokens_sub-row.
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '1'.
              APPEND t_mess.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

* Checking for Select-options Declaration according to standards

    ELSEIF t_tokens_sub-str = 'SELECT-OPTIONS'.
      l_tabix = sy-tabix + 1.

      READ TABLE t_tokens_sub INDEX l_tabix.

      IF t_tokens_sub-str(l_optlen) <> p_opt.
        w_var_ctr = w_var_ctr + 1.
        row1 = t_tokens_sub-row.
        CONCATENATE 'Error: SELECT-OPTIONS name is not matching '
                           t_tokens_sub-str
                        INTO t_mess-message
                        SEPARATED BY space.
        READ TABLE source_main INDEX t_tokens_sub-row.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '1'.
        APPEND t_mess.
      ENDIF.
* Checking for range table Declaration according to standards

    ELSEIF t_tokens_sub-str = 'RANGES'.
      l_tabix = sy-tabix + 1.

      READ TABLE t_tokens_sub INDEX l_tabix.
      IF NOT p_range IS INITIAL.
        IF t_tokens_sub-str(l_optlen) <> p_range.
          w_var_ctr = w_var_ctr + 1.
          row1 = t_tokens_sub-row.
          CONCATENATE 'Error: RANGE TABLE name is not matching '
                             t_tokens_sub-str
                          INTO t_mess-message
                          SEPARATED BY space.
          READ TABLE source_main INDEX t_tokens_sub-row.
          t_mess-lineno2 = source_main-lineno.
          t_mess-program = source_main-program.
          t_mess-item_no = '1'.
          APPEND t_mess.
        ENDIF.
      ENDIF.
* Checking for Global Variables Declaration according to standards

********************* change start

    ELSEIF t_tokens_sub-str = 'DATA'.
      l_tabix1 = sy-tabix + 1.
      READ TABLE t_tokens_sub INDEX l_tabix1.
      IF sy-subrc = 0.
        IF t_tokens_sub-str = 'BEGIN'.
          flg_1 = 'B'.
        ELSEIF t_tokens_sub-str = 'END'.
          CLEAR flg_1.
        ELSE.
          IF flg_1 = 'B'.

          ELSEIF t_tokens_sub-str IN r_intstc.

          ELSE.
            READ TABLE source_main INDEX t_tokens_sub-row.

            IF source_main-form = ' ' AND
               t_tokens_sub-str(l_glob) <> p_glob.
              IF sy-subrc = 0.
***Changes shastry

                READ TABLE t_tokens_sub INDEX l_tabix1.

                l_tabix = sy-tabix + 1.

                READ TABLE t_tokens_sub INDEX l_tabix.

                IF t_tokens_sub-str = 'TYPE' OR t_tokens_sub-str =
                'LIKE'.
***  Changes Shastry
                  IF sy-subrc NE 0.

*                  l_tabix = sy-tabix - 2.
                    READ TABLE t_tokens_sub INDEX l_tabix1.

                    READ TABLE source_main INDEX t_tokens_sub-row.


                    IF source_main-form = ' ' AND
                           t_tokens_sub-str(l_glob) <> p_glob.

****END Changes Shastry
                      w_var_ctr = w_var_ctr + 1.

                      CONCATENATE
                      'Error: Global variable name is not matching  '
        t_tokens_sub-str
                                                              INTO
t_mess-message
                                                               SEPARATED
                                                               BY
                                                               space.

                      t_mess-lineno2 = source_main-lineno.
                      t_mess-program = source_main-program.
                      t_mess-item_no = '1'.
                      APPEND t_mess.

                    ENDIF.
                  ENDIF.
                ENDIF.

***  End Changes
                IF sy-subrc = 0.
                  count = 0.
                  l_tabix = sy-tabix + 1.
                  READ TABLE t_tokens_sub INDEX l_tabix.
                  count = count + 1.

                  IF count = 1.

                    SELECT SINGLE *
                    INTO i_dd02l             " Table Name
                    FROM dd02l                              " SAP Tables
                    WHERE tabname = t_tokens_sub-str.

                    IF sy-subrc NE 0.

                      SPLIT t_tokens_sub-str AT l_sep1 INTO l_types
                      l_fld1.

                      IF l_types IS NOT INITIAL AND STRLEN( l_types ) <
                      6.

                        SELECT SINGLE *             " Table Name
                        INTO i_ddtypet
                        FROM ddtypet
                        " SAP Tables
                        WHERE typegroup = l_types .

                        IF sy-subrc = 0.

                          l_tabix = sy-tabix - 2.
                          READ TABLE t_tokens_sub INDEX l_tabix.

                          IF t_tokens_sub-str(l_tabl) <> p_tabl AND
                          t_tokens_sub-str(l_wa) <> p_wa.

                            CONCATENATE
                            'Error: Internal Table name is not matching'
                                         t_tokens_sub-str
                                         INTO t_mess-message
                                         SEPARATED BY space.

*              READ TABLE source_main INDEX t_itab1-row2.

                            t_mess-lineno2 = source_main-lineno.
                            t_mess-program = source_main-program.
                            t_mess-item_no = '2'.
                            APPEND t_mess.
                            w_itab_ctr = w_itab_ctr + 1.
                          ENDIF.

                        ENDIF.

                      ELSE.
                        sy-subrc = 4.

                      ENDIF.
                    ENDIF.
                  ENDIF.
*                ENDIF.
                ENDIF.

                IF sy-subrc NE 0.

                  l_tabix = sy-tabix - 2.
                  READ TABLE t_tokens_sub INDEX l_tabix.

                  READ TABLE source_main INDEX t_tokens_sub-row.


                  IF source_main-form = ' ' AND
                         t_tokens_sub-str(l_glob) <> p_glob.

****END Changes Shastry
                    w_var_ctr = w_var_ctr + 1.

                    CONCATENATE
                    'Error: Global variable name is not matching  '
      t_tokens_sub-str
                                                            INTO
t_mess-message
                                                             SEPARATED
                                                             BY
                                                             space.

                    t_mess-lineno2 = source_main-lineno.
                    t_mess-program = source_main-program.
                    t_mess-item_no = '1'.
                    APPEND t_mess.

                  ENDIF.
                ENDIF.
              ENDIF.
            ELSEIF source_main-form <> ' ' AND
                       t_tokens_sub-str(l_loc) <> p_loc.
              IF sy-subrc = 0.
***Changes shastry

                READ TABLE t_tokens_sub INDEX l_tabix1.

                l_tabix = sy-tabix + 1.

                READ TABLE t_tokens_sub INDEX l_tabix.

                IF t_tokens_sub-str = 'TYPE' OR t_tokens_sub-str =
                'LIKE'.

****  Changes Shastry
                  IF sy-subrc NE 0.

                    READ TABLE t_tokens_sub INDEX l_tabix1.

                    READ TABLE source_main INDEX t_tokens_sub-row.

                    IF source_main-form <> ' ' AND
                             t_tokens_sub-str(l_loc) <> p_loc.


                      CONCATENATE
                      'Error: Local variable name is not matching  '
t_tokens_sub-str
                                                             INTO
t_mess-message
                                                              SEPARATED
                                                              BY space
                                                              .
                      READ TABLE source_main INDEX t_tokens_sub-row.
                      READ TABLE t_mess WITH KEY lineno2 =
                      source_main-lineno.
                      IF sy-subrc NE 0 AND t_mess-item_no NE '1'.
                        w_var_ctr = w_var_ctr + 1.
                        t_mess-lineno2 = source_main-lineno.
                        t_mess-program = source_main-program.
                        t_mess-item_no = '1'.
                        APPEND t_mess.
                      ENDIF.
                    ENDIF.
                  ENDIF.
                ENDIF.
****  End Changes
                IF sy-subrc = 0.
                  count = 0.
                  l_tabix = sy-tabix + 1.
                  READ TABLE t_tokens_sub INDEX l_tabix.
                  count = count + 1.

                  IF count = 1.

                    SELECT SINGLE *
                    INTO i_dd02l             " Table Name
                    FROM dd02l                              " SAP Tables
                    WHERE tabname = t_tokens_sub-str.

                    IF sy-subrc NE 0.

                      SPLIT t_tokens_sub-str AT l_sep1 INTO l_types
                      l_fld1.

                      IF l_types IS NOT INITIAL AND STRLEN( l_types ) <
                      6.

                        SELECT SINGLE *             " Table Name
                        INTO i_ddtypet
                        FROM ddtypet
                        " SAP Tables
                        WHERE typegroup = l_types .

                        IF sy-subrc = 0.

                          l_tabix = sy-tabix - 2.
                          READ TABLE t_tokens_sub INDEX l_tabix.

                          IF t_tokens_sub-str(l_ltab) <> p_ltab AND
                          t_tokens_sub-str(l_lwa) <> p_lwa.

                            CONCATENATE
'Error: Local Internal Table name is not matching'
                                         t_tokens_sub-str
                                         INTO t_mess-message
                                         SEPARATED BY space.

                            READ TABLE source_main INDEX
                            t_tokens_sub-row.
***Changes by Shastry
                            READ TABLE t_mess WITH KEY lineno2 =
                            source_main-lineno.
                            IF sy-subrc NE 0 AND t_mess-item_no NE '2'.
***END Changes by Shastry
                              t_mess-lineno2 = source_main-lineno.
                              t_mess-program = source_main-program.
                              t_mess-item_no = '2'.
                              APPEND t_mess.
                              w_itab_ctr = w_itab_ctr + 1.
                            ENDIF.
                          ENDIF.

                        ENDIF.
                      ELSE.
                        sy-subrc = 4.
                      ENDIF.
                    ENDIF.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDIF.
            IF sy-subrc NE 0.

              l_tabix = sy-tabix - 2.
              READ TABLE t_tokens_sub INDEX l_tabix.

              READ TABLE source_main INDEX t_tokens_sub-row.

              IF source_main-form <> ' ' AND
                       t_tokens_sub-str(l_loc) <> p_loc.

****END Changes Shastry

                CONCATENATE
                'Error: Local variable name is not matching  '
t_tokens_sub-str
                                                       INTO
                                                       t_mess-message
                                                        SEPARATED BY
                                                        space
                                                        .
                READ TABLE source_main INDEX t_tokens_sub-row.
***Changes by Shastry
                READ TABLE t_mess WITH KEY lineno2 = source_main-lineno.
                IF sy-subrc NE 0 AND t_mess-item_no NE '1'.
                  w_var_ctr = w_var_ctr + 1.
***END Changes by Shastry
                  t_mess-lineno2 = source_main-lineno.
                  t_mess-program = source_main-program.
                  t_mess-item_no = '1'.
                  APPEND t_mess.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    count = count + 1.
    l_count = count + 1.
    CLEAR t_mess.
  ENDLOOP.

  CALL FUNCTION 'RS_PROGRAM_INDEX'
   EXPORTING
     pg_name             = g_pname
* IMPORTING
*   MESSAGE_CLASS       =
   TABLES
     compo               = i_compo
     cross_ref           = i_cross_ref
     inc                 = i_inc
  EXCEPTIONS
    syntax_error        = 1
    OTHERS              = 2
           .
  IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.


ENDFORM.                    " VARIABLE_NAMING

*&---------------------------------------------------------------------*
*&      Form  SORT_CHECKING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sort_checking.


  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA:
    l_key_index LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s.

  LOOP AT t_tokens_sub WHERE str = 'READ' .
    CLEAR found.
    nextidx = sy-tabix + 1 .
    lno = t_tokens_sub-row .
    row1 = t_tokens_sub-row .
    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.

    IF sy-subrc = 0.
      l_from = t_statements_sub-from.
      l_to   = t_statements_sub-to.
      l_syrow = sy-tabix + 1.
      IF NOT sy_read IS INITIAL.
        PERFORM check_sysubrc USING l_syrow nextidx flag_s lno.
      ENDIF.
    ENDIF.

    READ TABLE t_tokens_sub INDEX nextidx .
    IF t_tokens_sub-str = 'TABLE' .
*         perform find_sort using t_name l_no .
    ELSE ." it is not READ TABLE syntax
      CLEAR: nextidx, nextread,found,l_from, l_to, tabnam, l_key_index.
      REFRESH t_key1_tab.
      CONTINUE.
    ENDIF.

    nextidx = nextidx + 1 .

    READ TABLE t_tokens_sub INDEX nextidx .


    tabnam = t_tokens_sub-str .

    LOOP AT t_tokens_sub FROM l_from TO l_to.
      IF t_tokens_sub-str = 'BINARY'.
        found = '1'.
      ENDIF.
      IF t_tokens_sub-str = 'INDEX'.
        found = '2'.
      ENDIF.
    ENDLOOP.

    IF found = '1'.
      LOOP AT t_tokens_sub FROM l_from TO l_to.
        IF t_tokens_sub-str = 'KEY'.
          l_key_index = sy-tabix + 1.
          READ TABLE t_tokens_sub INDEX l_key_index.
          IF sy-subrc = 0.
            t_key1_tab-key = t_tokens_sub-str.
            APPEND t_key1_tab.
            DO.
              l_key_index = l_key_index + 3.
              IF l_key_index > l_to.
                EXIT.
              ENDIF.
              READ TABLE t_tokens_sub INDEX l_key_index.
              IF sy-subrc = 0.
                IF t_tokens_sub-str = 'BINARY'.
                  EXIT.
                ELSEIF t_tokens_sub-str = 'INTO'.
                  EXIT.
                ELSE.
                  t_key1_tab-key = t_tokens_sub-str.
                  APPEND t_key1_tab.
                ENDIF.
              ENDIF.
            ENDDO.
          ENDIF.

        ENDIF.
      ENDLOOP.
      IF NOT sort_bny IS INITIAL.
        PERFORM find_sort USING tabnam lno .
      ENDIF.
    ELSEIF found = '2'.

    ELSEIF NOT read_bny IS INITIAL.
      READ TABLE source_main INDEX lno.
      READ TABLE t_mess WITH KEY item_no = '4'
                                lineno2 = source_main-lineno .
      IF sy-subrc <> 0.

        t_mess-message = 'Binary search missing after read'.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '4'.
        APPEND t_mess.
        w_bny_ctr = w_bny_ctr + 1.
      ENDIF.
    ENDIF.

* let us clear our variables
    CLEAR: nextidx, nextread,found, l_from, l_to, tabnam,l_key_index.
    REFRESH t_key1_tab.
  ENDLOOP .

ENDFORM.                    " SORT_CHECKING

*&---------------------------------------------------------------------*
*&      Form  find_sort
*&--------------------------------------7-------------------------------
*
*       text
*----------------------------------------------------------------------*
*      -->P_TABNAM  text
*      -->P_LNO  text
*----------------------------------------------------------------------*
FORM find_sort USING    p_tabnam
                        p_lno .


  DATA: l_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: l_tokens LIKE stoken OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF l_keywords OCCURS 1,
            line(20),
        END OF l_keywords.
  DATA: l_warn .

  DATA:
    l_tabix LIKE sy-tabix,
    l_stmt_to LIKE sstmnt-to.
  DATA: BEGIN OF t_key_table OCCURS 0,
          key LIKE stoken-str,
        END OF t_key_table.

  LOOP AT t_tokens_sub WHERE str = 'SORT'.
    l_tabix = sy-tabix + 1.
    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_stmt_to = t_statements_sub-to.
    ENDIF.

    READ TABLE t_tokens_sub INDEX l_tabix.
    IF sy-subrc = 0.
      IF t_tokens_sub-str = p_tabnam.
        IF t_tokens_sub-row < p_lno .
          l_tabix = l_tabix + 2.
          REFRESH t_key_table.
          LOOP AT t_tokens_sub FROM l_tabix TO l_stmt_to.
            CASE t_tokens_sub-str.
              WHEN 'DESCENDING' OR 'ASCENDING' OR 'AS' OR 'TEXT' OR
                   'STABLE' OR 'BY'.
              WHEN OTHERS.
                t_key_table = t_tokens_sub-str.
                APPEND t_key_table.
            ENDCASE.
          ENDLOOP.
          IF sy-subrc <> 0.
            l_warn = 'Y'.
          ELSE.
            l_warn = 'Z'.
          ENDIF.
        ELSE.
          l_warn = 'X' .
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP .
  IF t_key_table[] IS INITIAL.
    IF l_warn = 'X'.
      CLEAR l_warn.
      READ TABLE source_main INDEX p_lno.
      READ TABLE t_mess WITH KEY item_no = '3'
                                lineno2 = source_main-lineno .
      IF sy-subrc <> 0.
        w_sort_ctr = w_sort_ctr + 1.
        CONCATENATE 'Warning : Sort has been used for'
                   p_tabnam
                  ' but after reading the table'
                  INTO t_mess-message
                  SEPARATED BY space.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '3'.
        APPEND t_mess.
      ENDIF.
    ELSEIF l_warn = 'Y'.
      READ TABLE source_main INDEX p_lno.
      READ TABLE t_mess WITH KEY item_no = '3'
                                lineno2 = source_main-lineno .
      IF sy-subrc <> 0.
        w_sort_ctr = w_sort_ctr + 1.
        CONCATENATE 'Warning : Sort has been used for'
                    p_tabnam
                   ' but WITHOUT ANY KEYS'
                  INTO t_mess-message
                  SEPARATED BY space.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '3'.
        APPEND t_mess.
      ENDIF.
    ELSEIF l_warn = 'Z'.
      READ TABLE source_main INDEX p_lno.
      READ TABLE t_mess WITH KEY item_no = '3'
                                lineno2 = source_main-lineno .
      IF sy-subrc <> 0.
        w_sort_ctr = w_sort_ctr + 1.
        CONCATENATE 'No sort has been used for'
                  p_tabnam
                  INTO t_mess-message
                  SEPARATED BY space.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '3'.
        APPEND t_mess.
      ENDIF.
    ENDIF.
  ELSE.
    IF t_key_table[] <> t_key1_tab[].
      READ TABLE source_main INDEX p_lno.
      READ TABLE t_mess WITH KEY item_no = '3'
                                lineno2 = source_main-lineno .
      IF sy-subrc <> 0.
        w_sort_ctr = w_sort_ctr + 1.
        CONCATENATE 'Warning : Sort has been used for'
                   p_tabnam
                 ' but not in proper order'
                  INTO t_mess-message
                  SEPARATED BY space.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '3'.
        APPEND t_mess.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    " find_sort

*&---------------------------------------------------------------------*
*&      Form  CHECK_WHERE_CLAUSE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM check_where_clause.

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA:
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4).

  LOOP AT t_tokens_sub WHERE str = 'SELECT' . "search for select
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .

    CLEAR:
      l_from,
      l_to.

    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements_sub-from.
      l_to = t_statements_sub-to.
      IF into_cor = 'X'.
        LOOP AT t_tokens_sub FROM l_from TO l_to.
          IF t_tokens_sub-str = 'CORRESPONDING'.
            READ TABLE source_main INDEX t_tokens_sub-row.
            READ TABLE t_mess WITH KEY item_no = '17'
                                       lineno2 = source_main-lineno .
            IF sy-subrc <> 0.
              t_mess-message = 'INTO COREESPONDING is used in SELECT'.
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.

              t_mess-item_no = '17'.
              APPEND t_mess.
              w_intocor_ctr = w_intocor_ctr + 1.
            ENDIF.

          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.

    IF sel_star = 'X'.
      CLEAR wa_tokens.
      READ TABLE t_tokens_sub INTO wa_tokens INDEX nextidx.
      IF wa_tokens-str = '*'.
        READ TABLE source_main INDEX wa_tokens-row.
        READ TABLE t_mess WITH KEY item_no = '15'
                                   lineno2 = source_main-lineno .
        IF sy-subrc <> 0.
          t_mess-message = 'SELECT * has been used'.
          t_mess-lineno2 = source_main-lineno.
          t_mess-program = source_main-program.

          t_mess-item_no = '15'.
          APPEND t_mess.
          w_star_ctr = w_star_ctr + 1.
        ENDIF.

      ENDIF.
    ENDIF.

    .
    READ TABLE t_statements_sub WITH KEY FROM = l_new_tabix.

    IF sy-subrc = 0.
      l_syrow = sy-tabix + 1.
      flag_s = 'S'.
      IF NOT sy_sel IS INITIAL.
        READ TABLE t_statements_sub INDEX l_syrow.
        IF sy-subrc = 0.
          READ TABLE t_tokens_sub INDEX t_statements_sub-from.
          IF sy-subrc = 0.
            IF t_tokens_sub-str = 'ENDSELECT'.
              l_syrow = l_syrow + 1.
            ENDIF.
          ENDIF.
        ENDIF.
        PERFORM check_sysubrc USING l_syrow nextidx flag_s lno.
      ENDIF.
    ENDIF.
    IF NOT hard_wre IS INITIAL.
      LOOP AT t_tokens_sub FROM nextidx TO l_to.
        IF t_tokens_sub-str = 'WHERE'.    " start investigations
          lno = t_tokens_sub-row .
          LOOP AT t_tokens_sub FROM sy-tabix TO l_to.
            IF t_tokens_sub-str CS ''''.
              READ TABLE source_main INDEX lno.
              READ TABLE t_mess WITH KEY item_no = '9'
                                        lineno2 = source_main-lineno .
              IF sy-subrc <> 0.
                t_mess-message =
                'Warning: Hardcoding in where / IF clause Line'.
                t_mess-lineno2 = source_main-lineno.
                t_mess-program = source_main-program.

                t_mess-item_no = '9'.
                APPEND t_mess.
                w_whr_ctr = w_whr_ctr + 1.
              ENDIF.
            ENDIF.
          ENDLOOP.
        ELSE.
          CONTINUE.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " CHECK_WHERE_CLAUSE
*&---------------------------------------------------------------------*
*&      Form  int_table_checking
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM int_table_checking.

  DATA:  l_tabix TYPE i, "counter
         l_tabl  TYPE i,
         l_old_tabix TYPE i,
         l_name(30) TYPE c,
         l_struc TYPE i,
         l_lstruc TYPE i,
         l_typeln TYPE i,
         l_walen TYPE i,
         l_var TYPE i,
         l_counter TYPE i,
         l_tabname1,
         key_wd LIKE stoken-str.
  RANGES:
    r_typ_inttab FOR stoken-str,
    r_typ_struct FOR stoken-str.

  DATA: BEGIN OF t_keywords OCCURS 1,
             line(20),
        END OF t_keywords.

  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.

  DATA: BEGIN OF t_itab1   OCCURS 0,
           str1 LIKE stoken-str, "tokens of the program being tested
           row2 LIKE stoken-row,
        END OF t_itab1.
  DATA:  split1(20),split2(20).


  t_keywords = 'TYPES'.      APPEND t_keywords.

  l_tabl = STRLEN( p_tabl ). "finding length of the parameters
  l_struc = STRLEN( p_struc ).
  l_lstruc = STRLEN( p_lstr ).
  l_typeln = STRLEN( p_type ).
  l_walen  = STRLEN( p_wa ).
  r_typ_struct-sign = 'I'.
  r_typ_struct-option = 'EQ'.
  r_typ_inttab-sign = 'I'.
  r_typ_inttab-option = 'EQ'.
** Begin of version 2
  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                          TOKENS INTO t_tokens
                          KEYWORDS   FROM t_keywords.
  LOOP AT t_tokens.
    CLEAR:
      r_typ_struct-low,
      r_typ_inttab-low.
    IF t_tokens-str = 'TYPES'.

      l_old_tabix = sy-tabix.
      l_tabix = sy-tabix + 1.
      READ TABLE t_tokens INDEX l_tabix.
      IF sy-subrc = 0.
        l_name = t_tokens-str.
        IF t_tokens-str = 'BEGIN'.
          READ TABLE t_statements WITH KEY FROM = l_old_tabix.
          IF sy-subrc = 0.
            LOOP AT t_tokens FROM l_old_tabix TO t_statements-to.
              IF t_tokens-str = 'OCCURS'.
                l_tabix = sy-tabix - 1.
                READ TABLE t_tokens INDEX l_tabix.
                IF sy-subrc = 0.
                  IF NOT p_type IS INITIAL.
                    IF t_tokens-str(l_typeln) NE p_type.

                      CONCATENATE
                        'TYPES'
                        t_tokens-str
                        'Name is not matching'
                        INTO t_mess-message.

                      READ TABLE source_main INDEX t_tokens-row.
                      t_mess-lineno2 = source_main-lineno.
                      t_mess-program = source_main-program.
                      t_mess-item_no = '18'.
                      READ TABLE t_mess WITH KEY item_no = '18'
                                               lineno2 = t_mess-lineno2.
                      IF sy-subrc <> 0.
                        w_types_ctr = w_types_ctr + 1.
                        APPEND t_mess.
                      ENDIF.

                    ENDIF.
                  ENDIF.
                  r_typ_inttab-low = t_tokens-str.
                  APPEND r_typ_inttab.
                  EXIT.
                ENDIF.
              ENDIF.
            ENDLOOP.
          ENDIF.

          IF r_typ_inttab-low IS INITIAL.
            l_tabix = l_tabix + 2.
            READ TABLE t_tokens INDEX l_tabix.
            IF sy-subrc = 0.
              IF NOT p_type IS INITIAL.

                IF t_tokens-str(l_typeln) NE p_type.

                  CONCATENATE
                    'TYPES'
                    t_tokens-str
                    'Name is not matching'
                    INTO t_mess-message
                    SEPARATED BY space.
                  READ TABLE source_main INDEX t_tokens-row.
                  t_mess-lineno2 = source_main-lineno.
                  t_mess-program = source_main-program.
                  t_mess-item_no = '18'.
                  READ TABLE t_mess WITH KEY item_no = '18'
                                             lineno2 = t_mess-lineno2.
                  IF sy-subrc <> 0.
                    w_types_ctr = w_types_ctr + 1.
                    APPEND t_mess.
                  ENDIF.

                ENDIF.
              ENDIF.
              r_typ_struct-low = t_tokens-str.
              APPEND r_typ_struct.
            ENDIF.
          ENDIF.

          l_counter = l_counter + 1.
        ELSEIF t_tokens-str = 'END'.
          l_counter = l_counter - 1.
        ELSE.
          IF l_counter = 0.
            READ TABLE t_statements WITH KEY  FROM = l_old_tabix.
            IF sy-subrc = 0.
              LOOP AT t_tokens FROM l_old_tabix TO t_statements-to.
                IF t_tokens-str = 'OCCURS' OR t_tokens-str = 'INITIAL'
                   OR t_tokens-str = 'STANDARD' OR t_tokens-str =
                   'HASHED'
                   OR t_tokens-str = 'SORTED'.
                  r_typ_inttab-low = l_name.
                  APPEND r_typ_inttab.

                  EXIT.
                ENDIF.
              ENDLOOP.
            ENDIF.

            IF r_typ_inttab-low IS INITIAL.
              r_typ_struct-low = l_name.
              APPEND r_typ_inttab.

            ENDIF.

          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.

** End of version 2

  REFRESH:
    t_keywords,
    t_tokens,
    t_statements.
  t_keywords = 'DATA'.           APPEND t_keywords.

  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                          TOKENS INTO t_tokens
                          KEYWORDS   FROM t_keywords.

*  read table t_tokens index 1.

  LOOP AT t_tokens.

* Checking for Internal Table Declaration according to standards

    IF   ( t_tokens-str = 'DATA' OR t_tokens-str = 'TYPES' )
         AND
         sy-tabix    <>   1.

      key_wd =  t_tokens-str.

      READ TABLE t_itab1 WITH KEY
                  str1 = 'BEGIN'.
* Checking for Internal Table Declared with keyword BEGIN & OCCURS

      IF sy-subrc = 0.
        READ TABLE t_itab1 WITH KEY
               str1 = 'OCCURS'.
        IF sy-subrc = 0.
          READ TABLE t_itab1 INDEX 4.
          r_intstc-low = t_itab1-str1.
          APPEND r_intstc.
          READ TABLE source_main INDEX t_itab1-row2.
          IF source_main-form <> ' '.
            PERFORM validate_local_int_tab USING t_itab1-str1
                                                 t_itab1-row2
                                                 l_tabl.
          ELSE.
            IF t_itab1-str1(l_tabl) <> p_tabl.
              CONCATENATE 'Error: Internal Table name is not matching'
                           t_itab1-str1
                           INTO t_mess-message
                           SEPARATED BY space.

              READ TABLE source_main INDEX t_itab1-row2.

              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '2'.
              APPEND t_mess.
              w_itab_ctr = w_itab_ctr + 1.
            ENDIF.
          ENDIF.
* Checking for STRUCTURE Declaration according to standards
        ELSE.
          READ TABLE t_itab1 INDEX 4.
          r_intstc-low = t_itab1-str1.
          APPEND r_intstc.
          IF t_itab1-str1 IN r_work_area AND
                                   NOT r_work_area[] IS  INITIAL.
            READ TABLE source_main INDEX t_itab1-row2.
            IF source_main-form <> ' '.
              PERFORM validate_local_wa USING t_itab1-str1
                                                   t_itab1-row2
                                                   l_tabl.
            ELSE.
              IF t_itab1-str1(l_walen) <> p_wa.

                w_itab_ctr = w_itab_ctr + 1.
                CONCATENATE
                'Error: Work Area name is not matching'
                                             t_itab1-str1
                                      INTO t_mess-message
                                       SEPARATED BY space
    .

                READ TABLE source_main INDEX t_itab1-row2.

                t_mess-lineno2 = source_main-lineno.
                t_mess-program = source_main-program.
                t_mess-item_no = '2'.
                APPEND t_mess.
              ENDIF.
            ENDIF.

          ELSE.
            READ TABLE source_main INDEX t_itab1-row2.
            IF source_main-form <> ' '.
              PERFORM validate_local_struc USING t_itab1-str1
                                                   t_itab1-row2
                                                   l_lstruc.
            ELSE.
              IF t_itab1-str1(l_struc) <> p_struc.
                w_itab_ctr = w_itab_ctr + 1.
                CONCATENATE 'Error: Structure name is not matching'
                             t_itab1-str1
                             INTO t_mess-message
                             SEPARATED BY space.

                READ TABLE source_main INDEX t_itab1-row2.

                t_mess-lineno2 = source_main-lineno.
                t_mess-program = source_main-program.
                t_mess-item_no = '2'.
                APPEND t_mess.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
* Checking for Internal Table Declared with keyword OCCURS

      ELSE.
        READ TABLE t_itab1 WITH KEY
            str1 = 'OCCURS'.
        IF sy-subrc = 0.
          READ TABLE t_itab1 INDEX 2.
          r_intstc-low = t_itab1-str1.
          APPEND r_intstc.
          READ TABLE source_main INDEX t_itab1-row2.
          IF source_main-form <> ' '.
            PERFORM validate_local_int_tab USING t_itab1-str1
                                                 t_itab1-row2
                                                 l_tabl.
          ELSE.
            IF t_itab1-str1(l_tabl) <> p_tabl.
              w_itab_ctr = w_itab_ctr + 1.
              CONCATENATE 'Error: Internal Table name is not matching'
                          t_itab1-str1
                          INTO t_mess-message
                          SEPARATED BY space.

              READ TABLE source_main INDEX t_itab1-row2.

              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '2'.
              APPEND t_mess.
            ENDIF.
          ENDIF.
* Checking for Internal Table Declared with keyword INITIAL

        ELSE.

          READ TABLE t_itab1 WITH KEY
            str1 = 'INITIAL'.
          IF sy-subrc = 0.
            READ TABLE t_itab1 INDEX 2.
            r_intstc-low = t_itab1-str1.
            APPEND r_intstc.
            READ TABLE source_main INDEX t_itab1-row2.
            IF source_main-form <> ' '.
              PERFORM validate_local_int_tab USING t_itab1-str1
                                                   t_itab1-row2
                                                   l_tabl.
            ELSE.
              IF t_itab1-str1(l_tabl) <> p_tabl.
                w_itab_ctr = w_itab_ctr + 1.
                CONCATENATE 'Error: Internal Table name is not matching'
                              t_itab1-str1
                              INTO t_mess-message
                              SEPARATED BY space.

                READ TABLE source_main INDEX t_itab1-row2.

                t_mess-lineno2 = source_main-lineno.
                t_mess-program = source_main-program.
                t_mess-item_no = '2'.
                APPEND t_mess.
              ENDIF.
            ENDIF.

*Checking for Internal Table declared with keywords Standard,Sorted,
*Hashed,Index Or Any
          ELSE.
            READ TABLE t_itab1 INDEX 4.
            IF sy-subrc = 0.
              IF ( ( NOT r_typ_inttab[] IS INITIAL ) AND
                 t_itab1-str1 IN r_typ_inttab ).

                READ TABLE t_itab1 INDEX 2.
                r_intstc-low = t_itab1-str1.
                APPEND r_intstc.
                READ TABLE source_main INDEX t_itab1-row2.
                IF source_main-form <> ' '.
                  PERFORM validate_local_int_tab USING t_itab1-str1
                                                 t_itab1-row2
                                                 l_tabl.
                ELSE.
                  IF t_itab1-str1(l_tabl) <> p_tabl.
                    w_itab_ctr = w_itab_ctr + 1.
                    CONCATENATE
                    'Error: Internal Table name is not MATCHING'
                                t_itab1-str1
                                INTO t_mess-message
                                SEPARATED BY space.

                    READ TABLE source_main INDEX t_itab1-row2.

                    t_mess-lineno2 = source_main-lineno.
                    t_mess-program = source_main-program.
                    t_mess-item_no = '2'.
                    APPEND t_mess.
                  ENDIF.
                ENDIF.

**********************
              ELSEIF ( ( NOT r_typ_struct[] IS INITIAL ) AND
                      t_itab1-str1 IN r_typ_struct ).

                READ TABLE t_itab1 INDEX 2.
                r_intstc-low = t_itab1-str1.
                APPEND r_intstc.
                IF t_itab1-str1 IN r_work_area AND
                   NOT r_work_area[] IS INITIAL.
                  READ TABLE source_main INDEX t_itab1-row2.
                  IF source_main-form <> ' '.
                    PERFORM validate_local_wa USING t_itab1-str1
                                                         t_itab1-row2
                                                         l_tabl.
                  ELSE.
                    IF t_itab1-str1(l_walen) <> p_wa.

                      w_itab_ctr = w_itab_ctr + 1.
                      CONCATENATE
                      'Error: Work Area name is not matching'
                                                   t_itab1-str1
                                              INTO t_mess-message
                                               SEPARATED BY space
    .

                      READ TABLE source_main INDEX t_itab1-row2.

                      t_mess-lineno2 = source_main-lineno.
                      t_mess-program = source_main-program.
                      t_mess-item_no = '2'.
                      APPEND t_mess.
                    ENDIF.
                  ENDIF.


                ELSE.
                  READ TABLE source_main INDEX t_itab1-row2.
                  IF source_main-form <> ' '.
                    PERFORM validate_local_struc USING t_itab1-str1
                                                         t_itab1-row2
                                                         l_tabl.
                  ELSE.
                    IF t_itab1-str1(l_struc) <> p_struc.

                      w_itab_ctr = w_itab_ctr + 1.
                      CONCATENATE
                      'Error: Structure name is not matching'
                                                     t_itab1-str1
                                              INTO t_mess-message
                                               SEPARATED BY space
    .

                      READ TABLE source_main INDEX t_itab1-row2.

                      t_mess-lineno2 = source_main-lineno.
                      t_mess-program = source_main-program.
                      t_mess-item_no = '2'.
                      APPEND t_mess.
                    ENDIF.
                  ENDIF.
                ENDIF.
***********************
              ELSE.


                READ TABLE t_itab1 INDEX 4.
                CASE t_itab1-str1.

                  WHEN 'STANDARD' OR 'SORTED' OR 'HASHED' OR 'INDEX'
                    OR 'ANY'.                                        " 1
                    READ TABLE t_itab1 INDEX 5.
                    IF t_itab1-str1 = 'TABLE'.
                      READ TABLE t_itab1 INDEX 2.
                      r_intstc-low = t_itab1-str1.
                      APPEND r_intstc.
                      w_ini_ctr = w_ini_ctr + 1.
                      CONCATENATE
                  'Error: Internal Table declared without initial size'
                                     t_itab1-str1
                                     INTO t_mess-message
                                     SEPARATED BY space.

                      READ TABLE source_main INDEX t_itab1-row2.

                      t_mess-lineno2 = source_main-lineno.
                      t_mess-program = source_main-program.
                      t_mess-item_no = '8'.
                      APPEND t_mess.
                      READ TABLE source_main INDEX t_itab1-row2.
                      IF source_main-form <> ' '.
                        PERFORM validate_local_int_tab USING
                        t_itab1-str1
                                                 t_itab1-row2
                                                 l_tabl.
                      ELSE.
                        IF t_itab1-str1(l_tabl) <> p_tabl.
                          w_itab_ctr = w_itab_ctr + 1.
                          CONCATENATE
                          'Error: Internal Table name is not MATCHING'
                                      t_itab1-str1
                                      INTO t_mess-message
                                      SEPARATED BY space.

                          READ TABLE source_main INDEX t_itab1-row2.

                          t_mess-lineno2 = source_main-lineno.
                          t_mess-program = source_main-program.
                          t_mess-item_no = '2'.
                          APPEND t_mess.
                        ENDIF.
                      ENDIF.
                    ENDIF.

* Checking for Internal Table declared with keywords TABLE or RANGE

                  WHEN 'TABLE' OR 'RANGE'.
                    " 2

                    READ TABLE t_itab1 INDEX 2.
                    r_intstc-low = t_itab1-str1.
                    APPEND r_intstc.
                    w_ini_ctr = w_ini_ctr + 1.
                    CONCATENATE
                  'Error: Internal Table declared without initial size'
                                     t_itab1-str1
                                     INTO t_mess-message
                                     SEPARATED BY space.

                    READ TABLE source_main INDEX t_itab1-row2.

                    t_mess-lineno2 = source_main-lineno.
                    t_mess-program = source_main-program.
                    t_mess-item_no = '8'.
                    APPEND t_mess.
                    READ TABLE source_main INDEX t_itab1-row2.
                    IF source_main-form <> ' '.
                      PERFORM validate_local_int_tab USING t_itab1-str1
                                                     t_itab1-row2
                                                     l_tabl.
                    ELSE.
                      IF t_itab1-str1(l_tabl) <> p_tabl.
                        w_itab_ctr = w_itab_ctr + 1.
                        CONCATENATE
                        'Error: Internal Table name is not MATCHING'
                                     t_itab1-str1
                                     INTO t_mess-message
                                     SEPARATED BY space.

                        READ TABLE source_main INDEX t_itab1-row2.

                        t_mess-lineno2 = source_main-lineno.
                        t_mess-program = source_main-program.
                        t_mess-item_no = '2'.
                        APPEND t_mess.
                      ENDIF.
                    ENDIF.
* Checking for Internal Table declared in some other way

                  WHEN OTHERS.
                    " 3
***** Addition for table type
                    SELECT SINGLE typename INTO l_tabname1
                      FROM dd40l WHERE typename = t_itab1-str1
                      AND as4local = 'A'.
                    IF sy-subrc = 0.
                      READ TABLE t_itab1 INDEX 2.
                      r_intstc-low = t_itab1-str1.
                      APPEND r_intstc.
                      READ TABLE source_main INDEX t_itab1-row2.
                      IF source_main-form <> ' '.
                        PERFORM validate_local_int_tab USING
                        t_itab1-str1
                                                       t_itab1-row2
                                                       l_tabl.
                      ELSE.
                        IF t_itab1-str1(l_tabl) <> p_tabl.
                          w_itab_ctr = w_itab_ctr + 1.
                          CONCATENATE
                          'Error: Internal Table name is not MATCHING'
                                      t_itab1-str1
                                      INTO t_mess-message
                                      SEPARATED BY space.

                          READ TABLE source_main INDEX t_itab1-row2.

                          t_mess-lineno2 = source_main-lineno.
                          t_mess-program = source_main-program.
                          t_mess-item_no = '2'.
                          APPEND t_mess.
                        ENDIF.
                      ENDIF.
                    ELSE.
                      SELECT SINGLE tabname INTO l_tabname1
                          FROM dd02l WHERE tabname = t_itab1-str1.
                      IF sy-subrc = 0.


                        READ TABLE t_itab1 INDEX 2.

                        IF t_itab1-str1 <> 'END'.
                          r_intstc-low = t_itab1-str1.
                          APPEND r_intstc.
                          IF t_itab1-str1 IN r_work_area AND
                                            NOT r_work_area[] IS INITIAL
                                            .
                            READ TABLE source_main INDEX t_itab1-row2.
                            IF source_main-form <> ' '.
                              PERFORM validate_local_wa USING
                              t_itab1-str1
t_itab1-row2
l_tabl.
                            ELSE.
                              IF t_itab1-str1(l_walen) <> p_wa.

                                w_itab_ctr = w_itab_ctr + 1.
                                CONCATENATE
                                'Error: Work Area name is not matching'
t_itab1-str1
                                                        INTO
                                                        t_mess-message
                                                         SEPARATED BY
                                                         space
              .

                                READ TABLE source_main INDEX
                                t_itab1-row2.

                                t_mess-lineno2 = source_main-lineno.
                                t_mess-program = source_main-program.
                                t_mess-item_no = '2'.
                                APPEND t_mess.
                              ENDIF.
                            ENDIF.


                          ELSE.
                            READ TABLE source_main INDEX t_itab1-row2.
                            IF source_main-form <> ' '.
                              PERFORM validate_local_struc USING
                              t_itab1-str1
t_itab1-row2
l_tabl.
                            ELSE.
                              IF t_itab1-str1(l_struc) <> p_struc.

                                w_itab_ctr = w_itab_ctr + 1.
                                CONCATENATE
                                'Error: Structure name is not matching'
t_itab1-str1
                                                                INTO
t_mess-message
SEPARATED BY space.

                                READ TABLE source_main INDEX
                                t_itab1-row2.

                                t_mess-lineno2 = source_main-lineno.
                                t_mess-program = source_main-program.
                                t_mess-item_no = '2'.
                                APPEND t_mess.
                              ENDIF.
                            ENDIF.
                          ENDIF.
                        ENDIF.
************************************************************************
* Intenal Table Declaration :-
*
*TYPES: BEGIN OF STRUC, NAME(10), AGE TYPE I, END OF STRUC,
*       HTAB TYPE HASHED TABLE OF STRUC WITH UNIQUE KEY NAME.
*DATA : PERSONS TYPE HTAB.

* Internal Table Declaration of this type is to be checked for
* Standard Declaration.An attempt has been made in the following ELSE
* statement
************************************************************************
* Checking for variable declaration according to standards
* incomplete to be done
*                read table t_itab1 index 4.
*                split t_itab1-str1 at '-' into split1 split2.
*                if sy-subrc = 0.
*                write sy-subrc.
*                endif.
************************************************************************
                      ELSEIF t_itab1-str1 IN r_intstc.
                        IF NOT r_intstc[] IS INITIAL.
                          READ TABLE t_itab1 INDEX 2.
                          IF t_itab1-str1 <> 'END' .
                            r_intstc-low = t_itab1-str1.
                            APPEND r_intstc.
                            IF t_itab1-str1 IN r_work_area AND
                                     NOT r_work_area[] IS  INITIAL.
                              READ TABLE source_main INDEX t_itab1-row2.
                              IF source_main-form <> ' '.
                                PERFORM validate_local_wa USING
                                t_itab1-str1
t_itab1-row2
l_tabl.
                              ELSE.
                                IF t_itab1-str1(l_walen) <> p_wa.

                                  w_itab_ctr = w_itab_ctr + 1.
                                  CONCATENATE
'Error: Work Area name is not matching'
t_itab1-str1
                                                        INTO
                                                        t_mess-message
                                                         SEPARATED BY
                                                         space
                .

                                  READ TABLE source_main INDEX
                                  t_itab1-row2.

                                  t_mess-lineno2 = source_main-lineno.
                                  t_mess-program = source_main-program.
                                  t_mess-item_no = '2'.
                                  APPEND t_mess.
                                ENDIF.
                              ENDIF.


                            ELSE.
                              READ TABLE source_main INDEX t_itab1-row2.
                              IF source_main-form <> ' '.
                                PERFORM validate_local_struc USING
                                t_itab1-str1
t_itab1-row2
l_tabl.
                              ELSE.
                                IF t_itab1-str1(l_struc) <> p_struc.

                                  w_itab_ctr = w_itab_ctr + 1.
                                  CONCATENATE
'Error: Structure name is not matching'
t_itab1-str1
                                                                  INTO
t_mess-message
SEPARATED BY space.

                                  READ TABLE source_main INDEX
                                  t_itab1-row2.

                                  t_mess-lineno2 = source_main-lineno.
                                  t_mess-program = source_main-program.
                                  t_mess-item_no = '2'.
                                  APPEND t_mess.
                                ENDIF.
                              ENDIF.
                            ENDIF.
                          ENDIF.
                        ENDIF.
                      ELSE.

                      ENDIF.
                    ENDIF.
                ENDCASE.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
      REFRESH t_itab1.
    ENDIF.
    t_itab1-str1 = t_tokens-str.
    t_itab1-row2 = t_tokens-row.
    APPEND t_itab1.

  ENDLOOP.

  READ TABLE t_itab1 INDEX 1.

  IF t_itab1-str1 = 'DATA'.

    READ TABLE t_itab1 WITH KEY
          str1 = 'BEGIN'.

    IF sy-subrc = 0.
      READ TABLE t_itab1 WITH KEY
             str1 = 'OCCURS'.
      IF sy-subrc = 0.
        READ TABLE t_itab1 INDEX 4.
        r_intstc-low = t_itab1-str1.
        APPEND r_intstc.
        READ TABLE source_main INDEX t_itab1-row2.
        IF source_main-form <> ' '.
          PERFORM validate_local_int_tab USING t_itab1-str1
                                         t_itab1-row2
                                         l_tabl.
        ELSE.
          IF t_itab1-str1(l_tabl) <> p_tabl.
            w_itab_ctr = w_itab_ctr + 1.
            CONCATENATE 'Error: Internal Table name is not matching'
                         t_itab1-str1
                        INTO t_mess-message
                        SEPARATED BY space.

            READ TABLE source_main INDEX t_itab1-row2.

            t_mess-lineno2 = source_main-lineno.
            t_mess-program = source_main-program.
            t_mess-item_no = '2'.
            APPEND t_mess.

          ENDIF.
        ENDIF.
      ELSE.
        READ TABLE t_itab1 INDEX 4.
        r_intstc-low = t_itab1-str1.
        APPEND r_intstc.
        IF t_itab1-str1 IN r_work_area AND
                                 NOT r_work_area[] IS  INITIAL.
          READ TABLE source_main INDEX t_itab1-row2.
          IF source_main-form <> ' '.
            PERFORM validate_local_wa USING t_itab1-str1
                                                 t_itab1-row2
                                                 l_tabl.
          ELSE.
            IF t_itab1-str1(l_walen) <> p_wa.

              w_itab_ctr = w_itab_ctr + 1.
              CONCATENATE
              'Error: Work Area name is not matching'
                                           t_itab1-str1
                                    INTO t_mess-message
                                     SEPARATED BY space
  .

              READ TABLE source_main INDEX t_itab1-row2.

              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '2'.
              APPEND t_mess.
            ENDIF.
          ENDIF.

        ELSE.
          READ TABLE source_main INDEX t_itab1-row2.
          IF source_main-form <> ' '.
            PERFORM validate_local_struc USING t_itab1-str1
                                                 t_itab1-row2
                                                 l_tabl.
          ELSE.
            IF t_itab1-str1(l_struc) <> p_struc.
              w_itab_ctr = w_itab_ctr + 1.
              CONCATENATE 'Error: Structure name is not matching'
                           t_itab1-str1
                           INTO t_mess-message
                           SEPARATED BY space.

              READ TABLE source_main INDEX t_itab1-row2.

              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '2'.
              APPEND t_mess.
            ENDIF.
          ENDIF.

        ENDIF.
      ENDIF.
    ELSE.
      READ TABLE t_itab1 WITH KEY
          str1 = 'OCCURS'.
      IF sy-subrc = 0.
        READ TABLE t_itab1 INDEX 2.
        r_intstc-low = t_itab1-str1.
        APPEND r_intstc.
        READ TABLE source_main INDEX t_itab1-row2.
        IF source_main-form <> ' '.
          PERFORM validate_local_int_tab USING t_itab1-str1
                                         t_itab1-row2
                                         l_tabl.
        ELSE.
          IF t_itab1-str1(l_tabl) <> p_tabl.
            w_itab_ctr = w_itab_ctr + 1.
            CONCATENATE
            'Error: Internal Table name is not MATCHING'
                         t_itab1-str1
                         INTO t_mess-message
                         SEPARATED BY space.

            READ TABLE source_main INDEX t_itab1-row2.

            t_mess-lineno2 = source_main-lineno.
            t_mess-program = source_main-program.
            t_mess-item_no = '2'.
            APPEND t_mess.
          ENDIF.
        ENDIF.
      ELSE.
        READ TABLE t_itab1 WITH KEY
          str1 = 'INITIAL'.
        IF sy-subrc = 0.
          READ TABLE t_itab1 INDEX 2.
          r_intstc-low = t_itab1-str1.
          APPEND r_intstc.
          READ TABLE source_main INDEX t_itab1-row2.
          IF source_main-form <> ' '.
            PERFORM validate_local_int_tab USING t_itab1-str1
                                           t_itab1-row2
                                           l_tabl.
          ELSE.
            IF t_itab1-str1(l_tabl) <> p_tabl.
              w_itab_ctr = w_itab_ctr + 1.
              CONCATENATE 'Error: Internal Table name is not matching'
                           t_itab1-str1
                           INTO t_mess-message
                           SEPARATED BY space.

              READ TABLE source_main INDEX t_itab1-row2.

              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '2'.
              APPEND t_mess.
            ENDIF.
          ENDIF.
*Checking for Internal Table declared with keywords Standard,Sorted,
*Hashed,Index Or Any
        ELSE.
          READ TABLE t_itab1 INDEX 4.
          IF sy-subrc = 0.
            IF ( ( NOT r_typ_inttab[] IS INITIAL )
              AND t_itab1-str1 IN r_typ_inttab ).

              READ TABLE t_itab1 INDEX 2.
              r_intstc-low = t_itab1-str1.
              APPEND r_intstc.
              READ TABLE source_main INDEX t_itab1-row2.
              IF source_main-form <> ' '.
                PERFORM validate_local_int_tab USING t_itab1-str1
                                               t_itab1-row2
                                               l_tabl.
              ELSE.
                IF t_itab1-str1(l_tabl) <> p_tabl.
                  w_itab_ctr = w_itab_ctr + 1.
                  CONCATENATE
                  'Error: Internal Table name is not MATCHING'
                              t_itab1-str1
                              INTO t_mess-message
                              SEPARATED BY space.

                  READ TABLE source_main INDEX t_itab1-row2.

                  t_mess-lineno2 = source_main-lineno.
                  t_mess-program = source_main-program.
                  t_mess-item_no = '2'.
                  APPEND t_mess.
                ENDIF.
              ENDIF.
            ELSEIF ( ( NOT r_typ_struct[] IS INITIAL )
              AND t_itab1-str1 IN r_typ_struct ).

              READ TABLE t_itab1 INDEX 2.

              IF t_itab1-str1 <> 'END' .
                r_intstc-low = t_itab1-str1.
                APPEND r_intstc.
                IF t_itab1-str1 IN r_work_area AND
                                        NOT r_work_area[] IS  INITIAL
.
                  READ TABLE source_main INDEX t_itab1-row2.
                  IF source_main-form <> ' '.
                    PERFORM validate_local_wa USING t_itab1-str1
                                                         t_itab1-row2
                                                         l_tabl.
                  ELSE.
                    IF t_itab1-str1(l_walen) <> p_wa.

                      w_itab_ctr = w_itab_ctr + 1.
                      CONCATENATE
                      'Error: Work Area name is not matching'
                                                   t_itab1-str1
                                            INTO t_mess-message
                                             SEPARATED BY space
    .

                      READ TABLE source_main INDEX t_itab1-row2.

                      t_mess-lineno2 = source_main-lineno.
                      t_mess-program = source_main-program.
                      t_mess-item_no = '2'.
                      APPEND t_mess.
                    ENDIF.
                  ENDIF.


                ELSE.
                  READ TABLE source_main INDEX t_itab1-row2.
                  IF source_main-form <> ' '.
                    PERFORM validate_local_struc USING t_itab1-str1
                                                         t_itab1-row2
                                                         l_tabl.
                  ELSE.
                    IF t_itab1-str1(l_struc) <> p_struc.

                      w_itab_ctr = w_itab_ctr + 1.
                      CONCATENATE
                      'Error: Structure name is not matching'
                                                     t_itab1-str1
                                              INTO t_mess-message
                                               SEPARATED BY space
    .

                      READ TABLE source_main INDEX t_itab1-row2.

                      t_mess-lineno2 = source_main-lineno.
                      t_mess-program = source_main-program.
                      t_mess-item_no = '2'.
                      APPEND t_mess.
                    ENDIF.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDIF.

          ELSE.

            READ TABLE t_itab1 INDEX 4.
            CASE t_itab1-str1.
              WHEN 'STANDARD' OR 'SORTED' OR 'HASHED' OR 'INDEX' OR
                   'ANY'.

                READ TABLE t_itab1 INDEX 5.
                IF t_itab1-str1 = 'TABLE'.
                  READ TABLE t_itab1 INDEX 2.
                  r_intstc-low = t_itab1-str1.
                  APPEND r_intstc.
                  w_ini_ctr = w_ini_ctr + 1.
                  CONCATENATE
                'Error: Internal Table declared without initial size'
                                   t_itab1-str1
                                   INTO t_mess-message
                                   SEPARATED BY space.
                  t_mess-lineno2 = t_itab1-row2.
                  t_mess-program = source_main-program.
                  t_mess-item_no = '8'.
                  APPEND t_mess.
                  READ TABLE source_main INDEX t_itab1-row2.
                  IF source_main-form <> ' '.
                    PERFORM validate_local_int_tab USING t_itab1-str1
                                                   t_itab1-row2
                                                   l_tabl.
                  ELSE.
                    IF t_itab1-str1(l_tabl) <> p_tabl.
                      w_itab_ctr = w_itab_ctr + 1.
                      CONCATENATE
                      'Error: Internal Table name is not MATCHING'
                                   t_itab1-str1
                                   INTO t_mess-message
                                   SEPARATED BY space.

                      READ TABLE source_main INDEX t_itab1-row2.

                      t_mess-lineno2 = source_main-lineno.
                      t_mess-item_no = '2'.
                      APPEND t_mess.

                    ENDIF.
                  ENDIF.
                ENDIF.

* Checking for Internal Table declared with keywords TABLE or RANGE

              WHEN 'TABLE' OR 'RANGE'.

                READ TABLE t_itab1 INDEX 2.
                r_intstc-low = t_itab1-str1.
                APPEND r_intstc.
                w_ini_ctr = w_ini_ctr + 1.
                CONCATENATE
                'Error: Internal Table declared without initial size'
                                   t_itab1-str1
                                   INTO t_mess-message
                                   SEPARATED BY space.

                READ TABLE source_main INDEX t_itab1-row2.

                t_mess-lineno2 = source_main-lineno.
                t_mess-program = source_main-program.
                t_mess-item_no = '8'.
                APPEND t_mess.
                READ TABLE source_main INDEX t_itab1-row2.
                IF source_main-form <> ' '.
                  PERFORM validate_local_int_tab USING t_itab1-str1
                                                 t_itab1-row2
                                                 l_tabl.
                ELSE.
                  IF t_itab1-str1(l_tabl) <> p_tabl.
                    w_itab_ctr = w_itab_ctr + 1.
                    CONCATENATE
                    'Error: Internal Table name is not matching'
t_itab1-str1
                                                         INTO
                                                         t_mess-message
                                                          SEPARATED BY
                                                          space
                      .

                    READ TABLE source_main INDEX t_itab1-row2.

                    t_mess-lineno2 = source_main-lineno.
                    t_mess-program = source_main-program.
                    t_mess-item_no = '2'.
                    APPEND t_mess.
                  ENDIF.
                ENDIF.
              WHEN OTHERS.
                SELECT SINGLE typename INTO l_tabname1
                      FROM dd40l WHERE typename = t_itab1-str1
                      AND as4local = 'A'.
                IF sy-subrc = 0.
                  READ TABLE t_itab1 INDEX 2.
                  r_intstc-low = t_itab1-str1.
                  APPEND r_intstc.
                  READ TABLE source_main INDEX t_itab1-row2.
                  IF source_main-form <> ' '.
                    PERFORM validate_local_int_tab USING t_itab1-str1
                                                   t_itab1-row2
                                                   l_tabl.
                  ELSE.
                    IF t_itab1-str1(l_tabl) <> p_tabl.
                      w_itab_ctr = w_itab_ctr + 1.
                      CONCATENATE
                      'Error: Internal Table name is not MATCHING'
                                  t_itab1-str1
                                  INTO t_mess-message
                                  SEPARATED BY space.

                      READ TABLE source_main INDEX t_itab1-row2.

                      t_mess-lineno2 = source_main-lineno.
                      t_mess-program = source_main-program.
                      t_mess-item_no = '2'.
                      APPEND t_mess.
                    ENDIF.
                  ENDIF.
                ELSE.
                  SELECT SINGLE tabname INTO l_tabname1
                      FROM dd02l WHERE tabname = t_itab1-str1.
                  IF sy-subrc = 0.
                    READ TABLE t_itab1 INDEX 2.
                    IF t_itab1-str1 <> 'END'.
                      r_intstc-low = t_itab1-str1.
                      APPEND r_intstc.
                      READ TABLE source_main INDEX t_itab1-row2.
                      IF source_main-form <> ' '.
                        PERFORM validate_local_struc USING t_itab1-str1
t_itab1-row2
                                                             l_tabl.
                      ELSE.
                        IF t_itab1-str1(l_struc) <> p_struc.

                          w_itab_ctr = w_itab_ctr + 1.
                          CONCATENATE
                          'Error: Structure name is not matching'
t_itab1-str1
                                                          INTO
                                                          t_mess-message
                                                           SEPARATED BY
                                                           space
                  .

                          READ TABLE source_main INDEX t_itab1-row2.

                          t_mess-lineno2 = source_main-lineno.
                          t_mess-program = source_main-program.
                          t_mess-item_no = '2'.
                          APPEND t_mess.
                        ENDIF.
                      ENDIF.
                    ENDIF.

                  ELSEIF t_itab1-str1 IN r_intstc.
                    IF NOT r_intstc[] IS INITIAL.

                      READ TABLE t_itab1 INDEX 2.

                      IF t_itab1-str1 <> 'END'.
                        r_intstc-low = t_itab1-str1.
                        APPEND r_intstc.
                        IF t_itab1-str1 IN r_work_area AND
                         NOT r_work_area[] IS  INITIAL.
                          READ TABLE source_main INDEX t_itab1-row2.
                          IF source_main-form <> ' '.
                            PERFORM validate_local_wa USING t_itab1-str1
 t_itab1-row2
                                                                 l_tabl.
                          ELSE.
                            IF t_itab1-str1(l_walen) <> p_wa.

                              w_itab_ctr = w_itab_ctr + 1.
                              CONCATENATE
                              'Error: Work Area name is not matching'
                                                           t_itab1-str1
                                                    INTO t_mess-message
                                                     SEPARATED BY space
            .

                              READ TABLE source_main INDEX t_itab1-row2.

                              t_mess-lineno2 = source_main-lineno.
                              t_mess-program = source_main-program.
                              t_mess-item_no = '2'.
                              APPEND t_mess.
                            ENDIF.
                          ENDIF.

                        ELSE.
                          READ TABLE source_main INDEX t_itab1-row2.
                          IF source_main-form <> ' '.
                            PERFORM validate_local_struc USING
                            t_itab1-str1
t_itab1-row2
                                                                 l_tabl.
                          ELSE.
                            IF t_itab1-str1(l_struc) <> p_struc.

                              w_itab_ctr = w_itab_ctr + 1.
                              CONCATENATE
                              'Error: Structure name is not matching'
t_itab1-str1
                                                              INTO
t_mess-message
                                                               SEPARATED
                                                               BY space
                                          .

                              READ TABLE source_main INDEX t_itab1-row2.

                              t_mess-lineno2 = source_main-lineno.
                              t_mess-program = source_main-program.
                              t_mess-item_no = '2'.
                              APPEND t_mess.
                            ENDIF.
                          ENDIF.
                        ENDIF.
                      ENDIF.
                    ENDIF.
                  ELSEIF t_itab1-str1 IN r_typ_struct.
                    IF NOT r_typ_struct[] IS INITIAL.
                      READ TABLE t_itab1 INDEX 2.
                      IF t_itab1-str1 <> 'END' .
                        r_intstc-low = t_itab1-str1.
                        APPEND r_intstc.
                        IF t_itab1-str1 IN r_work_area AND
                         NOT r_work_area[] IS  INITIAL.
                          READ TABLE source_main INDEX t_itab1-row2.
                          IF source_main-form <> ' '.
                            PERFORM validate_local_wa USING t_itab1-str1
 t_itab1-row2
                                                                 l_tabl.
                          ELSE.
                            IF t_itab1-str1(l_walen) <> p_wa.

                              w_itab_ctr = w_itab_ctr + 1.
                              CONCATENATE
                              'Error: Work Area name is not matching'
                                                           t_itab1-str1
                                                    INTO t_mess-message
                                                     SEPARATED BY space
            .

                              READ TABLE source_main INDEX t_itab1-row2.

                              t_mess-lineno2 = source_main-lineno.
                              t_mess-program = source_main-program.
                              t_mess-item_no = '2'.
                              APPEND t_mess.
                            ENDIF.
                          ENDIF.

                        ELSE.
                          READ TABLE source_main INDEX t_itab1-row2.
                          IF source_main-form <> ' '.
                            PERFORM validate_local_struc USING
                            t_itab1-str1
t_itab1-row2
                                                                 l_tabl.
                          ELSE.
                            IF t_itab1-str1(l_struc) <> p_struc.

                              w_itab_ctr = w_itab_ctr + 1.
                              CONCATENATE
'Error: Structure name is not matching'
t_itab1-str1
                                                      INTO
                                                      t_mess-message
                                                       SEPARATED BY
                                                       space
    .

                              READ TABLE source_main INDEX t_itab1-row2.

                              t_mess-lineno2 = source_main-lineno.
                              t_mess-program = source_main-program.
                              t_mess-item_no = '2'.
                              APPEND t_mess.
                            ENDIF.
                          ENDIF.
                        ENDIF.
                      ENDIF.
                    ENDIF.

                  ENDIF.
                ENDIF.
            ENDCASE.
          ENDIF.
        ENDIF.
      ENDIF.

    ENDIF.
  ENDIF.

ENDFORM.                    " int_table_checking
*&---------------------------------------------------------------------*
*&      Form  logical_flow_of_the_program
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM logical_flow_of_the_program.
  DATA incl_flag.
  DATA: BEGIN OF t_keywords OCCURS 1,
             line(20),
        END OF t_keywords,
        BEGIN OF i_subroutine OCCURS 0,
            form(30) TYPE c,
        END OF i_subroutine,
        BEGIN OF t_keywords1 OCCURS 1,
             line(20),
        END OF t_keywords1.

  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE,
  wa_tokens LIKE stoken,
        t_tokens1 LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: source_temp LIKE source_main OCCURS 0 WITH HEADER LINE.

  DATA: BEGIN OF t_itab1   OCCURS 0,
           str1 LIKE stoken-str, "tokens of the program being tested
        END OF t_itab1,
        subnam(30).
  DATA: l_start_row  LIKE stoken-row,
        l_end_row  LIKE stoken-row.
  DATA:
    source_backup LIKE source_main OCCURS 0 WITH HEADER LINE,
    source_backup_tmp LIKE source_main OCCURS 0 WITH HEADER LINE.

  DATA source_incl LIKE source_main OCCURS 0 WITH HEADER LINE.
  DATA: l_str1 LIKE stoken-str.

********************** Under construction ************************
  t_keywords = 'INCLUDE'.       APPEND t_keywords.
*  t_keywords = 'INCLUDES'.       APPEND t_keywords.

  DO.

    SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                         TOKENS INTO t_tokens
                         KEYWORDS   FROM t_keywords .
    READ TABLE t_tokens INDEX 2.
*LOOP AT T_TOKENS.
    IF sy-subrc = 0.
      prog = t_tokens-str.
      READ TABLE t_statements WITH KEY FROM = 1.

      REFRESH source_incl.
      READ REPORT t_tokens-str INTO source_incl.
      PERFORM populate_lineno TABLES source_incl.
      IF t_statements-terminator = '.'.
        IF incl_flag NE 'X'.
          APPEND LINES OF source_incl TO source_temp.
          t_tokens-row = t_tokens-row + 1.
          INSERT lines of source_temp
                            INTO source INDEX  t_tokens-row.
          INSERT lines of source_temp
                           INTO source_main INDEX  t_tokens-row.
          t_tokens-row = t_tokens-row - 1.
          DELETE source INDEX t_tokens-row.
          DELETE source_main INDEX t_tokens-row.

        ELSE.
          APPEND LINES OF source_incl TO source_temp.
          source-line = space.
          MODIFY source INDEX t_tokens-row TRANSPORTING line.
          source_main-line = space.
          MODIFY source_main INDEX t_tokens-row TRANSPORTING line.

          INSERT lines of source_temp
                            INTO source INDEX  t_tokens-row.
          INSERT lines of source_temp
                           INTO source_main INDEX  t_tokens-row.
        ENDIF.
        REFRESH:
          source_temp.
      ELSEIF t_statements-terminator = ','.
        IF incl_flag NE 'X'.
          incl_flag = 'X'.
          l_start_row = t_tokens-row.
        ENDIF.
        APPEND LINES OF source_incl TO source_temp.
        source-line = space.
        MODIFY source INDEX t_tokens-row TRANSPORTING line.
        source_main-line = space.
        MODIFY source_main INDEX t_tokens-row TRANSPORTING line.
        t_tokens-row = t_tokens-row + 1.
        READ TABLE source INDEX t_tokens-row.
        CONCATENATE 'INCLUDE:'
                     source-line
                     INTO source-line.
        MODIFY source INDEX t_tokens-row TRANSPORTING line .

        source_main-line = source-line.
        MODIFY source_main INDEX t_tokens-row TRANSPORTING line .

      ENDIF.
    ELSE.
      EXIT.
    ENDIF.

  ENDDO.
*ENDLOOP.
  source_main-program = g_pname.
  MODIFY source_main TRANSPORTING program WHERE program IS INITIAL .
********************** Under construction ************************



  REFRESH t_keywords.

  t_keywords = 'PERFORM'.       APPEND t_keywords.
  t_keywords1 = 'FORM'.       APPEND t_keywords1.
  t_keywords1 = 'ENDFORM'.      APPEND t_keywords1.

** Get the tokens of the original source table.

  DO.

    SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                         TOKENS INTO t_tokens
                         KEYWORDS   FROM t_keywords .
    READ TABLE t_tokens INDEX 2.

    IF sy-subrc = 0.
      l_str1 = t_tokens-str.
      SCAN ABAP-SOURCE source
                          STATEMENTS INTO t_statements
                          TOKENS       INTO t_tokens1
                          KEYWORDS   FROM t_keywords1.
      READ TABLE t_tokens1 WITH KEY
          str = t_tokens-str.
      IF sy-subrc = 0.
** Begin of version 2
        l_start_row = t_tokens1-row + 1.
** End of version 2
        DELETE t_tokens1 WHERE row <= l_start_row OR
                      str <> 'ENDFORM'.
        READ TABLE t_tokens1 INDEX 1.
        IF sy-subrc = 0.
          l_end_row = t_tokens1-row - 1.
          t_tokens-row = t_tokens-row + 1.
          INSERT lines of source_main FROM l_start_row TO l_end_row
              INTO TABLE source_temp.
          LOOP AT source_temp.
            REFRESH i_subroutine.
            TRANSLATE source_temp TO UPPER CASE.
            SPLIT source_temp-line AT space
               INTO TABLE i_subroutine.
            DELETE i_subroutine WHERE form IS INITIAL.
            READ TABLE i_subroutine INDEX 1.
            CONDENSE i_subroutine-form.
            IF i_subroutine-form = 'PERFORM'.
              READ TABLE i_subroutine INDEX 2.
              IF sy-subrc = 0.
                IF i_subroutine-form CA '.'.
                  SPLIT i_subroutine-form AT '.' INTO i_subroutine-form
                                  l_str1.
                ENDIF.
                CONDENSE i_subroutine-form.

                IF i_subroutine-form = t_tokens-str.
                  CLEAR source_temp-line.
                  MODIFY source_temp.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDLOOP.
          INSERT lines of source_temp
                          INTO source INDEX  t_tokens-row.

          source_temp-form = t_tokens-str.

          MODIFY source_temp TRANSPORTING form WHERE form = ' '.
          CLEAR source_temp.
          INSERT lines of source_temp
                          INTO source_main INDEX  t_tokens-row.
*** Begin of version 2
          APPEND LINES OF source_temp
                          TO source_backup.
*** End of version 2
          t_tokens-row = t_tokens-row - 1.
          DELETE source INDEX t_tokens-row.
          DELETE source_main INDEX t_tokens-row.
          REFRESH source_temp.
        ENDIF.
      ELSE.

        DELETE source INDEX t_tokens-row.
        DELETE source_main INDEX t_tokens-row.

      ENDIF.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.

  REFRESH:
    t_tokens1,
    t_statements.
  SCAN ABAP-SOURCE source
                        STATEMENTS INTO t_statements
                        TOKENS       INTO t_tokens1
                        KEYWORDS   FROM t_keywords1.
  READ TABLE t_tokens1 INDEX 1.
  IF sy-subrc = 0.
    l_start_row = t_tokens1-row.
  ENDIF.
  DELETE t_tokens1 WHERE str <> 'ENDFORM' AND str <> 'FORM'.
  LOOP AT t_tokens1.
    IF t_tokens1-str = 'FORM'.
      l_start_row = t_tokens1-row.
    ELSEIF t_tokens1-str = 'ENDFORM'.
      LOOP AT source FROM l_start_row TO t_tokens1-row.
        source-line = 'X'.
        MODIFY source.
      ENDLOOP.
      LOOP AT source_main FROM l_start_row TO t_tokens1-row.
        source_main-line = 'X'.
        MODIFY source_main.
      ENDLOOP.
      CLEAR l_start_row.
    ENDIF.

  ENDLOOP.
  DELETE source WHERE LINE = 'X'.
  DELETE source_main WHERE LINE = 'X'.

* Get the tokens of/ the modified source table.
  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements_sub
                        TOKENS INTO t_tokens_sub
                        LEVELS INTO t_level_sub
                        STRUCTURES INTO t_struc_sub
                        WITH ANALYSIS
                        WITH INCLUDES.

ENDFORM.                    " logical_flow_of_the_program
*&---------------------------------------------------------------------*
*&      Form  CHECK_SYSUBRC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_TO  text
*----------------------------------------------------------------------*
FORM check_sysubrc USING  p_syrow value(p_nxtidx) p_flag value(p_no).
  DATA: l_stab TYPE i,
        l_etab TYPE i,
        found,
        tabnam1(30).
  p_nxtidx = p_nxtidx + 1.
  READ TABLE t_tokens_sub INDEX p_nxtidx.
  tabnam1 = t_tokens_sub-str.
  READ TABLE t_statements_sub INDEX p_syrow.
  l_stab = t_statements_sub-from.
  l_etab = t_statements_sub-to.
  READ TABLE t_tokens_sub INDEX l_stab.
  CASE t_tokens_sub-str.
    WHEN 'IF' OR 'CASE' OR 'CHECK'.
      LOOP AT t_tokens_sub FROM l_stab TO l_etab.
        IF t_tokens_sub-str = 'SY-SUBRC'.
          found ='1'.
          EXIT.
        ENDIF.
      ENDLOOP.
    WHEN OTHERS.
  ENDCASE.
  IF found <> '1'.
    IF p_flag <> 'S'.
      READ TABLE source_main INDEX p_no.
      IF sy-subrc = 0.
        READ TABLE t_mess WITH KEY item_no = '7'
                                   lineno2 = source_main-lineno .
        IF sy-subrc <> 0.
          CONCATENATE
       'ERROR: No SY-SUBRC check after READ Statement FOR' tabnam1 INTO
                 t_mess-message SEPARATED BY space.
          t_mess-lineno2 = source_main-lineno.
          t_mess-program = source_main-program.
          t_mess-item_no = '7'.
          APPEND t_mess.
          w_syread_ctr = w_syread_ctr + 1.
        ENDIF.
      ENDIF.
    ELSE.

      READ TABLE source_main INDEX p_no.
      IF sy-subrc = 0.
        READ TABLE t_mess WITH KEY item_no = '6'
                                   lineno2 = source_main-lineno .
        IF sy-subrc <> 0.

          t_mess-lineno2 = source_main-lineno.
          t_mess-program = source_main-program.
          t_mess-message =
          'ERROR:No SY-SUBRC check after SELECT Statement'.
          t_mess-item_no = '6'.
          APPEND t_mess.
          w_sysel_ctr = w_sysel_ctr + 1.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  CLEAR found.
ENDFORM.                    " CHECK_SYSUBRC
*&---------------------------------------------------------------------*
*&      Form  WRITE_MSG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM write_msg.
  IF sy-lsind = 1.

    list_flag = 'X'.
    NEW-PAGE LINE-SIZE 255.

*    SORT t_mess by item_no lineno2.
*    Delete adjacent duplicates from t_mess comparing lineno2.
    LOOP AT t_mess WHERE item_no = sy-lisel+1(5).

      IF t_mess-item_no = 20 OR t_mess-item_no = 28
      OR t_mess-item_no = 33.

        EXIT.

      ENDIF.

      FORMAT COLOR COL_GROUP INTENSIFIED OFF.
      WRITE: /,/ 'PROGRAM:   ', t_mess-program,
             40 'LINE:', 50 t_mess-lineno2,
             254 space.
      HIDE: t_mess-program,
            t_mess-lineno2.
      FORMAT COLOR COL_NORMAL INTENSIFIED OFF.
      WRITE:/ t_mess-message,
            254 space.

      HIDE: t_mess-program,
            t_mess-lineno2.

    ENDLOOP.

    IF sy-subrc <> 0.
      MESSAGE s000(zga) WITH 'Please select a valid line'.
    ENDIF.
    CLEAR:
        t_mess-program,
        t_mess-lineno2.
  ENDIF.

ENDFORM.                    " WRITE_MSG
*&---------------------------------------------------------------------*
*&      Form  HALF_COMMENT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM half_comment.

  DATA: t_tokens TYPE stokex OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.
  DATA: l_to TYPE i,
        l_tabix TYPE i,
        l_tabl TYPE i,
        row1 TYPE i,
        row2 TYPE i,
        flg_2(1) TYPE c,
        ind TYPE i,
        col1 TYPE i,
        colrow TYPE i,
        len  TYPE i,
        rownxt TYPE i,
        str1(75) TYPE c,
        str2(255) TYPE c,
        slt1(255) TYPE c,
        slt2(255) TYPE c,
        l_token_fr TYPE i,
        fnd(1) TYPE c,
        l_offset LIKE stoken-len,
        l_length LIKE stoken-len,
        l_len TYPE i,
        l_field LIKE stoken-str,
        lno1 TYPE i,
        line_no TYPE i,
        l_ind_char.
*** Changes Shastry***
  DATA: l_sep TYPE c VALUE '-',
        l_sep1 TYPE c VALUE '_'.
  DATA: l_tab TYPE dd02l-tabname,
        l_fld TYPE string.
  DATA: i_dd02l TYPE dd02l OCCURS 0 WITH HEADER LINE.
  DATA: i_dd04l TYPE dd04l OCCURS 0 WITH HEADER LINE.

  DATA: l_types TYPE ddtypet-typegroup,
        l_fld1 TYPE string.
  DATA: i_ddtypet TYPE ddtypet OCCURS 0 WITH HEADER LINE.
*****End of Changes****

  t_keywords ='DATA'.               APPEND t_keywords.
  t_keywords ='TYPES'.              APPEND t_keywords.
  t_keywords ='CONSTANTS'.          APPEND t_keywords.
  t_keywords ='SELECT-OPTIONS'.     APPEND t_keywords.
  t_keywords ='PARAMETERS'.         APPEND t_keywords.
  t_keywords ='RANGES'.             APPEND t_keywords.


  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens
                           KEYWORDS   FROM t_keywords
                           WITH ANALYSIS.

  LOOP AT t_tokens.
    CLEAR lno1.


    CASE t_tokens-str.
      WHEN 'DATA' OR 'TYPES'.
        lno1 = sy-tabix + 1.
        READ TABLE t_tokens INDEX lno1.
        IF NOT r_intstc[] IS INITIAL.
          IF ( t_tokens-str <> 'BEGIN' ) AND ( t_tokens-str <>
   'END' ) AND
                              ( NOT ( t_tokens-str IN r_intstc ) ).
            l_field = t_tokens-str.
            l_length = t_tokens-len.
***      Changes Shastry
            IF t_tokens-ovfl = 'X'.
              l_length = l_length - 30.
*        l_field = l_field+l_offset(l_length).
            ENDIF.
****      END changes
            fnd = '1'.
          ENDIF.
        ELSE.
          IF ( t_tokens-str <> 'BEGIN' ) AND ( t_tokens-str <>
   'END' ).
            l_field = t_tokens-str.
            l_length = t_tokens-len.
***      Changes Shastry
            IF t_tokens-ovfl = 'X'.
              l_length = l_length - 30.
*        l_field = l_field+l_offset(l_length).
            ENDIF.
****      END changes

            fnd = '1'.
          ENDIF.
        ENDIF.
      WHEN 'CONSTANTS' OR 'SELECT-OPTIONS' OR 'PARAMETERS' OR 'RANGES'.

        lno1 = sy-tabix + 1.
        fnd = '1'.
        READ TABLE t_tokens INDEX lno1.
        IF ( t_tokens-str = 'BEGIN' ) OR ( t_tokens-str = 'END' ).
          fnd = '0'.
        ENDIF.
        l_field = t_tokens-str.
        l_length = t_tokens-len.

***      Changes Shastry
        IF t_tokens-ovfl = 'X'.
          l_length = l_length - 30.
*        l_field = l_field+l_offset(l_length).
        ENDIF.
****      END changes

    ENDCASE.

*   half line comment
    IF fnd = '1'.
      CLEAR fnd.
********************************************************************
      CLEAR line_no.
      line_no = lno1 + 1.
      READ TABLE t_tokens INDEX line_no.
      IF sy-subrc = 0.
        IF t_tokens-str = 'TYPE' OR t_tokens-str = 'LIKE'.
          line_no = line_no + 1.
          READ TABLE t_tokens INDEX line_no.
          IF sy-subrc = 0.
            IF t_tokens-str = 'C' OR
*               t_tokens-str = 'P' OR
               t_tokens-str = 'N' OR
               t_tokens-str = 'F' .
*******Changes Shastry
              line_no = line_no - 2.
              READ TABLE t_tokens INDEX line_no.
******* End Changes
              l_offset = l_length - 1.
              l_ind_char = l_field+l_offset(1).
              IF l_ind_char = ')'.
              ELSE.
****************************************************************<
                IF no_len = 'X' AND t_tokens-ovfl NE 'X'.
                  CONCATENATE
                    'Length is not specified while declaring '
                    t_tokens-str
                    INTO t_mess-message
                    SEPARATED BY space.
                  READ TABLE source_main INDEX t_tokens-row.
                  t_mess-lineno2 = source_main-lineno.
                  t_mess-program = source_main-program.
                  t_mess-item_no = '10'.
                  READ TABLE t_mess WITH KEY item_no = '10'
                                         lineno2 = t_mess-lineno2.
                  IF sy-subrc <> 0.
                    APPEND t_mess.
                    w_lnth_ctr = w_lnth_ctr + 1.
                  ENDIF.
                ENDIF.
              ENDIF.
            ELSEIF t_tokens-str = 'D' OR
                   t_tokens-str = 'T' OR
                   t_tokens-str = 'I' OR
                   t_tokens-str = 'P'.
            ELSE.
              CHECK no_delm = 'X'.

****            Changes Shastry

              SELECT SINGLE *             " Table Name
              INTO i_dd02l
              FROM dd02l                              " SAP Tables
              WHERE tabname = t_tokens-str .

              IF sy-subrc NE 0.

                SPLIT t_tokens-str AT l_sep1 INTO l_types l_fld1.

                IF l_types IS NOT INITIAL.

                  SELECT SINGLE *             " Table Name
                  INTO i_ddtypet
                  FROM ddtypet                              " SAP Tables
                  WHERE typegroup = l_types .

                  IF sy-subrc NE 0.

                    SELECT SINGLE *             " Table Name
                    INTO i_dd04l
                    FROM dd04l                              " SAP Tables
                    WHERE rollname = t_tokens-str .

                    IF sy-subrc NE 0.

                      SPLIT t_tokens-str AT l_sep INTO l_tab l_fld.

                      IF l_tab IS NOT INITIAL.

                        IF l_tab CS 'sy'.

                          l_tab = 'SYST'.

                        ENDIF.

                        SELECT SINGLE *             " Table Name
                        INTO i_dd02l
                        FROM dd02l
                        " SAP Tables
                        WHERE tabname = l_tab .

                        IF sy-subrc NE 0.

**********

                          SELECT SINGLE * FROM dd04l WHERE rollname =
                t_tokens-str.
                          IF sy-subrc = 0.
                            IF dd04l-as4local <> 'A'.
                              CONCATENATE
                           'Data Element'
                            t_tokens-str
                           'is not active'
                             INTO t_mess-message
                              SEPARATED BY space.
                              READ TABLE source_main INDEX t_tokens-row.
                              t_mess-lineno2 =  source_main-lineno.
                              t_mess-program = source_main-program.
                              t_mess-item_no = '13'.
                              READ TABLE t_mess WITH KEY item_no = '13'
                                                       lineno2 =
                                                       t_mess-lineno2.
                              IF sy-subrc <> 0.
                                APPEND t_mess.
                                w_dataelm_ctr = w_dataelm_ctr + 1.
                              ENDIF.

                            ENDIF.
                          ELSE.
                            CONCATENATE
'Data Element is not specified while declaring '
                             l_field
                             INTO t_mess-message
                              SEPARATED BY space.
                            READ TABLE source_main INDEX t_tokens-row.
                            t_mess-lineno2 =  source_main-lineno.
                            t_mess-program = source_main-program.
                            t_mess-item_no = '13'.
                            READ TABLE t_mess WITH KEY item_no = '13'
                                                     lineno2 =
                                                     t_mess-lineno2.
                            IF sy-subrc <> 0.
                              APPEND t_mess.
                              w_dataelm_ctr = w_dataelm_ctr + 1.
                            ENDIF.

                          ENDIF.
                        ENDIF.
                      ENDIF.
                    ENDIF.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDIF.
            CLEAR: l_tab, l_fld.
          ENDIF.

        ELSEIF t_tokens-str = 'FOR'.

        ELSEIF t_tokens-str = 'AS'.

        ELSEIF t_tokens-str = 'RADIOBUTTON'.

        ELSE.
          line_no = line_no - 1.
          READ TABLE t_tokens INDEX line_no.

          l_offset = l_length - 1.
          l_ind_char = l_field+l_offset(1).
          IF l_ind_char = ')'.
          ELSE.
            IF no_len = 'X' AND t_tokens-ovfl NE 'X'.

              CONCATENATE
                'Length is not specified while declaring '
                t_tokens-str
                INTO t_mess-message
                SEPARATED BY space.

              READ TABLE source_main INDEX t_tokens-row.
              t_mess-lineno2 =  source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '10'.
              READ TABLE t_mess WITH KEY item_no = '10'
                                     lineno2 = t_mess-lineno2.
              IF sy-subrc <> 0.
                APPEND t_mess.
                w_lnth_ctr = w_lnth_ctr + 1.
              ENDIF.
            ENDIF.
          ENDIF.
          IF no_type = 'X'.

            CONCATENATE
              'Data type is not specified while declaring '
              t_tokens-str
              INTO t_mess-message
              SEPARATED BY space.

            READ TABLE source_main INDEX t_tokens-row.
            t_mess-lineno2 =  source_main-lineno.
            t_mess-program = source_main-program.
            t_mess-item_no = '11'.
            READ TABLE t_mess WITH KEY item_no = '11'
                                   lineno2 = t_mess-lineno2.
            IF sy-subrc <> 0.
              APPEND t_mess.
              w_type_ctr = w_type_ctr + 1.

            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
********************************************************************
      CLEAR:
        slt1,
        slt2,
        l_token_fr.

      lno1 = lno1 - 1.
      READ TABLE t_statements WITH KEY FROM = lno1.
      row1 = t_statements-trow.
      col1 = t_statements-tcol.
      IF t_statements-colonrow IS INITIAL.
        l_token_fr = t_statements-from.
      ELSE.
        l_token_fr = t_statements-from + 1.
      ENDIF.

      len  = 255 - col1.

**************** CHANGE START
      colrow = t_statements-colonrow.
      CLEAR: l_to,
             flg_2,
             str1,
             str2,
             row2,
             slt1,
             slt2.
      IF colrow < row1.
        ind = sy-tabix - 1.
        READ TABLE t_statements INDEX ind.
        l_to = t_statements-to.
        l_to = l_to + 2.
        READ TABLE t_tokens INDEX l_to.
        row2 = t_tokens-row.
        LOOP AT source FROM row2 TO row1.
          str1 = source-line.
          IF str1 CP '*"*' AND str1 NP '*"'.
            flg_2 = '1'.
            EXIT.
          ENDIF.
        ENDLOOP.
      ENDIF.
      IF flg_2 <> '1'.
*************** CHANGE END

        READ TABLE source INDEX row1.
        str1 = source-line+col1(len).
        IF str1 CP '*"*' AND str1 NP '*"'.
        ELSE.
          rownxt = row1 + 1.
          READ TABLE source INDEX rownxt.
          str2 = source-line.
          SPLIT str2 AT '"' INTO slt1 slt2.

          IF NOT slt1 IS INITIAL AND NOT slt2 IS INITIAL.
            READ TABLE t_tokens INDEX l_token_fr.
            IF sy-subrc = 0.
              t_tokens-row = t_tokens-row - 1.
            ENDIF.
            READ TABLE source INDEX t_tokens-row.
            IF source-line+0(1) = '*'.
            ELSE.
              t_mess-message = 'Half line comment missing'.
              lno1 = lno1 + 1.
              READ TABLE t_tokens INDEX lno1.
              READ TABLE source_main INDEX t_tokens-row.
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '5'.
              READ TABLE t_mess WITH KEY item_no = '5'
                                     lineno2 = t_mess-lineno2.
              IF sy-subrc <> 0.
                IF NOT half_com IS INITIAL.
                  APPEND t_mess.
                  w_half_ctr = w_half_ctr + 1.
                ENDIF.
              ENDIF.
            ENDIF.
          ELSEIF slt2 IS INITIAL.
            READ TABLE t_tokens INDEX l_token_fr.
            IF sy-subrc = 0.
              t_tokens-row = t_tokens-row - 1.
            ENDIF.
            READ TABLE source INDEX t_tokens-row.
            IF source-line+0(1) = '*'.
            ELSE.
              t_mess-message = 'Half line comment missing'.
              lno1 = lno1 + 1.
              READ TABLE t_tokens INDEX lno1.
              READ TABLE source_main INDEX t_tokens-row.
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '5'.
              READ TABLE t_mess WITH KEY item_no = '5'
                                     lineno2 = t_mess-lineno2.
              IF sy-subrc <> 0.
                IF NOT half_com IS INITIAL.
                  APPEND t_mess.
                  w_half_ctr = w_half_ctr + 1.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    CLEAR t_mess.
  ENDLOOP.

ENDFORM.                    " HALF_COMMENT
*&---------------------------------------------------------------------*
*&      Form  GET_SOURCE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_source.


  IF p_status = 'X'.
    g_status = 'A'.
  ELSE.
    g_status = 'I'.
  ENDIF.
  PERFORM get_prog_attr.

  READ REPORT g_pname INTO source STATE g_status.
  source_main[] = source[].
  LOOP AT source_main.
    source_main-lineno = sy-tabix.
    MODIFY source_main.
  ENDLOOP.


  DESCRIBE TABLE source LINES codesize .
  IF codesize > 4000 .
    t_mess-message = 'Warning : Code size is too long'.
    APPEND t_mess.
  ENDIF .
ENDFORM.                    " GET_SOURCE
*&---------------------------------------------------------------------*
*&      Form  WRITE_OVERALL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM write_overall.
  FORMAT COLOR COL_HEADING.
  ULINE 1(85).
  WRITE:/1 sy-vline,
         2 'Item No',
         10 sy-vline,
         11 'Type of defect',
         61 sy-vline,
         62 'No of defects',
         85 sy-vline.
  ULINE /1(85).
  FORMAT COLOR OFF.
  FORMAT COLOR COL_NORMAL INTENSIFIED OFF.
  WRITE:/1 sy-vline,
         2 '1',
         10 sy-vline,
         11 'Variable/Constant Name Not According To Standards',
         61 sy-vline.
  IF w_var_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_var_ctr ,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_var_ctr,
           85 sy-vline.
  ENDIF.
  FORMAT COLOR COL_NORMAL.
  WRITE:/1 sy-vline,
       2 '2',
       10 sy-vline,
       11 'Table & Structure Name Not According To Standards',
       61 sy-vline.
  IF w_itab_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_itab_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_itab_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
         2 '3',
         10 sy-vline,
         11 'No sort before binary search',
         61 sy-vline.
  IF w_sort_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_sort_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_sort_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
         2 '4',
         10 sy-vline,
         11 'No Binary search in READ',
         61 sy-vline.
  IF w_bny_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_bny_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_bny_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
         2 '5',
         10 sy-vline,
         11 'Half line comment missing',
         61 sy-vline.

  IF w_half_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_half_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_half_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
          2 '6',
          10 sy-vline,
          11 'SY-SUBRC not checked after select',
          61 sy-vline.

  IF w_sysel_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_sysel_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_sysel_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '7',
           10 sy-vline,
           11 'SY-SUBRC not checked after read',
           61 sy-vline.

  IF w_syread_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_syread_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_syread_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '8',
           10 sy-vline,
           11 'Table Without Initial Size Declaration',
           61 sy-vline.
  IF w_ini_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_ini_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_ini_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '9',
           10 sy-vline,
           11 'Hard Coding in Where / IF Clause',
           61 sy-vline.
  IF w_whr_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_whr_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_whr_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '10',
           10 sy-vline,
           11 'No length specified while declaring field',
           61 sy-vline.
  IF w_lnth_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_lnth_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_lnth_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '11',
           10 sy-vline,
           11 'Field declaration without any data type ',
           61 sy-vline.
  IF w_type_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_type_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_type_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '12',
           10 sy-vline,
           11 'SELECT inside a LOOP ',
           61 sy-vline.
  IF w_seloop_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_seloop_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_seloop_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '13',
           10 sy-vline,
           11 'Data element not used while declaring variable',
           61 sy-vline.
  IF w_dataelm_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_dataelm_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_dataelm_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '14',
           10 sy-vline,
           11 'Error while using DELETE ADJACENT',
           61 sy-vline.
  IF w_deladj_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_deladj_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_deladj_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR OFF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '15',
           10 sy-vline,
           11 'SELECT * has been used ',
           61 sy-vline.
  IF w_star_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_star_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_star_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR OFF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '16',
           10 sy-vline,
           11 'Move-corresponding is not recommended',
           61 sy-vline.
  IF w_mvcrr_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_mvcrr_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_mvcrr_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '17',
           10 sy-vline,
           11 'INTO CORRESPONDING in SELECT is not recommended',
           61 sy-vline.
  IF w_intocor_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_intocor_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_intocor_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR OFF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '18',
           10 sy-vline,
           11 'TYPES naming standards not matching',
           61 sy-vline.
  IF w_types_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_types_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_types_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR OFF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '19',
           10 sy-vline,
           11 'Text symbol not properly used',
           61  sy-vline.
  IF w_textelm_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_textelm_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_textelm_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
             2 '20',
             10 sy-vline,
             11 'Valid Transaction Code ',
             61  sy-vline.

  IF w_tcode_ctr IS INITIAL.
    FORMAT COLOR COL_TOTAL.
    WRITE:68 'NOT AVAILABLE',
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_tcode_ctr ,
             85 sy-vline .
  ENDIF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
             2 '21',
             10 sy-vline,
             11 'Selecting from Cluster Tables',
             61  sy-vline.

  IF w_selclus_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_selclus_ctr ,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.
    WRITE:62 w_selclus_ctr ,
             85 sy-vline .
  ENDIF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '22',
           10 sy-vline,
           11 'Hard Break Points Used',
           61  sy-vline.
  IF w_uname_brpnt_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_uname_brpnt_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_uname_brpnt_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '23',
           10 sy-vline,
           11 'User Name(SY-UNAME) Check in the Program',
           61  sy-vline.
  IF w_uname_chk_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_uname_chk_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_uname_chk_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
           2 '24',
           10 sy-vline,
           11 'SORT / DELETE inside a LOOP ',
           61 sy-vline.
  IF w_sortloop_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_sortloop_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_sortloop_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
             2 '25',
             10 sy-vline,
             11 'Direct Table Entries Update / Insert / Delete',
             61 sy-vline.
  IF w_tabl_upd_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_tabl_upd_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_tabl_upd_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
             2 '26',
             10 sy-vline,
             11 'Negative SQL Statements used in Where Condition',
             61 sy-vline.
  IF w_neg_sql_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_neg_sql_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_neg_sql_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
             2 '27',
             10 sy-vline,
             11 'Usage Of "ON Change Of" Statement',
             61 sy-vline.
  IF w_on_chg_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_on_chg_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_on_chg_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
             2 '28',
             10 sy-vline,
             11 'DB Table Hits in a Program',
             61 sy-vline.

  FORMAT COLOR COL_POSITIVE.
  WRITE:64 'CLICK FOR DETAILS',
         85 sy-vline.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
             2 '29',
             10 sy-vline,
             11 'Check for Initial before For All Entries',
             61 sy-vline.
  IF w_int_ini_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_int_ini_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_int_ini_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
               2 '30',
               10 sy-vline,
               11 'Check for One Statement Per Line',
               61 sy-vline.
  IF w_stat_lin_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_stat_lin_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_stat_lin_ctr ,
           85 sy-vline .
  ENDIF.
  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
               2 '31',
               10 sy-vline,
               11 'Sorting the Hashed Table',
               61 sy-vline.
  IF w_srt_hash_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_srt_hash_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_srt_hash_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
               2 '32',
               10 sy-vline,
               11 'Size Limit Check for the Ranges',
               61 sy-vline.
  IF w_rang_chk_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_rang_chk_ctr,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_NEGATIVE.

    WRITE:62 w_rang_chk_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR COL_NORMAL.

  WRITE:/1 sy-vline,
               2 '33',
               10 sy-vline,
               11 'Availability of View for the Joined Tables',
               61 sy-vline.
  IF w_view_chk_ctr IS INITIAL.
    FORMAT COLOR COL_POSITIVE.
    WRITE:62 w_view_chk_ctr ,
           85 sy-vline.
  ELSE.
    FORMAT COLOR COL_TOTAL.

    WRITE:62 w_view_chk_ctr ,
           85 sy-vline .
  ENDIF.

  FORMAT COLOR OFF.

  ULINE /1(85).

  FORMAT COLOR OFF.
ENDFORM.                    " WRITE_OVERALL
*&---------------------------------------------------------------------*
*&      Form  PRINT_REPORT_HEADER
*&---------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM print_report_header.
  ULINE.
  WRITE:/61 'IBM',
        /55 'CODE OPTIMIZER'.
  ULINE.



ENDFORM.                    " PRINT_REPORT_HEADER
*&---------------------------------------------------------------------*
*&      Form  GOTO_PROGRAM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM goto_program.

  IF sy-lsind = 2.

    IF NOT t_mess-program IS INITIAL AND NOT t_mess-lineno2 IS INITIAL
    AND t_mess-item_no NE 20 AND t_mess-item_no NE 28 AND t_mess-item_no
    NE 33 AND t_mess-item_no NE 35.

      CALL FUNCTION 'RS_TOOL_ACCESS'
         EXPORTING
           operation                 = 'SHOW'
          object_name               = t_mess-program
          object_type               = 'P'
*      ENCLOSING_OBJECT          =
          position                  =   t_mess-lineno2

*      DEVCLASS                  =
*      INCLUDE                   =
        version                   = g_status
       monitor_activation        = 'X'
*      WB_MANAGER                =
*      IN_NEW_WINDOW             =
*      WITH_OBJECTLIST           = ' '
*    IMPORTING
*      NEW_NAME                  =
*      WB_TODO_REQUEST           =
*    TABLES
*      OBJLIST                   =
     EXCEPTIONS
       not_executed              = 1
       invalid_object_type       = 2
       OTHERS                    = 3
       .
      IF sy-subrc = 0.
        CLEAR:
          t_mess-program,
          t_mess-lineno2.
      ELSE.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        CLEAR:
               t_mess-program,
               t_mess-lineno2.

      ENDIF.
    ENDIF.
    CLEAR:
        t_mess-program,
        t_mess-lineno2.
  ENDIF.

  IF sy-lsind = 3.

    IF NOT t_mess-program IS INITIAL AND NOT t_mess-lineno2 IS INITIAL
  AND t_mess-item_no EQ 34.

      CALL FUNCTION 'RS_TOOL_ACCESS'
         EXPORTING
           operation                 = 'SHOW'
          object_name               = t_mess-program
          object_type               = 'P'
*      ENCLOSING_OBJECT          =
          position                  =   t_mess-lineno2

*      DEVCLASS                  =
*      INCLUDE                   =
        version                   = g_status
       monitor_activation        = 'X'
*      WB_MANAGER                =
*      IN_NEW_WINDOW             =
*      WITH_OBJECTLIST           = ' '
*    IMPORTING
*      NEW_NAME                  =
*      WB_TODO_REQUEST           =
*    TABLES
*      OBJLIST                   =
     EXCEPTIONS
       not_executed              = 1
       invalid_object_type       = 2
       OTHERS                    = 3
       .
      IF sy-subrc = 0.
        CLEAR:
          it_mess-program,
          it_mess-lineno2.
      ELSE.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        CLEAR:
               t_mess-program,
               t_mess-lineno2.

      ENDIF.
    ENDIF.
    CLEAR:
        t_mess-program,
        t_mess-lineno2.
  ENDIF.


ENDFORM.                    " GOTO_PROGRAM
*&---------------------------------------------------------------------*
*&      Form  SELECT_WITHIN_LOOP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM select_within_loop.
  DATA t_tokens_temp LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA l_loop_ctr TYPE i.
  t_tokens_temp[] = t_tokens_sub[].
****Changes 04-11-2009
  DELETE t_tokens_temp WHERE str NE 'LOOP'
                       AND   str NE 'ENDLOOP'
                       AND   str NE 'SELECT'
                       AND   str NE 'DO'
                       AND   str NE 'ENDDO'.

  LOOP AT t_tokens_temp.
    IF t_tokens_temp-str = 'LOOP' OR
       t_tokens_temp-str = 'DO' .
      l_loop_ctr = l_loop_ctr + 1.
    ENDIF.
    IF t_tokens_temp-str = 'ENDLOOP' OR
       t_tokens_temp-str = 'ENDDO' .
      l_loop_ctr = l_loop_ctr - 1.
    ENDIF.
    IF t_tokens_temp-str = 'SELECT'.
      IF l_loop_ctr <> 0.
        t_mess-message = 'SELECT statement is used within a LOOP'.
        READ TABLE source_main INDEX t_tokens_temp-row.
        t_mess-lineno2 =  source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '12'.
        APPEND t_mess.
        w_seloop_ctr = w_seloop_ctr + 1.

      ENDIF.
    ENDIF.
  ENDLOOP.


ENDFORM.                    " SELECT_WITHIN_LOOP
*&---------------------------------------------------------------------*
*&      Form  del_adja
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM del_adja.

  DATA: lno TYPE i,
        nextidx TYPE i,
        l_tabnam(30) TYPE c,
        l_flag_compare,
        srtidx TYPE i,
        l_to TYPE i.

  LOOP AT t_tokens_sub WHERE str = 'DELETE'.
    CLEAR l_flag_compare.
    CLEAR t_key1_tab.
    REFRESH t_key1_tab.
    lno = t_tokens_sub-row.
    srtidx = sy-tabix.
    nextidx = sy-tabix + 1.
    READ TABLE t_tokens_sub INDEX nextidx.
    IF t_tokens_sub-str = 'ADJACENT'.
      nextidx = nextidx + 3.
      READ TABLE t_tokens_sub INDEX nextidx.
      IF sy-subrc = 0.
** Get the table name
        l_tabnam = t_tokens_sub-str.
      ENDIF.
      READ TABLE t_statements_sub WITH KEY FROM = srtidx.
      IF sy-subrc = 0.
        l_to   = t_statements_sub-to.
        LOOP AT t_tokens_sub FROM srtidx TO l_to.
          IF t_tokens_sub-str = 'COMPARING'.
            nextidx = sy-tabix + 1.
            READ TABLE t_tokens_sub INDEX nextidx.
            IF sy-subrc = 0.
              IF t_tokens_sub-str = 'ALL'.
                EXIT.
              ENDIF.

            ENDIF.
            l_flag_compare = 'X'.
          ELSE.
            IF l_flag_compare = 'X'.
              t_key1_tab-key = t_tokens_sub-str.
              APPEND t_key1_tab.
            ENDIF.
          ENDIF.
        ENDLOOP.

        PERFORM find_sort1 USING l_tabnam
                                 t_tokens_sub-row.

      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " del_adja

*&---------------------------------------------------------------------*
*&      Form  find_sort
*&---------------------------------------------------------------------
*
*       text
*----------------------------------------------------------------------*
*      -->P_TABNAM  text
*      -->P_LNO  text
*----------------------------------------------------------------------*
FORM find_sort1 USING    p_tabnam
                        value(p_lno) .


  DATA: l_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: l_tokens LIKE stoken OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF l_keywords OCCURS 1,
            line(20),
        END OF l_keywords.
  DATA: l_warn .

  DATA:
    l_tabix LIKE sy-tabix,
    l_stmt_to LIKE sstmnt-to.
  DATA: BEGIN OF t_key_table OCCURS 0,
          key LIKE stoken-str,
        END OF t_key_table.

  LOOP AT t_tokens_sub WHERE str = 'SORT'.
    l_tabix = sy-tabix + 1.
    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_stmt_to = t_statements_sub-to.
    ENDIF.

    READ TABLE t_tokens_sub INDEX l_tabix.
    IF sy-subrc = 0.
      IF t_tokens_sub-str = p_tabnam.
        IF t_tokens_sub-row < p_lno .
          l_tabix = l_tabix + 2.
          REFRESH t_key_table.
          LOOP AT t_tokens_sub FROM l_tabix TO l_stmt_to.
            CASE t_tokens_sub-str.
              WHEN 'DESCENDING' OR 'ASCENDING' OR 'AS' OR 'TEXT' OR
                   'STABLE' OR 'BY'.
              WHEN OTHERS.
                t_key_table = t_tokens_sub-str.
                APPEND t_key_table.
            ENDCASE.
          ENDLOOP.
          IF sy-subrc <> 0.
            l_warn = 'Y'.
          ELSE.
            l_warn = 'Z'.
          ENDIF.
        ELSE.
          l_warn = 'X' .
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP .
  IF t_key_table[] IS INITIAL.
    IF l_warn = 'X'.
      CLEAR l_warn.
      READ TABLE source_main INDEX p_lno.
      READ TABLE t_mess WITH KEY item_no = '14'
                                lineno2 = source_main-lineno .
      IF sy-subrc <> 0.
        w_deladj_ctr = w_deladj_ctr + 1.
        CONCATENATE 'Warning : Sort has been used for'
                   p_tabnam
                  ' but after DELETE ADJACENT'
                  INTO t_mess-message
                  SEPARATED BY space.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '14'.
        APPEND t_mess.
      ENDIF.
    ELSEIF l_warn = 'Y'.
      READ TABLE source_main INDEX p_lno.
      READ TABLE t_mess WITH KEY item_no = '14'
                                lineno2 = source_main-lineno .
      IF sy-subrc <> 0.
        w_deladj_ctr = w_deladj_ctr + 1.
        CONCATENATE 'Warning : Sort has been used for'
                    p_tabnam
                   ' but WITHOUT ANY KEYS'
                  INTO t_mess-message
                  SEPARATED BY space.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '14'.
        APPEND t_mess.
      ENDIF.
    ELSEIF l_warn = 'Z'.
      READ TABLE source_main INDEX p_lno.
      READ TABLE t_mess WITH KEY item_no = '14'
                                lineno2 = source_main-lineno .
      IF sy-subrc <> 0.
        w_deladj_ctr = w_deladj_ctr + 1.
        CONCATENATE 'No sort has been used for'
                  p_tabnam
                  INTO t_mess-message
                  SEPARATED BY space.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '14'.
        APPEND t_mess.
      ENDIF.
    ENDIF.
  ELSE.
    IF t_key_table[] <> t_key1_tab[].
      READ TABLE source_main INDEX p_lno.
      READ TABLE t_mess WITH KEY item_no = '14'
                                lineno2 = source_main-lineno .
      IF sy-subrc <> 0.
        w_deladj_ctr = w_deladj_ctr + 1.
        CONCATENATE 'Warning : Sort has been used for'
                   p_tabnam
                 ' but not in proper order'
                  INTO t_mess-message
                  SEPARATED BY space.
        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '14'.
        APPEND t_mess.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    " find_sort1
*&---------------------------------------------------------------------*
*&      Form  POPULATE_LINENO
*&---------------------------------------------------------------------*
* Form for populating line no. for includes
*----------------------------------------------------------------------*
FORM populate_lineno TABLES source_incl STRUCTURE source_main.

  LOOP AT source_incl.
    source_incl-lineno = sy-tabix.
    MODIFY source_incl TRANSPORTING lineno.
  ENDLOOP.
  source_incl-program = prog.
  MODIFY source_incl TRANSPORTING program WHERE program IS INITIAL..
ENDFORM.                    " POPULATE_LINENO
*&---------------------------------------------------------------------*
*&      Form  GET_MOD_APP_LOOP_READ
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_mod_app_loop_read.
  DATA l_string(30) TYPE c.
  DATA l_tabix TYPE i.

  r_work_area-sign = 'I'.
  r_work_area-option = 'EQ'.

  LOOP AT t_tokens_sub.
    IF t_tokens_sub-str = 'APPEND' OR
       t_tokens_sub-str = 'MODIFY' OR
       t_tokens_sub-str = 'LOOP' OR
       t_tokens_sub-str = 'READ'.
      l_string = t_tokens_sub-str.
      READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
      IF sy-subrc = 0.
        LOOP AT t_tokens_sub FROM t_statements_sub-from
                   TO t_statements_sub-to.
          IF t_tokens_sub-str = 'INTO' AND
             ( l_string = 'LOOP' OR l_string = 'READ' ).
            l_tabix = sy-tabix + 1.
            READ TABLE t_tokens_sub INDEX l_tabix.
            IF sy-subrc = 0.
              IF t_tokens_sub-str IN r_work_area.
                IF r_work_area[] IS INITIAL.
                  r_work_area-low = t_tokens_sub-str.
                  APPEND r_work_area.
                ENDIF.
              ELSE.
                r_work_area-low = t_tokens_sub-str.
                APPEND r_work_area.
              ENDIF.
            ENDIF.
          ELSEIF t_tokens_sub-str = 'TO' AND
               l_string = 'APPEND'.
            l_tabix = sy-tabix - 1.
            READ TABLE t_tokens_sub INDEX l_tabix.
            IF sy-subrc = 0.
              IF t_tokens_sub-str IN r_work_area.
                IF r_work_area[] IS INITIAL.
                  r_work_area-low = t_tokens_sub-str.
                  APPEND r_work_area.
                ENDIF.

              ELSE.
                r_work_area-low = t_tokens_sub-str.
                APPEND r_work_area.
              ENDIF.
            ENDIF.

          ELSEIF t_tokens_sub-str = 'FROM' AND
               l_string = 'MODIFY'.
            l_tabix = sy-tabix + 1.
            READ TABLE t_tokens_sub INDEX l_tabix.
            IF sy-subrc = 0.
              IF t_tokens_sub-str IN r_work_area.
                IF r_work_area[] IS INITIAL.
                  r_work_area-low = t_tokens_sub-str.
                  APPEND r_work_area.

                ENDIF.
              ELSE.

                r_work_area-low = t_tokens_sub-str.
                APPEND r_work_area.
              ENDIF.
            ENDIF.

          ENDIF.

        ENDLOOP.
      ENDIF.


    ENDIF.
  ENDLOOP.


ENDFORM.                    " GET_MOD_APP_LOOP_READ
*&---------------------------------------------------------------------*
*&      Form  GET_PROG_ATTR
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_prog_attr.
  DATA: req LIKE e070-trkorr,
        task LIKE e070-trkorr.
  DATA mode(255) TYPE c.
  CALL FUNCTION 'RS_EDTR_ATTR_SHOW'
   EXPORTING
     program_name               = g_pname
*   WITH_PROGDIR_ENTRY         = ' '
*   WITH_TRDIR_ENTRY           = ' '
*   CALLED_BY_SHDB             = ' '
*   TYPE_SWITCH_ALLOWED        = 'X'
   IMPORTING
     leaved_with_mode           = mode
*   LEAVE_TO_EDITOR            =
*   LEAVED_WITH_FCODE          =
*   PROGRAM_CORRNUM            =
*   PROGRAM_ORDERNUM           =
* CHANGING
*   PROGRAM_PROGDIR            =
*   PROGRAM_TRDIR              =
   EXCEPTIONS
     program_name_missing       = 1
     program_not_exists         = 2
     OTHERS                     = 3
            .
  IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ELSE.
    IF mode = 'MODF'.
      g_status = 'I'.
    ENDIF.
  ENDIF.

  WRITE:/1 'Program:',
         10 g_pname.

  CLEAR task.
  SELECT
    trkorr
    FROM e071
    INTO task
    UP TO 1 ROWS
    WHERE obj_name = g_pname.
  ENDSELECT.
  WRITE:/1 'Task' ,
        10  task.
  DATA: BEGIN OF include OCCURS 0,
          incl(30) TYPE c,
        END OF include.

  CALL FUNCTION 'GET_INCLUDETAB'
    EXPORTING
      progname = g_pname
    TABLES
      incltab  = include.
  LOOP AT include.
    CLEAR task.
    IF include-incl+0(1) = 'Y' OR
       include-incl+0(1) = 'Z'.
      WRITE:/1 'Include:',
           10 include-incl.
      WRITE:/1 'Task' .

      SELECT
       trkorr
       FROM e071
       INTO task
       UP TO 1 ROWS
       WHERE obj_name = include-incl.
      ENDSELECT.
      IF sy-subrc = 0.

        WRITE:10  task.
      ENDIF.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " GET_PROG_ATTR
*&---------------------------------------------------------------------*
*&      Form  CHECK_TEXT_SYMBOL
*&---------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM check_text_symbol.

ENDFORM.                    " CHECK_TEXT_SYMBOL
*&---------------------------------------------------------------------*
*&      Form  html_download
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM html_download.
  CALL FUNCTION 'LIST_DOWNLOAD_HTML'
* EXPORTING
*   LIST_INDEX               = SLIST_INDEX_DEFAULT
   EXCEPTIONS
     list_index_invalid       = 1
     download_error           = 2
     OTHERS                   = 3
            .
  IF sy-subrc <> 0.
    MESSAGE i010(01) WITH 'Error while downloading list into html'.
  ENDIF.

ENDFORM.                    " html_download
*&---------------------------------------------------------------------*
*&      Form  VALIDATE_LOCAL_INT_TAB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_T_ITAB1_STR1  text
*      -->P_T_ITAB1_ROW2  text
*----------------------------------------------------------------------*
FORM validate_local_int_tab  USING    p_table
                                      p_row
                                      l_length.
  DATA: l_length1 TYPE i.
  CLEAR t_mess.
  l_length1 = STRLEN( p_ltab ).
  CLEAR t_mess.
  IF p_table(l_length1) <> p_ltab.
    CONCATENATE 'Error: Local Internal Table name is not matching'
                         p_table
                         INTO t_mess-message
                         SEPARATED BY space.

    READ TABLE source_main INDEX p_row.
    READ TABLE t_mess WITH KEY lineno2 = source_main-lineno.
    IF sy-subrc NE 0 AND t_mess-item_no NE '2'.

      t_mess-lineno2 = source_main-lineno.
      t_mess-program = source_main-program.
      t_mess-item_no = '2'.
      APPEND t_mess.
      w_itab_ctr = w_itab_ctr + 1.
    ENDIF.
  ENDIF.
ENDFORM.                    " VALIDATE_LOCAL_INT_TAB
*&---------------------------------------------------------------------*
*&      Form  VALIDATE_LOCAL_WA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_T_ITAB1_STR1  text
*      -->P_T_ITAB1_ROW2  text
*      -->P_L_TABL  text
*----------------------------------------------------------------------*
FORM validate_local_wa  USING    p_table
                                      p_row
                                      l_length.
  DATA: l_length1 TYPE i.
  CLEAR t_mess.
  l_length1 = STRLEN( p_lwa ).
  IF p_table(l_length1) <> p_lwa.
    CONCATENATE 'Error: Local Work Area name is not matching'
                         p_table
                         INTO t_mess-message
                         SEPARATED BY space.

    READ TABLE source_main INDEX p_row.
    READ TABLE t_mess WITH KEY lineno2 = source_main-lineno.
    IF sy-subrc NE 0 AND t_mess-item_no NE '2'.

      t_mess-lineno2 = source_main-lineno.
      t_mess-program = source_main-program.
      t_mess-item_no = '2'.
      APPEND t_mess.
      w_itab_ctr = w_itab_ctr + 1.
    ENDIF.
  ENDIF.
ENDFORM.                    " VALIDATE_LOCAL_WA
*&---------------------------------------------------------------------*
*&      Form  VALIDATE_LOCAL_STRUC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_T_ITAB1_STR1  text
*      -->P_T_ITAB1_ROW2  text
*      -->P_L_TABL  text
*----------------------------------------------------------------------*
FORM validate_local_struc  USING    p_table
                                      p_row
                                      l_length.
  DATA: l_length1 TYPE i.
  CLEAR t_mess.
  l_length1 = STRLEN( p_lstr ).
  IF p_table(l_length1) <> p_lstr.
    CONCATENATE 'Error: Local Structure name is not matching'
                         p_table
                         INTO t_mess-message
                         SEPARATED BY space.

    READ TABLE source_main INDEX p_row.
    READ TABLE t_mess WITH KEY lineno2 = source_main-lineno.
    IF sy-subrc NE 0 AND t_mess-item_no NE '2'.
*
      t_mess-lineno2 = source_main-lineno.
      t_mess-program = source_main-program.
      t_mess-item_no = '2'.
      APPEND t_mess.
      w_itab_ctr = w_itab_ctr + 1.
    ENDIF.
  ENDIF.
ENDFORM.                    " VALIDATE_LOCAL_STRUC
*&---------------------------------------------------------------------*
*&      Form  TCODE_CHECK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM tcode_check .

  DATA:
    l_tabix LIKE sy-tabix,
    lin TYPE i.

  SELECT tstc~tcode tstc~pgmna tstct~ttext INTO TABLE i_tcode FROM tstc
  INNER JOIN tstct ON tstc~tcode = tstct~tcode
  WHERE pgmna = g_pname.

  DESCRIBE TABLE i_tcode LINES lin.

  w_tcode_ctr = lin. "l_tabix.

  IF w_tcode_ctr > 0.
    t_mess-item_no = '20'.
    APPEND t_mess.

  ENDIF.

  CLEAR i_tcode.

  CLEAR:
            t_mess-program,
            t_mess-item_no.


ENDFORM.                    " TCODE_CHECK
*&---------------------------------------------------------------------*
*&      Form  list_tcodes
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM list_tcodes .

  READ TABLE t_mess WITH KEY t_mess-item_no.

  IF t_mess-item_no = 20.

    IF sy-subrc = 0.

      IF sy-lsind = 1.

        IF w_tcode_ctr = 0.
          MESSAGE s000(zga) WITH 'Please select a valid line'.

        ELSE.

          list_flag = 'X'.
          NEW-PAGE LINE-SIZE 255.

          ULINE.
          FORMAT COLOR COL_GROUP INTENSIFIED OFF.
          WRITE:/5 'Transaction Code Description', 60 'Transaction Code'
          .
          ULINE.

          WRITE:/.

          CLEAR t_mess-item_no.
          LOOP AT i_tcode .
            FORMAT COLOR COL_NORMAL INTENSIFIED OFF.
            WRITE:/10 i_tcode-ttext, 65 i_tcode-tcode.

            HIDE: i_tcode-ttext,
                  i_tcode-tcode.

          ENDLOOP.
          t_mess-item_no = 35.
        ENDIF.
        IF sy-subrc <> 0.
          MESSAGE s000(zga) WITH 'Please select a valid line'.

        ENDIF.

      ENDIF.

    ENDIF.

  ENDIF.


ENDFORM.                    " list_tcodes
*&---------------------------------------------------------------------*
*&      Form  goto_transaction
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM goto_transaction .

  IF sy-lsind = 2.

    IF t_mess-item_no = 35.

      IF NOT i_tcode-tcode IS INITIAL AND NOT i_tcode-name IS INITIAL.

        CALL FUNCTION 'RS_TOOL_ACCESS'
          EXPORTING
            operation                 = 'SHOW'
           object_name               = i_tcode-tcode
           object_type               = 'T'
*      ENCLOSING_OBJECT          =
           position                  =   i_tcode-tcode

*      DEVCLASS                  =
*      INCLUDE                   =
         version                   = g_status
        monitor_activation        = 'X'
*      WB_MANAGER                =
*      IN_NEW_WINDOW             =
*      WITH_OBJECTLIST           = ' '
*    IMPORTING
*      NEW_NAME                  =
*      WB_TODO_REQUEST           =
*    TABLES
*      OBJLIST                   =
      EXCEPTIONS
        not_executed              = 1
        invalid_object_type       = 2
        OTHERS                    = 3
        .
        IF sy-subrc = 0.
          CLEAR:
           i_tcode-ttext,
              i_tcode-tcode.
        ELSE.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
          CLEAR:
                    i_tcode-ttext,
                    i_tcode-tcode.

        ENDIF.

      ENDIF.
    ENDIF.
    CLEAR:
              i_tcode-ttext,
              i_tcode-tcode.
  ENDIF.

ENDFORM.                    " goto_transaction
*&---------------------------------------------------------------------*
*&      Form  Select_cluster
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM select_cluster .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA: tabclass LIKE dd02l-tabclass.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4),
    count TYPE i.

  LOOP AT t_tokens_sub WHERE str = 'SELECT' . "search for select
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .
    CLEAR:

      l_from,
      l_to.

    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements_sub-from.
      l_to = t_statements_sub-to.
      IF sel_clus = 'X'.
        LOOP AT t_tokens_sub FROM l_from TO l_to.

          IF t_tokens_sub-str = 'FROM' OR t_tokens_sub-str = 'ON' OR
          t_tokens_sub-str = 'JOIN'.

            count = 0.

          ENDIF.

          IF count = 1.

            wa_tabname = t_tokens_sub-str.

            SELECT SINGLE tabclass FROM dd02l INTO tabclass WHERE
            tabname = wa_tabname.

            IF tabclass = 'CLUSTER'.

              READ TABLE source_main INDEX t_tokens_sub-row.
              READ TABLE t_mess WITH KEY item_no = '21'
                                         lineno2 = source_main-lineno .
              IF sy-subrc <> 0.

                CONCATENATE 'Select From the Cluster Table      '
                            t_tokens_sub-str
                          INTO t_mess-message
                          SEPARATED BY space.

                t_mess-lineno2 = source_main-lineno.
                t_mess-program = source_main-program.

                t_mess-item_no = '21'.
                APPEND t_mess.
                w_selclus_ctr = w_selclus_ctr + 1.
              ENDIF.
            ENDIF.
            CLEAR tabclass.
          ENDIF.
          count = count + 1.
        ENDLOOP.
      ENDIF.
    ENDIF.
    CLEAR:
          t_mess-program,
          t_mess-lineno2.
  ENDLOOP.
ENDFORM.                    " Select_cluster
*&---------------------------------------------------------------------*
*&      Form  Hard_brpnts
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM hard_brpnts .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA: tabclass LIKE dd02l-tabclass.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4),
    count TYPE i.

  LOOP AT t_tokens_sub WHERE str = 'BREAK-POINT' OR str = 'BREAK' OR str
  = 'ASSERT' OR str = 'LOG-POINT'.
    "Search for Hard Break Point, Assert or Log-Point
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .
    CLEAR: l_from,
           l_to.

    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements_sub-from.
      l_to = t_statements_sub-to.
      IF hard_br = 'X'.
        LOOP AT t_tokens_sub FROM l_from TO l_to.

          IF t_tokens_sub-str = 'BREAK-POINT' OR t_tokens_sub-str =
          'BREAK' OR t_tokens_sub-str = 'ASSERT' OR t_tokens_sub-str =
          'LOG-POINT'.
            READ TABLE source_main INDEX t_tokens_sub-row.
            READ TABLE t_mess WITH KEY item_no = '22'
                                       lineno2 = source_main-lineno .
            IF sy-subrc <> 0.
              t_mess-message = 'HARD BREAK POINTS USED'.
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.

              t_mess-item_no = '22'.
              APPEND t_mess.
              w_uname_brpnt_ctr = w_uname_brpnt_ctr + 1.
            ENDIF.

          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
    CLEAR:
          t_mess-program,
          t_mess-lineno2.
  ENDLOOP.

ENDFORM.                    " hard_brpnts
*&---------------------------------------------------------------------*
*&      Form  View_chck
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM view_chck .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA: tabclass LIKE dd02l-tabclass.
  DATA: BEGIN OF it_tabname OCCURS 0,
         tabname LIKE dd02l-tabname,
        END OF it_tabname.
  DATA: tabname LIKE dd02l-tabname,
        tabname1 LIKE dd02l-tabname,
        tabname2 LIKE dd02l-tabname.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    flag,
    row LIKE stoken-row,
    count TYPE i.
  DATA: tab1 LIKE dd02l-tabname,
        tab2 LIKE dd02l-tabname.

  DATA: l_loop_ctr TYPE i VALUE -1.
  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.

  t_keywords ='SELECT'.             APPEND t_keywords.

  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens
                           KEYWORDS   FROM t_keywords .

  t_tokens_sub[] = t_tokens[].
  t_statements1[] = t_statements[].

  LOOP AT t_tokens_sub WHERE str = 'SELECT' . "search for select

    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR: flag_s,
          count.
    nextidx = sy-tabix + 1 .
    CLEAR:
      flag,
      l_from,
      l_to.
    row = t_tokens_sub-row.

    READ TABLE t_statements WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements-from.
      l_to = t_statements-to.
      IF view_chk = 'X'.

        LOOP AT t_tokens_sub FROM l_from TO l_to.

          IF t_tokens_sub-str = 'JOIN' .

            count = count + 1.

            flag = 1.

            IF count > 1.
              CLEAR flag.
            ENDIF.

          ENDIF.

          IF flag = 1.

            READ TABLE source_main INDEX row.
            READ TABLE t_mess WITH KEY item_no = '33'
                                       lineno2 = source_main-lineno
                                       .
            IF sy-subrc <> 0.

              t_mess-message =
'Performance Issue: Tables are Joined in the Select State' &
'ment.Click Here to See the Details'
              .
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '33'.
              APPEND t_mess.

              w_view_chk_ctr = w_view_chk_ctr + 1.
            ENDIF.
          ENDIF.
          CLEAR flag.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDLOOP.
  CLEAR:
            t_mess-program,
            t_mess-lineno2,
            t_mess-item_no.

ENDFORM.                    " View_chck

*&---------------------------------------------------------------------*
*&      Form  VIEW_LIST
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM view_list .

  IF t_mess-item_no = 33.

    IF sy-lsind = 1.

      it_mess[] = t_mess[].

      LOOP AT it_mess WHERE item_no = 33.

        IF w_view_chk_ctr = 0.
          MESSAGE s000(zga) WITH 'Please select a valid line'.

        ELSE.

          list_flag = 'X'.
          NEW-PAGE LINE-SIZE 255.

          ULINE.
          FORMAT COLOR COL_GROUP INTENSIFIED OFF.
          WRITE: /,/ 'PROGRAM:   ', it_mess-program,
                 40 'LINE:', 50 it_mess-lineno2,
                 254 space.
          HIDE: it_mess-program,
              it_mess-lineno2.

          FORMAT COLOR COL_NORMAL INTENSIFIED OFF.
          WRITE:/ it_mess-message,
                254 space.

          HIDE: it_mess-program,
              it_mess-lineno2.

        ENDIF.
        program = it_mess-program.
        index = it_mess-lineno2.
      ENDLOOP.

    ENDIF.

  ENDIF.

ENDFORM.                    " VIEW_LIST

*&---------------------------------------------------------------------*
*&      Form  SORT_LOOP
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sort_loop .

  DATA t_tokens_temp LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA l_loop_ctr TYPE i.
  t_tokens_temp[] = t_tokens_sub[].
****Changes 04-11-2009
  DELETE t_tokens_temp WHERE str NE 'LOOP'
                       AND   str NE 'SORT'
                       AND   str NE 'DELETE'
                       AND   str NE 'DO'
                       AND   str NE 'ENDDO'
                       AND   str NE 'ENDLOOP'.

  LOOP AT t_tokens_temp.
    IF t_tokens_temp-str = 'LOOP' OR
       t_tokens_temp-str = 'DO'.
      l_loop_ctr = l_loop_ctr + 1.
    ENDIF.
    IF t_tokens_temp-str = 'SORT' .
      IF l_loop_ctr <> 0.
        t_mess-message = 'SORT is used within a LOOP'.
        READ TABLE source_main INDEX t_tokens_temp-row.
        t_mess-lineno2 =  source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '24'.
        APPEND t_mess.
        w_sortloop_ctr = w_sortloop_ctr + 1.

      ENDIF.
    ENDIF.
    IF t_tokens_temp-str = 'DELETE'.
      IF l_loop_ctr <> 0.
        t_mess-message = 'DELETE is used within a LOOP'.
        READ TABLE source_main INDEX t_tokens_temp-row.
        t_mess-lineno2 =  source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '24'.
        APPEND t_mess.
        w_sortloop_ctr = w_sortloop_ctr + 1.

      ENDIF.
    ENDIF.

    IF t_tokens_temp-str = 'ENDLOOP' OR
       t_tokens_temp-str = 'ENDDO'.
      l_loop_ctr = l_loop_ctr - 1.
    ENDIF.

    CLEAR:
          t_mess-program,
          t_mess-lineno2.

  ENDLOOP.

ENDFORM.                    " SORT_LOOP
*&---------------------------------------------------------------------*
*&      Form  TABL_UPDATE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM tabl_update .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA: tabclass LIKE dd02l-tabclass.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4),
    count TYPE i.

  LOOP AT t_tokens_sub WHERE str = 'INSERT' OR str = 'UPDATE' OR
  str = 'DELETE' OR str = 'MODIFY'. "search for select
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .
    CLEAR:

      l_from,
      l_to.

    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements_sub-from .
      l_to = t_statements_sub-to.
      IF tabl_upd = 'X'.

        LOOP AT t_tokens_sub FROM l_from TO l_to.

          wa_tabname = t_tokens_sub-str.

          SELECT SINGLE tabclass FROM dd02l INTO tabclass WHERE tabname
          = wa_tabname.

          IF tabclass = 'TRANSP' OR tabclass = 'CLUSTER'.

            READ TABLE source_main INDEX t_tokens_sub-row.
            READ TABLE t_mess WITH KEY item_no = '25'
                                       lineno2 = source_main-lineno .
            IF sy-subrc <> 0.

              CONCATENATE
'Direct Table Entries INSERTION / UPDATION / DELETION / MODIFY For Ta' &
'ble :     '
                          t_tokens_sub-str
                        INTO t_mess-message
                        SEPARATED BY space.

              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.

              t_mess-item_no = '25'.
              APPEND t_mess.
              w_tabl_upd_ctr = w_tabl_upd_ctr + 1.
            ENDIF.
          ENDIF.
          CLEAR tabclass.
          count = count + 1.
        ENDLOOP.
      ENDIF.
    ENDIF.
    CLEAR:
          t_mess-program,
          t_mess-lineno2.
  ENDLOOP.


ENDFORM.                    " TABL_UPDATE
*&---------------------------------------------------------------------*
*&      Form  NEG_SQL_STATEMENTS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM neg_sql_statements .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
          nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA:
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4).

  LOOP AT t_tokens_sub WHERE str = 'SELECT' . "search for select
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .

    CLEAR:
      l_from,
      l_to.

    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements_sub-from.
      l_to = t_statements_sub-to.
      IF neg_sql = 'X'.
        LOOP AT t_tokens_sub FROM l_from TO l_to.
          IF t_tokens_sub-str = '<>' OR t_tokens_sub-str = 'NE' OR
          t_tokens_sub-str = '<' OR t_tokens_sub-str = 'LT' OR
          t_tokens_sub-str = '>' OR t_tokens_sub-str = 'GT'
              OR t_tokens_sub-str = '<=' OR t_tokens_sub-str = 'LE' OR
              t_tokens_sub-str = '>=' OR t_tokens_sub-str = 'GE' OR
              t_tokens_sub-str = 'CN'  OR t_tokens_sub-str = 'NA'
               OR t_tokens_sub-str = 'NS' OR t_tokens_sub-str = 'NP'.

            READ TABLE source_main INDEX t_tokens_sub-row.
            READ TABLE t_mess WITH KEY item_no = '26'
                                       lineno2 = source_main-lineno .

            IF sy-subrc <> 0.
              t_mess-message =
              'Negative SQL Statements in Where Condition of Select'.
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.

              t_mess-item_no = '26'.
              APPEND t_mess.
              w_neg_sql_ctr = w_neg_sql_ctr + 1.
            ENDIF.

          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
    CLEAR:
          t_mess-program,
          t_mess-lineno2.

  ENDLOOP.

ENDFORM.                    " NEG_SQL_STATEMENTS
*&---------------------------------------------------------------------*
*&      Form  ON_CHANGE_OF
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM on_change_of .

  DATA t_tokens_temp LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA l_loop_ctr TYPE i.

  DATA: nextidx  LIKE sy-tabix , " start of read table block
          nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA:
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4).

  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.

  t_keywords ='ON'.             APPEND t_keywords.

  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens
                           KEYWORDS   FROM t_keywords .

  t_tokens_sub[] = t_tokens[].


  LOOP AT t_tokens_sub WHERE str = 'ON' . "search for select
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .

    CLEAR:
      l_from,
      l_to.

    READ TABLE t_statements WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements-from.
      l_to = t_statements-to.
      IF on_chg = 'X'.

        LOOP AT t_tokens_sub FROM l_from TO l_to.

          IF t_tokens_sub-str = 'CHANGE'.

            READ TABLE source_main INDEX t_tokens_sub-row.
            READ TABLE t_mess WITH KEY item_no = '27'
                                       lineno2 = source_main-lineno .

            IF sy-subrc <> 0.
              t_mess-message = 'Usage of On Change Of Statement'.
              READ TABLE source_main INDEX t_tokens_sub-row.
              t_mess-lineno2 =  source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '27'.
              APPEND t_mess.
              w_on_chg_ctr = w_on_chg_ctr + 1.

            ENDIF.

          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
    CLEAR:
          t_mess-program,
          t_mess-lineno2.
  ENDLOOP.
ENDFORM.                    " ON_CHANGE_OF
*&---------------------------------------------------------------------*
*&      Form  uname_check
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM uname_check .
  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA: tabclass LIKE dd02l-tabclass.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4),
    count TYPE i.

  LOOP AT t_tokens_sub WHERE str = 'IF' . "search for IF
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .
    CLEAR:

      l_from,
      l_to.

    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements_sub-from.
      l_to = t_statements_sub-to.
      IF uname_ck = 'X'.
        LOOP AT t_tokens_sub FROM l_from TO l_to.

          IF t_tokens_sub-str = 'SY-UNAME'.

            READ TABLE source_main INDEX t_tokens_sub-row.
            READ TABLE t_mess WITH KEY item_no = '23'
                                       lineno2 = source_main-lineno .
            IF sy-subrc <> 0.

              CONCATENATE 'User Name Check Used in the Program'
                           t_tokens_sub-str
                         INTO t_mess-message
                         SEPARATED BY space.

              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.

              t_mess-item_no = '23'.
              APPEND t_mess.
              w_uname_chk_ctr = w_uname_chk_ctr + 1.

            ENDIF.
          ENDIF.

        ENDLOOP.
**** Changes 04-11-2009
        IF NOT hard_wre IS INITIAL.
          LOOP AT t_tokens_sub FROM l_from TO l_to.
            IF t_tokens_sub-str CS ''''.
              READ TABLE source_main INDEX t_tokens_sub-row.
              READ TABLE t_mess WITH KEY item_no = '9'
                                        lineno2 = source_main-lineno .
              IF sy-subrc <> 0.
                t_mess-message =
                'Warning: Hardcoding in where / IF clause Line'.
                t_mess-lineno2 = source_main-lineno.
                t_mess-program = source_main-program.

                t_mess-item_no = '9'.
                APPEND t_mess.
                w_whr_ctr = w_whr_ctr + 1.
              ENDIF.
            ENDIF.
          ENDLOOP.
        ENDIF.

      ENDIF.
      CLEAR:
            t_mess-program,
            t_mess-lineno2.
    ENDIF.
  ENDLOOP.


ENDFORM.                    " uname_check
*&---------------------------------------------------------------------*
*&      Form  TABL_hit_cnt
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM tabl_hit_cnt .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA: tabclass LIKE dd02l-tabclass.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4),
    count TYPE i.

  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.

  t_keywords ='SELECT'.             APPEND t_keywords.


  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens
                           KEYWORDS   FROM t_keywords .


  t_tokens_sub[] = t_tokens[].

  LOOP AT t_tokens_sub WHERE str = 'SELECT' . "search for select
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .
    CLEAR:

      l_from,
      l_to.

    READ TABLE t_statements WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements-from.
      l_to = t_statements-to.
      IF tabl_cnt = 'X'.
        LOOP AT t_tokens_sub FROM l_from TO l_to.

          IF t_tokens_sub-str = 'FROM' OR t_tokens_sub-str = 'ON' OR
          t_tokens_sub-str = 'JOIN'.

            count = 0.

          ENDIF.

          IF count = 1.

            t_tabl_cnt-tabname = t_tokens_sub-str.

            wa_tabname = t_tokens_sub-str.

            SELECT SINGLE tabclass FROM dd02l INTO tabclass WHERE
            tabname = wa_tabname.
            IF sy-subrc = 0.
              APPEND t_tabl_cnt.
            ENDIF.

          ENDIF.

          count = count + 1.
        ENDLOOP.


      ENDIF.
    ENDIF.
  ENDLOOP.

  w_tabl_cnt_ctr = 1.
  t_mess-item_no = '28'.
  APPEND t_mess.

  CLEAR:
            t_mess-program,
            t_mess-item_no.
*            t_tabl_cnt.

ENDFORM.                    " TABL_hit_cnt
*&---------------------------------------------------------------------*
*&      Form  TABL_CNT_LIST
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM tabl_cnt_list .

  DATA: it_tabl_cnt LIKE t_tabl_cnt OCCURS 0 WITH HEADER LINE.

  READ TABLE t_mess WITH KEY t_mess-item_no.


  IF t_mess-item_no = 28.

    IF sy-subrc = 0.

      IF sy-lsind = 1.

        SORT t_tabl_cnt BY tabname..

        LOOP AT t_tabl_cnt.
          COLLECT t_tabl_cnt INTO it_tabl_cnt..
        ENDLOOP.

        NEW-PAGE LINE-SIZE 255.

        ULINE.
        FORMAT COLOR COL_GROUP INTENSIFIED OFF.
        WRITE:/5 'Table Name', 65 'Hit Count'.
        ULINE.

        WRITE:/.

        LOOP AT it_tabl_cnt.

          IF it_tabl_cnt-count = 1.

            FORMAT COLOR COL_POSITIVE INTENSIFIED OFF.

            WRITE:/10 it_tabl_cnt-tabname, 65 it_tabl_cnt-count.

          ELSE.

            IF it_tabl_cnt-count = 2 .

              FORMAT COLOR COL_TOTAL INTENSIFIED OFF.

              WRITE:/10 it_tabl_cnt-tabname, 65 it_tabl_cnt-count.

            ELSE.

              IF it_tabl_cnt-count > 2.

                FORMAT COLOR COL_NEGATIVE INTENSIFIED OFF.

                WRITE:/10 it_tabl_cnt-tabname, 65 it_tabl_cnt-count.

              ENDIF.

            ENDIF.

          ENDIF.

        ENDLOOP.

        CLEAR:
            t_mess-program,
            t_mess-lineno2,
            t_mess-item_no.

      ENDIF.
    ENDIF.
  ENDIF.



ENDFORM.                    " TABL_CNT_LIST
*&---------------------------------------------------------------------*
*&      Form  Itab_initial_check
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM itab_initial_check .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextidx1  LIKE sy-tabix  ,
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(30),
        tabnam1(30), " name for internal table,
        tabnam2(31), " name for internal table,
        tabnam3(31). " name for internal table.

  DATA: lno TYPE i ,
        lno1 TYPE i.

  DATA:
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4),
    count TYPE i,
    a1,
    a2 ,a3, a4.
  DATA: a5 TYPE i,
        a6 TYPE i.

  DATA:
    wa_tokens1 LIKE t_tokens_sub,
    l_key_index1 LIKE sy-tabix,
    l_new_tabix1 LIKE sy-tabix,
    l_stmt_index1 LIKE sy-tabix,
    l_from1 LIKE sstmnt-from,
    l_to1 LIKE sstmnt-to,
    l_syrow1 LIKE sy-tabix,
    flag_s1,
    row1(4),
    count1 TYPE i,
    l_loop_ctr TYPE i.

  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.

  t_keywords ='IF'.             APPEND t_keywords.
  t_keywords ='SELECT'.             APPEND t_keywords.
  t_keywords ='ENDIF'.             APPEND t_keywords.
  t_keywords = 'CHECK'.          APPEND t_keywords.

  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens
                           KEYWORDS   FROM t_keywords .

  t_tokens_sub[] = t_tokens[].
  t_tokens_sub1[] = t_tokens_sub[].

  CLEAR t_tokens_sub.

  LOOP AT t_tokens_sub.

    IF t_tokens_sub-str = 'IF' OR t_tokens_sub-str = 'CHECK'.

      CLEAR l_new_tabix.
      l_new_tabix = sy-tabix.
      lno = t_tokens_sub-row.
      CLEAR flag_s.
      nextidx = sy-tabix + 1 .
      CLEAR:
        a3,
        l_from,
        l_to,
        tabnam1.

      READ TABLE t_statements WITH KEY FROM = sy-tabix.
      IF sy-subrc = 0.
        l_from = t_statements-from .
        l_to = t_statements-to.
        IF int_ini = 'X'.

          LOOP AT t_tokens_sub FROM l_from TO l_to.

            IF t_tokens_sub-str = 'IS' OR t_tokens_sub-str = 'NOT' OR
            t_tokens_sub-str = 'IF'.

              count = 0.
            ENDIF.

            IF t_tokens_sub-str = 'INITIAL'.
              a3 = 1.
              count = 0.
            ENDIF.

            IF count = 1.
              tabnam1 = t_tokens_sub-str.
            ENDIF.

            count = count + 1.
          ENDLOOP.

          IF a3 NE 1.
            CLEAR tabnam1.
          ENDIF.
          IF tabnam1 IS INITIAL.
            a3 = 0.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    IF t_tokens_sub-str = 'SELECT' . "search for For All Entries

      CLEAR l_new_tabix.
      l_new_tabix = sy-tabix.
      lno = t_tokens_sub-row.
      CLEAR flag_s.
      nextidx = sy-tabix + 1 .
      CLEAR:
        a1,
        a2,
        l_from,
        l_to.

      READ TABLE t_statements WITH KEY FROM = sy-tabix.
      IF sy-subrc = 0.
        l_from = t_statements-from.
        l_to = t_statements-to.
        IF int_ini = 'X'.
          LOOP AT t_tokens_sub FROM l_from TO l_to.

            IF t_tokens_sub-str = 'ENTRIES'.

              a1 = 1.

            ENDIF.

            IF t_tokens_sub-str = 'IN'.
              a2 = 1.
              count1 = 0.

            ENDIF.

            IF count1 = 1.

              IF a1 = 1 AND a2 = 1.
                tabnam = t_tokens_sub-str.
                a5 = t_tokens_sub-row.

                CONCATENATE tabnam '[]' INTO tabnam2.

                IF tabnam = tabnam1 OR tabnam2 = tabnam1 .

                  EXIT.

                ELSE.

                  IF a3 NE 1 AND tabnam1 IS INITIAL.
                    .
                    READ TABLE source_main INDEX t_statements-trow.
                    READ TABLE t_mess WITH KEY item_no = '29'
                                               lineno2 =
                                               source_main-lineno .
                    IF sy-subrc <> 0.

                      CONCATENATE
'Check the Internal Table before Using For All Entries'
                                   tabnam
                                 INTO t_mess-message
                                 SEPARATED BY space.

                      t_mess-lineno2 = source_main-lineno.
                      t_mess-program = source_main-program.

                      t_mess-item_no = '29'.
                      APPEND t_mess.
                      w_int_ini_ctr = w_int_ini_ctr + 1.
                    ENDIF.

                  ENDIF.
                ENDIF.
              ENDIF.
            ENDIF.
            count1 = count1 + 1.
          ENDLOOP.
          CLEAR count1.
        ENDIF.
      ENDIF.
    ENDIF.

    IF t_tokens_sub-str = 'ENDIF'.
      CLEAR tabnam1.
      CLEAR count.
      CLEAR a3.
    ENDIF.
  ENDLOOP.
  CLEAR:
            t_mess-program,
            t_mess-lineno2.

ENDFORM.                    " Itab_initial_check
*&---------------------------------------------------------------------*
*&      Form  STATEMENT_LINE_CHK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM statement_line_chk .

  DATA: BEGIN OF t_statements_lin OCCURS 0.
          INCLUDE STRUCTURE sstmnt.
  DATA: count TYPE i VALUE 1.
  DATA: END OF t_statements_lin.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4),
    count TYPE i.

  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: t_statements_sub LIKE sstmnt OCCURS 100 WITH HEADER LINE.

  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.


  DATA: BEGIN OF itab OCCURS 100,
          trow TYPE sstmnt-trow,
        END OF itab.

  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens.

  t_tokens_sub = t_tokens.

  LOOP AT t_statements.

    ON CHANGE OF t_statements-trow.

      count = 0.

    ENDON.

    IF count > 0.

      READ TABLE source_main INDEX t_statements-trow.
      READ TABLE t_mess WITH KEY item_no = '30'
                                 lineno2 = source_main-lineno .
      IF sy-subrc <> 0.

        CONCATENATE 'Check for One Statement Per Line'
                     t_tokens_sub-str
                   INTO t_mess-message
                   SEPARATED BY space.

        t_mess-lineno2 = source_main-lineno.
        t_mess-program = source_main-program.

        t_mess-item_no = '30'.
        APPEND t_mess.
        w_stat_lin_ctr = w_stat_lin_ctr + 1.
      ENDIF.
    ENDIF.
    count = count + 1.

  ENDLOOP.
  CLEAR:
            t_mess-program,
            t_mess-lineno2.

ENDFORM.                    " STATEMENT_LINE_CHK
*&---------------------------------------------------------------------*
*&      Form  SORT_HASH_TABLE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sort_hash_table .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: nextidx1  LIKE sy-tabix , " start of read table block
        nextread1 LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: tabnam1(10). " name for internal table.

  DATA: lno TYPE i .
  DATA: lno1 TYPE i .
  DATA: tabclass LIKE dd02l-tabclass.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4),
    count TYPE i.

  DATA:
    wa_tokens1 LIKE t_tokens_sub,
    l_key_index1 LIKE sy-tabix,
    l_new_tabix1 LIKE sy-tabix,
    l_stmt_index1 LIKE sy-tabix,
    l_from1 LIKE sstmnt-from,
    l_to1 LIKE sstmnt-to,
    l_syrow1 LIKE sy-tabix,
    flag_s1,
    row1(4),
    count1 TYPE i.

  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.

  t_keywords ='SORT'.             APPEND t_keywords.

  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens
                          KEYWORDS   FROM t_keywords .

  t_tokens_sub1 = t_tokens.

  LOOP AT t_tokens_sub WHERE str = 'DATA' OR str = 'TYPES' .
    "search for Variable Declaration
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .
    CLEAR:

      l_from,
      l_to.

    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from = t_statements_sub-from + 1.
      l_to = t_statements_sub-to.
      IF srt_hash = 'X'.
        count = 0.
        LOOP AT t_tokens_sub FROM l_from TO l_to.

          IF count = 0.

            tabnam = t_tokens_sub-str.

          ENDIF.

          IF t_tokens_sub-str = 'TYPE' .

            count = 0.

          ENDIF.

          IF t_tokens_sub-str = 'HASHED' AND count = 1.
            tabnam1 = tabnam.
            CLEAR tabnam.

            LOOP AT t_tokens_sub WHERE str = 'SORT' . "search for Sort
              CLEAR l_new_tabix.
              l_new_tabix = sy-tabix.
              lno = t_tokens_sub-row.
              CLEAR flag_s.
              nextidx = sy-tabix + 1 .
              CLEAR:

                l_from1,
                l_to1.

              READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
              IF sy-subrc = 0.
                l_from1 = t_statements_sub-from + 1.
                l_to1 = t_statements_sub-to.
                IF srt_hash = 'X'.
                  count1 = 0.
                  LOOP AT t_tokens_sub FROM l_from1 TO l_to1.

                    IF count1 = 0.

                      tabnam = t_tokens_sub-str.

                      IF tabnam = tabnam1.

                        READ TABLE source_main INDEX
                        t_statements_sub-trow.
                        READ TABLE t_mess WITH KEY item_no = '31'
                                                   lineno2 =
                                                   source_main-lineno .
                        IF sy-subrc <> 0.

                          CONCATENATE 'Sort Is used on Hashed Table'
                                       t_tokens_sub-str
                                     INTO t_mess-message
                                     SEPARATED BY space.

                          t_mess-lineno2 = source_main-lineno.
                          t_mess-program = source_main-program.

                          t_mess-item_no = '31'.
                          APPEND t_mess.
                          w_srt_hash_ctr = w_srt_hash_ctr + 1.
                        ENDIF.

                      ENDIF.

                    ENDIF.
                  ENDLOOP.

                ENDIF.
              ENDIF.
            ENDLOOP.

          ENDIF.

          count = count + 1.

        ENDLOOP.

      ENDIF.
    ENDIF.
  ENDLOOP.
  CLEAR:
            t_mess-program,
            t_mess-lineno2.

ENDFORM.                    " SORT_HASH_TABLE
*&---------------------------------------------------------------------*
*&      Form  RANGES_SIZE_CHK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM ranges_size_chk .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: tabnam1(10). " name for internal table.
  DATA: tabnam2(10). " name for internal table.

  DATA: lno TYPE i .
  DATA: lno1 TYPE i .
  DATA: tabclass LIKE dd02l-tabclass.
  DATA l_loop_ctr TYPE i.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
     l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_stmt_index LIKE sy-tabix,
    l_from1 LIKE sstmnt-from,
    l_to1 LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4),
    count TYPE i,
    count1 TYPE i.

  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.

  t_keywords ='RANGES'.             APPEND t_keywords.
  t_keywords ='APPEND'.             APPEND t_keywords.
  t_keywords = 'LOOP'.             APPEND t_keywords.
  t_keywords = 'ENDLOOP'.             APPEND t_keywords.

  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens
                          KEYWORDS   FROM t_keywords .

  t_tokens_sub1 = t_tokens_sub.

  LOOP AT t_tokens_sub1 WHERE str = 'RANGES' .
    "search for Ranges Declaration
    CLEAR l_new_tabix.
    l_new_tabix = sy-tabix.
    lno = t_tokens_sub-row.
    CLEAR flag_s.
    nextidx = sy-tabix + 1 .
    CLEAR:

      l_from1,
      l_to1.

    READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
    IF sy-subrc = 0.
      l_from1 = t_statements_sub-from + 1.
      l_to1 = t_statements_sub-to.
      IF rang_chk = 'X'.
        count = 1.
        LOOP AT t_tokens_sub FROM l_from1 TO l_to1.

          IF t_tokens_sub1-str = 'Begin' OR t_tokens_sub-str = 'of'.

            count = 0.

          ENDIF.

          IF count = 1.

            tabnam = t_tokens_sub1-str.
            CONCATENATE tabnam '[]' INTO tabnam1.

            LOOP AT t_tokens_sub.

              IF t_tokens_sub-str = 'LOOP'.
                l_loop_ctr = l_loop_ctr + 1.
              ENDIF.

              IF t_tokens_sub-str = 'ENDLOOP'.
                l_loop_ctr = l_loop_ctr - 1.
              ENDIF.

              IF t_tokens_sub-str = 'APPEND' . "search for Append

                IF l_loop_ctr <> 0.
                  CLEAR l_new_tabix.
                  l_new_tabix = sy-tabix.
                  lno = t_tokens_sub-row.
                  CLEAR flag_s.
                  nextidx = sy-tabix + 1 .
                  CLEAR:

                    l_from,
                    l_to.

                  READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
                  IF sy-subrc = 0.
                    l_from = t_statements_sub-from + 1.
                    l_to = t_statements_sub-to.
                    IF rang_chk = 'X'.
                      count1 = 0.
                      LOOP AT t_tokens_sub FROM l_from TO l_to.

                        IF count1 = 0.

                          tabnam2 = t_tokens_sub-str.

                          IF tabnam = tabnam2 OR tabnam1 = tabnam2.

                            READ TABLE source_main INDEX
                            t_statements_sub-trow.
                            READ TABLE t_mess WITH KEY item_no = '32'
                                                       lineno2 =
source_main-lineno .
                            IF sy-subrc <> 0.

                              CONCATENATE
                              'Check the Size Limit of The Ranges'
                                           t_tokens_sub-str
                                         INTO t_mess-message
                                         SEPARATED BY space.

                              t_mess-lineno2 = source_main-lineno.
                              t_mess-program = source_main-program.

                              t_mess-item_no = '32'.
                              APPEND t_mess.
                              w_rang_chk_ctr = w_rang_chk_ctr + 1.
                            ENDIF.

                          ENDIF.

                        ENDIF.
                      ENDLOOP.

                    ENDIF.
                  ENDIF.
                ENDIF.
              ENDIF.

            ENDLOOP.

          ENDIF.

          count = count + 1.

        ENDLOOP.

      ENDIF.
    ENDIF.
  ENDLOOP.
  CLEAR:
            t_mess-program,
            t_mess-lineno2.

ENDFORM.                    " RANGES_SIZE_CHK
*&---------------------------------------------------------------------*
*&      Form  VIEW_DISPLAY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM view_display .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
          nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA: tabclass LIKE dd02l-tabclass.
  DATA: BEGIN OF it_tabname OCCURS 0,
         tabname LIKE dd02l-tabname,
        END OF it_tabname.
  DATA: tabname1 LIKE dd02l-tabname,
        tabname2 LIKE dd02l-tabname,
        tabname3 LIKE dd02l-tabname,
        tabname4 LIKE dd02l-tabname.

  DATA:
    wa_tabname LIKE dd02l-tabname,
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    flag,
    row(4),
    index1(10),
    count TYPE i.
  DATA: tab1 LIKE dd02l-tabname,
        tab2 LIKE dd02l-tabname.

  DATA: t_viewname LIKE it_viewname OCCURS 0 WITH HEADER LINE.
  DATA: l_loop_ctr TYPE i VALUE -1.
  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.

  IF it_mess-item_no = 33.

    IF sy-lsind = 2.

      index1 = index.

      LOOP AT source_main WHERE lineno = it_mess-lineno2.
        index1 = sy-tabix .
      ENDLOOP.


      LOOP AT t_tokens_sub WHERE row = index1 . "search for select

        CLEAR it_tabname[].
        CLEAR: tabname3, tabname1, tabname2, tabname4.
        CLEAR l_new_tabix.
        l_new_tabix = sy-tabix.
        lno = t_tokens_sub-row.
        CLEAR flag_s.
        nextidx = sy-tabix + 1 .
        CLEAR:
          l_from,
          l_to.

        READ TABLE t_statements1 WITH KEY FROM = sy-tabix.
        IF sy-subrc = 0.
          l_from = t_statements1-from.
          l_to = t_statements1-to.
          IF view_chk = 'X'.
            LOOP AT t_tokens_sub FROM l_from TO l_to.

              IF t_tokens_sub-str = 'FROM' OR t_tokens_sub-str = 'ON' OR
              t_tokens_sub-str = 'JOIN' .

                count = 0.
                flag = 1.

              ENDIF.

              IF count = 1 AND flag = 1.

                IF tabname1 IS NOT INITIAL AND tabname2 IS NOT INITIAL
                AND
                tabname3 IS NOT INITIAL AND tabname4 IS INITIAL.
                  tabname4 = t_tokens_sub-str.

                  SELECT SINGLE tabname FROM dd02l INTO tabnam WHERE
                  tabname = tabname4.
                  IF sy-subrc NE 0.
                    CLEAR tabname4.
                  ENDIF.

                ENDIF.

                IF tabname1 IS NOT INITIAL AND tabname2 IS NOT INITIAL
                AND tabname3 IS INITIAL .

                  tabname3 = t_tokens_sub-str.
                  SELECT SINGLE tabname FROM dd02l INTO tabnam WHERE
                  tabname = tabname3.
                  IF sy-subrc NE 0.
                    CLEAR tabname3.
                  ENDIF.

                ENDIF.

                IF tabname1 IS NOT INITIAL AND tabname2 IS INITIAL .

                  tabname2 = t_tokens_sub-str.
                  SELECT SINGLE tabname FROM dd02l INTO tabnam WHERE
                  tabname = tabname2.
                  IF sy-subrc NE 0.
                    CLEAR tabname2.
                  ENDIF.

                ENDIF.

                IF tabname1 IS INITIAL.
                  tabname1 = t_tokens_sub-str.

                  SELECT SINGLE tabname FROM dd02l INTO tabnam WHERE
                  tabname = tabname1.
                  IF sy-subrc NE 0.
                    CLEAR tabname1.
                  ENDIF.

                ENDIF.

              ENDIF.

              count = count + 1.
            ENDLOOP.

            IF tabname1 IS NOT INITIAL AND tabname2 IS NOT INITIAL AND
            tabname3 IS INITIAL.

              SELECT dd26s~viewname dd26s~tabname dd02l~tabname
              dd02l~viewclass dd02t~ddtext
              INTO TABLE it_viewname FROM dd02l INNER JOIN
              dd26s ON dd02l~tabname = dd26s~viewname
              INNER JOIN dd02t ON dd02l~tabname = dd02t~tabname
      WHERE dd26s~tabname = tabname1 OR dd26s~tabname = tabname2 AND
      dd02l~viewclass = 'D' AND dd02t~ddlanguage = 'EN'.

              IF it_viewname IS NOT INITIAL.

                LOOP AT it_viewname.

                  it_viewname-tabname1 = tabname1.
                  it_viewname-tabname2 = tabname2.
                  it_viewname-tabname3 = tabname3.
                  it_viewname-count = 1.

                  MODIFY it_viewname TRANSPORTING tabname1 tabname2
                  tabname3 count.

                ENDLOOP.

              ENDIF.
            ENDIF.

            IF tabname1 IS NOT INITIAL AND tabname2 IS NOT INITIAL AND
            tabname3 IS NOT INITIAL.

              SELECT dd26s~viewname dd26s~tabname dd02l~tabname
              dd02l~viewclass dd02t~ddtext
              INTO TABLE it_viewname FROM dd02l INNER JOIN
              dd26s ON dd02l~tabname = dd26s~viewname
             INNER JOIN dd02t ON dd02l~tabname = dd02t~tabname
      WHERE dd26s~tabname = tabname1 OR dd26s~tabname = tabname2 OR
      dd26s~tabname = tabname3 AND
      dd02l~viewclass = 'D' AND dd02t~ddlanguage = 'EN'.

              IF it_viewname IS NOT INITIAL.

                LOOP AT it_viewname.

                  it_viewname-tabname1 = tabname1.
                  it_viewname-tabname2 = tabname2.
                  it_viewname-tabname3 = tabname3.
                  it_viewname-count = 1.

                  MODIFY it_viewname TRANSPORTING tabname1 tabname2
                  tabname3 count.

                ENDLOOP.

              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.

      ENDLOOP.

      t_mess-program = program.
      t_mess-lineno2 = it_mess-lineno2.
      t_mess-item_no = '34'.

      FORMAT COLOR COL_GROUP INTENSIFIED OFF.
      WRITE: /,/ 'PROGRAM:   ', t_mess-program,
             40 'LINE:', 50 t_mess-lineno2,
             254 space.
      HIDE: t_mess-program,
            t_mess-lineno2.
      FORMAT COLOR COL_NORMAL INTENSIFIED OFF.
      WRITE:/ 'Click here to Go to the Program',
            254 space.

      HIDE: t_mess-program,
            t_mess-lineno2.

      IF sy-subrc <> 0.
        MESSAGE s000(zga) WITH 'Please select a valid line'.
        CLEAR:
            t_mess-program,
            t_mess-lineno2.
      ENDIF.

      IF it_viewname[] IS INITIAL.

        SKIP 2.

        FORMAT COLOR COL_GROUP INTENSIFIED OFF.
        WRITE:/ 'NO Views Available for the Joined Tables',
        it_viewname-tabname1(10), it_viewname-tabname2(10) ,
        it_viewname-tabname3(10).

        CLEAR:
            it_mess-program,
            it_mess-lineno2,
            it_mess-item_no.

      ELSE.

        ULINE.
        CLEAR count.

        WRITE:/.

        FORMAT COLOR COL_GROUP INTENSIFIED OFF.
        WRITE:/ 'Available Views for the Joined Tables',
        it_viewname-tabname1(10), it_viewname-tabname2(10) ,
        it_viewname-tabname3(10).

        FORMAT COLOR COL_NORMAL INTENSIFIED OFF.
        WRITE:/25 'View Short Text' , 62 'Viewname'.

        SORT it_viewname BY viewname ftabname.
        DELETE ADJACENT DUPLICATES FROM it_viewname COMPARING viewname
        ftabname.

        LOOP AT it_viewname.

          AT NEW viewname.

            CLEAR count.

          ENDAT.

          IF it_viewname-tabname3 IS INITIAL.

            IF count = 1.

              WRITE:/5 it_viewname-ddtext, 60 it_viewname-viewname.
              CLEAR count.
            ENDIF.

          ENDIF.

          IF count = 2.

            WRITE:/5 it_viewname-ddtext, 60 it_viewname-viewname.
            CLEAR count.
          ENDIF.

          count = count + 1.

        ENDLOOP.
        CLEAR:
            it_mess-program,
            it_mess-lineno2,
            it_mess-item_no.

      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    " VIEW_DISPLAY
*&---------------------------------------------------------------------*
*&      Form  CONST_NAME_CHECK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM const_name_check .

  DATA: nextidx  LIKE sy-tabix , " start of read table block
        nextread LIKE sy-tabix . " end of read table block

  DATA:
    l_tabix LIKE sy-tabix,
    flg_s,
    count TYPE i,
        row(4),
   l_conslen TYPE i,
   l_strlen  TYPE i.

  DATA: t_tokens LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA: t_statements LIKE sstmnt OCCURS 100 WITH HEADER LINE.
  DATA: BEGIN OF t_keywords OCCURS 1,
               line(20),
        END OF t_keywords.

  t_keywords ='CONSTANTS'.             APPEND t_keywords.

  SCAN ABAP-SOURCE source STATEMENTS INTO t_statements
                           TOKENS INTO t_tokens
                          KEYWORDS   FROM t_keywords .

  l_conslen = STRLEN( p_const ).

  LOOP AT t_tokens .

    IF t_tokens-str = 'CONSTANTS'.
      l_tabix = sy-tabix + 1.
      READ TABLE t_tokens INDEX l_tabix.
      IF sy-subrc = 0.
        IF t_tokens-str = 'BEGIN'.
          flg_s = 'B'.
          l_tabix = sy-tabix + 2.

          READ TABLE t_tokens INDEX l_tabix.

          IF t_tokens-str(l_conslen) NE p_const.

            row1 = t_tokens-row.
            CONCATENATE 'Error: CONSTANT name is not matching '
                         t_tokens-str
                         INTO t_mess-message
                         SEPARATED BY space.
            READ TABLE source_main INDEX t_tokens-row.
            t_mess-lineno2 = source_main-lineno.
            t_mess-program = source_main-program.
            t_mess-item_no = '1'.
            READ TABLE t_mess WITH KEY item_no = '1'
                                         lineno2 = t_mess-lineno2.
            IF sy-subrc <> 0.
              w_var_ctr = w_var_ctr + 1.
              APPEND t_mess.
            ENDIF.
          ENDIF.

        ELSEIF t_tokens-str = 'END'.
          CLEAR flg_s.
        ELSE.
          IF flg_s = 'B'.

          ELSEIF flg_s IS INITIAL.
            IF t_tokens-str(l_conslen) NE p_const.

              row1 = t_tokens-row.
              CONCATENATE 'Error: CONSTANT name is not matching '
                           t_tokens-str
                           INTO t_mess-message
                           SEPARATED BY space.
              READ TABLE source_main INDEX t_tokens-row.
              t_mess-lineno2 = source_main-lineno.
              t_mess-program = source_main-program.
              t_mess-item_no = '1'.
              READ TABLE t_mess WITH KEY item_no = '1'
                                           lineno2 = t_mess-lineno2.
              IF sy-subrc <> 0.
                w_var_ctr = w_var_ctr + 1.
                APPEND t_mess.
              ENDIF.
            ENDIF.

          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " CONST_NAME_CHECK
*&---------------------------------------------------------------------*
*&      Form  check_select_endselect
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM check_select_endselect .

  DATA t_tokens_temp LIKE stoken OCCURS 0 WITH HEADER LINE.
  DATA l_loop_ctr TYPE i.
  DATA: l_sel_ctr TYPE i.

  DATA: nextidx  LIKE sy-tabix , " start of read table block
          nextread LIKE sy-tabix . " end of read table block

  DATA: found . " for determining that it is a binary search
  DATA: tabnam(10). " name for internal table.
  DATA: lno TYPE i .
  DATA:
    wa_tokens LIKE t_tokens_sub,
    l_key_index LIKE sy-tabix,
    l_new_tabix LIKE sy-tabix,
    l_stmt_index LIKE sy-tabix,
    l_from LIKE sstmnt-from,
    l_to LIKE sstmnt-to,
    l_syrow LIKE sy-tabix,
    flag_s,
    row(4).

  t_tokens_temp[] = t_tokens_sub[].
****Changes 04-11-2009
  DELETE t_tokens_temp WHERE str NE 'SELECT'
                       AND   str NE 'ENDSELECT'.

  LOOP AT t_tokens_sub WHERE str = 'SELECT'
                            OR str = 'ENDSELECT' .
    IF t_tokens_sub-str = 'SELECT' .
      CLEAR l_sel_ctr.
      l_loop_ctr = l_loop_ctr + 1.
      l_sel_ctr = t_tokens_sub-row.

*      CLEAR l_new_tabix.
*
*      l_new_tabix = sy-tabix.
*      lno = t_tokens_temp-row.
*      CLEAR flag_s.
*      nextidx = sy-tabix + 1 .

      CLEAR:
        l_from,
        l_to.

      READ TABLE t_statements_sub WITH KEY FROM = sy-tabix.
      IF sy-subrc = 0.
        l_from = t_statements_sub-from.
        l_to = t_statements_sub-to.

        LOOP AT t_tokens_sub FROM l_from TO l_to.

          IF t_tokens_sub-str = 'UP'.

            CLEAR: l_sel_ctr .
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.


    IF t_tokens_sub-str = 'ENDSELECT' .
      l_loop_ctr = l_loop_ctr - 1.
*    ENDIF.
*    IF t_tokens_temp-str = 'SELECT'.
      IF NOT l_sel_ctr IS INITIAL .
        t_mess-message = 'SELECT statement need to be optimized'.
        READ TABLE source_main INDEX l_sel_ctr.
        t_mess-lineno2 =  source_main-lineno.
        t_mess-program = source_main-program.
        t_mess-item_no = '15'.
        APPEND t_mess.
        w_star_ctr = w_star_ctr + 1.

      ENDIF.
    ENDIF.
  ENDLOOP.


ENDFORM.                    " check_select_endselect

*Text symbol text
*001:Data  Declaration Check
*002:Program Standards Check
*003:SY-SUBRC Check After SELECT
*004:SY-SUBRC Check After READ
*005:Sort before Binary Search
*006:Binary Search In READ
*007:Hard coding in WHERE / IF clause
*008:Half Line Comment Check
*009:No Data Type Specified
*010:No Length Specified
*011:SELECT inside a LOOP
*012:Data element is not specified
*013:Sort before delete adjacent
*014:Check SELECT *
*015:Check MOVE-CORRESPONDING
*016:INTO CORRESPONDING in select
*017:Check for Valid Transaction Code
*018:Select from Cluster Tables
*019:Hard Break Points in Code
*020:User Name Check in the Code
*021:Available Views for Joined Tables
*022:Sort / Delete inside the loop
*023:Direct Table Entries Update / Insert / Deletion
*024:Negative SQLstatements in Where Condition
*025:Usage of ON CHANGE OF Statement
*026:DB Table Hit Count
*027:Warning to Check the Size Limit of Ranges
*028:Check for initial before for all entries
*029:Check for One Statement per Line

*030:Check For Sort on the Hashed Internal Table
*Selection text
*G_PNAME:        Program Name
*HALF_COM:        Half Line Comment Check
*HARD_WRE:        Hard coding in WHERE clause
*HTML_DWN:        Download to HTML
*NO_DELM:        Data element is not specified
*NO_LEN:        No Length Specified
*NO_TYPE:        No Data Type Specified
*P_CHKB:        Checkbox Starts With
*P_CONST:        Constant Name Starts With
*P_GLOB:        Global Variable Starts With
*P_LOC:        Local Variable Starts With
*P_LSTR:        Local Structure Starts With
*P_LTAB:        Local Internal Tab Starts With
*P_LWA:        Local Work Area Starts With
*P_OPT:        Select-Option Starts With
*P_PARA:        Parameter Starts With
*P_RADB:        Radiobutton Starts With
*P_RANGE:        Range table Starts With
*P_STATUS:        Active Version
*P_STRUC:        Structure Name Starts With
*P_TABL:        Internal Table Name Start With
*P_TYPE:        TYPE Starts with
*P_WA:        Work Area Starts with
*READ_BNY:        Binary Search In READ
*SEL_LOOP:        SELECT inside a LOOP
*SORT_BNY:        Sort before Binary Search
*SY_READ:        SY-SUBRC Check After READ
*SY_SEL:        SY-SUBRC Check After SELECT
