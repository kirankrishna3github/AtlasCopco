*&---------------------------------------------------------------------*
*&  Include           YSE_F124_MERGE
*&---------------------------------------------------------------------*

*----------------------------------------------------------------------
*---------- F¨¹llen der internen Tabelle IF123 --------------------------
*---------- mit den Werten der Regeltabelle ZTF123 ----------------------
*---------- und den Tabellennamen, die zu den Regeln geh#ren -----------
*-----------------------------------------------------------------------
form fill_xf123_if123.
  select * from ztf123 into table zxf123. "#EC CI_NOWHERE
  LOOP AT zxf123.
    IF zxf123-bukrs <> p_bukrs.
      delete zxf123.
    ENDIF.
  ENDLOOP.
  perform fill_if123.
  perform itext_ergaenzen.
  sort itext by kritx.
endform.                    "fill_xf123_if123
*-----------------------------------------------------------------------
form fill_if123.
  loop at zxf123.
    move-corresponding zxf123 to if123.
    if if123-kont2 eq space.
      if123-kont2 = if123-kont1.
    endif.
    perform fill_tablx
            using zxf123-koart.
*----- W#hrungsfelder aus ZTF123 merken ---------------------------------
    perform fill_dfiestab.
    append if123.
  endloop.
endform.                                                    "FILL_IF123
*-----------------------------------------------------------------------
*           FORM FILL_TABLX
*-----------------------------------------------------------------------
*---------- F¨¹llen der Felder IF123-TABLx (x=1-4); ---------------------
*---------- falls Konto in Index-Tabelle und Felder aus Index-Tabelle --
*---------- werden die Felder mit TABELLE gef¨¹llt, ---------------------
*---------- sonst werden die entsprechenden Tabellen -------------------
*---------- (BKPF, BSEG ...) gesucht. ----------------------------------
*-----------------------------------------------------------------------
form fill_tablx
     using koart like bseg-koart.
  data: bedng like tf123-bedg1,
        table like if123-tabl1.
  do 5 times varying bedng from zxf123-bedg1 next zxf123-bedg2
             varying table from if123-tabl1 next if123-tabl2.
    table = space.
    check not bedng is initial.
    perform find_tabl
            using    koart bedng
            changing table.
  enddo.
endform.                               "FILL_TABLX
*---------------------------------------------------------------------*
*       FORM FIND_TABL                                                *
*---------------------------------------------------------------------*
*       Die Bedinung BEDGX wird in den Tabellen der Feldleiste        *
*       TABL (BKPF, BSEG ...) gesucht und der Tabellenname nach TABLX *
*       geschrieben. Wird keine Tabelle gefunden ist TABLX initial    *
*---------------------------------------------------------------------*
*  -->  KOART         Kontoart                                        *
*  -->  BEDGX         Bedingung    x (x=1-4)                          *
*  -->  TABLX         Tabellenname x (x=1-4)                          *
*  -->  INDEX         Nummer der Bedingung                            *
*---------------------------------------------------------------------*
form find_tabl using    i_koart like bseg-koart
                        i_bedgx like if123-bedg1
               changing e_tablx like if123-tabl1.
  data: text(15) type c,
        table    like if123-tabl1,
        rc       like sy-subrc.
*
  case i_koart.
    when char_d.
      tabl-tab1 = 'BSID'.
    when char_k.
      tabl-tab1 = 'BSIK'.
    when char_s.
      tabl-tab1 = 'BSIS'.
  endcase.
*
  do tabl-ntabl times varying table from tabl-tab1 next tabl-tab2.
    select * from dd03l
             where tabname   = table
             and   fieldname = i_bedgx
             and   as4local  = char_a.
      exit.
    endselect.
    if sy-subrc eq 0.
      e_tablx = table.
      exit.
    endif.
  enddo.
*
*----- Texte f¨¹r #berschriften sammeln ---------------------------------
*
  perform schluesselwort_lesen2(sapfs003)
          using e_tablx i_bedgx text rc.
  check rc is initial.
  itext-kritx+00(10) = e_tablx.
  itext-kritx+10(01) = '-'.
  itext-kritx+11(09) = i_bedgx.
  condense itext-kritx no-gaps.
  itext-textx        = text.
  collect itext.
endform.                               "FIND_TABL
*&---------------------------------------------------------------------*
*&      Form  FILL_DFIESTAB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form fill_dfiestab.
  if if123-tabl1 = 'BSID'
  or if123-tabl1 = 'BSIK'
  or if123-tabl1 = 'BSIS'.
    perform ddif_fieldinfo_get using if123-tabl1 if123-bedg1.
  endif.

  if if123-tabl2 = 'BSID'
  or if123-tabl2 = 'BSIK'
  or if123-tabl2 = 'BSIS'.
    perform ddif_fieldinfo_get using if123-tabl2 if123-bedg2.
  endif.

  if if123-tabl3 = 'BSID'
  or if123-tabl3 = 'BSIK'
  or if123-tabl3 = 'BSIS'.
    perform ddif_fieldinfo_get using if123-tabl3 if123-bedg3.
  endif.

  if if123-tabl4 = 'BSID'
  or if123-tabl4 = 'BSIK'
  or if123-tabl4 = 'BSIS'.
    perform ddif_fieldinfo_get using if123-tabl4 if123-bedg4.
  endif.

  if if123-tabl5 = 'BSID'
  or if123-tabl5 = 'BSIK'
  or if123-tabl5 = 'BSIS'.
    perform ddif_fieldinfo_get using if123-tabl5 if123-bedg5.
  endif.

endform.                               " FILL_DFIESTAB
*&---------------------------------------------------------------------*
*&      Form  DDIF_FIELDINFO_GET
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form ddif_fieldinfo_get using p_tabname p_fieldname.
  data: tabname  like dfiestab-tabname,
        fieldname like dfiestab-fieldname.

  clear dfiestab.
  refresh dfiestab.
  tabname = p_tabname.
  fieldname = p_fieldname.
  call function 'DDIF_FIELDINFO_GET'
       exporting
            tabname        = tabname
            fieldname      = fieldname
            Langu          = sy-langu                            "878408
       tables
            dfies_tab      =  dfiestab
       exceptions
            not_found      = 1
            internal_error = 2
            others         = 3.
  if sy-subrc = 0.
    if dfiestab-datatype = 'DATS'.                          "418389
      Read table Dfiestab index 1 into Tdfies.                   "878408
      append tdfies.                                        "418389
    elseif dfiestab-datatype = 'CURR'                       "418389
    and ( dfiestab-reftable = 'BSIS' or dfiestab-reftable = 'BSIK'
    or    dfiestab-reftable = 'BSID' or dfiestab-reftable = 'T001' ).
      Read table Dfiestab index 1 into Tdfies.                   "878408
      append tdfies.
      case zxf123-koart.
        when 'D'.
          betraeged = 'X'.
        when 'K'.
          betraegek = 'X'.
        when 'S'.
          betraeges = 'X'.
      endcase.
    endif.
  endif.
endform.                               " DDIF_FIELDINFO_GET
*&---------------------------------------------------------------------*
*&      Form  ITEXT_ERGAENZEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form itext_ergaenzen.
  data: text(15) type c,
        table    like if123-tabl1,
        rc       like sy-subrc,
        bedng like tf123-bedg1.
  perform itexterg_fuellen.
  loop at itexterg.
    read table itext with key kritx = itexterg-kritx.
    if sy-subrc ne 0.
      perform schluesselwort_lesen2(sapfs003)
              using itexterg-table itexterg-bedng text rc.
      check rc is initial.
      perform itext_fuellen using itexterg-table itexterg-bedng text.
    endif.
  endloop.
endform.                               " ITEXT_ERGAENZEN
*&---------------------------------------------------------------------*
*&      Form  ITEXTERG_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form itexterg_fuellen.
  itexterg-table = 'BSID'.
  itexterg-bedng = 'XREF3'.
  itexterg-kritx = 'BSID-XREF3'.
  append itexterg.
  itexterg-table = 'BSIS'.
  itexterg-bedng = 'XREF3'.
  itexterg-kritx = 'BSIS-XREF3'.
  append itexterg.
  itexterg-table = 'BSEG'.
  itexterg-bedng = 'EBELN'.
  itexterg-kritx = 'BSEG-EBELN'.
  append itexterg.
  itexterg-table = 'BSEG'.
  itexterg-bedng = 'EBELP'.
  itexterg-kritx = 'BSEG-EBELP'.
  append itexterg.
  itexterg-table = 'BSIS'.
  itexterg-bedng = 'GSBER'.
  itexterg-kritx = 'BSIS-GSBER'.
  append itexterg.
*  ITEXTERG-TABLE = 'BKPF'.
*  ITEXTERG-BEDNG = 'XBLNR'.
*  ITEXTERG-KRITX = 'BKPF-XBLNR'.
*  APPEND ITEXTERG.
endform.                               " ITEXTERG_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  ITEXT_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_TABLE  text                                                *
*      -->P_BEDNG  text                                                *
*      -->P_TEXT  text                                                 *
*----------------------------------------------------------------------*
form itext_fuellen using    p_table
                            p_bedng
                            p_text.
  itext-kritx+00(10) = p_table.
  itext-kritx+10(01) = '-'.
  itext-kritx+11(09) = p_bedng.
  condense itext-kritx no-gaps.
  itext-textx        = p_text.
  collect itext.

endform.                               " ITEXT_FUELLEN


*---------------------------------------------------------------------*
*       FORM CHECK_XFIELD                                             *
*---------------------------------------------------------------------*
*       Mindestens ein Konto mu# selektiert sein                      *
*---------------------------------------------------------------------*
form check_xfield.
*
  if  x_kunnr eq space
  and x_shbkn eq space
  and x_lifnr eq space
  and x_shblf eq space
  and x_saknr eq space.
* Sie haben keine Konten selektiert
    message e111.
  endif.
  if x_saknr = space and xsobwere = 'X'.
    message e118.
  endif.
  if xtol = 'X' and min_bel ne 0.
    message e099.
  endif.
  If xsobebvk = 'X'.
     If x_saknr = space.
        Message e892.
     Elseif X_kunnr = 'X'
     or     X_shbkn = 'X'
     or     X_lifnr = 'X'
     or     X_shblf = 'X'.
        Message w892.
     Endif.
  endif.
  if xsobebvk = 'X' and zwaers ne space.
    message e890(fg).
  endif.
  if xauslw = 'X' and zwaers ne space.
    message e894(fg).
  endif.
  if xauslw = 'X'
  or xsobebvk = 'X'
  or zwaers <> space.
    xf124e = 'X'.
  else.
    xf124e = space.
  endif.
  if  xaugdt = 'X'
  and xf124e = 'X'.
    message e022.
  endif.
endform.                               "CHECK_XFIELD.
*&---------------------------------------------------------------------*
*&      Form  GJVTAB_INIT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form gjvtab_init.
  clear gjvtab.
  refresh gjvtab.
endform.                               " GJVTAB_INIT
*---------------------------------------------------------------------*
*       FORM CHECK_AUTHORITY                                          *
*---------------------------------------------------------------------*
*       Berechtigungspr¨¹fungen f¨¹r SAPF124                            *
*---------------------------------------------------------------------*
form check_authority.
  check sy-ucomm ne 'SPOS'.                                 "616384
  check sy-ucomm ne 'SAVE'.                                 "725776
  perform check_authority_bukrs.
  perform check_authority_koart.
  call function 'FI_ADD_AUTHORITY_CHECK'                    "516329
  importing e_xblar = gb_xaubl                              "516329
            e_xgsbe = gb_xaugs.                             "516329
  if gb_xaubl ne space.                                     "516329
    perform record_fill using 'AUBLA' space space space space"516329
    space space 'I'.                                        "516329
  endif.                                                    "516329
  if gb_xaugs ne space.                                     "516329
    perform record_fill using 'AUGSB' space space space space"516329
    space space 'I'.                                        "516329
  endif.                                                    "516329
endform.                    "CHECK_AUTHORITY
*---------------------------------------------------------------------*
*       FORM CHECK_AUTHORITY_BUKRS                                    *
*---------------------------------------------------------------------*
*       Pr¨¹fung der Buchungskreisberechtigung                         *
*---------------------------------------------------------------------*
form check_authority_bukrs.
  data: text(20)     type c.
  data: begin of itab occurs 3,
          bukrs like t001-bukrs,
        end of itab.
  clear i001.
  refresh i001.
*----- Kein Check beim Anlegen von Wertemengen -------------------------
  check sy-ucomm ne 'FSET'.
  if x_testl eq space.
    actvt = '02'.                      " Anzeigeberechtigung
  else.
    actvt = '03'.                      " #nderungsberechtigung
  endif.
*
  authorit = '00'.
  select * from t001
           where bukrs IN bukrx.
    i001 = t001.
    append i001.
    gjvtab-periv = t001-periv.
    collect gjvtab.
    authority-check object 'F_BKPF_BUK'
      id 'BUKRS' field t001-bukrs
      id 'ACTVT' field actvt.
    if sy-subrc ne 0.
      authorit = actvt.
      itab-bukrs = t001-bukrs.
      append itab.
    endif.
  endselect.

*----- Text f¨¹r Fehlermeldung aufbauen ---------------------------------
  loop at itab.
    case sy-tabix.
      when 1.
        text+00 = itab-bukrs.
      when 2.
        text+04 = ','.
        text+06 = itab-bukrs.
      when 3.
        text+10 = ','.
        text+12 = itab-bukrs.
      when 4.
        text+17 = '...'.
    endcase.
  endloop.
*
  case authorit.
    when '02'.
      set cursor field 'P_BUKRS'.
*----- Keine Berechtigung zum #ndern von Buchungskreis $ ---------------
      message e112 with text.
    when '03'.
      set cursor field 'P_BUKRS'.
*----- Keine Berechtigung zum Anzeigen von Buchungskreis $ -------------
      message e113 with text.
  endcase.
endform.                               "CHECK_AUTHORITY_BUKRS.
*---------------------------------------------------------------------*
*       FORM CHECK_AUTHORITY_KOART                                    *
*---------------------------------------------------------------------*
*       Pr¨¹fung der Kontoartenberechtigung                            *
*       Der Anwender mu# die Berechtigung zum Anzeigen und #ndern     *
*       einer Kontoart (D,K,S) haben, um den Ausgleich druchzuf¨¹hren. *
* Bei SAPF123W wird wg. Defaults f. Parameter nur f. Sako geprueft
*---------------------------------------------------------------------*
form check_authority_koart.
  data: text(21)      type c,
        text0(200)    type c,
        text1(80)     type c,
        text2(20)     type c.
  data: begin of itab occurs 3,
          text(20) type c,
        end of itab.
*
* Initialisieren der Berechtigung (00 hei#t berechtigt zum Ausgleich)
*
  authorit = '00'.
  if x_testl eq space.
    actvt = '02'.                      "#nderungsberechtigung
    text1 = text-004.                  "Keine #nderungsberechtigung f¨¹r
  else.
    actvt = '03'.                      "Anzeigeberechtigung
    text1 = text-005.                  "Keine Anzeigeberechtigung f¨¹r
  endif.
*
  do 3 times.
    case sy-index.
      when 1.
        check not x_kunnr is initial   "G.V.24.04.96
           or not x_shbkn is initial.
        koart = char_d.
        text2 = 'Debitoren'(001).
      when 2.
        check not x_lifnr is initial   "G.V.24.04.96
           or not x_shblf is initial.
        koart = char_k.
        text2 = 'Kreditoren'(002).
      when 3.
        check not x_saknr is initial.  "G.V.24.04.96
        koart = char_s.
        text2 = 'Sachkonten'(003).
    endcase.
*   Check nur falls Kontoart bei Aufruf selektiert wurde
    authority-check object 'F_BKPF_KOA'
      id 'KOART' field koart
      id 'ACTVT' field actvt.
    if sy-subrc ne 0.
      authorit = actvt.                "Merken, dass Auth. fehlt
      itab-text = text2.
      append itab.
    endif.
  enddo.
*
  if  authorit ne '00'.
*
* Text f¨¹r Fehlermeldung aufbauen
*
    loop at itab.
      case sy-tabix.
        when 1.
          text+00(20) = itab-text.
          text0+00    = text.
        when 2.
          text+20(1)  = ','.
          condense text no-gaps.
          text0+00    = text.
          text+00(20) = itab-text.
          text0+20    = text.
        when 3.
          text+20(1)  = ','.
          condense text no-gaps.
          text0+20  = text.
          text0+40  = itab-text.
      endcase.
    endloop.
    condense text0.
*
    message e114 with text1 text0.
  endif.
endform.                               "CHECK_AUTHORITY_KOART.
*&---------------------------------------------------------------------*
*&      Form  CHECK_AUGDT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form check_augdt.
  if ( not augdt is initial and xaugdt = 'X' )
  or ( augdt is initial and xaugdt is initial ).
    message e018.
  endif.
  if augdt is initial and not bmonat is initial.
    message e021.
  endif.
  Save_augdt = Augdt.                                            "985181
endform.                               " CHECK_AUGDT
*&---------------------------------------------------------------------*
*&      Form  GJVTAB_CHECK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form gjvtab_check.
*----- Periodenangabe nur erlaubt, wenn nicht mehrere GJ-Varianten -----
*----- im Spiel sind ---------------------------------------------------
  if not bmonat is initial.
    describe table gjvtab lines sy-tfill.
    if sy-tfill > 1.
      message e020.
    endif.
  endif.
endform.                               " GJVTAB_CHECK
*&---------------------------------------------------------------------*
*&      Form  PERIODE_ERMITTELN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_AUGDAT  text                                               *
*----------------------------------------------------------------------*
form periode_ermitteln using i_bukrs like t001-bukrs
                             i_augdt like bkpf-budat
                             e_gjahr like bseg-gjahr
                             e_monat.
  data: rcperiod like sy-subrc.

  check augdttab-xnok is initial.

  call function 'FI_PERIOD_DETERMINE'
    EXPORTING
      i_bukrs        = i_bukrs
      i_budat        = i_augdt
      i_monat        = e_monat
      i_gjahr        = e_gjahr
    IMPORTING
      e_gjahr        = e_gjahr
      e_monat        = e_monat
    EXCEPTIONS
      fiscal_year    = 1
      period         = 2
      period_version = 3
      posting_period = 4
      special_period = 5
      version        = 6
      posting_date   = 7
      others         = 8.
  rcperiod = sy-subrc.
  If Rcperiod ne 0.                                              "985181
     If Augdt ne Save_augdt.                                     "985181
    if flg_liste = char_3.
*----- Ausgabe: Kein Ausgleich -----------------------------------------
      perform record_clearing_info using 'NOCLEAR' ' ' 'X' koart.
    endif.
*----- Fehlerprotokoll f¨¹llen ------------------------------------------
    perform fehler_merken.
    perform augdttab_fuellen using i_bukrs i_augdt 'X'.
     Else.                                                       "985181
    message id sy-msgid type sy-msgty number sy-msgno
          with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  endif.
  Else.                                                          "985181
    perform augdttab_fuellen using i_bukrs i_augdt ' '.
  endif.
endform.                               " PERIODE_ERMITTELN
*&---------------------------------------------------------------------*
*&      Form  AUGDTTAB_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form augdttab_fuellen using p_bukrs like t001-bukrs
                            p_augdt like bseg-augdt
                            p_xnok  like augdttab-xnok.
  augdttab-bukrs = p_bukrs.
  augdttab-augdt = p_augdt.
  augdttab-xnok =  p_xnok.
endform.                               " AUGDTTAB_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  PERIODE_PRUEFEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form periode_pruefen using i_bukrs like t001-bukrs
                           i_augdt like bkpf-budat
                           i_gjahr like bseg-gjahr
                           i_monat
                           i_mess.                              "1112148
  perform periode_ermitteln using i_bukrs i_augdt i_gjahr i_monat.
  PERFORM period_check
  USING i_bukrs '+' '+' i_gjahr i_monat i_mess.                 "1112148
endform.                               " PERIODE_PRUEFEN
*&---------------------------------------------------------------------*
*&      Form  PERIOD_CHECK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form period_check using i_bukrs like t001-bukrs
                        i_koart like bseg-koart
                        i_konto
                        i_gjahr like bseg-gjahr
                        i_monat
                        i_mess.                                 "1112148
  data: konto    like t001b-vkont,
        monat    like t001b-frpe1,
        rccheck like sy-subrc.

  check augdttab-xnok is initial.
*Typenkonflikte vermeiden

  konto = i_konto.
  monat = i_monat.

  call function 'FI_PERIOD_CHECK'
    EXPORTING
      i_bukrs          = i_bukrs
      i_gjahr          = i_gjahr
      i_koart          = i_koart
      i_konto          = konto
      i_monat          = monat
    EXCEPTIONS
      error_period     = 1
      error_period_acc = 2
      others           = 3.
  rccheck = sy-subrc.
  if rccheck ne 0.
    if x_testl ='X'.
      IF i_mess = space.                                        "1112148
        if flg_liste = char_3.
*----- Ausgabe: Kein Ausgleich -----------------------------------------
          perform record_clearing_info using 'NOCLEAR' ' ' 'X' i_koart.
        endif.
*----- Fehlerprotokoll f¨¹llen ------------------------------------------
        perform fehler_merken.
        perform augdttab_fuellen using i_bukrs augdt 'X'.
      else.
        message id sy-msgid type 'W' number sy-msgno
           with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      endif.
    else.
      IF i_mess = space.                                        "1112148
        if flg_liste = char_3.
*----- Ausgabe: Kein Ausgleich -----------------------------------------
          perform record_clearing_info using 'NOCLEAR' ' ' 'X' i_koart.
        endif.
*----- Fehlerprotokoll f¨¹llen ------------------------------------------
        perform fehler_merken.
        perform augdttab_fuellen using i_bukrs augdt 'X'.
      else.
        message id sy-msgid type 'E' number sy-msgno
           with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      endif.
    endif.
  else.
    Perform Augdttab_fuellen using I_bukrs Augdt ' '.            "985181
  endif.


endform.                               " PERIOD_CHECK
*---------------------------------------------------------------------*
*       FORM SELECT_T030                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
form select_t030.

* SKV-Konten in allen BUKen aufsammeln, f. Check in read_bsis
  refresh i030_skv.
  clear i030_skv.
  loop at i001.
    select * from  t030
             where ktopl =  i001-ktopl
               and ktosl =  'SKV'.     " Skontoverrechnung
      i030_skv-bukrs = i001-bukrs.
      i030_skv-konts = t030-konts.
      collect i030_skv.
    endselect.
* WE/RE-Konten bestimmen, falls bessere Zuordnung erforderlich, z.B. bei
* Lieferpl#nen
    if i001-ktopl ne i030_were-ktopl.
      clear i030_were.
      select * from  t030 into table i030_were
               where ktopl =  i001-ktopl
                 and ktosl =  'WRX'.   " WE/RE-Konto
    endif.
    loop at i030_were.
*       LOOP AT I001 WHERE KTOPL EQ I030_WERE-KTOPL.
*         MOVE-CORRESPONDING I001 TO IWERE.
*         EXIT.
*       ENDLOOP.
*       CHECK SY-SUBRC IS INITIAL.
      iwere-bukrs = i001-bukrs.
      iwere-hkont = i030_were-konts.
      if not iwere-hkont is initial.
        collect iwere.
      endif.
      iwere-hkont = i030_were-konth.
      if not iwere-hkont is initial.
        collect iwere.
      endif.
    endloop.
  endloop.
endform.                    "SELECT_T030
*-----------------------------------------------------------------------
*       FORM CHECK_RULES                                               *
*-----------------------------------------------------------------------
*       Sind Anwenderkriterien in der Tabelle TF123 gepflegt           *
*-----------------------------------------------------------------------
form check_rules.
  describe table zxf123 lines sy-tfill. "Gefuellt in INITILIZATION
  if sy-tfill = 0.
* Anwenderkriterien f¨¹r maschinelles Ausgleichen sind nicht gepflegt
    message w100.
  endif.
endform.                               "CHECK_RULES.
*---------------------------------------------------------------------*
*       FORM CHECK_ECHTL                                              *
*---------------------------------------------------------------------*
form check_echtl.
  if x_testl = space.
    x_echtl = char_x.
*   Dieser Programmlauf ist ein Echtlauf!
    message w013.
  else.
    x_echtl = space.
  endif.
endform.                    "CHECK_ECHTL
*---------------------------------------------------------------------*
*       FORM INIT_LIST                                                *
*---------------------------------------------------------------------*
*       Initialisieren der Ausgabeliste abh#ngig von der Eingabe      *
*---------------------------------------------------------------------*
form init_list.
  if xausbel = 'X'
  or xnausbel = 'X'.
    flg_liste = char_3.
  else.
    flg_liste = char_2.
  endif.
endform.                               "INIT_LIST


*&---------------------------------------------------------------------*
*&      Form  CHECK_WAEHRUNG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form check_waehrung.
  if not zwaers is initial.
    select single * from tcurc where waers = zwaers.
    if sy-subrc = 0.
      bsis-waers = zwaers.
    else.
      message e107(sg) with zwaers.
    endif.
  endif.

endform.                               " CHECK_WAEHRUNG
*&---------------------------------------------------------------------*
*-----------------------------------------Form Regus_pruefen-----"681786
form regus_pruefen.                                         "681786
  data: begin of xregus occurs 51,                          "681786
           koart like regus-koart,                          "681786
           bukrs like regus-bukrs,                          "681786
           konko like regus-konko,                          "681786
           laufd like regus-laufd,                          "681786
           laufi like regus-laufi,                          "681786
        end of xregus.                                      "681786
  data: rc like sy-subrc.                                   "681786
                                                            "681786
  if x_echtl ='X'                                           "681786
  and ( x_kunnr = 'X' or x_lifnr = 'X' ).                   "681786
    loop at i001.                                           "681786
      select * from regus                                   "681786
      where bukrs = i001-bukrs                              "681786
      and   koart = 'D'                                     "681786
      and   laufi <> '$F124$'.                              "965141
        xregus-laufd = regus-laufd.                         "681786
        xregus-laufi = regus-laufi.                         "681786
        collect xregus.                                     "681786
      endselect.                                            "681786
      select * from regus                                   "681786
      where bukrs = i001-bukrs                              "681786
      and   koart = 'K'                                     "681786
      and   laufi <> '$F124$'.                              "965141
        xregus-laufd = regus-laufd.                         "681786
        xregus-laufi = regus-laufi.                         "681786
        collect xregus.                                     "681786
      endselect.                                            "681786
    endloop.                                                "681786
    loop at xregus.                                         "681786
      regus-laufd = xregus-laufd.                           "681786
      regus-laufi = xregus-laufi.                           "681786
      perform regus_pruefen_fehler(sapf110e) using rc.      "681786
    endloop.                                                "681786
    clear regus.                                            "681786
  endif.                                                    "681786
endform.                                                    "681786
*&---------------------------------------------------------------------*


*&---------------------------------------------------------------------*
*&      Form  KONTOTABELLEN_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form kontotabellen_fuellen.
  perform tdebi_fuellen.
  perform tkredi_fuellen.
  perform tsako_fuellen.
*----- Nur Konten mit Soll u. Habenbuchungen (bei Debi/Kredi) ----------
  if x_saknr = space.
    perform record_fill
           using 'SOHA ' space space space space space space char_i.
  endif.
endform.                               " KONTOTABELLEN_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  TDEBI_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form tdebi_fuellen.
  data: begin of lt_knbw occurs 1.                          "500429
          include structure knbw.                           "500429
  data: end of lt_knbw.                                     "500429

  if  x_kunnr eq space
  and x_shbkn eq space.
*----- Keine Debitorenbelege selektiert --------------------------------
    perform record_fill
            using 'BSID ' space space space space space space char_s.
    exit.
  endif.
*----- Normale OP's ----------------------------------------------------
  if x_shbkn eq space and x_kunnr ne space.
    select distinct bukrs kunnr shkzg from bsid into tdebi
                            where bukrs in bukrx
                              and kunnr in kontd
                              and umsks eq space
                              and gjahr in gjahx.
      call function 'FI_WT_READ_KNBW'                       "500429
      exporting i_kunnr = tdebi-kunnr                       "500429
                i_bukrs = tdebi-bukrs                       "500429
      tables t_knbw     = lt_knbw                           "500429
      exceptions not_found = 1.                             "500429
      if sy-subrc = 0.                                      "500429
        tdebi-wt_newwt = 'X'.                               "500429
      else.                                                 "538265
        clear tdebi-wt_newwt.                               "538265
      endif.                                                "500429
      append tdebi.
    endselect.
    if sy-subrc ne 0.
*----- Keine Debitorenbelege selektiert --------------------------------
      perform record_fill
              using 'BSID ' space space space space space space char_s.
    endif.
  endif.
*----- Sonderhauptbuchvorg#nge (au#er 'A' und 'W') ---------------------
  if x_shbkn ne space and x_kunnr eq space.
    select distinct bukrs kunnr shkzg from bsid into tdebi
                            where bukrs in bukrx
                              and kunnr in kontd
                              and umsks ne char_w           "401470
                              and umskz ne space
                              and gjahr in gjahx.
      call function 'FI_WT_READ_KNBW'                       "500429
      exporting i_kunnr = tdebi-kunnr                       "500429
                i_bukrs = tdebi-bukrs                       "500429
      tables t_knbw     = lt_knbw                           "500429
      exceptions not_found = 1.                             "500429
      if sy-subrc = 0.                                      "500429
        tdebi-wt_newwt = 'X'.                               "500429
      else.                                                 "538265
        clear tdebi-wt_newwt.                               "538265
      endif.                                                "500429
      append tdebi.
    endselect.
    if sy-subrc ne 0.
*----- Keine SHB-Vorg#nge der Klasse 'A' und 'W' -----------------------
      perform record_fill
              using '    ' space space space space space space char_i.
*----- Keine Debitorenbelege selektiert --------------------------------
      perform record_fill
              using 'BSID ' space space space space space space char_s.
    else.
*----- Keine SHB-Vorg#nge der Klasse 'A' und 'W' -----------------------
      perform record_fill
              using '    ' space space space space space space char_i.
    endif.
  endif.
*----- Normale OP's und Sonderhauptbuchvorg#nge (au#er 'A' und 'W')-----
  if x_shbkn ne space and x_kunnr ne space.
    select distinct bukrs kunnr shkzg from bsid into tdebi
                            where bukrs in bukrx
                              and kunnr in kontd
                              and umsks ne char_w           "401470
                              and gjahr in gjahx.
      call function 'FI_WT_READ_KNBW'                       "500429
      exporting i_kunnr = tdebi-kunnr                       "500429
                i_bukrs = tdebi-bukrs                       "500429
      tables t_knbw     = lt_knbw                           "500429
      exceptions not_found = 1.                             "500429
      if sy-subrc = 0.                                      "500429
        tdebi-wt_newwt = 'X'.                               "500429
      else.                                                 "538265
        clear tdebi-wt_newwt.                               "538265
      endif.                                                "500429
      append tdebi.
    endselect.
    if sy-subrc ne 0.
*----- Keine SHB-Vorg#nge der Klasse 'A' und 'W' -----------------------
      perform record_fill
              using '    ' space space space space space space char_i.
*----- Keine Debitorenbelege selektiert --------------------------------
      perform record_fill
          using 'BSID ' space space space space space space char_s.
    else.
*----- Keine SHB-Vorg#nge der Klasse 'A' und 'W' -----------------------
      perform record_fill
              using '    ' space space space space space space char_i.
    endif.
  endif.
  sort tdebi by bukrs kunnr.
endform.                               " TDEBI_FUELLEN

*&---------------------------------------------------------------------*
*&      Form  TKREDI_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form tkredi_fuellen.

  if  x_lifnr eq space
  and x_shblf eq space.
*----- Keine Kreditorenbelege selektiert -------------------------------
    perform record_fill
            using 'BSIK ' space space space space space space char_s.
    exit.
  endif.
*----- Normale OP's ----------------------------------------------------
  if x_shblf eq space and x_lifnr ne space.
    select distinct bukrs lifnr shkzg from bsik into tkredi
                            where bukrs in bukrx
                              and lifnr in kontk
                              and umsks eq space
                              and gjahr in gjahx.
      append tkredi.
    endselect.
    if sy-subrc ne 0.
*----- Keine Kreditorenbelege selektiert -------------------------------
      perform record_fill
              using 'BSIK ' space space space space space space char_s.
    endif.
  endif.
*----- Sonderhauptbuchvorg#nge (au#er 'A' und 'W') ---------------------
  if x_shblf ne space and x_lifnr eq space.
    select distinct bukrs lifnr shkzg from bsik into tkredi
                            where bukrs in bukrx
                              and lifnr in kontk
                              and umsks ne char_w           "401470
                              and umskz ne space
                              and gjahr in gjahx.
      append tkredi.
    endselect.
    if sy-subrc ne 0.
*----- Keine SHB-Vorg#nge der Klasse 'A' und 'W' -----------------------
      perform record_fill
              using '    ' space space space space space space char_i.
*----- Keine Kreditorenbelege selektiert -------------------------------
      perform record_fill
            using 'BSIK ' space space space space space space char_s.
    else.
*----- Keine SHB-Vorg#nge der Klasse 'A' und 'W' -----------------------
      perform record_fill
              using '    ' space space space space space space char_i.
    endif.
  endif.
*----- Normale OP's und Sonderhauptbuchvorg#nge (au#er 'A' und 'W')-----
  if x_shblf ne space and x_lifnr ne space.
    select distinct bukrs lifnr shkzg from bsik into tkredi
                            where bukrs in bukrx
                              and lifnr in kontk
                              and umsks ne char_w           "401470
                              and gjahr in gjahx.
      append tkredi.
    endselect.
    if sy-subrc ne 0.
*----- Keine SHB-Vorg#nge der Klasse 'A' und 'W' -----------------------
      perform record_fill
              using '    ' space space space space space space char_i.
*----- Keine Kreditorenbelege selektiert -------------------------------
      perform record_fill
          using 'BSIK ' space space space space space space char_s.
    else.
*----- Keine SHB-Vorg#nge der Klasse 'A' und 'W' -----------------------
      perform record_fill
              using '    ' space space space space space space char_i.
    endif.
  endif.
  sort tkredi by bukrs lifnr.
endform.                               " TKREDI_FUELLEN

*&---------------------------------------------------------------------*
*&      Form  TSAKO_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form tsako_fuellen.

  data: begin of skb1tab,
          bukrs like skb1-bukrs,
          saknr like skb1-saknr,
        end of skb1tab.

  if x_saknr eq space.
*----- Keine Sachkontenbelege selktiert --------------------------------
    perform record_fill
            using 'BSIS ' space space space space space space char_s.
    exit.
  endif.
  loop at i001.
    select  bukrs saknr from skb1 into skb1tab
                                  where bukrs = i001-bukrs
                                     and saknr in konts
                                     and xopvw = 'X'. "#EC CI_SGLSELECT
      tsako-bukrs = skb1tab-bukrs.
      tsako-hkont = skb1tab-saknr.
      tsako-shkzg = 'H'.
      append tsako.
      tsako-bukrs = skb1tab-bukrs.
      tsako-hkont = skb1tab-saknr.
      tsako-shkzg = 'S'.
      append tsako.
    endselect.
  endloop.
  sort tsako by bukrs hkont.
  describe table tsako lines sy-tfill.
  if sy-tfill eq 0.
*----- Keine Sachkontenbelege selektiert -------------------------------
    perform record_fill
            using 'BSIS ' space space space space space space char_s.
  endif.
endform.                               " TSAKO_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  DEBI_VERARBEITEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form debi_verarbeiten.
  last_kunnr = space.
  last_bukrs = space.
  last_tabix = 0.                 " verwendet in form regeln_vorbereiten
  loop at tdebi.
    at new bukrs.
      new_bukr = 'X'.
      suinf = space.
    endat.
    if tdebi-kunnr = last_kunnr and tdebi-bukrs = last_bukrs.
      refresh xbsid.
      refresh xbsidgr.
      koart = char_d.
*----- Sind f¨¹r das Konto Regeln in TF123 hinterlegt? ------------------
      perform check_table_if123
                           using koart tdebi-bukrs tdebi-kunnr
                           changing flag_if123.
      if flag_if123 eq char_x.
        if x_echtl = 'X' or xtol = 'X' .
          perform echtlauf using koart.
        else.
          perform testlauf using koart.
        endif.
      endif.
    else.
      last_kunnr = tdebi-kunnr.
      last_bukrs = tdebi-bukrs.
    endif.
    at end of bukrs.
      if flg_liste = '2' and suinf = 'X'.
*----- Ausgabe der Summenzeile bei Statistik pro BUkrs -----------------
        bukreis = tdebi-bukrs.
        perform sum_info using bukreis '1' sum1_op sum1_ap sum1_eap.
      endif.
    endat.
  endloop.

endform.                               " DEBI_VERARBEITEN
*
*&---------------------------------------------------------------------*
*&      Form  KREDI_VERARBEITEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form kredi_verarbeiten.
  last_lifnr = space.
  last_bukrs = space.
  last_tabix = 0.
  loop at tkredi.
    at new bukrs.
      new_bukr = 'X'.
      suinf = space.
    endat.
    if tkredi-lifnr = last_lifnr and tkredi-bukrs = last_bukrs.
      refresh xbsik.
      refresh xbsikgr.
      koart = char_k.
*----- Sind f¨¹r das Konto Regeln in TF123 hinterlegt? ------------------
      perform check_table_if123
                           using koart tkredi-bukrs tkredi-lifnr
                           changing flag_if123.
      if flag_if123 eq char_x.
        if x_echtl = 'X' or xtol = 'X' .
          perform echtlauf using koart.
        else.
          perform testlauf using koart.
        endif.
      endif.
    else.
      last_lifnr = tkredi-lifnr.
      last_bukrs = tkredi-bukrs.
    endif.
    at end of bukrs.
      if flg_liste = '2' and suinf = 'X'.
*----- Ausgabe der Summenzeile bei Statistik pro Bukrs -----------------
        bukreis = tkredi-bukrs.
        perform sum_info using bukreis '1' sum1_op sum1_ap sum1_eap.
      endif.
    endat.
  endloop.

endform.                               " KREDI_VERARBEITEN
*&---------------------------------------------------------------------*
*&      Form  SAKO_VERARBEITEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form sako_verarbeiten.
  last_hkont = space.
  last_bukrs = space.
  last_tabix = 0.
  loop at tsako.
    at new bukrs.
      new_bukr = 'X'.
      suinf = space.
    endat.
    if tsako-hkont = last_hkont and tsako-bukrs = last_bukrs.
      if xsobwere = 'X'.
        refresh iekbe.
        refresh ixaccdn.
        ctixaccdn = 0.
      endif.
      refresh xbsis.
      refresh xbsisgr.
      clear zaehler_xbsisgr.                                "427471
      clear x_exit.                                         "427471
      koart = char_s.
*----- Sind f¨¹r das Konto Regeln in TF123 hinterlegt? ------------------
      perform check_table_if123
                           using koart tsako-bukrs tsako-hkont
                           changing flag_if123.
      if flag_if123 eq char_x.
        if x_echtl = 'X' or xtol = 'X' .
          perform echtlauf using koart.
        else.
          perform testlauf using koart.
        endif.
      endif.
    else.
      last_hkont = tsako-hkont.
      last_bukrs = tsako-bukrs.
    endif.
    at end of bukrs.
      if flg_liste = '2' and suinf = 'X'.
*----- Ausgabe der Summenzeile bei Statistik pro Bukrs -----------------
        bukreis = tsako-bukrs.
        perform sum_info using bukreis '1' sum1_op sum1_ap sum1_eap.
      endif.
    endat.
  endloop.
endform.                               " SAKO_VERARBEITEN
*&---------------------------------------------------------------------*
*&      Form  CHECK_TABLE_IF123
*&---------------------------------------------------------------------*
*       Sind f¨¹r ein KOnto Regeln in TF123 hinterlegt?
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form check_table_if123 using
                            i_koart    like bseg-koart
                            i_bukrs    like t001-bukrs
                            i_konto
                   changing flag_if123 type c.

* CHECK SAVE2_KONTO NE I_KONTO.
* SAVE2_KONTO = I_KONTO.
  flag_if123 = space.
  set extended check off.
*----- Zuerst mit Kontenplan lesen und dann eventuell ohne -------------
  read table i001 with key bukrs = i_bukrs.
  if sy-subrc = 0.
    loop at if123 where ktopl eq i001-ktopl
                    and koart eq i_koart
                    and kont1 le i_konto
                    and kont2 ge i_konto.
      flag_if123 = char_x.
      exit.
    endloop.
  endif.
  if sy-subrc ne 0.
    loop at if123
         where ktopl eq space
         and   koart eq i_koart
         and   kont1 le i_konto
         and   kont2 ge i_konto.
      flag_if123 = char_x.
      exit.
    endloop.
  endif.
  set extended check on.
  check flag_if123 eq space.
*----- Konto hat keine Regeln in TF123 ---------------------------------
*----- Eintrag ins Zusatzprotokoll, falls angekreuzt -------------------
  perform record_fill
         using 'RULES' i_bukrs i_koart i_konto space space space char_l.
endform.                               " CHECK_TABLE_IF123
*&---------------------------------------------------------------------*
*&      Form  ECHTLAUF
*&---------------------------------------------------------------------*
*       Speeren des KOntos im Echtlauf oder bei Benutzung von
*       Toleranzen wegen der Simulation, d.h. im Testlauf mit Tole-
*       ranzen wird die Transaktion aufgerufen und dann simuliert,
*       aber nicht gebucht
*----------------------------------------------------------------------*
*      -->P_KOART  text                                                *
*----------------------------------------------------------------------*
form echtlauf using koart like bseg-koart.
  case koart.
    when 'D'.
      enqsubrc = '9'.
*----- Sperren des Kontos im Echtlauf oder bei Toleranzen --------------
      perform sperren_konto using koart tdebi-bukrs tdebi-kunnr
                      changing enqsubrc.
      case enqsubrc.
        when '2'.                      " Systemfehler beim Sperren
*----- Alle Sperren d. Transaktion freigeben, refresh iregus -----------
          perform dequeue_all using  koart.
          exit.
        when others.                   " 0, 1, 3, 6
*----- 0 = Sperren OK , 1 = Konto gesperrt -----------------------------
*----- 3 = Sperreintrag in REGUS ---------------------------------------
*----- 6 = Sperreintrag in T042X ---------------------------------------

*----- Posten lesen, gruppieren, ausgeben u. ausziffern ----------------
          perform indextabellen_fuellen using koart.
*----- Entsperren des Kontos im Echtlauf -------------------------------
          if enqsubrc = 0.
            perform dequeue_all using  koart.
          endif.
      endcase.
    when 'K'.
      enqsubrc = '9'.
*----- Sperren des Kontos im Echtlauf oder bei Toleranzen --------------
      perform sperren_konto using koart tkredi-bukrs tkredi-lifnr
                      changing enqsubrc.
      case enqsubrc.
        when '2'.                      " Systemfehler
*----- Alle Sperren d. Transaktion freigeben, refresh iregus -----------
          perform dequeue_all using  koart.
          exit.
        when others.                   " 0, 1, 3, 6
*0 sperren ok, 1 foreign lock, 3 regus Eintrag vorh., t042x Eintrag vorh
*----- Posten lesen, gruppieren, ausgeben u. ausziffern ----------------
          perform indextabellen_fuellen using koart.
*----- Entsperren des Kontos Echtlauf ----------------------------------
          if enqsubrc = 0.
            perform dequeue_all using  koart.
          endif.
      endcase.
    when 'S'.
      enqsubrc = '9'.
*----- Sperren des Kontos im Echtlauf oder bei Toleranzen --------------
      perform sperren_konto using koart tsako-bukrs tsako-hkont
                      changing enqsubrc.
      case enqsubrc.
        when '2'.                      " Systemfehler
*----- Alle Sperren d. Transaktion freigeben, refresh iregus -----------
          perform dequeue_all using  koart.
          exit.
        when others.                   " 0, 1, 3, 6
*0 sperren ok, 1 foreign lock, 3 regus Eintrag vorh., t042x Eintrag vorh
*----- Posten lesen, gruppieren, ausgeben u. ausziffern ----------------
          perform indextabellen_fuellen using koart.
*----- Entsperren des Kontos im Echtlauf -------------------------------
          if enqsubrc = 0.
            perform dequeue_all using  koart.
          endif.
      endcase.

  endcase.
endform.                               " ECHTLAUF
*&---------------------------------------------------------------------*
*&      Form  TESTLAUF
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_KOART  text                                                *
*----------------------------------------------------------------------*
form testlauf using koart like bseg-koart.
*----- Posten lesen, gruppieren, ausgeben ------------------------------
  perform indextabellen_fuellen using koart.
endform.                               " TESTLAUF
*&---------------------------------------------------------------------*
*&      Form  SPERREN_KONTO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form sperren_konto using i_koart like bseg-koart
                         i_bukrs like bseg-bukrs
                         i_konto
                changing rc_enq  like sy-subrc.
  data: kunnr like knc1-kunnr,
        lifnr like lfc1-lifnr,
        hkont like bsis-hkont.

  case i_koart.
    when char_d.
      kunnr = i_konto.
      call function 'ENQUEUE_EFKNB1A'
           exporting
                kunnr          = kunnr
                bukrs          = i_bukrs
                _scope         = '1'
*----- _scope = 1 = Sperre bleibt bei der Transaktion,------------------
*----- die sie angefordert hat -----------------------------------------
           exceptions
                foreign_lock   = 1
                system_failure = 2.
      rc_enq = sy-subrc.
    when char_k.
      lifnr = i_konto.
      call function 'ENQUEUE_EFLFB1A'
        EXPORTING
          lifnr          = lifnr
          bukrs          = i_bukrs
          _scope         = '1'
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2.
      rc_enq = sy-subrc.
    when char_s.
      hkont = i_konto.
      call function 'ENQUEUE_EFSKB1A'
        EXPORTING
          saknr          = hkont
          bukrs          = i_bukrs
          _scope         = '1'
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2.
      rc_enq = sy-subrc.
  endcase.
*
  if koart eq char_d
  or koart eq char_k.
    if rc_enq eq 0.
*     BUKRS/KOART darf in T042X nicht f.Zahlungsvorschlag gesperrt sein.
*     SAPF124 darf beim Ausgleichen nicht mit Zahlpgm konkurrieren.
*     Eintr#ge in T042X von SAPF100 (F100XX) spielen keine Rolle.
      select * from t042x where koart eq i_koart
                           and  bukrs eq i_bukrs
                           and  laufi ne 'F100XX'.
        exit.
      endselect.
      if sy-subrc is initial.
        rc_enq = 6.
      else.
        regus-koart = i_koart.
        regus-bukrs = i_bukrs.
        regus-konko = i_konto.
        regus-laufd = sy-datum.
        regus-laufi = '$F124$'.
        insert regus.
        if sy-subrc = 0.
          select * from regus
                 where koart eq i_koart
                 and   bukrs eq i_bukrs
                 and   konko eq i_konto
                 and   laufi ne '$F124$'.
            exit.
          endselect.
          if sy-subrc ne 0.
            append regus to iregus.    "Sperren merken f. DEQUEUE_ALL
          else.
            delete from regus where koart = i_koart
                                and bukrs = i_bukrs
                                and konko = i_konto
                                and laufd = sy-datum
                                and laufi = '$F124$'.
            rc_enq = 3.
          endif.
        endif.
      endif.
    endif.
  endif.
*
  check rc_enq ne 0.
*
* Die verschiedenen Sperrf#lle und -fehler werden protokolliert
*
  case rc_enq.
    when 1.
      perform record_fill
              using 'LOCK1' i_bukrs i_koart i_konto space space space
                            char_l.
    when 2.
      perform record_fill
              using 'LOCK2' i_bukrs i_koart i_konto space space space
                            char_l.
    when 3.
      perform record_fill
              using 'LOCK3' i_bukrs i_koart i_konto space space space
                            char_l.
    when 6.
      perform record_fill
              using 'LOCK6' i_bukrs i_koart space space space space
                            char_l.
  endcase.
endform.                               " SPERREN_KONTO
*---------------------------------------------------------------------*
*       FORM DEQUEUE_ALL                                              *
*---------------------------------------------------------------------*
*       Alle Sperren aufheben                                         *
*---------------------------------------------------------------------*
*
form dequeue_all using i_koart like bseg-koart.
* Alle Sperren zu einer Transaktion freigeben
  call function 'DEQUEUE_ALL'.
*
  check i_koart eq char_d
  or    i_koart eq char_k.
*
* Eintr#ge dieses SAPF124 l#schen, sonst Deadlock bei parallelem Auszif.
  delete regus from table iregus.
  refresh iregus.
endform.                               "DEQUEUE_ALL
*&---------------------------------------------------------------------*
*&      Form  INDEXTABELLEN_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form indextabellen_fuellen using i_koart like bseg-koart.
  data:
    ls_xbsidgr like line of xbsidgr,
    ls_xbsikgr like line of xbsikgr,
    ls_xbsisgr like line of xbsisgr.

*DATA: OLD_HKONT LIKE BSEG-HKONT. "f¨¹r Test
  case i_koart.
    when 'D'.
*----- Wiederholten Aufruf bei gleichem Konto vermeiden ----------------
      if save_kunnr ne tdebi-kunnr.
        save_kunnr = tdebi-kunnr.
        perform regeln_vorbereiten using koart tdebi-kunnr tdebi-bukrs.
      endif.
*----- Lesen der BSID, F¨¹llen der XBSID, XBSIDGR -----------------------
      bsid_subrc = 9.
      perform read_bsid changing bsid_subrc.
      check bsid_subrc = 0.
*----- #berschrift Statistik, Z#hler initialisieren --------------------
      if flg_liste = '2' and new_bukr = 'X'.
        perform init_header_stat.
      endif.
      if flg_liste = '2'.
        suinf = 'X'.   " Flag f¨¹r Summeninfo, at end of bukrs
      endif.
*----- Sortieren XBSID, XBSIDGR ----------------------------------------
      perform sortieren using i_koart.
*----- Verarbeiten XBSIDGR ---------------------------------------------
      loop at xbsidgr.
        ls_xbsidgr = xbsidgr.

        If Min_bel = 0.                                          "985181
          Augdt = Save_augdt.                                    "985181
        endif.
        at new hkont.
          if flg_liste = '3'.
            new-page.
          endif.
        endat.
        perform ausgleich using koart xbsidgr-bet_bw.
        at end of xcurr.
          if min_bel ne 0.
            perform restbelege_buchen using koart.
          endif.
        endat.
        at end of hkont.
          If Flg_liste = '2'.                                   "1029245
           perform statistik using koart cnt_ap cnt_op cnt_eap enqsubrc
                                  tdebi-bukrs tdebi-kunnr xbsidgr-hkont.
            cnt_ap = 0.
            cnt_op = 0.
            cnt_eap = 0.
          endif.
        endat.
      endloop.
    when 'K'.
*----- Wiederholten Aufruf bei gleichem Konto vermeiden ----------------
      if save_lifnr ne tkredi-lifnr.
        save_lifnr = tkredi-lifnr.
       perform regeln_vorbereiten using koart tkredi-lifnr tkredi-bukrs.
      endif.
*----- Lesen der BSIK, F¨¹llen der XBSIK, XBSIKGR -----------------------
      bsik_subrc = 9.
      perform read_bsik changing bsik_subrc.
      check bsik_subrc = 0.
*----- #berschrift Statistik, Z#hler initialisieren --------------------
      if flg_liste = '2' and new_bukr = 'X'.
        perform init_header_stat.
      endif.
      if flg_liste = '2'.
        suinf = 'X'.   " Flag f¨¹r Summeninfo, at end of bukrs
      endif.
*----- Sortieren XBSIK, XBSIKGR ----------------------------------------
      perform sortieren using i_koart.
*----- Verarbeiten XBSIDGR ---------------------------------------------
      loop at xbsikgr.
        ls_xbsikgr = xbsikgr.

        If Min_bel = 0.                                          "985181
          Augdt = Save_augdt.                                    "985181
        endif.

        at new hkont.
          if flg_liste = '3'.
            new-page.
          endif.
        endat.
        perform ausgleich using koart xbsikgr-bet_bw.
        at end of xcurr.
          if min_bel ne 0.
            perform restbelege_buchen using koart.
          endif.
        endat.
        at end of hkont.
          If Flg_liste = '2'.                                   "1029245
           perform statistik using koart cnt_ap cnt_op cnt_eap enqsubrc
                                tkredi-bukrs tkredi-lifnr xbsikgr-hkont.
            cnt_ap  = 0.
            cnt_op  = 0.
            cnt_eap = 0.
          endif.
        endat.
      endloop.
    when 'S'.
*----- Wiederholten Aufruf bei gleichem Konto vermeiden ----------------
      if save_hkont ne tsako-hkont.
        save_hkont = tsako-hkont.
        perform regeln_vorbereiten using koart tsako-hkont tsako-bukrs.
      endif.
*----- Lesen der BSIS, F¨¹llen der XBSIS, XBSISGR -----------------------
*----- Sonderbearbeitung f¨¹r WE/RE-Konten ------------------------------
      bsis_subrc = 9.
      perform read_bsis changing bsis_subrc.
      check bsis_subrc = 0.
*----- #berschrift Statistik, Z#hler initialisieren --------------------
      if flg_liste = '2' and new_bukr = 'X'.
        perform init_header_stat.
      endif.
      if flg_liste = '2'.
        suinf = 'X'.   " Flag f¨¹r Summeninfo, at end of bukrs
      endif.
*----- Sortieren XBSIS, XBSISGR ----------------------------------------
      perform sortieren using i_koart.
*----- Verarbeiten XBSISGR ---------------------------------------------
      loop at xbsisgr.
        ls_xbsisgr = xbsisgr.

        If Min_bel = 0.                                          "985181
          Augdt = Save_augdt.                                    "985181
        endif.

        at new hkont.
          if flg_liste = '3'.
            new-page.
          endif.
        endat.
        if xbsisgr-bet_tw = 0.
          perform ausgleich using koart xbsisgr-bet_tw.
        else.
          read table iwere with key bukrs = bsis-bukrs
                                    hkont = bsis-hkont.
          if sy-subrc = 0.
*----- Sonderbearbeitung WE/RE-Konten ----------------------------------
            perform sonderverarbeitung_were.
          else.
            perform ausgleich using koart xbsisgr-bet_tw.
          endif.
        endif.
        at end of xcurr.
          if min_bel ne 0.
            perform restbelege_buchen using koart.
          endif.
        endat.
        at end of hkont.
          If Flg_liste = '2'.                                   "1029245
           perform statistik using koart cnt_ap cnt_op cnt_eap enqsubrc
                                  tsako-bukrs tsako-hkont xbsisgr-hkont.
            cnt_ap  = 0.
            cnt_op  = 0.
            cnt_eap = 0.
          endif.
        endat.
*    OLD_HKONT = XBSISGR-HKONT. "test
*    DELETE XBSISGR.
      endloop.                         "xbsisgr
  endcase.
endform.                               " INDEXTABELLEN_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  REGELN_VORBEREITEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form regeln_vorbereiten using koart   like bseg-koart
                              konto   like if123-kont1
                              i_bukrs like t001-bukrs.
  data: konto_vorh(1) type c.
  clear if123.
  set extended check off.
*----- Relevanter Bereich in Kopfzeile stellen -------------------------
  clear konto_vorh.
  read table i001 with key bukrs = i_bukrs.
  if sy-subrc = 0.
    loop at if123
               where ktopl eq i001-ktopl
               and   koart eq koart.
      if konto ge if123-kont1 and
         konto le if123-kont2.
        tabix = sy-tabix.
        konto_vorh = 'X'.
        exit.
      endif.
    endloop.
  endif.
  if sy-subrc ne 0 or konto_vorh = ' '.
    loop at if123
               where ktopl eq space
               and   koart eq koart.
      if konto ge if123-kont1 and
         konto le if123-kont2.
        tabix = sy-tabix.
        konto_vorh = 'X'.
        exit.
      endif.
    endloop.
  endif.
  set extended check on.
*----- Zeile merken, um unn#tiges assign zu vermeiden ------------------
  if last_tabix ne tabix or xsobwere = 'X'.
    last_tabix = tabix.
    flg_bkpf = ' '.
    flg_bseg = ' '.
*----- M¨¹ssen sp#ter BKPF bzw. BSEG gelesen werden? --------------------
    perform check_table using 'BKPF' changing flg_bkpf.
    perform check_table using 'BSEG' changing flg_bseg.

    do 5 times varying bedgx from if123-bedg1 next if123-bedg2
               varying tablx from if123-tabl1 next if123-tabl2.
      if bedgx ne space.
*----- Bedingungen werden den Feldsymbolen zugewiesen ------------------
        perform feldsymbole using bedgx tablx.
      else.
*----- Initialisieren der Kriterien, weil sonst ------------------------
*----- die Indextabellen falsch gef¨¹llt werden -------------------------
*----- z.B. wenn f¨¹r ein Konto in Tabelle Tf123 ------------------------
*----- mehr oder weniger Bedingungen vereinbart ------------------------
*----- wurden als f¨¹r ein anderes Konto --------------------------------
        case sy-index.
          when '1'.
            krit1 = space.
          when '2'.
            krit2 = space.
          when '3'.
            krit3 = space.
          when '4'.
            krit4 = space.
          when '5'.
            krit5 = space.
        endcase.
      endif.
    enddo.
  endif.
endform.                               " REGELN_VORBEREITEN
*---------------------------------------------------------------------*
*       FORM CHECK_TABLE                                              *
*---------------------------------------------------------------------*
*       Ist Tabelle TABLE in der internen Tabelle IF123 f¨¹r das       *
*       aktuelle Kontonummerintervall enthalten, mu# die Tabelle      *
*       nachgelesen werden - in diesem Fall wird FLG_TABLE gesetzt.   *
*       Beachte, da# die interne Tabelle IF123 bereits in             *
*       der Unterroutine CHECK_IF123 auf das aktuelle Kontonummer-    *
*       intervall eingestellt wurde.                                  *
*---------------------------------------------------------------------*
*  -->  TABLE       Tabelle ('BKPF', 'BSEG' ...)                      *
*  -->  FLG_TABLE   Flag                                              *
*---------------------------------------------------------------------*
form check_table
     using    table like if123-tabl1
     changing flg_table type c.
  data: tabl like if123-tabl1.
*
  flg_table = char_0.
  do 5 times varying tabl from if123-tabl1 next if123-tabl2.
    if tabl eq  table.
      flg_table = char_x.
      exit.
    endif.
  enddo.
endform.                               "CHECK_TABLE
*---------------------------------------------------------------------*
*       FORM FELDSYMBOLE                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  BEDGX                                                         *
*  -->  TABLX                                                         *
*---------------------------------------------------------------------*
form feldsymbole using    bedgx  like if123-bedg1
                          tablx  like if123-tabl1.

  data: bedingung(35) type c.

  bedingung(4)   = tablx.
  bedingung+4(1) = '-'.
  bedingung+5(30) = bedgx.
  case sy-index.
    when '1'.
      krit1 = bedingung.
      assign table field (bedingung) to <f1>.
    when '2'.
      krit2 = bedingung.
      assign table field (bedingung) to <f2>.
    when '3'.
      krit3 = bedingung.
      assign table field (bedingung) to <f3>.
    when '4'.
      krit4 = bedingung.
      assign table field (bedingung) to <f4>.
    when '5'.
      krit5 = bedingung.
      assign table field (bedingung) to <f5>.
  endcase.

endform.                    "FELDSYMBOLE
*&---------------------------------------------------------------------*
*&      Form  READ_BSID
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form read_bsid changing e_subrc like sy-subrc.
  data: yt_avis09 type  farmatch_payment_advices_list.
  data: yt_avis09_zeile type farmatch_payment_advices.
  data: lt_bsidkey type farmatch_items_table.
  data: ls_bsidkey type farmatch_items.
  data: ld_ignore_doc(1) type c.
  if x_avisd = space.
*----- Normale OP's ----------------------------------------------------
    if x_shbkn eq space and x_kunnr ne space.
      select * from bsid
                          where bukrs = tdebi-bukrs
                            and kunnr = tdebi-kunnr
                            and umsks eq space
                            and zuonr in so_zuonr
                            and gjahr in gjahx
                            and belnr in docnr
                            and budat in postdate.
        check bsid-xpypr = space.
*----- Zur Stornierung vorgemerkte Posten ausschlie#en, ----------------
*----- z.B. Abgrenzungsposten ------------------------------------------
        check bsid-xstov = space.
        clear: xbsid, xbsidgr.
        perform check_authority_add                         "516329
        using bsid-blart bsid-gsber                         "516329
        changing rtc.                                       "516329
        check rtc is initial.                               "516329
                                                            "516329
        if tdebi-wt_newwt is initial                        "500429
        or bsid-qsskz is initial.                           "500429
*----- Ist Belegbuchung zum Ausgleichsdatum erlaubt? -------------------
*----- Wird Ausgleichsdatum aus j¨¹ngstem Beleg bestimmt, werden Belege
*----- zun#chst selektiert; die Pr¨¹fung kann dann erst im sapmf05a
*----- erfolgen, weil Ausgleichsdatum erst kurz vor call transaction
*----- bestimmt werden kann
          if xf124e = space and xaugdt = space.
            perform currency_expiration_check using    bsid-waers augdt
                                                       bsid-bukrs
                                              changing ld_ignore_doc.
            check ld_ignore_doc = space.
          endif.
          if gd_ebpp_active = 'X' and bsid-zlsch ne space.
            perform check_payment_method using bsid-zlsch bsid-bukrs
                                         changing ld_ignore_doc.
            check ld_ignore_doc = space.
          endif.
*----- F¨¹llen der Gruppierungstabelle xbsidgr --------------------------
*----- und der Tabelle xbsid -------------------------------------------
          if  bsid-rebzt is initial
          and bsid-rebzg is initial.
            bsid-rebzg = bsid-belnr.
          endif.
          perform xbsid_xbsidgr_fuellen.
        else.                                               "500429
          perform record_fill                               "500429
          using 'QSSKZ' bsid-bukrs koart bsid-kunnr bsid-hkont"500429
                bsid-belnr bsid-buzei char_x.               "500429
        endif.                                              "500429
      endselect.
      e_subrc = sy-subrc.
      if e_subrc ne 0.
*----- Keine Debitorenbelege selektiert --------------------------------
        perform record_fill
        using 'BSID ' Tdebi-Bukrs Koart Tdebi-Kunnr space       "1029245
        space space char_l.                                     "1029245
      endif.
    endif.
*----- Normale OP's und SHB-Vorg#nge (au#er 'A' und 'W') ---------------
    if x_shbkn ne space and x_kunnr ne space.
      ktopl = space.
      select * from bsid
                          where bukrs = tdebi-bukrs
                            and kunnr = tdebi-kunnr
                            and umsks ne char_w             "401470
                            and zuonr in so_zuonr
                            and gjahr in gjahx
                            and belnr in docnr
                            and budat in postdate
                            and ( umskz in shbkd or umskz = space ).
                                                            "355602
        check bsid-xpypr = space.
*----- Zur Stornierung vorgemerkte Posten ausschlie#en, ----------------
*----- z.B. Abgrenzungsposten ------------------------------------------
        check bsid-xstov = space.
        check bsid-bstat ne 'S'.                            "353740
        clear: xbsid, xbsidgr.
        rtc = 0.
*----- Stat. SHB-Vorg#nge ausschlie#en ---------------------------------
        if bsid-umskz ne space.
          if ktopl = space.
            read table i001 with key bukrs = tdebi-bukrs.
            ktopl = i001-ktopl.
          endif.
          select * from t030 where ktopl = ktopl
                               and ktosl = 'SGA'.
            check t030-komok(1) = 'D'.
            if t030-komok+1(1) = bsid-umskz.
              rtc = 4.
              exit.
            endif.
          endselect.
        endif.
        check rtc = 0.
        perform check_authority_add                         "516329
        using bsid-blart bsid-gsber                         "516329
        changing rtc.                                       "516329
        check rtc is initial.                               "516329
                                                            "516329
        if tdebi-wt_newwt is initial                        "500429
        or bsid-qsskz is initial.                           "500429
*----- Ist Belegbuchung zum Ausgleichsdatum erlaubt? -------------------
*----- Wird Ausgleichsdatum aus j¨¹ngstem Beleg bestimmt, werden Belege
*----- zun#chst selektiert; die Pr¨¹fung kann dann erst im sapmf05a *
*----- erfolgen, weil Ausgleichsdatum erst kurz vor call transaction
*----- bestimmt werden kann
          if xf124e = space and xaugdt = space.
            perform currency_expiration_check using    bsid-waers augdt
                                                       bsid-bukrs
                                              changing ld_ignore_doc.
            check ld_ignore_doc = space.
          endif.

          if gd_ebpp_active = 'X' and bsid-zlsch ne space.
            perform check_payment_method using bsid-zlsch bsid-bukrs
                                         changing ld_ignore_doc.
            check ld_ignore_doc = space.
          endif.

*----- F¨¹llen der Gruppierungstabelle xbsidgr --------------------------
*----- und der Tabelle xbsid -------------------------------------------
          if  bsid-rebzt is initial                         "496007
          and bsid-rebzg is initial.
            bsid-rebzg = bsid-belnr.
          endif.                                            "496007

          perform xbsid_xbsidgr_fuellen.
        else.                                               "500429
          perform record_fill                               "500429
          using 'QSSKZ' bsid-bukrs koart bsid-kunnr bsid-hkont"500429
                bsid-belnr bsid-buzei char_x.               "500429
        endif.                                              "500429
      endselect.
      e_subrc = sy-subrc.
      if e_subrc ne 0.
*----- Keine Debitorenbelege selektiert --------------------------------
        perform record_fill
        using 'BSID ' Tdebi-Bukrs Koart Tdebi-Kunnr space       "1029245
        space space char_l.                                     "1029245
      endif.
    endif.
*----- Nur Sonderhauptbuchvorg#nge (au#er 'A' und 'W') -----------------
    if x_shbkn ne space and x_kunnr eq space.
      ktopl = space.
      select * from bsid
                          where bukrs = tdebi-bukrs
                            and kunnr = tdebi-kunnr
                            and umsks ne char_w             "401470
                            and umskz ne space
                            and zuonr in so_zuonr
                            and umskz in shbkd              "355602
                            and gjahr in gjahx
                            and belnr in docnr
                            and budat in postdate.
        check bsid-xpypr = space.
*----- Zur Stornierung vorgemerkte Posten ausschlie#en, ----------------
*----- z.B. Abgrenzungsposten ------------------------------------------
        check bsid-xstov = space.
        check bsid-bstat ne 'S'.                            "353740
        clear: xbsid, xbsidgr.
        rtc = 0.
*----- Stat. SHB-Vorg#nge ausschlie#en ---------------------------------
        if bsid-umskz ne space.
          if ktopl = space.
            read table i001 with key bukrs = tdebi-bukrs.
            ktopl = i001-ktopl.
          endif.
          select * from t030 where ktopl = ktopl
                               and ktosl = 'SGA'.
            check t030-komok(1) = 'D'.
            if t030-komok+1(1) = bsid-umskz.
              rtc = 4.
              exit.
            endif.
          endselect.
        endif.
        check rtc = 0.
        perform check_authority_add                         "516329
        using bsid-blart bsid-gsber                         "516329
        changing rtc.                                       "516329
        check rtc is initial.                               "516329
                                                            "516329
        if tdebi-wt_newwt is initial                        "500429
        or bsid-qsskz is initial.                           "500429
*----- Ist Belegbuchung zum Ausgleichsdatum erlaubt? -------------------
*----- Wird Ausgleichsdatum aus j¨¹ngstem Beleg bestimmt, werden Belege
*----- zun#chst selektiert; die Pr¨¹fung kann dann erst im sapmf05a *
*----- erfolgen, weil Ausgleichsdatum erst kurz vor call transaction
*----- bestimmt werden kann
          if xf124e = space and xaugdt = space.
            perform currency_expiration_check using   bsid-waers augdt
                                                      bsid-bukrs
                                             changing ld_ignore_doc.
            check ld_ignore_doc = space.
          endif.

          if gd_ebpp_active = 'X' and bsid-zlsch ne space.
            perform check_payment_method using bsid-zlsch bsid-bukrs
                                         changing ld_ignore_doc.
            check ld_ignore_doc = space.
          endif.

*----- F¨¹llen der Gruppierungstabelle xbsidgr --------------------------
*----- und der Tabelle xbsid -------------------------------------------
          if  bsid-rebzt is initial                         "496007
          and bsid-rebzg is initial.
            bsid-rebzg = bsid-belnr.
          endif.                                            "496007
          perform xbsid_xbsidgr_fuellen.
        else.                                               "500429
          perform record_fill                               "500429
          using 'QSSKZ' bsid-bukrs koart bsid-kunnr bsid-hkont"500429
                bsid-belnr bsid-buzei char_x.               "500429
        endif.                                              "500429
      endselect.
      e_subrc = sy-subrc.
      if e_subrc ne 0.
*----- Keine Debitorenbelege selektiert --------------------------------
        perform record_fill
        using 'BSID ' Tdebi-Bukrs Koart Tdebi-Kunnr space       "1029245
        space space char_l.                                     "1029245
      endif.
    endif.
  else.
    perform fill_gt_selavis.
    call function 'FARMATCH_GET_PAYMENT_ADVICES'
      TABLES
        it_select     = gt_selavis
        et_pa_list    = yt_avis09
      EXCEPTIONS
        nothing_found = 1
        system_error  = 2
        others        = 3.
    e_subrc = sy-subrc.
    if sy-subrc <> 0.
*----- Keine Debitorenbelege selektiert --------------------------------
      perform record_fill
          using 'BSID ' space space space space space space char_s.
    endif.
    loop at yt_avis09 into yt_avis09_zeile.
      lt_bsidkey = yt_avis09_zeile-items.
      loop at lt_bsidkey into ls_bsidkey.
        select single * from  bsid
               where  bukrs  = ls_bsidkey-bukrs
               and    kunnr  = ls_bsidkey-kunnr
               and    umsks  = ls_bsidkey-umsks
               and    umskz  = ls_bsidkey-umskz
               and    augdt  = ls_bsidkey-augdt
               and    augbl  = ls_bsidkey-augbl
               and    zuonr  = ls_bsidkey-zuonr
               and    gjahr  = ls_bsidkey-gjahr
               and    belnr  = ls_bsidkey-belnr
               and    buzei  = ls_bsidkey-buzei.
        if sy-subrc = 0.
          bsid-xref3 = yt_avis09_zeile-avsid.
          check bsid-gjahr in gjahx.
          check bsid-belnr in docnr.
          check bsid-zuonr in so_zuonr.
          check bsid-budat in postdate.
          check bsid-xpypr = space.
*----- Zur Stornierung vorgemerkte Posten ausschlie#en, ----------------
*----- z.B. Abgrenzungsposten ------------------------------------------
          check bsid-xstov = space.
          check bsid-bstat ne 'S'.
          clear: xbsid, xbsidgr.
          rtc = 0.
*----- Stat. SHB-Vorg#nge ausschlie#en ---------------------------------
          if bsid-umskz ne space.
            if ktopl = space.
              read table i001 with key bukrs = tdebi-bukrs.
              ktopl = i001-ktopl.
            endif.
            select * from t030 where ktopl = ktopl
                                 and ktosl = 'SGA'.
              check t030-komok(1) = 'D'.
              if t030-komok+1(1) = bsid-umskz.
                rtc = 4.
                exit.
              endif.
            endselect.
          endif.
          check rtc = 0.
          perform check_authority_add                       "516329
          using bsid-blart bsid-gsber                       "516329
          changing rtc.                                     "516329
          check rtc is initial.                             "516329
                                                            "516329
          if tdebi-wt_newwt is initial                      "500429
          or bsid-qsskz is initial.                         "500429
*----- IST BELEGBUCHUNG ZUM AUSGLEICHSDATUM ERLAUBT? -------------------
*----- Wird Ausgleichsdatum aus j¨¹ngstem Beleg bestimmt, werden Belege
*----- zun#chst selektiert; die Pr¨¹fung kann dann erst im sapmf05a *
*----- erfolgen, weil Ausgleichsdatum erst kurz vor call transaction
*----- bestimmt werden kann
            if xf124e = space and xaugdt = space.
            perform currency_expiration_check using    bsid-waers augdt
                                                       bsid-bukrs
                                              changing ld_ignore_doc.
              check ld_ignore_doc = space.
            endif.

            if gd_ebpp_active = 'X' and bsid-zlsch ne space.
              perform check_payment_method using bsid-zlsch bsid-bukrs
                                           changing ld_ignore_doc.
              check ld_ignore_doc = space.
            endif.

*----- F¨¹llen der Gruppierungstabelle xbsidgr --------------------------
*----- und der Tabelle xbsid -------------------------------------------
            if  bsid-rebzt is initial                       "496007
            and bsid-rebzg is initial.
              bsid-rebzg = bsid-belnr.
            endif.                                          "496007

            perform xbsid_xbsidgr_fuellen.
          else.                                             "500429
            perform record_fill                             "500429
            using 'QSSKZ' bsid-bukrs koart bsid-kunnr bsid-hkont"500429
                  bsid-belnr bsid-buzei char_x.             "500429
          endif.                                            "500429
        endif.
      endloop.
    endloop.
  endif.
endform.                               " READ_BSID
*&---------------------------------------------------------------------*
*&      Form  FILL_IT_SELAVIS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form fill_gt_selavis.
  refresh gt_selavis.
  clear   gt_selavis.
  gt_selavis-sign   = 'I'.
  gt_selavis-option = 'EQ'.

  gt_selavis-field = 'BUKRS'.
  gt_selavis-low   = tdebi-bukrs.
  clear gt_selavis-high.
  append gt_selavis.

  gt_selavis-field = 'KONTO'.
  gt_selavis-low   = tdebi-kunnr.
  clear gt_selavis-high.
  append gt_selavis.
*----- Only consider advices which are confirmed -----------------------
  gt_selavis-field = 'ASTAT'.
  gt_selavis-low   = 'C'..
  clear gt_selavis-high.
  append gt_selavis.
endform.                               " FILL_GT_SELAVIS
*&---------------------------------------------------------------------*
*&      Form  READ_BSIK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_BSIK_SUBRC  text                                           *
*----------------------------------------------------------------------*
form read_bsik changing e_subrc like sy-subrc.
  data: ld_ignore_doc(1) type c.
  Constants: Ldc_paym_directive like Bsik-Xref3 value 'FMPO'.    "861169

*----- Normale OP's ----------------------------------------------------
  if x_shblf eq space and x_lifnr ne space.
    select * from bsik
                        where bukrs = tkredi-bukrs
                          and lifnr = tkredi-lifnr
                          and umsks eq space
                          and zuonr in so_zuonr
                          and gjahr in gjahx
                          and belnr in docnr
                          and budat in postdate.
      check bsik-xpypr = space.
*----- Zur Stornierung vorgemerkte Posten ausschlie#en, ----------------
*----- z.B. Abgrenzungsposten ------------------------------------------
      check bsik-xstov = space.
      clear: xbsik, xbsikgr.
      perform check_authority_add                           "516329
      using bsik-blart bsik-gsber                           "516329
      changing rtc.                                         "516329
      check rtc is initial.                                 "516329
                                                            "516329
*----- F¨¹llen der Gruppierungstabelle xbsikgr --------------------------
*----- und der Tabelle xbsik -------------------------------------------
      If Bsik-qsshb = 0
      or ( Bsik-Xref3 = Ldc_paym_directive                       "861169
       and Gb_eaps_active <> space                               "861169
       and Bsik-Zlspr <> space ).                                "861169
*----- IST BELEGBUCHUNG ZUM AUSGLEICHSDATUM ERLAUBT? -------------------
*----- Wird Ausgleichsdatum aus j¨¹ngstem Beleg bestimmt, werden Belege
*----- zun#chst selektiert; die Pr¨¹fung kann dann erst im sapmf05a *
*----- erfolgen, weil Ausgleichsdatum erst kurz vor call transaction
*----- bestimmt werden kann
        if xf124e = space and xaugdt = space.
          perform currency_expiration_check using    bsik-waers augdt
                                                     bsik-bukrs
                                              changing ld_ignore_doc.
          check ld_ignore_doc = space.
        endif.
        if  bsik-rebzt is initial                           "496007
        and bsik-rebzg is initial.
          bsik-rebzg = bsik-belnr.
        endif.                                              "496007

        perform xbsik_xbsikgr_fuellen.
      else.
        perform record_fill
             using 'QSSHB' bsik-bukrs koart bsik-lifnr bsik-hkont
                   bsik-belnr bsik-buzei char_x.
      endif.
    endselect.
    e_subrc = sy-subrc.
    if e_subrc ne 0.
*----- Keine Kreditorenbelege selektiert -------------------------------
      perform record_fill
      using 'BSIK ' Tkredi-Bukrs Koart Tkredi-Lifnr space       "1029245
      space space char_l.                                       "1029245
    endif.
  endif.
*----- Normale OP's und Sonderhauptbuchvorg#nge (au#er 'A' und 'W')-----
  if x_shblf ne space and x_lifnr ne space.
    ktopl = space.
    select * from bsik
                        where bukrs = tkredi-bukrs
                          and lifnr = tkredi-lifnr
                          and umsks ne char_w               "401470
                          and zuonr in so_zuonr
                          and gjahr in gjahx
                          and belnr in docnr
                          and budat in postdate
                          and ( umskz in shbkk or umskz = space ).
                                                            "355602
      check bsik-xpypr = space.
*----- Zur Stornierung vorgemerkte Posten ausschlie#en, ----------------
*----- z.B. Abgrenzungsposten ------------------------------------------
      check bsik-xstov = space.
      check bsik-bstat ne 'S'.                              "353740
      clear: xbsik, xbsikgr.
      rtc = 0.
*----- Stat. SHB-Vorg#nge ausschlie#en ---------------------------------
      if bsik-umskz ne space.
        if ktopl = space.
          read table i001 with key bukrs = tkredi-bukrs.
          ktopl = i001-ktopl.
        endif.
        select * from t030 where ktopl = ktopl
                             and ktosl = 'SGA'.
          check t030-komok(1) = 'K'.
          if t030-komok+1(1) = bsik-umskz.
            rtc = 4.
            exit.
          endif.
        endselect.
      endif.
      check rtc = 0.
      perform check_authority_add                           "516329
      using bsik-blart bsik-gsber                           "516329
      changing rtc.                                         "516329
      check rtc is initial.                                 "516329
                                                            "516329
*----- F¨¹llen der Gruppierungstabelle xbsikgr --------------------------
*----- und der Tabelle xbsik -------------------------------------------
      If Bsik-qsshb = 0
      or ( Bsik-Xref3 = Ldc_paym_directive                       "861169
       and Gb_eaps_active <> space                               "861169
       and Bsik-Zlspr <> space ).                                "861169
*----- IST BELEGBUCHUNG ZUM AUSGLEICHSDATUM ERLAUBT? -------------------
*----- Wird Ausgleichsdatum aus j¨¹ngstem Beleg bestimmt, werden Belege
*----- zun#chst selektiert; die Pr¨¹fung kann dann erst im sapmf05a *
*----- erfolgen, weil Ausgleichsdatum erst kurz vor call transaction
*----- bestimmt werden kann
        if xf124e = space and xaugdt = space.
          perform currency_expiration_check using    bsik-waers augdt
                                                     bsik-bukrs
                                              changing ld_ignore_doc.
          check ld_ignore_doc = space.
        endif.
        if  bsik-rebzt is initial                           "496007
        and bsik-rebzg is initial.
          bsik-rebzg = bsik-belnr.
        endif.                                              "496007

        perform xbsik_xbsikgr_fuellen.
      else.
        perform record_fill
             using 'QSSHB' bsik-bukrs koart bsik-lifnr bsik-hkont
                   bsik-belnr bsik-buzei char_x.
      endif.
    endselect.
    e_subrc = sy-subrc.
    if e_subrc ne 0.
*----- Keine Kreditorenbelege selektiert -------------------------------
      perform record_fill
      using 'BSIK ' Tkredi-Bukrs Koart Tkredi-Lifnr space       "1029245
      space space char_l.                                       "1029245
    endif.
  endif.
*----- Nur Sonderhauptbuchvorg#nge (au#er 'A' und 'W') -----------------
  if x_shblf ne space and x_lifnr eq space.
    ktopl = space.
    select * from bsik
                        where bukrs = tkredi-bukrs
                          and lifnr = tkredi-lifnr
                          and umsks ne char_w               "401470
                          and umskz ne space
                          and zuonr in so_zuonr
                          and umskz in shbkk                "355602
                          and gjahr in gjahx
                          and belnr in docnr
                          and budat in postdate.
      check bsik-xpypr = space.
*----- Zur Stornierung vorgemerkte Posten ausschlie#en, ----------------
*----- z.B. Abgrenzungsposten ------------------------------------------
      check bsik-xstov = space.
      check bsik-bstat ne 'S'.                              "353740
      clear: xbsik, xbsikgr.
      rtc = 0.
*----- Stat. SHB-Vorg#nge ausschlie#en ---------------------------------
      if bsik-umskz ne space.
        if ktopl = space.
          read table i001 with key bukrs = tkredi-bukrs.
          ktopl = i001-ktopl.
        endif.
        select * from t030 where ktopl = ktopl
                             and ktosl = 'SGA'.
          check t030-komok(1) = 'K'.
          if t030-komok+1(1) = bsik-umskz.
            rtc = 4.
            exit.
          endif.
        endselect.
      endif.
      check rtc = 0.
      perform check_authority_add                           "516329
      using bsik-blart bsik-gsber                           "516329
      changing rtc.                                         "516329
      check rtc is initial.                                 "516329
                                                            "516329
*----- F¨¹llen der Gruppierungstabelle xbsikgr --------------------------
*----- und der Tabelle xbsik -------------------------------------------
      If Bsik-qsshb = 0
      or ( Bsik-Xref3 = Ldc_paym_directive                       "861169
       and Gb_eaps_active <> space                               "861169
       and Bsik-Zlspr <> space ).                                "861169
*----- IST BELEGBUCHUNG ZUM AUSGLEICHSDATUM ERLAUBT? -------------------
*----- Wird Ausgleichsdatum aus j¨¹ngstem Beleg bestimmt, werden Belege
*----- zun#chst selektiert; die Pr¨¹fung kann dann erst im sapmf05a *
*----- erfolgen, weil Ausgleichsdatum erst kurz vor call transaction
*----- bestimmt werden kann
        if xf124e = space and xaugdt = space.
          perform currency_expiration_check using     bsik-waers augdt
                                                      bsik-bukrs
                                             changing ld_ignore_doc.
          check ld_ignore_doc = space.
        endif.
        if  bsik-rebzt is initial                           "496007
        and bsik-rebzg is initial.
          bsik-rebzg = bsik-belnr.
        endif.                                              "496007

        perform xbsik_xbsikgr_fuellen.
      else.
        perform record_fill
             using 'QSSHB' bsik-bukrs koart bsik-lifnr bsik-hkont
                   bsik-belnr bsik-buzei char_x.
      endif.
    endselect.
    e_subrc = sy-subrc.
    e_subrc = sy-subrc.
    if e_subrc ne 0.
*----- Keine Kreditorenbelege selektiert -------------------------------
      perform record_fill
      using 'BSIK ' Tkredi-Bukrs Koart Tkredi-Lifnr space       "1029245
      space space char_l.                                       "1029245
    endif.
  endif.

endform.                               " READ_BSIK
*&---------------------------------------------------------------------*
*&      Form  READ_BSIS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_BSIS_SUBRC  text                                           *
*----------------------------------------------------------------------*
form read_bsis changing e_subrc like sy-subrc.
  data: subrcbseg like sy-subrc.
  data: ld_ignore_doc(1) type c.

  if x_saknr ne space.
    read table i030_skv with key bukrs = tsako-bukrs
                                 konts = tsako-hkont.
    if sy-subrc <> 0.                  "SY-SUBRC=0 -> SKV-Konto
      refresh ibsis.                                        "454904
      select * from bsis
                       where bukrs = tsako-bukrs
                         and hkont = tsako-hkont
                         and zuonr in so_zuonr
                         and gjahr in gjahx
                         and belnr in docnr
                         and budat in postdate
                         and xopvw eq char_x.
        perform check_authority_add                         "516329
        using bsis-blart bsis-gsber                         "516329
        changing rtc.                                       "516329
        check rtc is initial.                               "516329
                                                            "516329
*----- IST BELEGBUCHUNG ZUM AUSGLEICHSDATUM ERLAUBT? -------------------
*----- Wird Ausgleichsdatum aus j¨¹ngstem Beleg bestimmt, werden Belege
*----- zun#chst selektiert; die Pr¨¹fung kann dann erst im sapmf05a *
*----- erfolgen, weil Ausgleichsdatum erst kurz vor call transaction
*----- bestimmt werden kann
        if xf124e = space and xaugdt = space.
          perform currency_expiration_check using     bsis-pswsl augdt
                                                      bsis-bukrs
                                             changing ld_ignore_doc.
          check ld_ignore_doc = space.
        endif.

        move bsis to ibsis-bsis.
        append ibsis.
      endselect.
*----- WE/RE-Konto? ----------------------------------------------------
      if xsobwere = 'X'.
        read table iwere with key
                               bukrs = tsako-bukrs hkont = tsako-hkont.
        if sy-subrc = 0.
          loop at ibsis.
            bsis = ibsis-bsis.
            perform read_bseg_neu using bsis-bukrs bsis-belnr
                                        bsis-gjahr bsis-buzei
                                  changing subrcbseg.
            if subrcbseg = 0.
              ibsis-ebeln = bseg-ebeln.
              ibsis-ebelp = bseg-ebelp.
              modify ibsis.
            endif.
          endloop.
          sort ibsis by ebeln ebelp bsis-gjahr bsis-belnr bsis-buzei.
        endif.
      endif.

      loop at ibsis.
        at new ebelp.                                       "454904
          refresh iekbe.                                    "454904
          rcekbe = 4.                                       "454904
          rciekbe = 4.                                      "454904
        endat.                                              "454904
        bsis = ibsis-bsis.
        bseg-ebeln = ibsis-ebeln.                           "454904
        bseg-ebelp = ibsis-ebelp.                           "454904
*----- Zur Stornierung vorgemerkte Posten ausschlie#en, ----------------
*----- z.B. Abgrenzungsposten ------------------------------------------
        check bsis-xstov = space.
        clear: xbsis, xbsisgr.
*----- Fuellen der Gruppierungstabelle xbsisgr -------------------------
*----- und der Tabelle xbsis -------------------------------------------
*----- Sonderbearbeitung f¨¹r WE/RE-Konten ------------------------------
        perform xbsis_xbsisgr_fuellen.
        if x_exit = 'X'.
          exit.
        endif.
      endloop.
      if x_exit = 'X'.
        refresh ibsis.
      endif.
      e_subrc = sy-subrc.
    else.
      e_subrc = 7.
    endif.
    if e_subrc ne 0 and e_subrc ne 7.
*----- Keine Sachkontenbelege selektiert -------------------------------
      perform record_fill
      using 'BSIS ' Tsako-Bukrs Koart Tsako-Hkont space         "1029245
      space space char_l.                                       "1029245
    endif.
  endif.
endform.                               " READ_BSIS
*&---------------------------------------------------------------------*
*----------------------------------------------------------------"516329
form check_authority_add using id_blart like bkpf-blart     "516329
                               id_gsber like bseg-gsber     "516329
                         changing cd_subrc like sy-subrc.   "516329
  data: ld_aktvt like tact-actvt value '03',                "516329
        ld_rtcode type n.                                   "516329
                                                            "516329
  clear: cd_subrc, ld_rtcode.                               "516329
  if not gb_xaubl is initial.                               "516329
    call function 'FI_BLART_AUTH_CHECK'                     "516329
    exporting i_blart = id_blart                            "516329
              i_aktvt = ld_aktvt                            "516329
    importing e_rtcode = ld_rtcode.                         "516329
  endif.                                                    "516329
  if not gb_xaugs is initial                                "516329
  and ld_rtcode is initial                                  "516329
  and not id_gsber is initial.                              "516329
    call function 'FI_GSBER_AUTH_CHECK'                     "516329
    exporting i_gsber = id_gsber                            "516329
              i_aktvt = ld_aktvt                            "516329
    importing e_rtcode = ld_rtcode.                         "516329
  endif.                                                    "516329
  if not ld_rtcode is initial.                              "516329
    cd_subrc = '4'.                                         "516329
  endif.                                                    "516329
endform.                                                    "516329
*&---------------------------------------------------------------------*
*&      Form  XBSID_XBSIDGR_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form xbsid_xbsidgr_fuellen.
  data: subrcbkpf like sy-subrc.
  data: subrcbseg like sy-subrc.
  data: ld_ignore_doc(1) type c.

  clear xwrbtr.
  if bsid-pswbt = 0.
    perform fill_pswbt using    bsid-bukrs bsid-waers bsid-dmbtr
                                bsid-wrbtr ' '
                       changing bsid-pswbt.
  endif.

  move-corresponding bsid to xbsid.
  if xf124e = 'X'.
    perform  wrbtr_umrechnen using koart
                             changing ld_ignore_doc.
    check ld_ignore_doc = space.
  endif.
  if xwrbtr = 'X'.
    xbsid-xcurr = awaers.
  else.
    xbsid-xamnt = xbsid-wrbtr.
    xbsid-xcurr = xbsid-waers.
  endif.

  move-corresponding xbsid to xbsidgr.
  if bsid-shkzg = 'H'.
    xbsidgr-bet_bw = - xbsid-xamnt.
  else.
    xbsidgr-bet_bw =  xbsid-xamnt.
  endif.

  if x_avisd = 'X'.
    perform feldsymbole_veraendern_avis.
  endif.
  if flg_bkpf = 'X'.
    perform read_bkpf_neu
    using bsid-bukrs bsid-belnr bsid-gjahr 'X'              "455320
    changing subrcbkpf.
    check subrcbkpf = 0.
  endif.
  if flg_bseg = 'X'.
    perform read_bseg_neu using bsid-bukrs bsid-belnr bsid-gjahr
                                bsid-buzei
                          changing subrcbseg.
    check subrcbseg = 0.
  endif.

  if not krit1 is initial.
    xbsidgr-krit1 = krit1.
    xbsid-krit1 = krit1.
    perform check_betragsfelder using krit1.                "365889
    if not x_betrag is initial.                             "418389
      move <f1> to xbsid-bedg1.                             "365889
      move <f1> to xbsidgr-bedg1.                           "365889
    else.                                                   "365889
      write <f1> to xbsid-bedg1.                            "333215
      write <f1> to xbsidgr-bedg1.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsid-bedg1 is initial.
      while xbsid-bedg1(01) is initial.
        shift xbsid-bedg1.
        shift xbsidgr-bedg1.
      endwhile.
    endif.
  endif.

  if not krit2 is initial.
    xbsidgr-krit2 = krit2.
    xbsid-krit2 = krit2.
    perform check_betragsfelder using krit2.                "365889
    if not x_betrag is initial.                             "418389
      move <f2> to xbsid-bedg2.                             "365889
      move <f2> to xbsidgr-bedg2.                           "365889
    else.                                                   "365889
      write <f2> to xbsid-bedg2.                            "333215
      write <f2> to xbsidgr-bedg2.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsid-bedg2 is initial.
      while xbsid-bedg2(01) is initial.
        shift xbsid-bedg2.
        shift xbsidgr-bedg2.
      endwhile.
    endif.
  endif.

  if not krit3 is initial.
    xbsidgr-krit3 = krit3.
    xbsid-krit3 = krit3.
    perform check_betragsfelder using krit3.                "365889
    if not x_betrag is initial.                             "418389
      move <f3> to xbsid-bedg3.                             "365889
      move <f3> to xbsidgr-bedg3.                           "365889
    else.                                                   "365889
      write <f3> to xbsid-bedg3.                            "333215
      write <f3> to xbsidgr-bedg3.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsid-bedg3 is initial.
      while xbsid-bedg3(01) is initial.
        shift xbsid-bedg3.
        shift xbsidgr-bedg3.
      endwhile.
    endif.
  endif.

  if not krit4 is initial.
    xbsidgr-krit4 = krit4.
    xbsid-krit4 = krit4.
    perform check_betragsfelder using krit4.                "365889
    if not x_betrag is initial.                             "418389
      move <f4> to xbsid-bedg4.                             "365889
      move <f4> to xbsidgr-bedg4.                           "365889
    else.                                                   "365889
      write <f4> to xbsid-bedg4.                            "333215
      write <f4> to xbsidgr-bedg4.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsid-bedg4 is initial.
      while xbsid-bedg4(01) is initial.
        shift xbsid-bedg4.
        shift xbsidgr-bedg4.
      endwhile.
    endif.
  endif.

  if not krit5 is initial.
    xbsidgr-krit5 = krit5.
    xbsid-krit5 = krit5.
    perform check_betragsfelder using krit5.                "365889
    if not x_betrag is initial.                             "418389
      move <f5> to xbsid-bedg5.                             "365889
      move <f5> to xbsidgr-bedg5.                           "365889
    else.                                                   "365889
      write <f5> to xbsid-bedg5.                            "333215
      write <f5> to xbsidgr-bedg5.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsid-bedg5 is initial.
      while xbsid-bedg5(01) is initial.
        shift xbsid-bedg5.
        shift xbsidgr-bedg5.
      endwhile.
    endif.
  endif.
  append xbsid.
  collect xbsidgr.

endform.                               " XBSID_XBSIDGR_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  XBSIK_XBSIKGR_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form xbsik_xbsikgr_fuellen.
  data: subrcbkpf like sy-subrc.
  data: subrcbseg like sy-subrc.
  data: ld_ignore_doc(1) type c.

  clear xwrbtr.
  if bsik-pswbt = 0.
    perform fill_pswbt using bsik-bukrs bsik-waers bsik-dmbtr
                             bsik-wrbtr ' '
                    changing bsik-pswbt.
  endif.

  move-corresponding bsik to xbsik.
  if xf124e = 'X'.
    perform  wrbtr_umrechnen using koart
                          changing ld_ignore_doc.
    check ld_ignore_doc = space.
  endif.
  if xwrbtr = 'X'.
    xbsik-xcurr = awaers.
  else.
    xbsik-xamnt = xbsik-wrbtr.
    xbsik-xcurr = xbsik-waers.
  endif.

  move-corresponding xbsik to xbsikgr.
  if bsik-shkzg = 'H'.
    xbsikgr-bet_bw = - xbsik-xamnt.
  else.
    xbsikgr-bet_bw =  xbsik-xamnt.
  endif.

  if flg_bkpf = 'X'.
    perform read_bkpf_neu
    using bsik-bukrs bsik-belnr bsik-gjahr 'X'              "455320
    changing subrcbkpf.
    check subrcbkpf = 0.
  endif.
  if flg_bseg = 'X'.
    perform read_bseg_neu using bsik-bukrs bsik-belnr bsik-gjahr
                                bsik-buzei
                          changing subrcbseg.
    check subrcbseg = 0.
  endif.

  if not krit1 is initial.
    xbsikgr-krit1 = krit1.
    xbsik-krit1 = krit1.
    perform check_betragsfelder using krit1.                "365889
    if not x_betrag is initial.                             "418389
      move <f1> to xbsik-bedg1.                             "365889
      move <f1> to xbsikgr-bedg1.                           "365889
    else.                                                   "365889
      write <f1> to xbsik-bedg1.                            "333215
      write <f1> to xbsikgr-bedg1.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsik-bedg1 is initial.
      while xbsik-bedg1(01) is initial.
        shift xbsik-bedg1.
        shift xbsikgr-bedg1.
      endwhile.
    endif.
  endif.

  if not krit2 is initial.
    xbsikgr-krit2 = krit2.
    xbsik-krit2 = krit2.
    perform check_betragsfelder using krit2.                "365889
    if not x_betrag is initial.                             "418389
      move <f2> to xbsik-bedg2.                             "365889
      move <f2> to xbsikgr-bedg2.                           "365889
    else.                                                   "365889
      write <f2> to xbsik-bedg2.                            "333215
      write <f2> to xbsikgr-bedg2.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsik-bedg2 is initial.
      while xbsik-bedg2(01) is initial.
        shift xbsik-bedg2.
        shift xbsikgr-bedg2.
      endwhile.
    endif.
  endif.

  if not krit3 is initial.
    xbsikgr-krit3 = krit3.
    xbsik-krit3 = krit3.
    perform check_betragsfelder using krit3.                "365889
    if not x_betrag is initial.                             "418389
      move <f3> to xbsik-bedg3.                             "365889
      move <f3> to xbsikgr-bedg3.                           "365889
    else.                                                   "365889
      write <f3> to xbsik-bedg3.                            "333215
      write <f3> to xbsikgr-bedg3.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsik-bedg3 is initial.
      while xbsik-bedg3(01) is initial.
        shift xbsik-bedg3.
        shift xbsikgr-bedg3.
      endwhile.
    endif.
  endif.

  if not krit4 is initial.
    xbsikgr-krit4 = krit4.
    xbsik-krit4 = krit4.
    perform check_betragsfelder using krit4.                "365889
    if not x_betrag is initial.                             "418389
      move <f4> to xbsik-bedg4.                             "365889
      move <f4> to xbsikgr-bedg4.                           "365889
    else.                                                   "365889
      write <f4> to xbsik-bedg4.                            "333215
      write <f4> to xbsikgr-bedg4.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsik-bedg4 is initial.
      while xbsik-bedg4(01) is initial.
        shift xbsik-bedg4.
        shift xbsikgr-bedg4.
      endwhile.
    endif.
  endif.

  if not krit5 is initial.
    xbsikgr-krit5 = krit5.
    xbsik-krit5 = krit5.
    perform check_betragsfelder using krit5.                "365889
    if not x_betrag is initial.                             "418389
      move <f5> to xbsik-bedg5.                             "365889
      move <f5> to xbsikgr-bedg5.                           "365889
    else.                                                   "365889
      write <f5> to xbsik-bedg5.                            "333215
      write <f5> to xbsikgr-bedg5.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsik-bedg5 is initial.
      while xbsik-bedg5(01) is initial.
        shift xbsik-bedg5.
        shift xbsikgr-bedg5.
      endwhile.
    endif.
  endif.

  append xbsik.
  collect xbsikgr.

endform.                               " XBSIK_XBSIKGR_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  XBSIS_XBSISGR_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form xbsis_xbsisgr_fuellen.
  data: subrcbkpf like sy-subrc.
  data: subrcbseg like sy-subrc.
  data: ld_ignore_doc(1) type c.

  clear xwrbtr.
  if bsis-pswbt = 0.
    perform fill_pswbt using    bsis-bukrs bsis-waers bsis-dmbtr
                                bsis-wrbtr 'X'
                       changing bsis-pswbt.
  endif.

  move-corresponding bsis to xbsis.
  if xf124e = 'X'.
    perform  wrbtr_umrechnen using koart
                          changing ld_ignore_doc.
    check ld_ignore_doc = space.
  endif.
  if xwrbtr = 'X'.
    xbsis-xcurr = awaers.
  else.
    xbsis-xamnt = xbsis-pswbt.
    xbsis-xcurr = xbsis-pswsl.
  endif.

  move-corresponding xbsis to xbsisgr.
  if bsis-shkzg = 'H'.
    xbsisgr-bet_tw = - xbsis-xamnt.
  else.
    xbsisgr-bet_tw =  xbsis-xamnt.
  endif.

  if xsobebvk = 'X'.
    perform feldsymbole_veraendern_bvk using bsis-bukrs bsis-hkont.
  endif.
  xsobeerf = 'X'.
*----- Sonderbearbeitung f¨¹r WE/RE-Konten ------------------------------
  if xsobwere = 'X'.
    perform sonderbearbeitung_were changing subrcbkpf subrcbseg.
    check subrcbkpf = 0 and subrcbseg = 0.
  endif.

  if flg_bkpf = 'X'.
    perform read_bkpf_neu
    using bsis-bukrs bsis-belnr bsis-gjahr 'X'              "455320
    changing subrcbkpf.
    check subrcbkpf = 0.
  endif.
  if flg_bseg = 'X'.                                        "454904
    perform read_bseg_neu using bsis-bukrs bsis-belnr bsis-gjahr
                                bsis-buzei
                          changing subrcbseg.
    check subrcbseg = 0.
  endif.

  if not krit1 is initial.
    xbsisgr-krit1 = krit1.
    xbsis-krit1 = krit1.
    if xsobeerf = 'X'.
      perform check_betragsfelder using krit1.              "365889
      if not x_betrag is initial.                           "418389
        move <f1> to xbsis-bedg1.                           "365889
        move <f1> to xbsisgr-bedg1.                         "365889
      else.                                                 "365889
        write <f1> to xbsis-bedg1.                          "333215
        write <f1> to xbsisgr-bedg1.                        "333215
      endif.                                                "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
      if not xbsis-bedg1 is initial.
        while xbsis-bedg1(01) is initial.
          shift xbsis-bedg1.
          shift xbsisgr-bedg1.
        endwhile.
      endif.
    endif.
  endif.

  if not krit2 is initial.
    xbsisgr-krit2 = krit2.
    xbsis-krit2 = krit2.
    perform check_betragsfelder using krit2.                "365889
    if not x_betrag is initial.                             "418389
      move <f2> to xbsis-bedg2.                             "365889
      move <f2> to xbsisgr-bedg2.                           "365889
    else.                                                   "365889
      write <f2> to xbsis-bedg2.                            "333215
      write <f2> to xbsisgr-bedg2.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsis-bedg2 is initial.
      while xbsis-bedg2(01) is initial.
        shift xbsis-bedg2.
        shift xbsisgr-bedg2.
      endwhile.
    endif.
  endif.

  if not krit3 is initial.
    xbsisgr-krit3 = krit3.
    xbsis-krit3 = krit3.
    perform check_betragsfelder using krit3.                "365889
    if not x_betrag is initial.                             "418389
      move <f3> to xbsis-bedg3.                             "365889
      move <f3> to xbsisgr-bedg3.                           "365889
    else.                                                   "365889
      write <f3> to xbsis-bedg3.                            "333215
      write <f3> to xbsisgr-bedg3.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsis-bedg3 is initial.
      while xbsis-bedg3(01) is initial.
        shift xbsis-bedg3.
        shift xbsisgr-bedg3.
      endwhile.
    endif.
  endif.

  if not krit4 is initial.
    xbsisgr-krit4 = krit4.
    xbsis-krit4 = krit4.
    perform check_betragsfelder using krit4.                "365889
    if not x_betrag is initial.                             "418389
      move <f4> to xbsis-bedg4.                             "365889
      move <f4> to xbsisgr-bedg4.                           "365889
    else.                                                   "365889
      write <f4> to xbsis-bedg4.                            "333215
      write <f4> to xbsisgr-bedg4.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsis-bedg4 is initial.
      while xbsis-bedg4(01) is initial.
        shift xbsis-bedg4.
        shift xbsisgr-bedg4.
      endwhile.
    endif.
  endif.

  if not krit5 is initial.
    xbsisgr-krit5 = krit5.
    xbsis-krit5 = krit5.
    perform check_betragsfelder using krit5.                "365889
    if not x_betrag is initial.                             "418389
      move <f5> to xbsis-bedg5.                             "365889
      move <f5> to xbsisgr-bedg5.                           "365889
    else.                                                   "365889
      write <f5> to xbsis-bedg5.                            "333215
      write <f5> to xbsisgr-bedg5.                          "333215
    endif.                                                  "365889
*----- Fuehrende Leerzeichen entfernen, f. Betraege notwendig ----------
    if not xbsis-bedg5 is initial.
      while xbsis-bedg5(01) is initial.
        shift xbsis-bedg5.
        shift xbsisgr-bedg5.
      endwhile.
    endif.
  endif.

  append xbsis.
  collect xbsisgr.
  check not pzbsisgr is initial.
  zaehler_xbsisgr = zaehler_xbsisgr + 1.
  if zaehler_xbsisgr > pzbsisgr.
    describe table xbsisgr lines sy-tfill.
    if sy-tfill >= pzbsisgr.
      x_exit = 'X'.
    endif.
  endif.
endform.                               " XBSIS_XBSISGR_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  FILL_PSWBT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_BSIS_BUKRS  text
*      -->P_BSIS_WAERS  text
*      -->P_BSIS_DMBTR  text
*      -->P_BSIS_WRBTR  text
*      <--P_BSIS_PSWBT  text
*----------------------------------------------------------------------*
form fill_pswbt using    i_bukrs i_waers i_dmbtr i_wrbtr i_flag
                changing e_pswbt.
  if i_bukrs ne t001-bukrs.
    select single * from t001
           where bukrs eq i_bukrs.
  endif.
*
  if i_flag is initial.
    if t001-waers eq i_waers.
      e_pswbt = i_dmbtr.
    else.
      e_pswbt = i_wrbtr.
    endif.
  else.
    if bsis-pswsl eq t001-waers.
      e_pswbt = i_dmbtr.
    else.
      e_pswbt = i_wrbtr.
    endif.
  endif.
endform.                               " FILL_PSWBT
*&---------------------------------------------------------------------*
*&      Form  WRBTR_UMRECHNEN
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form wrbtr_umrechnen using koart
                     changing p_ignore_doc.
  data: begin of const_zuonr,
          kukey like febep-kukey,
          esnum like febep-esnum,
          kwaer like febep-kwaer,
       end of const_zuonr.
  Data: Refe16 type Wrbtr_x8.                               "972624
  data: wsubrc like sy-subrc.
  data: ld_fixed_rate like tcurr-ukurs.                     "439312
  data: ld_new_waers like bkpf-waers.
  data: ld_save_subrc like sy-subrc.

  case koart.
    when 'D'.
*-----------------------------------------------------------------------
*       Ausgleich in Drittw#hrung
*
*       POSTAB-PSWSL =/= POSTAB-WAERS ist nur bei Sachkonten m#glich,
*       die ihre Salden in Hausw#hrung haben, f¨¹r alle anderen Konten
*       sind die beiden Abfragen bedeutungsgleich. F¨¹r die Sachkonten
*       mit Salden in Hausw#hrung gilt:
*
*       Ausgleich in Hausw#hrung:  POSTAB-PSWSL = BKPF-WAERS, also
*                                  keinerlei Umrechnungen
*       Ausgleich in Belegw#hrung: POSTAB-WAERS = BKPF-WAERS, also
*                                  keinerlei Umrechnungen
*       Ausgleich in Drittw#hrung: POSTAB-WAERS =/= BKPF-WAERS und
*                                  POSTAB-PSWSL =/= BKPF-WAERS
*-----------------------------------------------------------------------
      if zwaers is initial.
        awaers = xbsid-waers.
      else.
        awaers = zwaers.
      endif.
      if xauslw = 'X' and gd_no_get_subsequent = space.
        clear ld_save_subrc.
        if gd_read_tcur_bukrs = 'X'.
          if gt_tcur_bukrs-bukrs ne xbsid-bukrs.
            read table gt_tcur_bukrs with key xbsid-bukrs.
            ld_save_subrc = sy-subrc.
          endif.
        endif.
        if ld_save_subrc = 0.
          perform currency_get_subsequent using awaers
                                                augdt
                                                xbsid-bukrs
                                          changing ld_new_waers.
          if awaers ne ld_new_waers.
            awaers = ld_new_waers.
          endif.
        endif.
      endif.
*------- Pr¨¹fe, ob ein Ausgleich in dieser W#hrung erlaubt ist ---------
*------- Es k#nnte auch eine auslaufende W#hrung vorgegeben worden sein
      perform currency_expiration_check using awaers augdt xbsid-bukrs
                                        changing p_ignore_doc.
      check p_ignore_doc = space.

      If Xbsid-Pycur eq Awaers                                   "878401
      and Xbsid-Pyamt ne 0.                                      "878401
         Xbsid-Xamnt = Xbsid-Pyamt.                              "878401
         Xwrbtr = 'X'.                                           "878401
      Elseif xbsid-waers ne awaers                               "878401
      and xbsid-pswsl ne awaers.
*------- Ursprungsbetrag retten ----------------------------------------
        old_wrbtr = xbsid-wrbtr.


        select single * from  bkpf
               where  bukrs       = xbsid-bukrs
               and    belnr       = xbsid-belnr
               and    gjahr       = xbsid-gjahr.
        check sy-subrc = 0.
        if xbsid-bukrs ne t001-bukrs.
          select single * from t001 where bukrs = xbsid-bukrs.
          check sy-subrc = 0.
        endif.
*------- Ausgleich in Hausw#hrung ohne erneute Kursumrechnung ? --------
        if  t001-waers eq awaers
        and t001-xslta ne space.
          xbsid-xamnt = xbsid-dmbtr.

*------- Umrechnen Belegw#hrung in Hausw#hrung der Position ------------
        else.
          call function 'READ_EXCHANGE_RATE'                "439312
          exporting date = augdt                            "439312
                    foreign_currency = awaers               "439312
                    local_currency   = xbsid-waers          "439312
          importing fixed_rate = ld_fixed_rate              "439312
          exceptions others = 7.                            "455974
          if sy-subrc = 0                                   "455974
          and not ld_fixed_rate is initial.                 "455974
            call function 'CONVERT_FOREIGN_TO_FOREIGN_CUR'  "439312
            exporting date = augdt                          "439312
                      from_amount = xbsid-wrbtr             "439312
                      from_currency = xbsid-waers           "439312
                      to_currency   = awaers                "439312
                      local_currency = bkpf-hwaer           "439312
            importing to_amount = xbsid-xamnt.
          else.                                             "439312
            if xbsid-waers ne bkpf-hwaer.
              call function 'CONVERT_TO_LOCAL_CURRENCY'
                EXPORTING
                  date             = augdt
                  foreign_amount   = xbsid-wrbtr
                  foreign_currency = xbsid-waers
                  local_currency   = bkpf-hwaer
                IMPORTING
                  local_amount     = refe16.
            else.
              refe16 = xbsid-wrbtr.
            endif.

*------- Umrechnen Hausw#hrung der Position in Zahlungsw#hrung ---------
            if bkpf-hwaer ne awaers.
              call function 'CONVERT_TO_FOREIGN_CURRENCY'
                   exporting  date             = augdt
                              local_amount     = refe16
                              foreign_currency = awaers
                              local_currency   = bkpf-hwaer
*                        rate             = bkpf-kursf
                   importing  foreign_amount   = xbsid-xamnt.
            else.
              xbsid-xamnt = refe16.
            endif.
          endif.                                            "439312
        endif.
        xwrbtr = 'X'.
      endif.
    when 'K'.
      if zwaers is initial.
        awaers = xbsik-waers.
      else.
        awaers = zwaers.
      endif.
      if xauslw = 'X' and gd_no_get_subsequent = space.
        clear ld_save_subrc.
        if gd_read_tcur_bukrs = 'X'.
          if gt_tcur_bukrs-bukrs ne xbsik-bukrs.
            read table gt_tcur_bukrs with key xbsik-bukrs.
            ld_save_subrc = sy-subrc.
          endif.
        endif.
        if ld_save_subrc = 0.
          perform currency_get_subsequent using awaers
                                                augdt
                                                xbsik-bukrs
                                          changing ld_new_waers.
          if awaers ne ld_new_waers.
            awaers = ld_new_waers.
          endif.
        endif.
      endif.
*------- Pr¨¹fe, ob ein Ausgleich in dieser W#hrung erlaubt ist ---------
*------- Es k#nnte auch eine auslaufende W#hrung vorgegeben worden sein
      perform currency_expiration_check using awaers augdt xbsik-bukrs
                                        changing p_ignore_doc.
      check p_ignore_doc = space.

      If Xbsik-Pycur eq Awaers                                   "878401
      and Xbsik-Pyamt ne 0.                                      "878401
         Xbsik-Xamnt = Xbsik-Pyamt.                              "878401
         Xwrbtr = 'X'.                                           "878401
      Elseif xbsik-waers ne awaers                               "878401
      and xbsik-pswsl ne awaers.
*------- Ursprungsbetrag retten ----------------------------------------
        old_wrbtr = xbsik-wrbtr.


        select single * from  bkpf
               where  bukrs       = xbsik-bukrs
               and    belnr       = xbsik-belnr
               and    gjahr       = xbsik-gjahr.
        check sy-subrc = 0.
        if xbsik-bukrs ne t001-bukrs.
          select single * from t001 where bukrs = xbsik-bukrs.
          check sy-subrc = 0.
        endif.
*------- Ausgleich in Hausw#hrung ohne erneute Kursumrechnung ? --------
        if  t001-waers eq awaers
        and t001-xslta ne space.
          xbsik-xamnt = xbsik-dmbtr.

*------- Umrechnen Belegw#hrung in Hausw#hrung der Position ------------
        else.
          call function 'READ_EXCHANGE_RATE'                "439312
          exporting date = augdt                            "439312
                    foreign_currency = awaers               "439312
                    local_currency   = xbsik-waers          "439312
          importing fixed_rate = ld_fixed_rate              "439312
          exceptions others = 7.                            "455974
          if sy-subrc = 0                                   "455974
          and not ld_fixed_rate is initial.                 "455974
            call function 'CONVERT_FOREIGN_TO_FOREIGN_CUR'  "439312
            exporting date = augdt                          "439312
                      from_amount = xbsik-wrbtr             "439312
                      from_currency = xbsik-waers           "439312
                      to_currency   = awaers                "439312
                      local_currency = bkpf-hwaer           "439312
            importing to_amount = xbsik-xamnt.
          else.                                             "439312
            if xbsik-waers ne bkpf-hwaer.
              call function 'CONVERT_TO_LOCAL_CURRENCY'
                EXPORTING
                  date             = augdt
                  foreign_amount   = xbsik-wrbtr
                  foreign_currency = xbsik-waers
                  local_currency   = bkpf-hwaer
                IMPORTING
                  local_amount     = refe16.
            else.
              refe16 = xbsik-wrbtr.
            endif.

*------- Umrechnen Hausw#hrung der Position in Zahlungsw#hrung ---------
            if bkpf-hwaer ne awaers.
              call function 'CONVERT_TO_FOREIGN_CURRENCY'
                   exporting  date             = augdt
                              local_amount     = refe16
                              foreign_currency = awaers
                              local_currency   = bkpf-hwaer
*                        rate             = bkpf-kursf
                   importing  foreign_amount   = xbsik-xamnt.
            else.
              xbsik-xamnt = refe16.
            endif.
          endif.                                            "439132
        endif.
        xwrbtr = 'X'.
      endif.
    when 'S'.
*------- Ausgleichsw#hrung awaers festlegen ----------------------------
* 1.Bei W#hrung aus Zuordnung ist awaers entweder Zuordnungsw#hrung
*   oder Belegw#hrung (falls Zuzordnungsw#hrung nicht existiert):
*   Die Ausgleichsw#hrung kann man in diesem Fall nicht vorgeben, d.h.
*   zwaers = space.
*   Sollen auslaufende W#hrungen ber¨¹cksichtigt werden, wird awaers
*   ebentuell durch die Nachfolgew#hrung ersetzt
* 2.Bei W#hrung nicht aus Zuordnung ist awaers entweder
*   die vorgegebene Ausgleichsw#hrung (falls auslaufende W#hrung
*   nicht ber¨¹cksichtigt werden sollen), die Belegw#hrung (falls
*   auslaufende W#hrungen ber¨¹cksichtigt werden sollen) oder die
*   Zuordnungsw#hrung (falls doch etwas in der Zuordnung stand)
*   Sollen auslaufende W#hrungen ber¨¹cksichtigt werden, wird awaers
*   ebentuell durch die Nachfolgew#hrung ersetzt

*------- W#hrung aus Zuordnung? ----------------------------------------
      if xsobebvk = 'X'.
*------- ... ja --------------------------------------------------------
        const_zuonr = xbsis-zuonr.
*------- Ist es auch wirklich eine W#hrung? ----------------------------
        if const_zuonr-kukey co '0123456789'                "357657
        and const_zuonr-esnum co '0123456789'.              "357657
          awaers = const_zuonr-kwaer.
          perform waehrung_pruefen using awaers.
          if awaers = space.
*------- W#hrung aus Zuordnung war ung¨¹ltig, setze Belegw#hrung
            awaers = xbsis-waers.
          endif.
        else.
*------- ... nein, setze Belegw#hrung
          awaers = xbsis-waers.
        endif.                                              "357657
      else.
        if zwaers is initial.
          awaers = xbsis-waers.
        else.
          awaers = zwaers.
        endif.
      endif.
      check awaers ne space.
      if xauslw = 'X' and gd_no_get_subsequent = space.
        clear ld_save_subrc.
        if gd_read_tcur_bukrs = 'X'.
          if gt_tcur_bukrs-bukrs ne xbsis-bukrs.
            read table gt_tcur_bukrs with key xbsis-bukrs.
            ld_save_subrc = sy-subrc.
          endif.
        endif.
        if ld_save_subrc = 0.
          perform currency_get_subsequent using awaers
                                                augdt
                                                xbsis-bukrs
                                          changing ld_new_waers.
          if awaers ne ld_new_waers.
            awaers = ld_new_waers.
          endif.
        endif.
      endif.
*------- Pr¨¹fe, ob ein Ausgleich in dieser W#hrung erlaubt ist ---------
*------- Es k#nnte auch eine auslaufende W#hrung vorgegeben worden sein
      perform currency_expiration_check using awaers augdt xbsis-bukrs
                                        changing p_ignore_doc.
      check p_ignore_doc = space.

      if xbsis-waers = awaers.
        xbsis-xamnt = xbsis-wrbtr.
        xwrbtr = 'X'.
      elseif xbsis-pswsl ne awaers.
*------- Ursprungsbetrag retten ----------------------------------------
        old_wrbtr = xbsis-wrbtr.


        select single * from  bkpf
               where  bukrs       = xbsis-bukrs
               and    belnr       = xbsis-belnr
               and    gjahr       = xbsis-gjahr.
        check sy-subrc = 0.
        if xbsis-bukrs ne t001-bukrs.
          select single * from t001 where bukrs = xbsis-bukrs.
          check sy-subrc = 0.
        endif.
*------- Ausgleich in Hausw#hrung ohne erneute Kursumrechnung ? --------
        if  t001-waers eq awaers
        and t001-xslta ne space.
          xbsis-xamnt = xbsis-dmbtr.

*------- Umrechnen Belegw#hrung in Hausw#hrung der Position ------------
        else.
          call function 'READ_EXCHANGE_RATE'                "439312
          exporting date = augdt                            "439312
                    foreign_currency = awaers               "439312
                    local_currency   = xbsis-waers          "439312
          importing fixed_rate = ld_fixed_rate              "439312
          exceptions others = 7.                            "455974
          if sy-subrc = 0                                   "455974
          and not ld_fixed_rate is initial.                 "455974
            call function 'CONVERT_FOREIGN_TO_FOREIGN_CUR'  "439312
            exporting date = augdt                          "439312
                      from_amount = xbsis-wrbtr             "439312
                      from_currency = xbsis-waers           "439312
                      to_currency   = awaers                "439312
                      local_currency = bkpf-hwaer           "439312
            importing to_amount = xbsis-xamnt.
          else.                                             "439312
            if xbsis-waers ne bkpf-hwaer.
              call function 'CONVERT_TO_LOCAL_CURRENCY'
                EXPORTING
                  date             = augdt
                  foreign_amount   = xbsis-wrbtr
                  foreign_currency = xbsis-waers
                  local_currency   = bkpf-hwaer
                IMPORTING
                  local_amount     = refe16.
            else.
              refe16 = xbsis-wrbtr.
            endif.

*------- Umrechnen Hausw#hrung der Position in Zahlungsw#hrung ---------
            if bkpf-hwaer ne awaers.
              call function 'CONVERT_TO_FOREIGN_CURRENCY'
                   exporting  date             = augdt
                              local_amount     = refe16
                              foreign_currency = awaers
                              local_currency   = bkpf-hwaer
*                        rate             = bkpf-kursf
                   importing  foreign_amount   = xbsis-xamnt.
            else.
              xbsis-xamnt = refe16.
            endif.
          endif.                                            "439312
        endif.
        xwrbtr = 'X'.
      endif.
  endcase.
endform.                               " WRBTR_UMRECHNEN
*&---------------------------------------------------------------------*
*&      Form  WAEHRUNG_PRUEFEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_AWAERS  text
*----------------------------------------------------------------------*
form waehrung_pruefen using    p_awaers.
  check p_awaers ne space.
  select single * from tcurc where waers = p_awaers.
  if sy-subrc ne 0.
    clear p_awaers.
  endif.
endform.                               " WAEHRUNG_PRUEFEN
*&---------------------------------------------------------------------*
*&      Form  FELDSYMBOLE_VERAENDERN_AVIS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_BSID_BUKRS  text
*      -->P_BSID_KUNNR  text
*----------------------------------------------------------------------*
form feldsymbole_veraendern_avis.
  data: bedingung(35) type c.

  krit1 = 'BSID-XREF3'.
  bedingung = 'BSID-XREF3'.
  assign table field (bedingung) to <f1>.
  clear: krit2, krit3, krit4, krit5.
endform.                               " FELDSYMBOLE_VERAENDERN_AVIS
*&---------------------------------------------------------------------*
*&      Form  FELDSYMBOLE_VER#NDERN_BVK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form feldsymbole_veraendern_bvk using pbukrs like bsis-bukrs
                                      phkont like bsis-hkont.
  data: bedingung(35) type c.

  if ( last_pbukrs ne pbukrs or last_phkont ne phkont )
  and xsobebvk = 'X'.
* Note 310882

    krit1 = 'BSIS-ZUONR'.
    bedingung = 'BSIS-ZUONR'.
    assign table field (bedingung) to <f1>.
    clear: krit2, krit3, krit4, krit5.
    last_pbukrs = pbukrs.
    last_phkont = phkont.
  else.
    exit.
  endif.
endform.                               " FELDSYMBOLE_VERAENDERN_BVK
*&---------------------------------------------------------------------*
*&      Form  FELDSYMBOLE_VER#NDERN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form feldsymbole_veraendern using pbukrs like bsis-bukrs
                                  phkont like bsis-hkont.
  data: bedingung(35) type c.

  if last_pbukrs ne pbukrs or last_phkont ne phkont.       "Note 310882
    krit1 = 'BSIS-XREF3'.
    bedingung = 'BSIS-XREF3'.
    assign table field (bedingung) to <f1>.
    krit2 = 'BSEG-EBELN'.
    bedingung = 'BSEG-EBELN'.
    assign table field (bedingung) to <f2>.
    krit3 = 'BSEG-EBELP'.
    bedingung = 'BSEG-EBELP'.
    assign table field (bedingung) to <f3>.
    krit4 = 'BSIS-GSBER'.
    bedingung = 'BSIS-GSBER'.
    assign table field (bedingung) to <f4>.
    clear krit5.
    last_pbukrs = pbukrs.
    last_phkont = phkont.
  else.
    exit.
  endif.
endform.                               " FELDSYMBOLE_VERAENDERN
*&---------------------------------------------------------------------*
*&      Form  SONDERBERARBEITUNG_WERE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form sonderbearbeitung_were changing e_subrcbkpf
                                     e_subrcbseg.

  read table iwere with key bukrs = bsis-bukrs hkont = bsis-hkont.
  if sy-subrc = 0.
    clear xsobeerf.
    perform refresh_were_tables.
*----- Kriterien aus TF123 ver#ndern -----------------------------------
    perform feldsymbole_veraendern using bsis-bukrs bsis-hkont.
*----- Wird gepr¨¹ft, ob das Feld XREF gef¨¹llt ist oder nicht     "377410
*----- Wenn ja, wird das Unterprogramm abgebrochen               "377410
    if not ( bsis-xref3 is initial or bsis-xref3+4(1) = '*' )."377410
      xsobeerf = 'X'.                                       "377410
      exit.                                                 "377410
    endif.                                                  "377410
    if rcekbe ne 0.                                         "454904
*----- Kennzeichen WE-Bezogene Rechnung gesetzt? -----------------------
      perform ekpo_lesen.
    endif.                                                  "454904
    if rcekpo = 0.
*----- Bestellentwicklung ermitteln ------------------------------------
      perform bestellentwicklung_ermitteln.
      if rciekbe = 0.                                       "454904
        clear docok.
        loop at iekbe.                                      "454904
*Vorsicht: eine Sollbuchung auf dem WE/RE-Konto im FI entspricht nicht
*unbedingt einem RE im MM.
*----- AWREF und AWORG ermitteln ---------------------------------------
          rcappend = 4.
          rcmkpf = 4.
          rcrbkp = 4.
          rcbkpf = 4.
          if iekbe-vgabe = '1'.
            perform mkpf_lesen.
          endif.
          if iekbe-vgabe = '2' or iekbe-vgabe = '3'.
            perform rbkp_lesen.
          endif.
          if rcmkpf = 0 or rcrbkp = 0 or rcbkpf = 0.
*----- Mit AWREF und AWORG zugh#rigen RW-Beleg ermitteln ---------------
            perform rw_beleg_bestimmen.
*----- Richtiger Beleg gefunden ? --------------------------------------
            if docok = 'X'.
              if ekpo-pstyp = '9'.                          "432613
                concatenate iekbe-lfgja iekbe-lfbnr         "432613
                into bsis-xref3.                            "432613
              else.                                         "432613
                concatenate iekbe-lfgja iekbe-lfbnr iekbe-lfpos
                into bsis-xref3.
              endif.                                        "432613
              xsobeerf = 'X'.
              exit.                                         "454904
            endif.
          endif.
        endloop.                                            "454904
      endif.
    endif.
  endif.
endform.                               " Sonderbearbeitung_WERE
*&---------------------------------------------------------------------*
*&      Form  REFRESH_WERE_TABLES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form refresh_were_tables.
  data: linmax like sy-tfill value '300'.
  check ctixaccdn gt linmax.
  clear: ixaccdn.
  refresh:  ixaccdn.
  ctixaccdn = 0.
endform.                               " REFRESH_WERE_TABLES
*&---------------------------------------------------------------------*
*&      Form  EKPO_LESEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form ekpo_lesen.
  rcekpo = 4.
*----- gepuffertes Lesen der EKPO --------------------------------------
  call function 'ME_EKPO_SINGLE_READ'
    EXPORTING
      pi_ebeln            = ibsis-ebeln                     "454904
      pi_ebelp            = ibsis-ebelp                     "454904
      pi_bypassing_buffer = ' '
      pi_refresh_buffer   = ' '
    IMPORTING
      po_ekpo             = ekpo
    EXCEPTIONS
      no_records_found    = 1
      others              = 2.
  if sy-subrc = 0.
    if ekpo-webre = 'X'.
      rcekpo = 0.
    endif.
  endif.
endform.                               " EKPO_LESEN
*&---------------------------------------------------------------------*
*&      Form  BESTELLENTWICKLUNG_ERMITTELN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form bestellentwicklung_ermitteln.

  if rcekbe ne 0.
    clear: ekbetab,
           iekbes,
           iekbez,
           iekbnk,
           iekbz.
    refresh: ekbetab,
             iekbes,
             iekbez,
             iekbnk,
             iekbz.
*   CALL FUNCTION 'ME_READ_HISTORY'
*        EXPORTING
*             EBELN   = EKPO-EBELN
*             EBELP   = EKPO-EBELP
*             WEBRE   = EKPO-WEBRE
*        TABLES
*             XEKBE   = EKBETAB
*             XEKBES  = IEKBES
*             XEKBEZ  = IEKBEZ
*             XEKBNK  = IEKBNK
*             XEKBZ   = IEKBZ
*        EXCEPTIONS
*             OTHERS  = 1.
    call function 'ME_READ_HISTORY_HEADER'
      EXPORTING
        i_ebeln   = ibsis-ebeln                             "454904
        i_ebelp   = ibsis-ebelp                             "454904
      TABLES
        t_ekbe    = ekbetab
      EXCEPTIONS
        not_found = 1
        others    = 2.

    if sy-subrc = 0.
      rcekbe = 0.
*------- Nur WE und RE ber¨¹cksichtigen ---------------------------------
      perform ekbetab_reduzieren.
      perform iekbe_fuellen.
      perform iekbe_sortieren.
    endif.
  endif.
endform.                               " BESTELLENTWICKLUNG_ERMITTELN
*&---------------------------------------------------------------------*
*&      Form  EKBETAB_REDUZIEREN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form ekbetab_reduzieren.
  delete ekbetab where vgabe ne '1'                         " 1 = WE
                   and vgabe ne '2'                         " 2 = RE
                   and vgabe ne '3'.   " 3 = Nachbelastung
endform.                               " EKBETAB_REDUZIEREN
*&---------------------------------------------------------------------*
*&      Form  IEKBE_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form iekbe_fuellen.
  loop at ekbetab.
    iekbe = ekbetab.
    append iekbe.
    rciekbe = 0.                                            "454904
  endloop.
endform.                               " IEKBE_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  IEKBE_SORTIEREN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form iekbe_sortieren.
  sort iekbe by ebeln ebelp bewtp
                      gjahr belnr buzei.
endform.                               " IEKBE_SORTIEREN
*&---------------------------------------------------------------------*
*&      Form  MKPF_LESEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form mkpf_lesen.
  read table ixaccdn with key awtyp = 'MKPF'
                              awref = iekbe-belnr
                              aworg = iekbe-gjahr.
  if sy-subrc = 0.
    rcmkpf = 0.
  else.
    select single * from mkpf where mblnr = iekbe-belnr
                                and mjahr = iekbe-gjahr.
    if sy-subrc = 0.
      rcmkpf = 0.
      rcappend = 0.
    endif.
  endif.
endform.                               " MKPF_LESEN
*&---------------------------------------------------------------------*
*&      Form  RBKP_LESEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form rbkp_lesen.
  data: subrcbkpf like sy-subrc.
  data: aworgbkpf like acchd-aworg.
*----- document of MR11? Can't decide whether old or new document"363689
  if ( iekbe-vgabe = '2' and iekbe-bewtp = 'K' ).           "363689
    read table ixaccdn with key awtyp = 'RMRP'              "363689
                                awref = iekbe-belnr         "363689
                                aworg = iekbe-gjahr.        "363689
    if sy-subrc = 0.                                        "363689
      rcrbkp = 0.                                           "363689
    else.                                                   "363689
      call function 'MRM_RBKP_SINGLE_READ'                  "363689
      exporting i_belnr     = iekbe-belnr                   "363689
                i_gjahr     = iekbe-gjahr                   "363689
                i_buffer_on = 'X'                           "363689
      importing e_rbkp      = rbkptab                       "363689
      exceptions entry_not_found = 1                        "363689
                 others          = 2.                       "363689
      if sy-subrc = 0.                                      "363689
        rcrbkp = 0.                                         "363689
        rcappend = 0.                                       "363689
      endif.                                                "363689
    endif.                                                  "363689
    if sy-subrc ne 0.                                       "363689
      concatenate bsis-bukrs iekbe-gjahr into aworgbkpf.    "454904
      read table ixaccdn with key awtyp = 'BKPF'            "363689
                                  awref = iekbe-belnr       "363689
                                  aworg = aworgbkpf.        "363689
      if sy-subrc = 0.                                      "363689
        rcrbkp = 0.                                         "363689
      else.                                                 "363689
        perform read_bkpf_neu                               "363689
        using bsis-bukrs iekbe-belnr iekbe-gjahr space      "455320
        changing subrcbkpf.                                 "454904
        if subrcbkpf = 0.                                   "363689
          rcbkpf = 0.                                       "363689
          rcappend = 0.                                     "363689
        else.                                               "363689
          rcbkpf = 9.                                       "363689
        endif.                                              "363689
      endif.                                                "363689
    endif.                                                  "363689
  else.                                                     "363689
*----- Rechnungen/Nachbelastungen aus der log. RP oder alte Rechnungen?
*----- bei Nachbelast. vgabe = '3', vgl. Fugr MRMP form EKBE_aufbauen
    if ( iekbe-vgabe = '2' and
       ( iekbe-bewtp = 'Q' or iekbe-bewtp = 'N' ) )
    or ( iekbe-vgabe = '3' and
       ( iekbe-bewtp = 'N' or iekbe-bewtp = 'W' ) ).
*----- neu... (aus log. RP, neu ab 3.0) --------------------------------
      read table ixaccdn with key awtyp = 'RMRP'
                                  awref = iekbe-belnr
                                  aworg = iekbe-gjahr.
    else.
*----- alt... ----------------------------------------------------------
      concatenate bsis-bukrs iekbe-gjahr into aworgbkpf.    "454904
      read table ixaccdn with key awtyp = 'BKPF'
                                  awref = iekbe-belnr
                                  aworg = aworgbkpf.
    endif.
    if sy-subrc = 0.
      rcrbkp = 0.
    else.
      if ( iekbe-vgabe = '2' and
         ( iekbe-bewtp = 'Q' or iekbe-bewtp = 'N' ) )
      or ( iekbe-vgabe = '3' and
         ( iekbe-bewtp = 'N' or iekbe-bewtp = 'W' ) ).
*----- Neue oder alte Rechnungspr¨¹fung ? -------------------------------
*----- ... neue --------------------------------------------------------

        call function 'MRM_RBKP_SINGLE_READ'
          EXPORTING
            i_belnr         = iekbe-belnr
            i_gjahr         = iekbe-gjahr
            i_buffer_on     = 'X'  "wegen Refresh im FUBA doch gut
          IMPORTING
            e_rbkp          = rbkptab
          EXCEPTIONS
            entry_not_found = 1
            others          = 2.
        if sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        endif.
        if sy-subrc = 0.
          rcrbkp = 0.
          rcappend = 0.
        endif.
      endif.
*----- ... alte --------------------------------------------------------
      if ( iekbe-vgabe = '2' and
         ( iekbe-bewtp = 'R' or iekbe-bewtp = 'K' ) )
      or ( iekbe-vgabe = '3' and
         ( iekbe-bewtp ne 'N' and iekbe-bewtp ne 'W' ) ).
        perform read_bkpf_neu
        using bsis-bukrs iekbe-belnr iekbe-gjahr space      "455320
        changing subrcbkpf.                                 "454904
        if subrcbkpf = 0.
          rcbkpf = 0.
          rcappend = 0.
        else.
          rcbkpf = 9.
        endif.
      endif.
    endif.
  endif.                                                    "363689
endform.                               " RBKP_LESEN
*&---------------------------------------------------------------------*
*&      Form  RW_BELEG_BESTIMMEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form rw_beleg_bestimmen.
  data: aworgbkpf like acchd-aworg.
  clear: xaccdn.
  refresh: xaccdn.
  if rcappend = 0.
    if iekbe-vgabe = '1'.
      awref    = mkpf-mblnr.
      aworg    = mkpf-mjahr.
      awtyp    = 'MKPF'.
      awsys    = mkpf-awsys.
    else.
      if rcrbkp = 0.
        awref    = rbkptab-belnr.
        aworg    = rbkptab-gjahr.
        awtyp    = 'RMRP'.
        awsys    = rbkptab-logsys.
      endif.
      if rcbkpf = 0.
        awref    = bkpf-awkey+00(10).
        aworg    = bkpf-awkey+10(10).
        awtyp    = bkpf-awtyp.
        awsys    = bkpf-awsys.
      endif.
    endif.
    if rcbkpf = 0.
*----- AC_Document_record nicht notwendig, da Beleg bereits FI-Beleg ist
      clear: xaccdn, ixaccdn.                               "420677
      ixaccdn-belnr = iekbe-belnr.
      ixaccdn-awref = awref.
      ixaccdn-aworg = aworg.
      ixaccdn-awsys = awsys.
      ixaccdn-awtyp = awtyp.
      ixaccdn-gjahr = bkpf-gjahr.                           "420677
      ixaccdn-bukrs = bkpf-bukrs.                           "420677
      ctixaccdn = ctixaccdn + 1.
      append ixaccdn.

      if  ixaccdn-belnr = bsis-belnr
      and ixaccdn-aworg+4(4) = bsis-gjahr
      and bsis-buzei = iekbe-buzei.
        docok = 'X'.
      endif.
    else.
      perform ac_document_record.
      if sy-subrc = 0.
        loop at xaccdn.
          ixaccdn = xaccdn.
          ctixaccdn = ctixaccdn + 1.
          append ixaccdn.
*----- Stimmt RW-Beleg mit aktuellem BSIS-Belegnr. ¨¹berein -------------
          if xaccdn-belnr = bsis-belnr
          and xaccdn-gjahr = bsis-gjahr.                    "309434
            docok = 'X'.
          endif.
        endloop.
      endif.
    endif.
  else.
    read table ixaccdn with key  belnr = bsis-belnr
                                 gjahr = bsis-gjahr.        "309434
    if sy-subrc = 0.
      if iekbe-vgabe = '1'.
        if  ixaccdn-awref = iekbe-belnr
        and ixaccdn-aworg = iekbe-gjahr.
          docok = 'X'.
        endif.
      else.
        if ( iekbe-vgabe = '2' and
           ( iekbe-bewtp = 'Q' or iekbe-bewtp = 'N' ) )
        or ( iekbe-vgabe = '3' and
           ( iekbe-bewtp = 'N' or iekbe-bewtp = 'W' ) ).
          if  ixaccdn-awref = iekbe-belnr
          and ixaccdn-aworg = iekbe-gjahr.
            docok = 'X'.
          endif.
        else.
          concatenate bsis-bukrs iekbe-gjahr into aworgbkpf."454904
          if  ixaccdn-awref = iekbe-belnr
          and ixaccdn-aworg = aworgbkpf
          and bsis-buzei    = iekbe-buzei.
            docok = 'X'.
          endif.
        endif.
      endif.
    endif.
  endif.
endform.                               " RW_BELEG_BESTIMMEN
*&---------------------------------------------------------------------*
*&      Form  AC_DOCUMENT_RECORD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form ac_document_record.
  xaccdn-awtyp = awtyp.
  xaccdn-awref = awref.
  xaccdn-aworg = aworg.
  xaccdn-awsys = awsys.
  append xaccdn.
  call function 'FI_DOCUMENT_NUMBER_GET'
    TABLES
      t_accdn = xaccdn.
endform.                               " AC_DOCUMENT_RECORD
*&---------------------------------------------------------------------*
*&      Form  READ_BKPF_NEU
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_BSID-BUKRS  text                                           *
*      -->P_BSID-BELNR  text                                           *
*      -->P_BSID-GJAHR  text                                           *
*----------------------------------------------------------------------*
form read_bkpf_neu using    bukrs like bseg-bukrs
                            belnr like bseg-belnr
                            gjahr like bseg-gjahr
                            xmesg type c                    "455320
                   changing e_subrc.
  check not ( bkpf-bukrs = bukrs                            "407054
          and bkpf-belnr = belnr                            "407054
          and bkpf-gjahr = gjahr ).                         "407054
  call function 'READ_DOCUMENT_HEADER'
    EXPORTING
      belnr          = belnr
      bukrs          = bukrs
      gjahr          = gjahr
      xarch          = ' '
    IMPORTING
      e_bkpf         = bkpf
    EXCEPTIONS
      exit           = 1
      not_found      = 2
      archive_cancel = 3
      others         = 4.
  if sy-subrc ne 0.
    e_subrc = sy-subrc.
    if xmesg = 'X'.                                         "455320
      perform record_fill
           using 'BKPF ' bukrs space space space belnr space char_s.
    endif.                                                  "455320
  endif.
endform.                               " READ_BKPF_NEU

*&---------------------------------------------------------------------*
*&      Form  READ_BSEG_NEU
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_BSID-BUKRS  text                                           *
*      -->P_BSID-BELNR  text                                           *
*      -->P_BSID-GJAHR  text                                           *
*      -->P_BSID_BUZEI  text                                           *
*----------------------------------------------------------------------*
form read_bseg_neu using    bukrs like bseg-bukrs
                            belnr like bseg-belnr
                            gjahr like bseg-gjahr
                            buzei like bseg-buzei
                   changing e_subrc.
  select single * from bseg
         where bukrs = bukrs
         and   belnr = belnr
         and   gjahr = gjahr
         and   buzei = buzei.
  if sy-subrc ne 0.
    e_subrc = sy-subrc.
    perform record_fill
            using 'BSEG ' bukrs space space space belnr buzei char_s.
  endif.
endform.                               " READ_BSEG_NEU
*&---------------------------------------------------------------------*
*&      Form  CHECK_BETRAGSFELDER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form check_betragsfelder using p_krit.

  data: tabl       like dfies-tabname,
        tabl1      like dfies-tabname,
        fnam       like dfies-fieldname,
        waehrfeld  like dfiestab-reffield.

  tabl  = p_krit(04).
  fnam  = p_krit+5(30).
  read table tdfies with key tabname   = tabl
                             fieldname = fnam.
  if sy-subrc = 0.
    if tdfies-datatype = 'DATS'.                            "418389
      x_betrag = 'Y'.                                       "418389
    else.                                                   "418389
      x_betrag = 'X'.
      if tdfies-reftable ne 'T001'.
        waehrfeld  = tdfies-reffield.
*        IF gb_xcopy IS INITIAL.                             "443350
*          CONCATENATE 'X' tabl INTO tabl1.
        concatenate 'GS_' tabl into tabl1.
*        ELSE.                                               "443350
*          CONCATENATE 'X' tabl 'COPY' INTO tabl1.           "443350
*        ENDIF.                                              "443350
        concatenate tabl1 '-' waehrfeld into curr.
      else.
        read table i001 with key bukrs = xbsid-bukrs.
        waehrfeld  = 'WAERS'.
        concatenate 'I001' '-' waehrfeld into curr.
      endif.
    endif.                                                  "418389
  else.
    clear x_betrag.
  endif.
endform.                               " CHECK_BETRAGSFELDER
*&---------------------------------------------------------------------*
*&      Form  INIT_header_stat
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form init_header_stat.
  cnt_ap = 0.
  cnt_op = 0.
  cnt_eap = 0.
  sum1_op = 0.
  sum1_ap = 0.
  sum1_eap = 0.
  new_bukr = space.
endform.                               " INIT_SHORT_LIST
*&---------------------------------------------------------------------*
*&      Form  SORTIEREN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_I_KOART  text
*----------------------------------------------------------------------*
form sortieren using    p_koart like bseg-koart.
  case p_koart.
    when 'D'.
      sort xbsid by hkont xcurr umskz bedg1 bedg2 bedg3 bedg4 bedg5
                    wrbtr budat descending.                      "792290
      sort xbsidgr by hkont bedg1 bedg2 bedg3 bedg4 bedg5 xcurr.
    when 'K'.
      sort xbsik by hkont xcurr umskz bedg1 bedg2 bedg3 bedg4 bedg5
                    wrbtr budat descending.                      "792290
      sort xbsikgr by hkont bedg1 bedg2 bedg3 bedg4 bedg5 xcurr.
    when 'S'.
*----- Bei WE/RE-Konten Sortierung nach Bestellnumer/Bestellposition ---
      if xsobwere = 'X'.
        read table iwere with key bukrs = bsis-bukrs hkont = bsis-hkont.
        if sy-subrc = 0.
          sort xbsis by hkont xcurr bedg2 bedg3 bedg1 bedg4 bedg5
*                       xamnt budat descending.                  "792290
                     xamnt budat descending belnr descending.   "1127849
          sort xbsisgr by hkont bedg2 bedg3 bedg1 bedg4 bedg5 xcurr.
        else.
          sort xbsis by hkont xcurr bedg1 bedg2 bedg3 bedg4 bedg5
*                       xamnt budat descending.                  "792290
                     xamnt budat descending belnr descending.   "1127849
          sort xbsisgr by hkont bedg1 bedg2 bedg3 bedg4 bedg5 xcurr.
        endif.
      else.
        sort xbsis by hkont xcurr bedg1 bedg2 bedg3 bedg4 bedg5
*                        xamnt budat descending.                 "792290
                      xamnt budat descending belnr descending.  "1127849
        sort xbsisgr by hkont bedg1 bedg2 bedg3 bedg4 bedg5 xcurr.
      endif.
  endcase.
endform.                               " SORTIEREN
*&---------------------------------------------------------------------*
*&      Form  AUSGLEICH
*&---------------------------------------------------------------------*
Form Ausgleich using I_koart like Bseg-Koart
                     I_sum like Xbsisgr-Bet_tw.
   Data: Rcgrup like sy-subrc.                                  "1029245

   Counter = 0.
   Case I_koart.
   When 'D'.
      Refresh Ybsid.
      Perform Read_xbsid.
   When 'K'.
      Refresh Ybsik.
      Perform Read_xbsik.
   When 'S'.
      Refresh Ybsis.
      Perform Read_xbsis.
   Endcase.
*  Ausgabe ausgl. Belege, Statistikz#hler, ybsik f¨¹llen
   Perform Belege_ausgeben using I_koart.
   If X_echtl = space.
*     test run
      If I_sum = 0.
*        group balances to 0
         If Flg_liste = char_3.
            Perform Acc_append_data using I_koart
                                          Augdt
                                          space
                                          'AUGDT'.
         Endif.
      Else.
*        group does not balance to 0
         If Xtol = 'X'.
*           with tolerances
            Rcgrup = 0.
            If Xtoleb = space.
               Perform Check_gruppe changing Rcgrup.
            Endif.
            If Rcgrup <> 0.
*              single line not permitted
               If Flg_liste = char_3.
                  Perform Acc_append_data using I_koart
                                                Augdt
                                                space
                                                'NOCLEAR'.
               Endif.
            Else.
               If Enqsubrc = 0.
            CLEAR gejahr.                                  "1121415
            monat = bmonat.                                "1121415
                  Perform Augdt_pruefen using I_koart.          "985181
                  Perform Call_transaction using I_koart.
               Else.
*                 enqueue failed
                  If Flg_liste = char_3.
                     Perform Acc_append_data using I_koart
                                                   Augdt
                                                   space
                                                   'ENQ'.
                  Endif.
               Endif.
            Endif.
         Else.
*           no tolerances
            If Flg_liste = char_3.
               Perform Acc_append_data using I_koart
                                             Augdt
                                             space
                                             'NOTZERO'.
            Endif.
         Endif.
      Endif.
      Perform Clear_augdt_testl using I_koart.
   Else.
*     productive run
      If I_sum = 0.
*        group balances to 0
         If Enqsubrc = 0.
*           enqeueue successfull
        CLEAR gejahr.                                           "1121415
        monat = bmonat.                                         "1121415
            Perform Augdt_pruefen using I_koart.
            Perform Call_transaction using I_koart.
         Else.
*           enqueue failed
            If Flg_liste = char_3.
               Perform Acc_append_data using I_koart
                                             Augdt
                                             space
                                             'ENQ'.
            Endif.
         Endif.
      Else.
*        group does not balance to 0.
         If Xtol = 'X'.
*           with tolerances
            Rcgrup = 0.
            If Xtoleb = space.
               Perform Check_gruppe changing Rcgrup.
            Endif.
            If Rcgrup <> 0.
*              single line not permitted
               If Flg_liste = char_3.
                  Perform Acc_append_data using I_koart
                                                Augdt
                                                space
                                                'NOCLEAR'.
               Endif.
            Else.
               If Enqsubrc = 0.
*                 enqueue successfull
            CLEAR gejahr.                                  "1121415
            monat = bmonat.                                "1121415
                  Perform Augdt_pruefen using I_koart.          "985181
                  Perform Call_transaction using I_koart.
               Else.
*                 enqueue failed
                  If Flg_liste = char_3.
                     Perform Acc_append_data using I_koart
                                                   Augdt
                                                   space
                                                   'ENQ'.
                  Endif.
               Endif.
            Endif.
         Else.
*           zero tolerance
            If Flg_liste = char_3.
               Perform Acc_append_data using I_koart
                                             Augdt
                                             space
                                             'NOTZERO'.
            Endif.
         Endif.
      Endif.
   Endif.
Endform.                               " AUSGLEICH
*&---------------------------------------------------------------------*
*&      Form  READ_XBSID
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form read_xbsid.

  read table xbsid with key
                           hkont = xbsidgr-hkont
                           xcurr = xbsidgr-xcurr
                           umskz = xbsidgr-umskz
                           bedg1 = xbsidgr-bedg1
                           bedg2 = xbsidgr-bedg2
                           bedg3 = xbsidgr-bedg3
                           bedg4 = xbsidgr-bedg4
                           bedg5 = xbsidgr-bedg5
         binary search.
endform.                               " READ_XBSID
*&---------------------------------------------------------------------*
*&      Form  READ_XBSIK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form read_xbsik.
  read table xbsik with key
                           hkont = xbsikgr-hkont
                           xcurr = xbsikgr-xcurr
                           umskz = xbsikgr-umskz
                           bedg1 = xbsikgr-bedg1
                           bedg2 = xbsikgr-bedg2
                           bedg3 = xbsikgr-bedg3
                           bedg4 = xbsikgr-bedg4
                           bedg5 = xbsikgr-bedg5
         binary search.

endform.                               " READ_XBSIK
*&---------------------------------------------------------------------*
*&      Form  READ_XBSIS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form read_xbsis.
  if xsobwere = space.
    read table xbsis with key
                             hkont = xbsisgr-hkont
                             xcurr = xbsisgr-xcurr
                             bedg1 = xbsisgr-bedg1
                             bedg2 = xbsisgr-bedg2
                             bedg3 = xbsisgr-bedg3
                             bedg4 = xbsisgr-bedg4
                             bedg5 = xbsisgr-bedg5
           binary search.
  else.
    read table iwere with key bukrs = bsis-bukrs hkont = bsis-hkont.
    if sy-subrc = 0.
      read table xbsis with key
                               hkont = xbsisgr-hkont
                               xcurr = xbsisgr-xcurr
                               bedg2 = xbsisgr-bedg2
                               bedg3 = xbsisgr-bedg3
                               bedg1 = xbsisgr-bedg1
                               bedg4 = xbsisgr-bedg4
                               bedg5 = xbsisgr-bedg5
            binary search.
    else.
      read table xbsis with key
                               hkont = xbsisgr-hkont
                               xcurr = xbsisgr-xcurr
                               bedg1 = xbsisgr-bedg1
                               bedg2 = xbsisgr-bedg2
                               bedg3 = xbsisgr-bedg3
                               bedg4 = xbsisgr-bedg4
                               bedg5 = xbsisgr-bedg5
             binary search.
    endif.
  endif.
endform.                               " READ_XBSIS
*&---------------------------------------------------------------------*
*&      Form  BELEGE_AUSGEBEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_KOART  text                                                *
*----------------------------------------------------------------------*
form belege_ausgeben using    i_koart like bseg-koart.
  case i_koart.
    when 'D'.
      icount = sy-tabix.
      while icount ne 0.
        read table xbsid index icount.
        if sy-subrc = 0.
*----- YBSID fuellen, AUGDT bestimmen ----------------------------------
*----- Statistikz#hler, Ausgabe ausgleichbarer Belege ------------------
          perform verarbeiten using koart xbsidgr-bet_bw.
        else.                          " sy-subrc nach read table ne 0
          icount = 0.
        endif.
      endwhile.
    when 'K'.
      icount = sy-tabix.
      while icount ne 0.
        read table xbsik index icount.
        if sy-subrc = 0.
*----- ybsik fuellen, AUGDT bestimmen ----------------------------------
*----- Statistikz#hler, Ausgabe ausgleichbarer Belege ------------------
          perform verarbeiten using koart xbsikgr-bet_bw.
        else.                          " sy-subrc nach read table ne 0
          icount = 0.
        endif.
      endwhile.
    when 'S'.
      icount = sy-tabix.
      while icount ne 0.
        read table xbsis index icount.
        if sy-subrc = 0.
*----- ybsis fuellen, AUGDT bestimmen ----------------------------------
*----- Statistikz#hler, Ausgabe ausgleichbarer Belege ------------------
          perform verarbeiten using koart xbsisgr-bet_tw.
        else.                          " sy-subrc nach read table ne 0
          icount = 0.
        endif.
      endwhile.
  endcase.
endform.                               " BELEGE_AUSGEBEN
*&---------------------------------------------------------------------*
*&      Form  Verarbeiten
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form verarbeiten using i_koart like bseg-koart
                       i_betrag like xbsidgr-bet_bw.
  case i_koart.
    when 'D'.
      if i_betrag = 0  or xtol = 'X'.
        if  ( xbsid-hkont eq xbsidgr-hkont )
        and ( xbsid-xcurr eq xbsidgr-xcurr )
        and ( xbsid-umskz eq xbsidgr-umskz )
        and ( xbsid-bedg1 eq xbsidgr-bedg1 )
        and ( xbsid-bedg2 eq xbsidgr-bedg2 )
        and ( xbsid-bedg3 eq xbsidgr-bedg3 )
        and ( xbsid-bedg4 eq xbsidgr-bedg4 )
        and ( xbsid-bedg5 eq xbsidgr-bedg5 ).
          icount = icount + 1.
          move-corresponding xbsid to ybsid.
*----- Ausgleichsdatum aus j¨¹ngstem Beleg? -----------------------------
          Perform Augdt_bestimmen using I_koart.                 "985181
          append ybsid.
*----- Z#hler f¨¹r Statistik --------------------------------------------
          if flg_liste = char_2.
            cnt_ap = cnt_ap + 1.
            cnt_op = cnt_op + 1.
            sum1_ap = sum1_ap + 1.
            sum1_op = sum1_op + 1.
          endif.
*----- Ausgabe der ausgleichbaren Belege -------------------------------
          if flg_liste = char_3.
            perform record_document using 'XBSID'.
          endif.
          if i_betrag ne 0.
            counter = counter + 1.
          endif.
        else.                          " keyfelder nicht gleich
          icount = 0.
        endif.
      else.
        if  ( xbsid-hkont eq xbsidgr-hkont )
        and ( xbsid-xcurr eq xbsidgr-xcurr )
        and ( xbsid-umskz eq xbsidgr-umskz )
        and ( xbsid-bedg1 eq xbsidgr-bedg1 )
        and ( xbsid-bedg2 eq xbsidgr-bedg2 )
        and ( xbsid-bedg3 eq xbsidgr-bedg3 )
        and ( xbsid-bedg4 eq xbsidgr-bedg4 )
        and ( xbsid-bedg5 eq xbsidgr-bedg5 ).
          icount = icount + 1.
*----- Z#hler f¨¹r Statistik --------------------------------------------
          if flg_liste = char_2.
            cnt_op = cnt_op + 1.
            sum1_op = sum1_op + 1.
          endif.
*----- Ausgabe der nicht ausgleichbaren Belege -------------------------
          if flg_liste = char_3.
            perform record_document using 'XBSID'.
          endif.
          counter = counter + 1.
        else.                          " key-felder nicht gleich
          icount = 0.
        endif.
      endif.
    when 'K'.
      if i_betrag = 0 or xtol = 'X'.
        if  ( xbsik-hkont eq xbsikgr-hkont )
        and ( xbsik-xcurr eq xbsikgr-xcurr )
        and ( xbsik-umskz eq xbsikgr-umskz )
        and ( xbsik-bedg1 eq xbsikgr-bedg1 )
        and ( xbsik-bedg2 eq xbsikgr-bedg2 )
        and ( xbsik-bedg3 eq xbsikgr-bedg3 )
        and ( xbsik-bedg4 eq xbsikgr-bedg4 )
        and ( xbsik-bedg5 eq xbsikgr-bedg5 ).
          icount = icount + 1.
          move-corresponding xbsik to ybsik.
*----- Ausgleichsdatum aus j¨¹ngstem Beleg? -----------------------------
          Perform Augdt_bestimmen using I_koart.                 "985181
          append ybsik.
*----- Z#hler f¨¹r Statistik --------------------------------------------
          if flg_liste = char_2.
            cnt_ap = cnt_ap + 1.
            cnt_op = cnt_op + 1.
            sum1_ap = sum1_ap + 1.
            sum1_op = sum1_op + 1.
          endif.
*----- Ausgabe der ausgleichbaren Belege -------------------------------
          if flg_liste = char_3.
            perform record_document using 'XBSIK'.
          endif.
          if i_betrag ne 0.
            counter = counter + 1.
          endif.
        else.                          " keyfelder nicht gleich
          icount = 0.
        endif.
      else.
        if  ( xbsik-hkont eq xbsikgr-hkont )
        and ( xbsik-xcurr eq xbsikgr-xcurr )
        and ( xbsik-umskz eq xbsikgr-umskz )
        and ( xbsik-bedg1 eq xbsikgr-bedg1 )
        and ( xbsik-bedg2 eq xbsikgr-bedg2 )
        and ( xbsik-bedg3 eq xbsikgr-bedg3 )
        and ( xbsik-bedg4 eq xbsikgr-bedg4 )
        and ( xbsik-bedg5 eq xbsikgr-bedg5 ).
          icount = icount + 1.
*----- Z#hler f¨¹r Statistik --------------------------------------------
          if flg_liste = char_2.
            cnt_op = cnt_op + 1.
            sum1_op = sum1_op + 1.
          endif.
*----- Ausgabe der nicht ausgleichbaren Belege -------------------------
          if flg_liste = char_3.
            perform record_document using 'XBSIK'.
          endif.
          counter = counter + 1.
        else.                          " key-felder nicht gleich
          icount = 0.
        endif.
      endif.
    when 'S'.
      if i_betrag = 0 or xtol = 'X'.
        if  ( xbsis-hkont eq xbsisgr-hkont )
        and ( xbsis-xcurr eq xbsisgr-xcurr )
        and ( xbsis-bedg1 eq xbsisgr-bedg1 )
        and ( xbsis-bedg2 eq xbsisgr-bedg2 )
        and ( xbsis-bedg3 eq xbsisgr-bedg3 )
        and ( xbsis-bedg4 eq xbsisgr-bedg4 )
        and ( xbsis-bedg5 eq xbsisgr-bedg5 ).
          icount = icount + 1.
          move-corresponding xbsis to ybsis.
*----- Ausgleichsdatum aus j¨¹ngstem Beleg? -----------------------------
          Perform Augdt_bestimmen using I_koart.                 "985181
          append ybsis.
*----- Z#hler f¨¹r Statistik --------------------------------------------
          if flg_liste = char_2.
            cnt_ap = cnt_ap + 1.
            cnt_op = cnt_op + 1.
            sum1_ap = sum1_ap + 1.
            sum1_op = sum1_op + 1.
          endif.
*----- Ausgabe der ausgleichbaren Belege -------------------------------
          if flg_liste = char_3.
            perform record_document using 'XBSIS'.
          endif.
          if i_betrag ne 0.
            counter = counter + 1.
          endif.
        else.                          " keyfelder nicht gleich
          icount = 0.
        endif.
      else.
        if  ( xbsis-hkont eq xbsisgr-hkont )
        and ( xbsis-xcurr eq xbsisgr-xcurr )
        and ( xbsis-bedg1 eq xbsisgr-bedg1 )
        and ( xbsis-bedg2 eq xbsisgr-bedg2 )
        and ( xbsis-bedg3 eq xbsisgr-bedg3 )
        and ( xbsis-bedg4 eq xbsisgr-bedg4 )
        and ( xbsis-bedg5 eq xbsisgr-bedg5 ).
          icount = icount + 1.
*----- Z#hler f¨¹r Statistik --------------------------------------------
          if flg_liste = char_2.
            cnt_op = cnt_op + 1.
            sum1_op = sum1_op + 1.
          endif.
*----- Ausgabe der nicht ausgleichbaren Belege -------------------------
          if flg_liste = char_3.
            perform record_document using 'XBSIS'.
          endif.
          counter = counter + 1.
        else.                          " key-felder nicht gleich
          icount = 0.
        endif.
      endif.
  endcase.
endform.                    "VERARBEITEN
*&---------------------------------------------------------------------*
*&      Form  AUGDT_BESTIMMEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_I_KOART  text
*----------------------------------------------------------------------*
form augdt_bestimmen using    p_koart like bseg-koart.
  case p_koart.
    when 'D'.
      if ybsid-budat > augdt.
        augdt = ybsid-budat.
      endif.
    when 'K'.
      if ybsik-budat > augdt.
        augdt = ybsik-budat.
      endif.
    when 'S'.
      if ybsis-budat > augdt.
        augdt = ybsis-budat.
      endif.
  endcase.
endform.                               " AUGDT_BESTIMMEN
*---------------------------------------------------------------------*
*       FORM RECORD_DOCUMENT                                          *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*  renewed by note 1029245                                            *
*---------------------------------------------------------------------*
form record_document using itab.
  case itab.
    when 'XBSID'.
      Move-corresponding Xbsid to Gs_dlist.
      Gs_dlist-Accnr = Xbsid-Kunnr.
   When 'XBSIK'.
      Move-corresponding Xbsik to Gs_dlist.
      Gs_dlist-Accnr = Xbsik-Lifnr.
   When 'XBSIS'.
      Move-corresponding Xbsis to Gs_dlist.
      Gs_dlist-Accnr = Xbsis-Hkont.
   When 'XBSISCOPY'.
      Move-corresponding Xbsiscopy to Gs_dlist.
      Gs_dlist-Accnr = Xbsiscopy-Hkont.
   Endcase.
   Append Gs_dlist to Gt_dlist.
endform.                    "RECORD_DOCUMENT
*&---------------------------------------------------------------------*
*&      Form  RECORD_CLEARING_INFO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form record_clearing_info using i_char i_uline1 i_uline2 koart.
  data:
    ld_footer   type slis_listheader.

  case i_char.
    when 'AUGDT'.
      perform acc_append_data using koart augdt ' ' 'AUGDT'.
    when 'AUGBL'.
      perform acc_append_data using koart augdt augblnr 'AUGBL'.
    when 'NOCLEAR'.
      perform acc_append_data using koart augdt ' ' 'NOCLEAR'.
    when 'NOCLEARTOL'.
      perform acc_append_data using koart augdt ' ' 'NOCLEARTOL'.
    when 'ENQ'.
      perform acc_append_data using koart augdt ' ' 'ENQ'.
  endcase.
endform.                               " RECORD_CLEARING_INFO
*&---------------------------------------------------------------------*
*&      Form  AUGDT_PRUEFEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form augdt_pruefen using p_koart like bseg-koart.
  case p_koart.
    when 'D'.
      clear augdttab.
      read table augdttab with key bukrs = ybsid-bukrs
                                   augdt = augdt.
      if sy-subrc ne 0.
        PERFORM periode_ermitteln                               "1121415
        USING ybsid-bukrs augdt gejahr monat.                   "1121415
*----- Buchungsperiode pr¨¹fen ------------------------------------------
        PERFORM periode_pruefen
        USING ybsid-bukrs augdt gejahr monat space.             "1121415
        collect augdttab.
      else.
        if augdttab-xnok = 'X'.
*----- Ausgabe: Kein Ausgleich -----------------------------------------
          perform record_clearing_info using 'NOCLEAR' ' ' 'X' p_koart.
        endif.
      endif.
    when 'K'.
      clear augdttab.
      read table augdttab with key bukrs = ybsik-bukrs
                                   augdt = augdt.
      if sy-subrc ne 0.
        PERFORM periode_ermitteln                               "1121415
        USING ybsik-bukrs augdt gejahr monat.                   "1121415
*----- Buchungsperiode pr¨¹fen ------------------------------------------
        PERFORM periode_pruefen
        USING ybsik-bukrs augdt gejahr monat space.             "1121415
        collect augdttab.
      else.
        if augdttab-xnok = 'X'.
*----- Ausgabe: Kein Ausgleich -----------------------------------------
          perform record_clearing_info using 'NOCLEAR' ' ' 'X' p_koart.
        endif.
      endif.
    when 'S'.
      clear augdttab.
      read table augdttab with key bukrs = ybsis-bukrs
                                   augdt = augdt.
      if sy-subrc ne 0.
        PERFORM periode_ermitteln                               "1121415
        USING ybsis-bukrs augdt gejahr monat.                   "1121415
*----- Buchungsperiode pr¨¹fen ------------------------------------------
        PERFORM periode_pruefen
        USING ybsis-bukrs augdt gejahr monat space.             "1121415
        collect augdttab.
      else.
        if augdttab-xnok = 'X'.
*----- Ausgabe: Kein Ausgleich -----------------------------------------
          perform record_clearing_info using 'NOCLEAR' ' ' 'X' p_koart.
        endif.
      endif.
  endcase.
endform.                               " AUGDT_PRUEFEN
*&---------------------------------------------------------------------*
*&      Form  check_gruppe
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_RCGRUP  text
*----------------------------------------------------------------------*
form check_gruppe changing p_rcgrup.
  case koart.
    when 'D'.
      describe table ybsid lines sy-tfill.
    when 'K'.
      describe table ybsik lines sy-tfill.
    when 'S'.
      describe table ybsis lines sy-tfill.
  endcase.
  if sy-tfill le 1.
    if sy-tfill = 1.
      case koart.
        when 'D'.
          read table ybsid index 1.
          if ybsid-wrbtr ne 0.
            p_rcgrup = 4.
          endif.
        when 'K'.
          read table ybsik index 1.
          if ybsik-wrbtr ne 0.
            p_rcgrup = 4.
          endif.
        when 'S'.
          read table ybsis index 1.
          if ybsis-pswbt ne 0.
            p_rcgrup = 4.
          endif.
      endcase.
    else.
      p_rcgrup = 4.
    endif.
  endif.
endform.                               " check_gruppe
*&---------------------------------------------------------------------*
*&      Form  CALL_TRANSACTION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form call_transaction using i_koart like bseg-koart.
*------ Tempor#res Speichern der auszugleichenden Belege aus YBSIS -----
  data  begin of tbsis occurs 1.
          include structure bsis.
  data  end of tbsis.
*------ Tempor#res Speichern der auszugleichenden Belege aus YBSID -----
  data  begin of tbsid occurs 1.
          include structure bsid.
  data  end of tbsid.
*------ Tempor#res Speichern der auszugleichenden Belege aus YBSIK -----
  data  begin of tbsik occurs 1.
          include structure bsik.
  data  end of tbsik.
  data: xcalltr(1) type c.

  check augdttab-xnok = ' '.

  x_ausglv = 'X'. " Ausgl.vorgang wurde versucht, nur f¨¹r Ausgabezwecke
  mod = 'N'.
  upd = 'S'.
*----- FB1* soll nicht mehr sperren ------------------------------------
*  export xf124e to memory id '%F124E%'.
*----- Export to memory und call transaction ---------------------------
  case i_koart.
    when 'D'.
      refresh messtab.
      clear messtab.
      if min_bel = 0.
        perform bdcdtab_fuellen using i_koart.
        export ybsid to memory id '%F124%'.
        call transaction 'FB1D' using bdcdtab
                                 mode mod
                                 update upd
                                 messages into messtab.
        xcalltr = 'X'.
      else.
*----- Belege f¨¹r sp#teren Ausgleich in PBSID sammeln ------------------
        perform belege_sammeln using i_koart.
*----- Ausgleich der Belege jetzt durchf¨¹hren? -------------------------
        if ct_pbsid ge min_bel.
          clear ct_pbsid.
          tbsid[] = ybsid[].
          ybsid[] = pbsid[].
          perform bdcdtab_fuellen using i_koart.
          export ybsid to memory id '%F124%'.
          call transaction 'FB1D' using bdcdtab
                                   mode mod
                                   update upd
                                   messages into messtab.
          ybsid[] = tbsid[].
          xcalltr = 'X'.
        endif.
      endif.
    when 'K'.
      refresh messtab.
      clear messtab.
      if min_bel = 0.
        perform bdcdtab_fuellen using i_koart.
        export ybsik to memory id '%F124%'.
        call transaction 'FB1K' using bdcdtab
                                 mode mod
                                 update upd
                                 messages into messtab.
        xcalltr = 'X'.
      else.
*----- Belege f¨¹r sp#teren Ausgleich in PBSID sammeln ------------------
        perform belege_sammeln using i_koart.
*----- Ausgleich der Belege jetzt durchf¨¹hren? -------------------------
        if ct_pbsik ge min_bel.
          clear ct_pbsik.
          tbsik[] = ybsik[].
          ybsik[] = pbsik[].
          perform bdcdtab_fuellen using i_koart.
          export ybsik to memory id '%F124%'.
          call transaction 'FB1K' using bdcdtab
                                   mode mod
                                   update upd
                                   messages into messtab.
          ybsik[] = tbsik[].
          xcalltr = 'X'.
        endif.
      endif.
    when 'S'.
      refresh messtab.
      clear messtab.
      if min_bel = 0.
        perform bdcdtab_fuellen using i_koart.
        export ybsis to memory id '%F124%'.
        call transaction 'FB1S' using bdcdtab
                               mode mod
                               update upd
                               messages into messtab.
        xcalltr = 'X'.
      else.
*----- Belege f¨¹r sp#teren Ausgleich in PBSIS sammeln ------------------
        perform belege_sammeln using i_koart.
*----- Ausgleich der Belege jetzt durchf¨¹hren? -------------------------
        if ct_pbsis ge min_bel.
          clear ct_pbsis.
          tbsis[] = ybsis[].
          ybsis[] = pbsis[].
          perform bdcdtab_fuellen using i_koart.
          export ybsis to memory id '%F124%'.
          call transaction 'FB1S' using bdcdtab
                                   mode mod
                                   update upd
                                   messages into messtab.
          ybsis[] = tbsis[].
          xcalltr = 'X'.
        endif.
      endif.
  endcase.
  if xcalltr = 'X'.
    if x_echtl = space.
*----- Meldung Batch-Input Daten auf Dynpro ... im Testlauf ignorieren -
      read table messtab with key msgid = '00' msgnr = '344'.
      if sy-subrc = 0.
        delete messtab index sy-tabix.
      endif.
    endif.
    perform messtab_auswerten using koart.
  endif.
endform.                               " CALL_TRANSACTION
*&---------------------------------------------------------------------*
*&      Form  BDCDTAB_FUELLEN
*&---------------------------------------------------------------------*
*  F¨¹llen der bdcdtab zur #bergabe f¨¹r call transaction
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form bdcdtab_fuellen using i_koart like bseg-koart.
  clear bdcdtab.
  case i_koart.
    when 'D'.
      refresh bdcdtab.
      read table ybsid index 1.
*--- Felder des Startdynpros der Ausgleichstransaktion f¨¹llen-----------
      bdcdtab-program = 'SAPMF05A'.
      bdcdtab-dynpro = '0131'.
      bdcdtab-dynbegin = 'X'.
      bdcdtab-fnam = ' '.
      bdcdtab-fval = ' '.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'RF05A-AGKON'.
      bdcdtab-fval = ybsid-kunnr.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-BUKRS'.
      bdcdtab-fval = ybsid-bukrs.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-WAERS'.
      Bdcdtab-Fval = Xbsidgr-Xcurr.                             "1033780
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-BUDAT'.
      write augdt to bdcdtab-fval dd/mm/yyyy.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-MONAT'.
      bdcdtab-fval = monat.                                     "1121415
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'RF05A-XNOPS'.
      bdcdtab-fval = 'X'.
      append bdcdtab.

      if x_avisd = 'X'.
        bdcdtab-dynpro = '0000'.
        bdcdtab-dynbegin = ' '.
        bdcdtab-fnam = 'RF05A-AVSID'.
        bdcdtab-fval = ybsid-xref3.
        append bdcdtab.
      endif.


*----- Toleranzen im Testlauf simulieren oder Buchen? ------------------
      if xtol = 'X' and x_echtl = space.
*---------- OP-Bearbeitung ---------------------------------------------
        bdcdtab-dynpro = '0000'.
        bdcdtab-dynbegin = ' '.
        bdcdtab-fnam = 'BDC_OKCODE'.
        bdcdtab-fval = 'PA'.
        append bdcdtab.

*---------- Simulieren -------------------------------------------------
        bdcdtab-program = 'SAPDF05X'.
*       BDCDTAB-DYNPRO = '1102'.
        bdcdtab-dynpro = '3100'.
        bdcdtab-dynbegin = 'X'.
        bdcdtab-fnam = 'BDC_OKCODE'.
        bdcdtab-fval = 'BS'.
        append bdcdtab.
*--------- Auf Dynpro 700 gibt es kein Simulieren! ---------------------
      else.
*---------- Buchen -----------------------------------------------------
        bdcdtab-dynpro = '0000'.
        bdcdtab-dynbegin = ' '.
        bdcdtab-fnam = 'BDC_OKCODE'.
        bdcdtab-fval = '/11'.
        append bdcdtab.
*---------- ENTER aud Dynpro 700 wegen automatischen Zeilen (313) ------
        if xnkon = space.
          bdcdtab-program = 'SAPMF05A'.
          bdcdtab-dynpro = '0700'.
          bdcdtab-dynbegin = 'X'.
          bdcdtab-fnam = 'BDC_OKCODE'.
          bdcdtab-fval = '/ '.
          append bdcdtab.
*---------- Buchen -----------------------------------------------------
          bdcdtab-dynpro = '0000'.
          bdcdtab-dynbegin = ' '.
          bdcdtab-fnam = 'BDC_OKCODE'.
          bdcdtab-fval = '/11'.
          append bdcdtab.
        endif.
      endif.
    when 'K'.
      refresh bdcdtab.
      read table ybsik index 1.
*--- Felder des Startdynpros der Ausgleichstransaktion f¨¹llen-----------
      bdcdtab-program = 'SAPMF05A'.
      bdcdtab-dynpro = '0131'.
      bdcdtab-dynbegin = 'X'.
      bdcdtab-fnam = ' '.
      bdcdtab-fval = ' '.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'RF05A-AGKON'.
      bdcdtab-fval = ybsik-lifnr.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-BUKRS'.
      bdcdtab-fval = ybsik-bukrs.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-WAERS'.
      Bdcdtab-Fval = Xbsikgr-Xcurr.                             "1033780
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-BUDAT'.
      write augdt to bdcdtab-fval dd/mm/yyyy.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-MONAT'.
      bdcdtab-fval = monat.                                     "1121415
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'RF05A-XNOPS'.
      bdcdtab-fval = 'X'.
      append bdcdtab.
*----- Toleranzen im Testlauf simulieren oder Buchen? ------------------
      if xtol = 'X' and x_echtl = space.
*---------- OP-Bearbeitung ---------------------------------------------
        bdcdtab-dynpro = '0000'.
        bdcdtab-dynbegin = ' '.
        bdcdtab-fnam = 'BDC_OKCODE'.
        bdcdtab-fval = 'PA'.
        append bdcdtab.

*---------- Simulieren -------------------------------------------------
        bdcdtab-program = 'SAPDF05X'.
*        BDCDTAB-DYNPRO = '1102'.
        bdcdtab-dynpro = '3100'.
        bdcdtab-dynbegin = 'X'.
        bdcdtab-fnam = 'BDC_OKCODE'.
        bdcdtab-fval = 'BS'.
        append bdcdtab.
*--------- Auf Dynpro 700 gibt es kein Simulieren! ---------------------
      else.
*---------- Buchen -----------------------------------------------------
        bdcdtab-dynpro = '0000'.
        bdcdtab-dynbegin = ' '.
        bdcdtab-fnam = 'BDC_OKCODE'.
        bdcdtab-fval = '/11'.
        append bdcdtab.
        if xnkon = space.
*---------- ENTER auf Dynpro 700 wegen automatischen Zeilen (313) ------
          bdcdtab-program = 'SAPMF05A'.
          bdcdtab-dynpro = '0700'.
          bdcdtab-dynbegin = 'X'.
          bdcdtab-fnam = 'BDC_OKCODE'.
          bdcdtab-fval = '/ '.
          append bdcdtab.
*---------- Buchen -----------------------------------------------------
          bdcdtab-dynpro = '0000'.
          bdcdtab-dynbegin = ' '.
          bdcdtab-fnam = 'BDC_OKCODE'.
          bdcdtab-fval = '/11'.
          append bdcdtab.
        endif.
      endif.
    when 'S'.
      refresh bdcdtab.
      read table ybsis index 1.
*--- Felder des Startdynpros der Ausgleichstransaktion f¨¹llen-----------
      bdcdtab-program = 'SAPMF05A'.
      bdcdtab-dynpro = '0131'.
      bdcdtab-dynbegin = 'X'.
      bdcdtab-fnam = ' '.
      bdcdtab-fval = ' '.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'RF05A-AGKON'.
      bdcdtab-fval = ybsis-hkont.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-BUKRS'.
      bdcdtab-fval = ybsis-bukrs.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-WAERS'.
      Bdcdtab-Fval = Xbsisgr-Xcurr.                             "1033780
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-BUDAT'.
      write augdt to bdcdtab-fval dd/mm/yyyy.
      append bdcdtab.

      bdcdtab-dynpro = '0000'.
      bdcdtab-dynbegin = ' '.
      bdcdtab-fnam = 'BKPF-MONAT'.
      bdcdtab-fval = monat.                                     "1121415
      append bdcdtab.

*----- Toleranzen im Testlauf simulieren oder Buchen? ------------------
      if xtol = 'X' and x_echtl = space.
*---------- OP-Bearbeitung ---------------------------------------------
        bdcdtab-dynpro = '0000'.
        bdcdtab-dynbegin = ' '.
        bdcdtab-fnam = 'BDC_OKCODE'.
        bdcdtab-fval = 'PA'.
        append bdcdtab.

*---------- Simulieren -------------------------------------------------
        bdcdtab-program = 'SAPDF05X'.
*        BDCDTAB-DYNPRO = '1103'.
        bdcdtab-dynpro = '3100'.
        bdcdtab-dynbegin = 'X'.
        bdcdtab-fnam = 'BDC_OKCODE'.
        bdcdtab-fval = 'BS'.
        append bdcdtab.
*--------- Auf Dynpro 700 gibt es kein Simulieren! ---------------------
      else.
*---------- Buchen -----------------------------------------------------
        bdcdtab-dynpro = '0000'.
        bdcdtab-dynbegin = ' '.
        bdcdtab-fnam = 'BDC_OKCODE'.
        bdcdtab-fval = '/11'.
        append bdcdtab.
*---------- ENTER auf Dynpro 700 wegen automatischen Zeilen (313) ------
        if xnkon = space.
          bdcdtab-program = 'SAPMF05A'.
          bdcdtab-dynpro = '0700'.
          bdcdtab-dynbegin = 'X'.
          bdcdtab-fnam = 'BDC_OKCODE'.
          bdcdtab-fval = '/ '.
          append bdcdtab.
*---------- Buchen -----------------------------------------------------
          bdcdtab-dynpro = '0000'.
          bdcdtab-dynbegin = ' '.
          bdcdtab-fnam = 'BDC_OKCODE'.
          bdcdtab-fval = '/11'.
          append bdcdtab.
        endif.
      endif.
  endcase.
endform.                               " BDCDTAB_FUELLEN

*&---------------------------------------------------------------------*
*&      Form  belege_sammeln
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_I_KOART  text
*----------------------------------------------------------------------*
form belege_sammeln using    p_koart.
  case p_koart.
    when 'D'.
      loop at ybsid.
        pbsid = ybsid.
        append pbsid.
        ct_pbsid = ct_pbsid + 1.
      endloop.
    when 'K'.
      loop at ybsik.
        pbsik = ybsik.
        append pbsik.
        ct_pbsik = ct_pbsik + 1.
      endloop.
    when 'S'.
      loop at ybsis.
        pbsis = ybsis.
        append pbsis.
        ct_pbsis = ct_pbsis + 1.
      endloop.
  endcase.
  Loop at Gt_dlist into Gs_dlist.                               "1029245
     Append Gs_dlist to Gt_dlist2.                              "1029245
  Endloop.                                                      "1029245
  Refresh Gt_dlist.                                             "1029245
ENDFORM.                               " belege_sammeln

*&---------------------------------------------------------------------*
*&      Form  messtab_auswerten
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_KOART  text
*----------------------------------------------------------------------*
form messtab_auswerten using koart.
  data: ld_errtol(1) type c.

*----- Verarbeitung der messtab ----------------------------------------
  if x_echtl = 'X'.
*----- Beleg gebucht? --------------------------------------------------
    read table messtab with key msgid = 'F5' msgnr = '312'.
*   "Beleg & wurde im Buchungskreis & gebucht"
    if sy-subrc eq 0.
*----- ... ja! ---------------------------------------------------------
*----- Ausgleichsbelegnr u. Ausgleichsdatum ausgeben -------------------
      if flg_liste = char_3.
        augblnr = messtab-msgv1.
        perform record_clearing_info using 'AUGBL' ' ' 'X' koart.
      endif.
      if flg_liste = char_2.
        perform statistik_fortschreiben using koart.
      endif.
    else.
*----- ... nein! -------------------------------------------------------
      if xtol = space.
        if flg_liste = char_3.
*----- Ausgabe: Kein Ausgleich -----------------------------------------
          perform record_clearing_info using 'NOCLEAR' ' ' 'X' koart.
        endif.
*----- Fehlerprotokoll f¨¹llen ------------------------------------------
        if x_fehler = 'X'.
          x_fehl_sub = 'X'.
          perform messtab_lesen using koart.
        endif.
      else.
*----- Bei Toleranzen: Differenz zu gro#? ------------------------------
        read table messtab with key msgid = 'F5' msgnr = '263'.
*       "Die Differenz ist f¨¹r einen Ausgleich zu gro#"
        if sy-subrc = 0.
*----- ... ja! ---------------------------------------------------------
          if flg_liste = char_3.
*----- Ausgabe: Kein Ausgleich (Differenz zu gro#, kein Fehlerprot. ----
          perform record_clearing_info using 'NOCLEARTOL' ' ' 'X' koart.
          endif.
        else.
*----- ... nein! -------------------------------------------------------
          if flg_liste = char_3.
*----- Ausgabe: Kein Ausgleich -----------------------------------------
            perform record_clearing_info using 'NOCLEAR' ' ' 'X' koart.
          endif.
*----- Fehlerprotokoll f¨¹llen ------------------------------------------
          if x_fehler = 'X'.
            x_fehl_sub = 'X'.
            perform messtab_lesen using koart.
          endif.
        endif.
      endif.
    endif.
  elseif ( x_echtl = space and xtol = 'X' ).
*----- Differenz zu gro#? ----------------------------------------------
    read table messtab with key msgid = 'F5' msgnr = '263'.
    if sy-subrc ne 0.
*----- nein --> Ausgleichsdatum ausgeben, falls kein anderer Fehler ----
      loop at messtab where msgtyp = 'E'.
        ld_errtol = 'X'.
        exit.
      endloop.
      if flg_liste = char_3.
        if enqsubrc = 0.
          if ld_errtol = 'X'.
            perform record_clearing_info using 'NOCLEAR' ' ' 'X' koart.
          else.
            perform record_clearing_info using 'AUGDT' ' ' 'X' koart.
          endif.
        endif.
      endif.
*----- Fehlerprotokoll f¨¹llen ------------------------------------------
      if x_fehler = 'X'.
        x_fehl_sub = 'X'.
        perform messtab_lesen using koart.
      endif.
      if flg_liste = char_2 and ld_errtol = space.
        perform statistik_fortschreiben using koart.
      endif.
    else.
*----- ... ja ----------------------------------------------------------
      if flg_liste = char_3.
*----- Ausgabe: Kein Ausgleich (Differenz zu gro#) ---------------------
        perform record_clearing_info using 'NOCLEARTOL' ' ' 'X' koart.
      endif.
    endif.
  endif.
  if min_bel ne 0.
    refresh: pbsid, pbsik, pbsis.
    Augdt = Save_augdt.                                          "985181
  Endif.
*----- immer Meldung bei ausl. W#hrung ------------------------- "985181
    read table messtab with key msgid = 'E!' msgnr = '101'.
    if sy-subrc = 0.
      perform auslaufende_waehrung_merken using messtab-msgid
                                                messtab-msgtyp
                                                messtab-msgnr
                                                messtab-msgv1.
  Endif.                                                         "985181
endform.                               " messtab_auswerten

*&---------------------------------------------------------------------*
*&      Form  statistik_fortschreiben
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_KOART  text
*----------------------------------------------------------------------*
form statistik_fortschreiben using    p_koart.
  case p_koart.
    when 'D'.
      if min_bel = 0.
        describe table ybsid lines sy-tfill.
      else.
        describe table pbsid lines sy-tfill.
      endif.
      cnt_eap = cnt_eap + sy-tfill.
      sum1_eap = sum1_eap + sy-tfill.
    when 'K'.
      if min_bel = 0.
        describe table ybsik lines sy-tfill.
      else.
        describe table pbsik lines sy-tfill.
      endif.
      cnt_eap = cnt_eap + sy-tfill.
      sum1_eap = sum1_eap + sy-tfill.
    when 'S'.
      if min_bel = 0.
        describe table ybsis lines sy-tfill.
      else.
        describe table pbsis lines sy-tfill.
      endif.
      cnt_eap = cnt_eap + sy-tfill.
      sum1_eap = sum1_eap + sy-tfill.
  endcase.

endform.                               " statistik_fortschreiben

*&---------------------------------------------------------------------*
*&      Form  MESSTAB_LESEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form messtab_lesen using i_koart like bseg-koart.
  clear cha500.
  clear t100.
  loop at messtab.
    perform nachricht_merken using messtab-msgspra messtab-msgid
                                   messtab-msgnr messtab-msgv1
                                   messtab-msgv2 messtab-msgv3
                                   messtab-msgv4
                                   i_koart
                                   messtab-dyname messtab-dynumb
                                   messtab-msgtyp.
  endloop.
endform.                               " MESSTAB_LESEN

*&---------------------------------------------------------------------*
*&      Form  clear_augdt_testl
*&---------------------------------------------------------------------*
*       Ausgleichsdatum aus j¨¹ngstem Beleg im Testlauf clearen
*----------------------------------------------------------------------*
*      -->P_KOART  text
*----------------------------------------------------------------------*
form clear_augdt_testl using p_koart.
  Check X_echtl = space.                                         "985181
  perform belege_sammeln using p_koart.
  case p_koart.
    when 'D'.
      if ct_pbsid ge min_bel.
        Clear Ct_pbsid.                                          "985181
        Augdt = Save_augdt.                                      "985181
        refresh pbsid.
      endif.
    when 'K'.
      if ct_pbsik ge min_bel.
        Clear Ct_pbsik.                                          "985181
        Augdt = Save_augdt.                                      "985181
        refresh pbsik.
      endif.
    when 'S'.
      if ct_pbsis ge min_bel.
        Clear Ct_pbsis.                                          "985181
        Augdt = Save_augdt.                                      "985181
        refresh pbsis.
      endif.
  endcase.
endform.                               " clear_augdt_testl

*&---------------------------------------------------------------------*
*&      Form  SONDERVERARBEITUNG_WERE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form sonderverarbeitung_were.
* redesigned by note 574482
  data: ld_grpsh like bseg-shkzg,
        ld_scount like sy-tabix,
        ld_hcount like sy-tabix.
  Data: Xbsiscopys2 type Yt_xbsis with header line,             "1026807
        Xbsiscopyh2 type Yt_xbsis with header line.             "1026807

  counter = 0.

*--search for the one document which is too much---------------------
  if xbsisgr-bet_tw > 0.
    ld_grpsh = 'S'.
    savebetrag_tw = xbsisgr-bet_tw.
  else.
    ld_grpsh = 'H'.
    savebetrag_tw = xbsisgr-bet_tw * -1.
  endif.
  if savebetrag_tw le 9999999999999.
    if xsobwere = space.
*        how is XBSIS sorted?
      read table xbsis
      with key hkont = xbsisgr-hkont
               xcurr = xbsisgr-xcurr
               bedg1 = xbsisgr-bedg1
               bedg2 = xbsisgr-bedg2
               bedg3 = xbsisgr-bedg3
               bedg4 = xbsisgr-bedg4
               bedg5 = xbsisgr-bedg5
               xamnt = savebetrag_tw
      binary search.
    else.
      read table iwere
      with key bukrs = bsis-bukrs
               hkont = bsis-hkont.
      if sy-subrc = 0.
        read table xbsis
        with key hkont = xbsisgr-hkont
                 xcurr = xbsisgr-xcurr
                 bedg2 = xbsisgr-bedg2
                 bedg3 = xbsisgr-bedg3
                 bedg1 = xbsisgr-bedg1
                 bedg4 = xbsisgr-bedg4
                 bedg5 = xbsisgr-bedg5
                 xamnt = savebetrag_tw
        binary search.
      else.
        read table xbsis
        with key hkont = xbsisgr-hkont
                 xcurr = xbsisgr-xcurr
                 bedg1 = xbsisgr-bedg1
                 bedg2 = xbsisgr-bedg2
                 bedg3 = xbsisgr-bedg3
                 bedg4 = xbsisgr-bedg4
                 bedg5 = xbsisgr-bedg5
                 xamnt = savebetrag_tw
        binary search.
      endif.
    endif.
    if sy-subrc = 0.
*        We've found one document with the amount of the whole group!
*        Now check the sign!....
         Savetabix = sy-tabix.
      while savetabix ne 0.
        if sy-subrc = 0.
          if  ( xbsis-hkont = xbsisgr-hkont )
          and ( xbsis-xcurr = xbsisgr-xcurr )
          and ( xbsis-bedg1 = xbsisgr-bedg1 )
          and ( xbsis-bedg2 = xbsisgr-bedg2 )
          and ( xbsis-bedg3 = xbsisgr-bedg3 )
          and ( xbsis-bedg4 = xbsisgr-bedg4 )
          and ( xbsis-bedg5 = xbsisgr-bedg5 )
          and ( xbsis-xamnt = savebetrag_tw ).
            if xbsis-shkzg = ld_grpsh.
*                    found one document with correct sign!
*                    write the document which can't be cleared
              counter = counter + 1.
              if flg_liste = char_2.
                cnt_op = cnt_op + 1.
                sum1_op = sum1_op + 1.
              endif.
              if  flg_liste = char_3.
                perform record_document using 'XBSIS'.
              endif.
              if xtol = 'X' and xtoleb = 'X'.
                append xbsis to xbsiscopytol.
                perform nachtraeglicher_ausgleich using koart
                                                        'WITH_TOL'.
                refresh xbsiscopytol.
              else.
                perform acc_append_data using koart augdt ' ' 'NOTZERO'.
              endif.
              delete xbsis index savetabix.
*                    stop reading and keep SAVETABIX
              exit.
            else.
*                    Read next document
              savetabix = savetabix + 1.
              read table xbsis index savetabix.
            endif.
          else.
*                 found no document with the correct sign
            savetabix = 0.
          endif.
        else.
          savetabix = 0.
        endif.
      endwhile.
    else.
*        found no document with the correct amount
      savetabix = 0.
    endif.
  else.
    savetabix = 0.
  endif.
  perform read_xbsis.
  check sy-subrc = 0.
  icount = sy-tabix.
*  now fill XBSISCOPY for further processing
  while icount ne 0.
    if sy-subrc = 0.
      if  ( xbsis-hkont = xbsisgr-hkont )
      and ( xbsis-xcurr = xbsisgr-xcurr )
      and ( xbsis-bedg1 = xbsisgr-bedg1 )
      and ( xbsis-bedg2 = xbsisgr-bedg2 )
      and ( xbsis-bedg3 = xbsisgr-bedg3 )
      and ( xbsis-bedg4 = xbsisgr-bedg4 )
      and ( xbsis-bedg5 = xbsisgr-bedg5 ).
        counter = counter + 1.
*----- Z#hler f¨¹r Statistik --------------------------------------------
        if flg_liste = char_2.
          cnt_op = cnt_op + 1.
          sum1_op = sum1_op + 1.
        endif.
        if savetabix = 0.
*              Above, we have not found one document with the missing
*              amount and the correct sign
*              => build XBSISCOPYS and -H for next strategy
          if xbsis-shkzg = 'S'.
            append xbsis to xbsiscopys.
          else.
            append xbsis to xbsiscopyh.
          endif.
        else.
*              build XBSISCOPY for clearing
          append xbsis to xbsiscopy.
        endif.
        icount = icount + 1.
        read table xbsis index icount.
      else.
        icount = 0.
      endif.
    else.
      icount = 0.
    endif.
  endwhile.
  if savetabix ne 0.
*     XBSISCOPY is filled and ready for clearing
    perform nachtraeglicher_ausgleich using koart
                                            space.
    refresh xbsiscopy.
    exit.
  endif.

  case counter.
    when 0.
*     no documents?
      exit.
    when 1.
*     already done above
      exit.
    when 2.
*     If these two matched, they would already be cleared.
    when 3.
*     if there were two matching, there would be one with amount of the
*     group
    when others.
*     try to biuld new groups of items balancing to 0
      Sort Xbsiscopyh by Xamnt ascending Budat ascending         "955803
                         Belnr ascending Buzei ascending.       "1026807
      Sort Xbsiscopys by Xamnt ascending Budat ascending         "955803
                         Belnr ascending Buzei ascending.       "1026807
      Xbsiscopys2[] = Xbsiscopys[].                             "1026807
      Xbsiscopyh2[] = Xbsiscopyh[].                             "1026807
      Sort Xbsiscopyh2 by Xamnt ascending Budat descending      "1026807
                         Belnr descending Buzei descending.     "1026807
      Sort Xbsiscopys2 by Xamnt ascending Budat descending      "1026807
                         Belnr descending Buzei descending.     "1026807
      describe table xbsiscopys lines ld_scount.
      describe table xbsiscopyh lines ld_hcount.
      if ld_scount > ld_hcount.
        perform extra_logic tables xbsiscopys
                                   Xbsiscopys2                  "1026807
                                   xbsiscopyh
                                   Xbsiscopyh2                  "1026807
                                   xbsiscopyeq
                            using 'X'.
*        now other turn round
        perform extra_logic tables xbsiscopyh
                                   Xbsiscopyh2                  "1026807
                                   xbsiscopys
                                   Xbsiscopys2                  "1026807
                                   xbsiscopyeq
                            using 'X'.
*        searching once more, less fast
        perform extra_logic tables xbsiscopys
                                   Xbsiscopys2                  "1026807
                                   xbsiscopyh
                                   Xbsiscopyh2                  "1026807
                                   xbsiscopyeq
                            using ' '.
        perform extra_logic tables xbsiscopyh
                                   Xbsiscopyh2                  "1026807
                                   xbsiscopys
                                   Xbsiscopys2                  "1026807
                                   xbsiscopyeq
                            using ' '.
      else.
        perform extra_logic tables xbsiscopyh
                                   Xbsiscopyh2                  "1026807
                                   xbsiscopys
                                   Xbsiscopys2                  "1026807
                                   xbsiscopyeq
                            using 'X'.
        perform extra_logic tables xbsiscopys
                                   Xbsiscopys2                  "1026807
                                   xbsiscopyh
                                   Xbsiscopyh2                  "1026807
                                   xbsiscopyeq
                            using 'X'.
        perform extra_logic tables xbsiscopyh
                                   Xbsiscopyh2                  "1026807
                                   xbsiscopys
                                   Xbsiscopys2                  "1026807
                                   xbsiscopyeq
                            using ' '.
        perform extra_logic tables xbsiscopys
                                   Xbsiscopys2                  "1026807
                                   xbsiscopyh
                                   Xbsiscopyh2                  "1026807
                                   xbsiscopyeq
                            using ' '.
      endif.
  endcase.

*--try to biuld XBSISCOPY so that it balances to 0-------------------
  Sort Xbsiscopyh by Xamnt descending Budat descending           "792290
                     Belnr descending.                          "1026807
  Sort Xbsiscopys by Xamnt descending Budat descending           "792290
                     Belnr descending.                          "1026807
  if ld_grpsh = 'S'.
    perform xbsiscopy_fuellen tables xbsiscopys.
    savebetrag_tw = savebetrag_tw * -1.
    perform xbsiscopy_fuellen tables xbsiscopyh.
  else.
    perform xbsiscopy_fuellen tables xbsiscopyh.
    savebetrag_tw = savebetrag_tw * -1.
    perform xbsiscopy_fuellen tables xbsiscopys.
  endif.
  if savebetrag_tw = 0.
*     XBSISCOPY balances to 0, XBSISCOPYTOL contains the rest
    if xtol = 'X'.
      describe table xbsiscopytol lines sy-tfill.
      if sy-tfill > 0.
        perform nachtraeglicher_ausgleich using koart
                                                'WITH_TOL'.
      endif.
    else.
      perform acc_append_data using koart augdt ' ' 'NOTZERO'.
    endif.

    loop at xbsiscopyeq into xbsiscopy.
*        put those found by SPECIAL_LOGIC into XBSISCOPY
      append xbsiscopy.
    endloop.
    describe table xbsiscopy lines sy-tfill.
    if sy-tfill > 0.
      perform nachtraeglicher_ausgleich using koart
                                              space.
    endif.
  else.
    loop at xbsiscopy.
      append xbsiscopy to xbsiscopytol.
      if flg_liste = char_3.
        perform record_document using 'XBSISCOPY'.
      endif.
    endloop.

    if xtol = 'X'. " consider tolerances
* Here you try to clear the records that have been just written
      perform nachtraeglicher_ausgleich using koart 'WITH_TOL'.
    else.
      perform acc_append_data using koart augdt ' ' 'NOTZERO'.
    endif.

*     there may be some found by SPECIAL_LOGIC that can be cleared
    xbsiscopy[] = xbsiscopyeq[].
    describe table xbsiscopy lines sy-tfill.
    if sy-tfill > 0.
      perform nachtraeglicher_ausgleich using koart space.
    endif.
  endif.
  refresh: xbsiscopy, xbsiscopytol, xbsiscopys, xbsiscopyh,
           xbsiscopyeq, Xbsiscopys2, Xbsiscopyh2.               "1026807
* redesigned by note 574482
endform.                               " SONDERVERARBEITUNG_WERE
*&---------------------------------------------------------------------*
*&      Form  Extra_logic
*&
*&      new with note 574482
*&---------------------------------------------------------------------*
form extra_logic tables ct_items1 structure xbsiscopy
                        Ct_items1d structure Xbsiscopy          "1026807
                        ct_items2 structure xbsiscopy
                        Ct_items2d structure Xbsiscopy          "1026807
                        ct_equals structure xbsiscopy
                 using cb_fast type c.
*  Logic: Fetch one document, then look for those with the other sign,
*  trying to build a group balancing to 0.
  field-symbols: <l_item1> like xbsiscopy,
                 <l_item2_low> like xbsiscopy,
                 <l_item2_high> like xbsiscopy.
  data: ld_sum type pswbt,
        ld_diff type pswbt,
        ld_low type sytabix,
        ld_high type sytabix,
        ld_high_keep type sytabix,
        ld_mini type pswbt,
        ld_maxi type pswbt,
        ld_residual type pswbt,
        ld_half type pswbt,
        lb_toolittle type c.
  data: lt_tmp type yt_xbsis with header line.

  describe table ct_items2 lines sy-tfill.
  check sy-tfill > 1.
  clear ld_sum.
  loop at ct_items1 assigning <l_item1>.
    check <l_item1>-xamnt <> ld_sum.
*     if there was no success, we need not repeat the whole procedure
*     for the same amount
    ld_sum = <l_item1>-xamnt.
    read table ct_items2 with key xamnt = ld_sum binary search.
    case sy-subrc.
      when 0.
*        found a pair of matching items
        append ct_items2 to ct_equals.
         Delete table Ct_items2d from Ct_items2.                "1026807
         delete table ct_items2.
         append <l_item1> to ct_equals.
         Delete table Ct_items1d from <L_item1>.                "1026807
        delete ct_items1.
        clear ld_sum.
        continue.
      when 4.
        if sy-tabix < 3.
          continue.
        endif.
      when 8.
        if sy-tabix < 3.
          exit.
        endif.
    endcase.
*     no such entry, but we need the index.
    ld_high_keep = sy-tabix - 1.
*     start searching with this. It has the highest amount possible
    clear ld_mini.
    ld_half = ld_sum / 2.
    loop at ct_items2 assigning <l_item2_low>.
*        get the smallest item in table 2
         check <l_item2_low>-xamnt <> ld_mini.                  "1026807
*        same amount as last turn, skip it!                     "1026807
         ld_low = sy-tabix.
      if not ld_low < ld_high_keep.
        exit.
      endif.
         ld_mini = <l_item2_low>-xamnt.                         "1026807
      if ld_mini > ld_half.
        exit.
      endif.
      if cb_fast = 'X'.
        ld_residual = ld_sum mod ld_mini.
        check ld_residual = 0.
      endif.
      refresh lt_tmp.
      ld_high = ld_high_keep.
      lb_toolittle = 'X'.
         While Ld_low =< Ld_high.                               "1026807
*           Read table 2 starting with the highest amount possible
*           and oldest date.                                    "1026807
            Read table Ct_items2d index Ld_high                 "1026807
            assigning <L_item2_high>.
            Ld_maxi = <L_item2_high>-Xamnt.
            If Ld_maxi = Ld_mini.                               "1026807
               If <L_item2_high> = <L_item2_low>.               "1026807
                  If Ld_low = Ld_high.                          "1026807
                     Exit.                                      "1026807
                  Endif.                                        "1026807
*                 Special treatment necessary: Due to the       "1026807
*                 different sorting of CT_ITEMS2 and CT_ITEMSD, "1026807
*                 a crossover now occurs: The first high items  "1026807
*                 is the low one, hence skip it!                "1026807
                  Ld_diff = Ld_maxi * ( Ld_high - Ld_low + 1 ). "1026807
                  If Ld_diff < Ld_sum.                          "1026807
                     Exit.                                      "1026807
                  Endif.                                        "1026807
                  If Cb_fast = space.                           "1026807
                     Ld_residual = Ld_sum mod Ld_maxi.          "1026807
                     If Ld_residual <> 0.                       "1026807
                        Clear Lb_toolittle.                     "1026807
                        Exit.                                   "1026807
                     Endif.                                     "1026807
                  Endif.                                        "1026807
                  Ld_high = Ld_high - 1.                        "1026807
                  Continue.                                     "1026807
               Endif.                                           "1026807
            Else.                                               "1026807
        if cb_fast = 'X'.
          ld_residual = ld_maxi mod ld_mini.
          if ld_residual <> 0.
            ld_high = ld_high - 1.
            clear lb_toolittle.
            continue.
          endif.
        endif.
            Endif.                                              "1026807
            ld_diff = ld_sum - ld_maxi.
        if ld_diff > ld_mini.
*              take and keep it in LT_TMP
          append <l_item2_high> to lt_tmp.
          ld_high = ld_high - 1.
          ld_sum = ld_sum - ld_maxi.
        elseif ld_diff = ld_mini.
*              together with the smallest, these items match!
          append <l_item2_high> to lt_tmp.
          append <l_item2_low> to lt_tmp.
          ld_sum = 0.
          exit.
        elseif ld_diff = 0.
*              bingo!
          append <l_item2_high> to lt_tmp.
          ld_sum = 0.
          exit.
        else.
*              If we took this, even the smallest item would be to big
          ld_high = ld_high - 1.
          clear lb_toolittle.
        endif.
      endwhile.
      if ld_sum = 0.
        clear lb_toolittle.
        exit.
      else.
        ld_sum = <l_item1>-xamnt.
      endif.
      if lb_toolittle = 'X'.
        if ld_low = 1.
          describe table ct_items2 lines sy-tfill.
          if ld_high_keep < sy-tfill.
            clear lb_toolittle.
          endif.
        else.
          clear lb_toolittle.
        endif.
        exit.
      endif.
    endloop.
    if ld_sum = 0.
      loop at lt_tmp assigning <l_item2_high>.
        append <l_item2_high> to ct_equals.
        delete table ct_items2 from <l_item2_high>.
            Delete table Ct_items2d from <L_item2_high>.        "1026807
         endloop.
         append <l_item1> to ct_equals.
         Delete table Ct_items1d from <L_item1>.                "1026807
      delete ct_items1.
    elseif lb_toolittle = 'X'.
      exit.
    else.
      ld_sum = <l_item1>-xamnt.
    endif.
  endloop.
endform.                    "Extra_logic

*&---------------------------------------------------------------------*
*&      Form  xbsiscopy_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form xbsiscopy_fuellen tables it_items structure xbsiscopyh.
*  redesigned with note 574482
  loop at it_items.
    move it_items to xbsiscopy.
    at last.
      if xbsiscopy-xamnt > savebetrag_tw
      and not savebetrag_tw = 0.
        append xbsiscopy to xbsiscopytol.
        if flg_liste = char_3.
          perform record_document using 'XBSISCOPY'.
        endif.
        savebetrag_tw = savebetrag_tw - xbsiscopy-xamnt.
        exit.
      endif.
    endat.
    if xbsiscopy-xamnt = 0
    or xbsiscopy-xamnt > savebetrag_tw.
      append xbsiscopy.
    else.
      append xbsiscopy to xbsiscopytol.
      if flg_liste = char_3.
        perform record_document using 'XBSISCOPY'.
      endif.
      savebetrag_tw = savebetrag_tw - xbsiscopy-xamnt.
    endif.
  endloop.
endform.                               " xbsiscopy_FUELLEN

*&---------------------------------------------------------------------*
*&      Form  NACHTRAEGLICHER_AUSGLEICH
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form nachtraeglicher_ausgleich using i_koart like bseg-koart
                                     p_with_tol.
  case i_koart.
    when 'S'.
      if p_with_tol = space.
        refresh ybsis.
        loop at xbsiscopy.
          ybsis = xbsiscopy.
          Perform Augdt_bestimmen using I_koart.                 "985181
          append ybsis.
*----- Z#hler f¨¹r Statistik --------------------------------------------
          if flg_liste = char_2.
            cnt_ap = cnt_ap + 1.
            sum1_ap = sum1_ap + 1.
          endif.
*----- Ausgabe der ausgleichbaren Belege -------------------------------
          if flg_liste = char_3.
            perform record_document using 'XBSISCOPY'.
          endif.
          delete xbsiscopy.
        endloop.
      else.
        refresh ybsis.
        loop at xbsiscopytol.
          ybsis = xbsiscopytol.
          Perform Augdt_bestimmen using I_koart.                 "985181
          append ybsis.
*----- Z#hler f¨¹r Statistik --------------------------------------------
          if flg_liste = char_2.
            cnt_ap = cnt_ap + 1.
            sum1_ap = sum1_ap + 1.
          endif.
*----- Ausgabe der ausgleichbaren Belege -------------------------------
*          IF FLG_LISTE = CHAR_3.
*            PERFORM RECORD_DOCUMENT USING 'XBSISCOPYTOL'.
*          ENDIF.
          delete xbsiscopytol.
        endloop.
      endif.
  endcase.
*----- Ausgabe des Ausgleichsdatums -----------------------------------
  if flg_liste = char_3 and x_testl = 'X' and xtol = space.
    perform record_clearing_info using 'AUGDT' 'X' 'X' i_koart.
  endif.
*----- Ausgabe des Ausgleichsdatums im Echtlauf, -----------------------
*----- falls Kontosperre nicht erfolgreich -----------------------------
  if x_echtl = 'X' and enqsubrc ne 0 and flg_liste = char_3.
    perform record_clearing_info using 'NOCLEAR' ' ' 'X' i_koart.
  endif.
*----- Buchungsperiode offen? ------------------------------------------
  Clear Gejahr.                                                  "985181
  monat = bmonat.                                          "1121415
  Perform Augdt_pruefen using I_koart.                           "985181

  if ( x_echtl ne space and enqsubrc = 0 )
  or ( x_echtl eq space and xtol = 'X' ).
*----- Ausgleichstransaktion aufrufen ----------------------------------
    perform call_transaction using koart.
  endif.
  perform clear_augdt_testl using koart.
endform.                               " NACHTRAEGLICHER_AUSGLEICH

*&---------------------------------------------------------------------*
*&      Form  restbelege_buchen
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_KOART  text
*----------------------------------------------------------------------*
form restbelege_buchen using koart.
  Gt_dlist[] = Gt_dlist2[].                                     "1029245
  Refresh Gt_dlist2.                                            "1029245
  CASE koart.
    when 'D'.
      clear ct_pbsid.
      describe table pbsid lines sy-tfill.
      if sy-tfill > 0.
        ybsid[] = pbsid[].
        if ( x_echtl ne space and enqsubrc = 0 )
        or ( x_echtl eq space and xtol = 'X' ).
*----- Ausgleichstransaktion aufrufen ----------------------------------
          perform  bdcdtab_fuellen using koart.
          mod = 'N'.
          upd = 'S'.
          refresh messtab.
          clear messtab.
          export ybsid to memory id '%F124%'.
          call transaction 'FB1D' using bdcdtab
                                        mode mod
                                        update upd
                                        messages into messtab.
          perform messtab_auswerten using koart.
        endif.
      endif.
    when 'K'.
      clear ct_pbsik.
      describe table pbsik lines sy-tfill.
      if sy-tfill > 0.
        ybsik[] = pbsik[].
        if ( x_echtl ne space and enqsubrc = 0 )
        or ( x_echtl eq space and xtol = 'X' ).
*----- Ausgleichstransaktion aufrufen ----------------------------------
          perform  bdcdtab_fuellen using koart.
          mod = 'N'.
          upd = 'S'.
          refresh messtab.
          clear messtab.
          export ybsik to memory id '%F124%'.
          call transaction 'FB1K' using bdcdtab
                                        mode mod
                                        update upd
                                        messages into messtab.
          perform messtab_auswerten using koart.
        endif.
      endif.
    when 'S'.
      clear ct_pbsis.
      describe table pbsis lines sy-tfill.
      if sy-tfill > 0.
        ybsis[] = pbsis[].
        if ( x_echtl ne space and enqsubrc = 0 )
        or ( x_echtl eq space and xtol = 'X' ).
*----- Ausgleichstransaktion aufrufen ----------------------------------
          perform  bdcdtab_fuellen using koart.
          mod = 'N'.
          upd = 'S'.
          refresh messtab.
          clear messtab.
          export ybsis to memory id '%F124%'.
          call transaction 'FB1S' using bdcdtab
                                        mode mod
                                        update upd
                                        messages into messtab.
          perform messtab_auswerten using koart.
        endif.
      endif.
  endcase.
  if min_bel ne 0.
    refresh: pbsid, pbsik, pbsis.
    Augdt = Save_augdt.                                          "985181
  endif.
endform.                               " restbelege_buchen

*&---------------------------------------------------------------------*
*&      Form  FEHLER_MERKEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form fehler_merken.
  data ls_msg like bdcmsgcoll.
  if x_fehler = 'X'.
    ls_msg-msgspra = sy-langu.
    ls_msg-msgid   = sy-msgid.
    ls_msg-msgnr   = sy-msgno.
    ls_msg-msgv1   = sy-msgv1.
    ls_msg-msgv2   = sy-msgv2.
    ls_msg-msgv3   = sy-msgv3.
    ls_msg-msgv4   = sy-msgv4.
    ls_msg-msgtyp  = sy-msgty.
    x_fehl_sub = 'X'.
    perform nachricht_merken using ls_msg-msgspra ls_msg-msgid
                                   ls_msg-msgnr   ls_msg-msgv1
                                   ls_msg-msgv2   ls_msg-msgv2
                                   ls_msg-msgv4 koart ' ' ' '
                                   ls_msg-msgtyp.
  endif.

endform.                               " FEHLER_MERKEN
*&---------------------------------------------------------------------*
*&      Form  NACHRICHT_MERKEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form nachricht_merken using i_msgspra like bdcmsgcoll-msgspra
                            i_msgid   like bdcmsgcoll-msgid
                            i_msgnr   like bdcmsgcoll-msgnr
                            i_msgv1   like bdcmsgcoll-msgv1
                            i_msgv2   like bdcmsgcoll-msgv2
                            i_msgv3   like bdcmsgcoll-msgv3
                            i_msgv4   like bdcmsgcoll-msgv4
                            i_koart   like bseg-koart
                            i_dynam   like bdcmsgcoll-dyname
                            i_dynum   like bdcmsgcoll-dynumb
                            i_msgtp   like bdcmsgcoll-msgtyp.
  select single * from t100
         where sprsl = i_msgspra
           and arbgb = i_msgid
           and msgnr = i_msgnr.
  if sy-subrc ne 0.
    cha500 = text-312.
    replace '&' with i_msgid into cha500.
    replace '&' with i_msgnr into cha500.
    condense cha500.
    perform fehlprot_fuellen using i_koart i_dynam i_dynum i_msgtp
                                   i_msgid i_msgnr cha500.
  endif.
  clear cha500.
  cha500+30 = t100-text.
  replace '&1'   with '&'   into cha500.
  replace '&2'   with '&'   into cha500.
  replace '&3'   with '&'   into cha500.
  replace '&4'   with '&'   into cha500.
  replace '&V1&' with '&'   into cha500.
  replace '&V2&' with '&'   into cha500.
  replace '&V3&' with '&'   into cha500.
  replace '&V4&' with '&'   into cha500.
  replace '&v1&' with '&'   into cha500.
  replace '&v2&' with '&'   into cha500.
  replace '&v3&' with '&'   into cha500.
  replace '&v4&' with '&'   into cha500.
  replace '&' with i_msgv1 into cha500.
  replace '&' with i_msgv2 into cha500.
  replace '&' with i_msgv3 into cha500.
  replace '&' with i_msgv4 into cha500.
  condense cha500.
  perform fehlprot_fuellen using i_koart i_dynam i_dynum i_msgtp
                                 i_msgid i_msgnr cha500.

endform.                               " NACHRICHT_MERKEN
*&---------------------------------------------------------------------*
*&      Form  FEHLPROT_FUELLEN
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form fehlprot_fuellen using i_koart like bseg-koart                 "4.7
                            i_dynam like bdcmsgcoll-dyname          "4.7
                            i_dynum like bdcmsgcoll-dynumb          "4.7
                            i_msgty like bdcmsgcoll-msgtyp          "4.7
                            i_msgid like bdcmsgcoll-msgid           "4.7
                            i_msgnr like bdcmsgcoll-msgnr           "4.7
                            i_ch500.

  clear fehlprot.
  case i_koart.
    when 'D'.
      fehlprot-bukrs = ybsid-bukrs.
      fehlprot-koart = koart.
      fehlprot-hkont = ybsid-hkont.
      fehlprot-konto = ybsid-kunnr.
      fehlprot-waers = ybsid-waers.
    when 'K'.
      fehlprot-bukrs = ybsik-bukrs.
      fehlprot-koart = koart.
      fehlprot-hkont = ybsik-hkont.
      fehlprot-konto = ybsik-lifnr.
      fehlprot-waers = ybsik-waers.
    when 'S'.
      fehlprot-bukrs = ybsis-bukrs.
      fehlprot-koart = koart.
      fehlprot-hkont = ybsis-hkont.
      fehlprot-konto = ybsis-hkont.
      fehlprot-waers = ybsis-pswsl.
  endcase.
  fehlprot-dyname = i_dynam.
  fehlprot-dynumb = i_dynum.
  fehlprot-msgtyp = i_msgty.
  fehlprot-msgid  = i_msgid.
  fehlprot-msgnr  = i_msgnr.
  fehlprot-text   = i_ch500.

  append fehlprot.
endform.                               " FEHLPROT_FUELLEN
*&---------------------------------------------------------------------*
*&      Form  TOP_OF_PAGE
*&---------------------------------------------------------------------*
*       new by note 1029245
*----------------------------------------------------------------------*
Form Top_of_page.
   Case Flg_liste.
   When char_2.
*     Statistics
      Perform Acc_top_of_list_statistik.
   When char_3.
*     List of items
      Perform Acc_top_of_page using Koart.
   When char_4.
*     additional log
      Perform Log_top_of_list.
   When char_5.
*     error log
      Perform Log_top_of_list_fault.
   Endcase.
Endform.
