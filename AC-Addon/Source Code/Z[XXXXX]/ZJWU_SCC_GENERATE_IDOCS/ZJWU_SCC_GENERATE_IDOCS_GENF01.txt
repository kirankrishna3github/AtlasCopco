*&---------------------------------------------------------------------*
*&  Include           ZJWU_SCC_GENERATE_IDOCS_GENF01
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*&      Form  CREATE_IDOCS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_MESSAGE_TYPE  text
*      -->P_C_LS  text
*      -->P_BUKRS  text
*      <--P_RESULT  text
*----------------------------------------------------------------------*
*======================================================================*
* Change History Log
*----------------------------------------------------------------------*
*Mod. no.|  Date    | Name                  | Corr. Nr   | Change
*----------------------------------------------------------------------*
*MOD-001 |12/04/2011| Lakshmi Reddy         | CD1K964361 | CR2005      *
*----------------------------------------------------------------------*
*MOD-002 |26/07/2011| Geert Rutten          | CD1K966809 | CR2096      *
*----------------------------------------------------------------------*
*MOD-003 |11/08/2011| Jules Smets           | CD1K967171 | CR2096      *
*----------------------------------------------------------------------*
*MOD-004 |14/08/2012| Johnny Wu             | CD1K972897 | CR2648      *
*----------------------------------------------------------------------*

FORM create_idocs USING p_message_type
                        p_ls.


  DATA: f_last,
        h_total_idocs TYPE i,
        h_total_lines TYPE i,
        h_calc(16) TYPE p DECIMALS 10,
        beg_idx    TYPE syindex,
        end_idx    TYPE syindex.


* FIND RECEIVING PARTNER
  SELECT SINGLE rcvprn idoctyp
  INTO  (wa_edidc-rcvprn, wa_edidc-idoctp)
  FROM edp13
  WHERE mestyp = p_message_type.
** Polulate Control Record
  wa_edidc-mestyp =  p_message_type.
*  wa_edidc-idoctp =  p_idoc_type.
  wa_edidc-rcvprt =  p_ls.

* Read Data

  IF sy-subrc EQ 0.

    CLEAR i_edidd_data_scc[].
    PERFORM fill_data TABLES i_edidd_data_scc
                      USING p_message_type.


    IF NOT i_edidd_data_scc[] IS INITIAL.
      LOOP AT i_edidd_data_scc.

        i_edidd_data = i_edidd_data_scc.
        APPEND i_edidd_data.
        CALL FUNCTION 'MASTER_IDOC_DISTRIBUTE'
          EXPORTING
            master_idoc_control            = wa_edidc
          TABLES
            communication_idoc_control     = i_edidc_control_comm
            master_idoc_data               = i_edidd_data
          EXCEPTIONS
            error_in_idoc_control          = 1
            error_writing_idoc_status      = 2
            error_in_idoc_data             = 3
            sending_logical_system_unknown = 4
            OTHERS                         = 5.
        IF sy-subrc EQ 0.
          CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'.

          CALL FUNCTION 'EDI_DOCUMENT_DEQUEUE_LATER'
            EXPORTING
              docnum                 = i_edidc_control_comm-docnum
            EXCEPTIONS
              idoc_is_not_to_dequeue = 1
              OTHERS                 = 2.

          WRITE : / 'Idoc type',p_message_type, 'generated ', i_edidd_data-sdata.
        ELSE.
          WRITE : / 'Idoc type',p_message_type, ' in Error ', i_edidd_data-sdata.
        ENDIF.
        CLEAR:   i_edidd_data.
        REFRESH: i_edidd_data.
      ENDLOOP.

    ELSE.
      i_edidd_data = i_edidd_data_scc.
      APPEND i_edidd_data.
      CALL FUNCTION 'MASTER_IDOC_DISTRIBUTE'
        EXPORTING
          master_idoc_control            = wa_edidc
        TABLES
          communication_idoc_control     = i_edidc_control_comm
          master_idoc_data               = i_edidd_data
        EXCEPTIONS
          error_in_idoc_control          = 1
          error_writing_idoc_status      = 2
          error_in_idoc_data             = 3
          sending_logical_system_unknown = 4
          OTHERS                         = 5.
      IF sy-subrc EQ 0.
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'.

        CALL FUNCTION 'EDI_DOCUMENT_DEQUEUE_LATER'
          EXPORTING
            docnum                 = i_edidc_control_comm-docnum
          EXCEPTIONS
           idoc_is_not_to_dequeue = 1
          OTHERS.
      ENDIF.

      WRITE : / 'Idoc type ',p_message_type, ' No data found '.
    ENDIF.
  ELSE.
    WRITE : / 'Idoc type ',p_message_type, ' Check Partner Profiles '.
  ENDIF.
  CLEAR:   i_edidd_data.
  REFRESH: i_edidd_data.

ENDFORM.                    "create_idocs


*&---------------------------------------------------------------------*
*&      Form  create_idocs2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_MESSAGE_TYPE  text
*      -->P_LS            text
*----------------------------------------------------------------------*
FORM create_idocs2 USING p_message_type
                        p_ls.


  DATA: f_last,
        h_total_idocs TYPE i,
        h_total_lines TYPE i,
        h_calc(16) TYPE p DECIMALS 10,
        beg_idx    TYPE syindex,
        end_idx    TYPE syindex.


* FIND RECEIVING PARTNER
  SELECT SINGLE rcvprn idoctyp
  INTO  (wa_edidc-rcvprn, wa_edidc-idoctp)
  FROM edp13
  WHERE mestyp = p_message_type.
** Polulate Control Record
  wa_edidc-mestyp =  p_message_type.
*  wa_edidc-idoctp =  p_idoc_type.
  wa_edidc-rcvprt =  p_ls.

* Read Data

  IF sy-subrc EQ 0.

    CLEAR i_edidd_data_scc[].
    PERFORM fill_data TABLES i_edidd_data_scc
                      USING p_message_type.

  ELSE.
    WRITE : / 'Idoc type ',p_message_type, ' Check Partner Profiles '.
  ENDIF.


ENDFORM.                    "create_idocs

*&---------------------------------------------------------------------*
*&      Form  FILL_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_I_EDIDD_DATA  text
*      -->P_P_MESSAGE_TYPE  text
*      -->P_P_BUKRS  text
*----------------------------------------------------------------------*
FORM fill_data  TABLES l_data STRUCTURE edidd
                USING  p_mes_type TYPE edipmestyp.
  TABLES: cdhdr, cdpos, yse_scc_used_mat.


  CONSTANTS: c_xxxx(4) TYPE c VALUE 'XXXX'.

  DATA: BEGIN OF i_cdhdr  OCCURS 0.
          INCLUDE STRUCTURE cdhdr.
  DATA: END OF i_cdhdr.

  DATA: lv_tabix TYPE sy-tabix,
        lv_index TYPE sy-tabix,
        lv_index3 TYPE sy-tabix,
        lv_kalab TYPE labst,
        lv_ind TYPE sy-tabix.

  DATA: lv_ersda TYPE ersda.


  DATA: lv_available_stck TYPE labst,
        lv_unrestr_stck TYPE labst,
        lv-index TYPE sy-tabix.


  DATA: BEGIN OF i_hdrpos  OCCURS 0,
         udate      LIKE cdhdr-udate,
         objectclas LIKE cdpos-objectclas,
         objectid LIKE cdpos-objectid ,
         changenr LIKE cdpos-changenr,
         tabname LIKE cdpos-tabname,
         tabkey LIKE cdpos-tabkey,
         fname LIKE cdpos-fname,
         chngind LIKE cdpos-chngind,
         valuenew LIKE cdpos-value_new,
         valueold LIKE cdpos-value_old,
        END OF i_hdrpos.

  DATA: BEGIN OF i_hdrpos2  OCCURS 0,
         udate      LIKE cdhdr-udate,
         objectclas LIKE cdpos-objectclas,
         objectid LIKE cdpos-objectid ,
         changenr LIKE cdpos-changenr,
         tabname LIKE cdpos-tabname,
         tabkey LIKE cdpos-tabkey,
         fname LIKE cdpos-fname,
         chngind LIKE cdpos-chngind,
         valuenew LIKE cdpos-value_new,
         valueold LIKE cdpos-value_old,
        END OF i_hdrpos2.

  DATA: lv_matnr TYPE matnr,
        lv_werks TYPE werks_d,
        lv_infnr TYPE infnr,
        lv_zeord TYPE dzeord,
        lv_werks_2 TYPE char2,
        lv_werks_stck TYPE char2,
        lv_werks_opo TYPE char2,
        lv_fam TYPE werks_d,
        lv_ekorg(2) TYPE c,
        lv_fam_stck TYPE werks_d,
        lv_zre1 TYPE labst,
        lv_fam_opo TYPE werks_d,
        lv_ebeln_pr TYPE ebeln,
        lv_loekz_pr TYPE loekz,
        lv_menge_d TYPE menge_d,
        lv_menge_c TYPE menge_d,
        lv_eeind TYPE eindt,
        lv_firstd TYPE lfdat,
        lv_lifnr2 TYPE lifnr,
        lv_prdha TYPE prodh_d,
        lv_transpmode TYPE ztranspmode,
        lv_plifz TYPE zsccplifz.

  DATA: lv_ebeln TYPE ebeln,
        lv_ebelp TYPE ebelp,
        lv_etenr TYPE eeten,
        lv_banfn TYPE banfn,
        lv_bnfpo TYPE bnfpo,
        lv_cpudt TYPE cpudt,
        lv_werks_cud TYPE char2,
        lv_fam_cud TYPE werks_d.

  DATA: i_mkpf       LIKE mkpf                OCCURS 0 WITH HEADER LINE.
  DATA: i_mseg       LIKE mseg                OCCURS 0 WITH HEADER LINE.

  CLEAR l_data.
*****************************************************************************************************************************************
* Material Information
  IF p_mes_type EQ c_mestyp_scc_matmas.
    CLEAR it_yse_scc_mat_prcs[].

* Begin of insert MOD-002
* Select all change documents for Material (MARA MARC MBEW EINE EORD)
    CLEAR i_cdhdr[].
    SELECT *
         INTO TABLE i_cdhdr
         FROM cdhdr
           WHERE ( objectclas = 'MATERIAL'       OR
                   objectclas = 'INFOSATZ'       OR
                   objectclas = 'ORDERBUCH' )
*             AND objectid   = dobject-objky
             AND ( udate IN s_ersda ).
*             AND  objectid IN s_matnr.¡§
    DESCRIBE TABLE i_cdhdr LINES sy-tfill.

* End of insert MOD-002

* initial download ?
* Begin of change MOD-002
*    if p_ini = 'X'.
*     if p_ini = 'X' or sy-tfill > 500.                     "MOD-003
    IF p_ini = 'X' OR sy-tfill > p_cdhdr.                   "MOD-003
* End of change MOD-002

      CLEAR it_werks[].
      SELECT  werks FROM t024w INTO TABLE it_werks
         WHERE werks IN s_werks AND ekorg EQ p_ekorg.

      SELECT c~matnr c~werks INTO CORRESPONDING FIELDS OF TABLE it_ini_mat
        FROM v_olr3_marx AS a
         INNER JOIN yse_scc_used_mat AS c
         ON a~matnr = c~matnr AND
            a~werks = c~werks
        FOR ALL ENTRIES IN it_werks
        WHERE a~werks = it_werks-werks AND
              a~matnr IN s_matnr AND
              a~werks IN s_werks AND
              a~matkl IN s_matkl AND
              a~mtart IN s_mtart.
*             c~flag = 'X'.

      LOOP AT it_ini_mat.
        it_yse_scc_mat_prcs-chgind = 'A'.
        it_yse_scc_mat_prcs-werks  = it_ini_mat-werks.
        it_yse_scc_mat_prcs-matnr  = it_ini_mat-matnr.
        it_yse_scc_mat_prcs-ekorg  = p_ekorg.
        CLEAR lv_ersda.
        SELECT SINGLE ersda FROM msta INTO lv_ersda
         WHERE matnr = it_yse_scc_mat_prcs-matnr  AND
              werks = it_yse_scc_mat_prcs-werks AND
              statm = 'E'.
        IF sy-subrc = 0.
          it_yse_scc_mat_prcs-udate = lv_ersda.
        ENDIF.
        APPEND it_yse_scc_mat_prcs.
      ENDLOOP.

    ELSE.

* Begin of delete MOD-002
** Select all change documents for Material (MARA MARC MBEW EINE EORD)
*      clear i_cdhdr[].
*      SELECT *
*           INTO TABLE i_cdhdr
*           FROM cdhdr
*             WHERE ( objectclas = 'MATERIAL'       OR
*                     objectclas = 'INFOSATZ'       OR
*                     objectclas = 'ORDERBUCH' )
**             AND objectid   = dobject-objky
*               AND ( UDATE IN s_ersda ).
**             AND  objectid IN s_matnr.¡§
* End of Delete MOD-002


      DESCRIBE TABLE i_cdhdr LINES sy-tfill.
      IF sy-tfill NE 0.
        SORT i_cdhdr BY udate utime.
* Fill internal table with changed documents
        CLEAR i_hdrpos[].
        SELECT changenr objectclas objectid tabname tabkey fname chngind value_new value_old
               FROM cdpos
               INTO CORRESPONDING FIELDS OF TABLE i_hdrpos
               FOR ALL ENTRIES IN i_cdhdr
               WHERE objectclas  = i_cdhdr-objectclas
                 AND objectid    = i_cdhdr-objectid
                 AND changenr    = i_cdhdr-changenr
                 AND ( ( tabname = 'MARC' AND ( fname = 'WERKS' OR fname = 'KEY') )
                    OR ( tabname = 'MARC' AND ( fname = 'MATNR' OR fname = 'KEY') )
                    OR ( tabname = 'MBEW' AND ( fname = 'VERPR' OR fname = 'KEY') )
                    OR ( tabname = 'MBEW' AND ( fname = 'STPRS' OR fname = 'KEY') )
                    OR ( tabname = 'MARC' AND ( fname = 'MMSTA' OR fname = 'KEY') )
                    OR ( tabname = 'MARC' AND ( fname = 'NFMAT' OR fname = 'KEY') )
                    OR ( tabname = 'EINE' AND ( fname = 'NETPR' OR fname = 'KEY') )
                    OR ( tabname = 'EINE' AND ( fname = 'WAERS' OR fname = 'KEY') )
                    OR ( tabname = 'EINE' AND ( fname = 'NORBM' OR fname = 'KEY') )
                    OR ( tabname = 'EORD' AND ( fname = 'LIFNR' OR fname = 'KEY') ) ).
        IF sy-subrc = 0.
          LOOP AT i_hdrpos.   " You can not join with cluster tables.
            SELECT SINGLE udate FROM cdhdr INTO i_hdrpos-udate
              WHERE changenr = i_hdrpos-changenr AND
                    objectclas = i_hdrpos-objectclas AND
                    objectid = i_hdrpos-objectid.
            IF sy-subrc = 0.
              MODIFY i_hdrpos TRANSPORTING udate.
            ENDIF.
          ENDLOOP.
        ENDIF.
* Do the same for table MARA and DMAKT         (which have no plant view)
        CLEAR i_hdrpos2[].
        SELECT changenr objectclas objectid tabname tabkey fname chngind value_new value_old
               FROM cdpos
               INTO CORRESPONDING FIELDS OF TABLE i_hdrpos2
               FOR ALL ENTRIES IN i_cdhdr
               WHERE objectclas  = i_cdhdr-objectclas
                 AND objectid    = i_cdhdr-objectid
                 AND changenr    = i_cdhdr-changenr
                 AND ( ( tabname = 'MARA' AND ( fname = 'BISMT' OR fname = 'KEY') )
                    OR ( tabname = 'MARA' AND ( fname = 'NTGEW' OR fname = 'KEY') )
                    OR ( tabname = 'MARA' AND ( fname = 'GEWEI' OR fname = 'KEY') )
                    OR ( tabname = 'MARA' AND ( fname = 'PRDHA' OR fname = 'KEY') )
                    OR ( tabname = 'DMAKT' AND ( fname = 'MAKTX'  OR fname = 'KEY') AND tabkey = 'E' ) ).
        IF sy-subrc = 0.
          LOOP AT i_hdrpos2.   " You can not join with cluster tables.
            SELECT SINGLE udate FROM cdhdr INTO i_hdrpos2-udate
              WHERE changenr = i_hdrpos2-changenr AND
                    objectclas = i_hdrpos2-objectclas AND
                    objectid = i_hdrpos2-objectid.
            IF sy-subrc = 0.
              MODIFY i_hdrpos2 TRANSPORTING udate.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF. " sy-tfill

* Check flag in YSE_SCC_USED_MAT.  If 'X'...it means the material was never send to SCC...
* materials with flag 'X' won't be processed with the change docs.
* Afterwards we put a 'P' from processed...
      CLEAR it_werks[].
      SELECT  werks FROM t024w INTO TABLE it_werks
         WHERE werks IN s_werks AND ekorg EQ p_ekorg.

      SELECT c~matnr c~werks INTO CORRESPONDING FIELDS OF TABLE it_x_mat
        FROM  v_olr3_marx AS a
         INNER JOIN yse_scc_used_mat AS c
         ON a~matnr = c~matnr AND
            a~werks = c~werks
        FOR ALL ENTRIES IN it_werks
        WHERE a~werks = it_werks-werks AND
              a~matnr IN s_matnr AND
              a~werks IN s_werks AND
              a~matkl IN s_matkl AND
              a~mtart IN s_mtart AND
              c~flag = 'X'.

      LOOP AT it_x_mat.
        it_yse_scc_mat_prcs-chgind = 'A'.
        it_yse_scc_mat_prcs-werks  = it_x_mat-werks.
        it_yse_scc_mat_prcs-matnr  = it_x_mat-matnr.
        it_yse_scc_mat_prcs-ekorg  = p_ekorg.
        CLEAR lv_ersda.
        SELECT SINGLE ersda FROM msta INTO lv_ersda
         WHERE matnr = it_yse_scc_mat_prcs-matnr  AND
              werks = it_yse_scc_mat_prcs-werks AND
              statm = 'E'.
        IF sy-subrc = 0.
          it_yse_scc_mat_prcs-udate = lv_ersda.
        ENDIF.
        APPEND it_yse_scc_mat_prcs.
      ENDLOOP.

* Filling of table YSE_SCC_MAT_PRCS. Per change Date/indicator/material/plant (and number of source List for EORD) it will show which tables need to be inserted/modified


      SORT i_hdrpos BY chngind udate tabname.
      LOOP AT i_hdrpos.

        CLEAR wa_yse_scc_mat_prcs.
        CLEAR: lv_matnr, lv_werks, lv_infnr, lv_zeord.

        IF i_hdrpos-tabname = 'MARC'.
          lv_matnr = i_hdrpos-objectid(18).
          lv_werks = i_hdrpos-tabkey+21(10).

          SELECT SINGLE * FROM yse_scc_used_mat
            WHERE matnr = lv_matnr AND
                  werks = lv_werks AND
                  flag <> 'X'.
          IF sy-subrc = 0.

            SELECT SINGLE * FROM yse_scc_mat_prcs INTO wa_yse_scc_mat_prcs
              WHERE chgind = i_hdrpos-chngind AND
                   udate = i_hdrpos-udate AND
                   matnr = lv_matnr AND
                   werks = lv_werks.
            IF sy-subrc <> 0.   " INSERT new Entry in YSE_SCC_MAT_PRCS
              CLEAR wa_yse_scc_mat_prcs.
              wa_yse_scc_mat_prcs-chgind = i_hdrpos-chngind.
              wa_yse_scc_mat_prcs-udate = i_hdrpos-udate.
              wa_yse_scc_mat_prcs-matnr = lv_matnr.
              wa_yse_scc_mat_prcs-werks = lv_werks.
              SELECT SINGLE ekorg FROM t024w INTO wa_yse_scc_mat_prcs-ekorg
                WHERE werks = lv_werks AND werks IN s_werks AND ekorg EQ p_ekorg.
              IF sy-subrc = 0.
                wa_yse_scc_mat_prcs-marc = 'X'.
                INSERT yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
              ENDIF.
            ELSE. " UPDATE Entry in YSE_SCC_MAT_PRCS
              wa_yse_scc_mat_prcs-marc = 'X'.
              MODIFY yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
            ENDIF.
          ENDIF. "in yse_scc_used_mat
        ENDIF.

        IF i_hdrpos-tabname = 'MBEW'.
          lv_matnr = i_hdrpos-objectid(18).
          lv_werks = i_hdrpos-tabkey+21(10).
          IF ( i_hdrpos-fname = 'VERPR' AND i_hdrpos-tabkey+21(2) = 'RU' ) OR
             ( i_hdrpos-fname = 'STPRS' AND i_hdrpos-tabkey+21(2) = 'CN' ).
            SELECT SINGLE * FROM yse_scc_used_mat
               WHERE matnr = lv_matnr AND
                     werks = lv_werks AND
                     flag <> 'X'.
            IF sy-subrc = 0.
              SELECT SINGLE * FROM yse_scc_mat_prcs INTO wa_yse_scc_mat_prcs
              WHERE chgind = i_hdrpos-chngind AND
                  udate = i_hdrpos-udate AND
                  matnr = lv_matnr AND
                  werks = lv_werks.
              IF sy-subrc <> 0 .
                CLEAR wa_yse_scc_mat_prcs.
                wa_yse_scc_mat_prcs-chgind = i_hdrpos-chngind.
                wa_yse_scc_mat_prcs-udate = i_hdrpos-udate.
                wa_yse_scc_mat_prcs-matnr = lv_matnr.
                wa_yse_scc_mat_prcs-werks = lv_werks.
                SELECT SINGLE ekorg FROM t024w INTO wa_yse_scc_mat_prcs-ekorg
                  WHERE werks = lv_werks AND werks IN s_werks AND ekorg = p_ekorg.
                IF sy-subrc = 0.
                  wa_yse_scc_mat_prcs-mbew = 'X'.
                  INSERT yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
                ENDIF.
              ELSE.
                wa_yse_scc_mat_prcs-mbew = 'X'.
                MODIFY yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
              ENDIF.
            ENDIF.  "in yse_scc_used_mat
          ENDIF. " VERPR or STPRS
        ENDIF.

        IF i_hdrpos-tabname = 'EINE'.

          SELECT SINGLE matnr FROM eina INTO lv_matnr
            WHERE infnr = i_hdrpos-objectid.
          lv_infnr = i_hdrpos-objectid.
          lv_werks = i_hdrpos-tabkey+18(4).

          SELECT SINGLE * FROM yse_scc_used_mat
             WHERE matnr = lv_matnr AND
                   werks = lv_werks AND
                   flag <> 'X'.
          IF sy-subrc = 0.

            SELECT SINGLE * FROM yse_scc_mat_prcs INTO wa_yse_scc_mat_prcs
            WHERE chgind = i_hdrpos-chngind AND
                 udate = i_hdrpos-udate AND
                 matnr = lv_matnr AND
                 werks = lv_werks.
            IF sy-subrc <> 0 .
              CLEAR wa_yse_scc_mat_prcs.
              wa_yse_scc_mat_prcs-chgind = i_hdrpos-chngind.
              wa_yse_scc_mat_prcs-udate = i_hdrpos-udate.
              wa_yse_scc_mat_prcs-werks = lv_werks.
              wa_yse_scc_mat_prcs-matnr = lv_matnr.
              SELECT SINGLE ekorg FROM t024w INTO wa_yse_scc_mat_prcs-ekorg
                WHERE werks = lv_werks AND werks IN s_werks AND ekorg = p_ekorg.
              IF sy-subrc = 0.
                wa_yse_scc_mat_prcs-infnr = lv_infnr.
                wa_yse_scc_mat_prcs-eine = 'X'.
                INSERT yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
              ENDIF.
            ELSE.
              wa_yse_scc_mat_prcs-infnr = lv_infnr.
              wa_yse_scc_mat_prcs-eine = 'X'.
              MODIFY yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
            ENDIF.
          ENDIF. " in yse_scc_used_mat
        ENDIF.

        IF i_hdrpos-tabname = 'EORD'.

          lv_matnr = i_hdrpos-objectid(18).
          lv_werks = i_hdrpos-objectid+18(4).
          lv_zeord = i_hdrpos-tabkey+25(5).

          SELECT SINGLE * FROM yse_scc_used_mat
             WHERE matnr = lv_matnr AND
                   werks = lv_werks AND
                   flag <> 'X'.
          IF sy-subrc = 0.

            SELECT SINGLE * FROM yse_scc_mat_prcs INTO wa_yse_scc_mat_prcs
            WHERE chgind = i_hdrpos-chngind AND
                  udate = i_hdrpos-udate AND
                  matnr = lv_matnr AND
                  werks = lv_werks.
            IF sy-subrc = 0 .
              SELECT SINGLE * FROM yse_scc_mat_prcs INTO wa_yse_scc_mat_prcs
              WHERE chgind = i_hdrpos-chngind AND
                    udate = i_hdrpos-udate AND
                    matnr = lv_matnr AND
                    werks = lv_werks AND
                    zeord = lv_zeord.
              IF sy-subrc = 0.
                CLEAR lv_lifnr2.
                SELECT SINGLE lifnr FROM eord INTO lv_lifnr2
                 WHERE matnr = lv_matnr AND
                       werks = lv_werks AND
                       zeord = lv_zeord AND
                       flifn = 'X'.
                IF sy-subrc = 0.
                  wa_yse_scc_mat_prcs-eord = 'X'.
                  MODIFY yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
                ENDIF.
              ELSE.
                SELECT SINGLE lifnr FROM eord INTO lv_lifnr2
                  WHERE matnr = lv_matnr AND
                        werks = lv_werks AND
                        zeord = lv_zeord AND
                        flifn = 'X'.
                IF sy-subrc = 0.
                  wa_yse_scc_mat_prcs-zeord = lv_zeord.
                  wa_yse_scc_mat_prcs-eord = 'X'.
                  MODIFY yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
                ENDIF.
              ENDIF.
            ELSE.
              SELECT SINGLE lifnr FROM eord INTO lv_lifnr2
                    WHERE matnr = lv_matnr AND
                          werks = lv_werks AND
                          zeord = lv_zeord AND
                          flifn = 'X'.
              IF sy-subrc = 0.
                CLEAR wa_yse_scc_mat_prcs.
                wa_yse_scc_mat_prcs-chgind = i_hdrpos-chngind.
                wa_yse_scc_mat_prcs-udate = i_hdrpos-udate.
                wa_yse_scc_mat_prcs-werks = lv_werks.
                wa_yse_scc_mat_prcs-matnr = lv_matnr.
                SELECT SINGLE ekorg FROM t024w INTO wa_yse_scc_mat_prcs-ekorg
                  WHERE werks = lv_werks AND werks IN s_werks AND ekorg = p_ekorg.
                IF sy-subrc = 0.
                  wa_yse_scc_mat_prcs-zeord = lv_zeord.
                  wa_yse_scc_mat_prcs-eord = 'X'.
                  INSERT yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
                ENDIF.
              ENDIF.
            ENDIF.
          ENDIF. " in yse_scc_used_mat
        ENDIF.
*          if i_hdrpos-tabname = 'MAKT'.
*             YSE_SCC_MAT_PRCS-UDATE = i_hdrpos-UDATE.
*             YSE_SCC_MAT_PRCS-OBJECTCLAS = i_hdrpos-OBJECTCLAS.
*             YSE_SCC_MAT_PRCS-MAKT = 'X'.
*          endif.

      ENDLOOP.

      SORT i_hdrpos2 BY chngind udate tabname.
      LOOP AT i_hdrpos2.

        CLEAR wa_yse_scc_mat_prcs.
        CLEAR: lv_matnr, lv_werks, lv_infnr, lv_zeord.

        IF i_hdrpos2-tabname = 'MARA'.
          lv_matnr = i_hdrpos2-objectid(18).
          SELECT SINGLE * FROM yse_scc_mat_prcs INTO wa_yse_scc_mat_prcs
           WHERE chgind = i_hdrpos2-chngind AND
                 udate = i_hdrpos2-udate AND
                 matnr = lv_matnr.
          IF sy-subrc <> 0.   " INSERT new Entry in YSE_SCC_MAT_PRCS
            CLEAR wa_yse_scc_mat_prcs.
            SELECT werks FROM marc INTO lv_werks
              WHERE matnr = lv_matnr.

              SELECT SINGLE ekorg FROM t024w INTO wa_yse_scc_mat_prcs-ekorg
                      WHERE werks = lv_werks AND werks IN s_werks AND ekorg = p_ekorg.
              IF sy-subrc = 0.
* Check if material is already send to SCC
* YSE_SCC_USED_MAT is filled up by program YSE_SCC_USED_MAT and contains all materials relevant for SCC
* The 'X' flag means a new one
                SELECT SINGLE * FROM yse_scc_used_mat
                 WHERE matnr = lv_matnr AND
                      werks = lv_werks AND
                      flag <> 'X'.
                IF sy-subrc = 0.
                  wa_yse_scc_mat_prcs-chgind = i_hdrpos2-chngind.
                  wa_yse_scc_mat_prcs-udate = i_hdrpos2-udate.
                  wa_yse_scc_mat_prcs-matnr = lv_matnr.
                  wa_yse_scc_mat_prcs-werks = lv_werks.
                  wa_yse_scc_mat_prcs-mara = 'X'.
                  INSERT yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
                ENDIF.   " in YSE_SCC_USED_MAT
              ENDIF.
            ENDSELECT.
          ELSE.
            SELECT werks FROM marc INTO lv_werks
             WHERE matnr = lv_matnr.

              SELECT SINGLE * FROM yse_scc_mat_prcs INTO wa_yse_scc_mat_prcs
              WHERE chgind = i_hdrpos2-chngind AND
                    udate = i_hdrpos2-udate AND
                    matnr = lv_matnr AND
                    werks = lv_werks.
              IF sy-subrc = 0.
                SELECT SINGLE * FROM yse_scc_used_mat
                 WHERE matnr = lv_matnr AND
                      werks = lv_werks AND
                      flag <> 'X'.
                IF sy-subrc = 0.
                  wa_yse_scc_mat_prcs-mara = 'X'.
                  MODIFY yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
                ENDIF.
              ELSE.
                CLEAR wa_yse_scc_mat_prcs.
                SELECT SINGLE ekorg FROM t024w INTO wa_yse_scc_mat_prcs-ekorg
                     WHERE werks = lv_werks AND werks IN s_werks AND ekorg = p_ekorg.
                IF sy-subrc = 0.
                  SELECT SINGLE * FROM yse_scc_used_mat
                   WHERE matnr = lv_matnr AND
                        werks = lv_werks AND
                        flag <> 'X'.
                  IF sy-subrc = 0.
                    wa_yse_scc_mat_prcs-chgind = i_hdrpos2-chngind.
                    wa_yse_scc_mat_prcs-udate = i_hdrpos2-udate.
                    wa_yse_scc_mat_prcs-matnr = lv_matnr.
                    wa_yse_scc_mat_prcs-werks = lv_werks.
                    wa_yse_scc_mat_prcs-mara = 'X'.
                    INSERT yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDSELECT.
          ENDIF.
        ENDIF.

        IF i_hdrpos2-tabname = 'DMAKT'.
          lv_matnr = i_hdrpos2-objectid(18).
          SELECT SINGLE * FROM yse_scc_mat_prcs INTO wa_yse_scc_mat_prcs
           WHERE chgind = i_hdrpos2-chngind AND
                 udate = i_hdrpos2-udate AND
                 matnr = lv_matnr.
          IF sy-subrc <> 0.   " INSERT new Entry in YSE_SCC_MAT_PRCS
            CLEAR wa_yse_scc_mat_prcs.
            SELECT werks FROM marc INTO lv_werks
              WHERE matnr = lv_matnr.

              SELECT SINGLE ekorg FROM t024w INTO wa_yse_scc_mat_prcs-ekorg
                      WHERE werks = lv_werks AND werks IN s_werks AND ekorg = p_ekorg.
              IF sy-subrc = 0.
                SELECT SINGLE * FROM yse_scc_used_mat
                WHERE matnr = lv_matnr AND
                     werks = lv_werks AND
                     flag <> 'X'.
                IF sy-subrc = 0.
                  wa_yse_scc_mat_prcs-chgind = i_hdrpos2-chngind.
                  wa_yse_scc_mat_prcs-udate = i_hdrpos2-udate.
                  wa_yse_scc_mat_prcs-matnr = lv_matnr.
                  wa_yse_scc_mat_prcs-werks = lv_werks.
                  wa_yse_scc_mat_prcs-makt = 'X'.
                  INSERT yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
                ENDIF.
              ENDIF.
            ENDSELECT.
          ELSE.
            SELECT werks FROM marc INTO lv_werks
             WHERE matnr = lv_matnr.

              SELECT SINGLE * FROM yse_scc_mat_prcs INTO wa_yse_scc_mat_prcs
              WHERE chgind = i_hdrpos2-chngind AND
                    udate = i_hdrpos2-udate AND
                    matnr = lv_matnr AND
                    werks = lv_werks.
              IF sy-subrc = 0.
                wa_yse_scc_mat_prcs-makt = 'X'.
                MODIFY yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
              ELSE.
                CLEAR wa_yse_scc_mat_prcs.
                SELECT SINGLE ekorg FROM t024w INTO wa_yse_scc_mat_prcs-ekorg
                   WHERE werks = lv_werks AND werks IN s_werks AND ekorg = p_ekorg.
                IF sy-subrc = 0.
                  SELECT SINGLE * FROM yse_scc_used_mat
                  WHERE matnr = lv_matnr AND
                       werks = lv_werks AND
                       flag <> 'X'.
                  IF sy-subrc = 0.
                    wa_yse_scc_mat_prcs-chgind = i_hdrpos2-chngind.
                    wa_yse_scc_mat_prcs-udate = i_hdrpos2-udate.
                    wa_yse_scc_mat_prcs-matnr = lv_matnr.
                    wa_yse_scc_mat_prcs-werks = lv_werks.
                    wa_yse_scc_mat_prcs-makt = 'X'.
                    INSERT yse_scc_mat_prcs FROM wa_yse_scc_mat_prcs.
                  ENDIF.
                ENDIF. " YSE_SCC_USED_MAT
              ENDIF.
            ENDSELECT.
          ENDIF.
        ENDIF.

      ENDLOOP.

* fill internal table to be used to fill the IDOC
      SELECT * FROM yse_scc_mat_prcs
          APPENDING CORRESPONDING FIELDS OF TABLE it_yse_scc_mat_prcs
          WHERE   udate IN s_ersda  AND
                  matnr IN s_matnr AND
                  werks IN s_werks  AND
                  ekorg EQ p_ekorg. "#EC CI_NOFIRST

*      ENDIF. "sy-tfill
    ENDIF.  " initial download ?
************************************ Further processing for initial download materials and changed materials **********************************************************

    DESCRIBE TABLE it_yse_scc_mat_prcs LINES sy-tfill.
    IF sy-tfill NE 0.
* Refine the table depending on the selections on the selection screen
      LOOP AT it_yse_scc_mat_prcs.
        lv_tabix = sy-tabix.
* Only Materials with Material Type/Material Group of selection screen
        CLEAR lv_prdha.
        SELECT SINGLE prdha FROM mara INTO lv_prdha
          WHERE matnr = it_yse_scc_mat_prcs-matnr AND
                matnr IN s_matnr AND
                mtart IN s_mtart AND
                matkl IN s_matkl.

        IF sy-subrc <> 0.
          DELETE it_yse_scc_mat_prcs INDEX lv_tabix.
          CONTINUE.
        ELSE.
          IF lv_prdha(4) NOT IN s_gac.
            DELETE it_yse_scc_mat_prcs INDEX lv_tabix.
            CONTINUE.
          ENDIF.
          IF lv_prdha+4(4) NOT IN s_pgc.
            DELETE it_yse_scc_mat_prcs INDEX lv_tabix.
            CONTINUE.
          ENDIF.
        ENDIF.
* Vendors which are not selected on selection screen-> exclude  otherwise allways send IDOC with or without vendor
        SELECT SINGLE lifnr FROM eord INTO lv_lifnr2
          WHERE matnr = it_yse_scc_mat_prcs-matnr AND
                werks = it_yse_scc_mat_prcs-werks AND
                bdatu > sy-datum AND
                flifn = 'X'.
        IF sy-subrc = 0.
          SELECT SINGLE lifnr FROM eord INTO lv_lifnr2
            WHERE matnr = it_yse_scc_mat_prcs-matnr AND
                  werks = it_yse_scc_mat_prcs-werks AND
                  lifnr IN s_ven AND
                  bdatu > sy-datum AND
                  flifn = 'X'.
          IF sy-subrc <> 0.
            DELETE it_yse_scc_mat_prcs INDEX lv_tabix.
            CONTINUE.
          ENDIF.
        ENDIF.

      ENDLOOP.

      SORT it_yse_scc_mat_prcs BY chgind matnr werks zeord ekorg infnr.
*      DELETE ADJACENT DUPLICATES FROM IT_YSE_SCC_MAT_PRCS COMPARING CHGIND UDATE MATNR WERKS ZEORD EKORG INFNR.
      DELETE ADJACENT DUPLICATES FROM it_yse_scc_mat_prcs COMPARING chgind matnr werks zeord ekorg infnr.
* Retrieve all material info
      LOOP AT it_yse_scc_mat_prcs.
        CLEAR: lv_werks_2, lv_fam, lv_evers, lv_transpmode.
        CLEAR wa_matmas.

        wa_matmas-matnr = it_yse_scc_mat_prcs-matnr.
        IF it_yse_scc_mat_prcs-chgind = 'I' OR it_yse_scc_mat_prcs-chgind = 'A'.
          wa_matmas-trtype = 'A'.
        ELSE.
          wa_matmas-trtype = 'C'.
        ENDIF.
        wa_matmas-werks = it_yse_scc_mat_prcs-werks.
        lv_werks_2 = wa_matmas-werks(2).
        SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam
          WHERE werks = lv_werks_2.
        IF sy-subrc = 0.
          wa_matmas-fam = lv_fam.
        ENDIF.
*            wa_matmas-ekorg = IT_YSE_SCC_MAT_PRCS-EKORG.


        PERFORM get_mara.
        PERFORM get_dmakt.
        PERFORM get_marc.
        PERFORM get_mbew.
        PERFORM get_eord.
        PERFORM get_eine.
* Find Lead Time
*        clear lv_transpmode.
*        SELECT SINGLE ZZTRANSPMODE FROM YSE_PO_TRANSPORT into lv_transpmode
*         WHERE EKORG = IT_YSE_SCC_MAT_PRCS-EKORG AND
*               BSART = c_po_replenishment AND
*               LIFNR = wa_matmas-lifnr AND
*               EVERS = lv_evers        AND
*               MATKL = lv_matkl        AND
*               ZZURGCODE = 'Z1'.
*        IF sy-subrc NE 0.
*          clear lv_transpmode.
*          SELECT SINGLE ZZTRANSPMODE FROM YSE_PO_TRANSPORT into lv_transpmode
*           WHERE EKORG = IT_YSE_SCC_MAT_PRCS-EKORG AND
*                 BSART = c_po_replenishment AND
*                 LIFNR = wa_matmas-lifnr AND
*                 EVERS = '*'        AND
*                 MATKL = lv_matkl        AND
*                 ZZURGCODE = 'Z1'.
*          IF sy-subrc NE 0.
*            clear lv_transpmode.
*            SELECT SINGLE ZZTRANSPMODE FROM YSE_PO_TRANSPORT into lv_transpmode
*             WHERE EKORG = IT_YSE_SCC_MAT_PRCS-EKORG AND
*                  BSART = c_po_replenishment AND
*                  LIFNR = wa_matmas-lifnr AND
*                  EVERS = lv_evers        AND
*                  MATKL = '*'             AND
*                  ZZURGCODE = 'Z1'.
*            IF sy-subrc NE 0.
*              clear lv_transpmode.
*              SELECT SINGLE ZZTRANSPMODE FROM YSE_PO_TRANSPORT into lv_transpmode
*               WHERE EKORG = IT_YSE_SCC_MAT_PRCS-EKORG AND
*                   BSART = c_po_replenishment AND
*                   LIFNR = wa_matmas-lifnr AND
*                   EVERS = '*'             AND
*                   MATKL = '*'             AND
*                   ZZURGCODE = 'Z1'.
*
*            ENDIF.
*          ENDIF.
*        ENDIF.
*        SELECT SINGLE PLIFZ FROM YSE_PO_PLDELTIME into lv_plifz
*          WHERE EKORG = IT_YSE_SCC_MAT_PRCS-EKORG AND
*                LIFNR = wa_matmas-lifnr AND
*                WERKS = wa_matmas-werks AND
*                ZZTRANSPMODE = lv_transpmode.
*        if lv_plifz is initial.
*          lv_plifz = lv_aplfz.
*          if lv_plifz is initial.
*            select single plifz from marc into lv_plifz
*              where matnr = wa_matmas-matnr and
*                    werks = wa_matmas-werks.
*          endif.
*        endif.

        SELECT SINGLE lead FROM yse_scc_used_mat INTO lv_plifz
          WHERE matnr = wa_matmas-matnr AND
                werks = wa_matmas-werks.

        wa_matmas-lead_time = lv_plifz.
* Fill Updated/Insert tables
        wa_matmas-eine = it_yse_scc_mat_prcs-eine.
        wa_matmas-marc = it_yse_scc_mat_prcs-marc.
        wa_matmas-mara = it_yse_scc_mat_prcs-mara.
        wa_matmas-mbew = it_yse_scc_mat_prcs-mbew.
        wa_matmas-eord = it_yse_scc_mat_prcs-eord.
        wa_matmas-makt = it_yse_scc_mat_prcs-makt.
        APPEND wa_matmas TO it_matmas.
      ENDLOOP.


*  change all 'X' (new created) into 'P' (Processed) in YSE_SCC_USED_MAT for the once we will create and IDOC(entries in it_matmas)
      LOOP AT it_matmas INTO wa_matmas.


        UPDATE yse_scc_used_mat SET flag = 'P'
          WHERE matnr = wa_matmas-matnr AND werks = wa_matmas-werks.

      ENDLOOP.
* Fill Idoc Material Information
      CLEAR wa_matmas.
      LOOP AT it_matmas INTO wa_matmas.
        CLEAR l_data.
        l_data-segnam  = c_segment_scc_matmas.
        l_data-sdata   = wa_matmas.
        APPEND l_data.
      ENDLOOP.
    ELSE.

      lv_ekorg = p_ekorg+0(2).
      SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam
        WHERE werks = lv_ekorg.

      CLEAR l_data.
      CLEAR wa_matmas.
      wa_matmas-fam = lv_fam.
      wa_matmas-werks = c_9999.
      wa_matmas-plant_credat = sy-datum.
      wa_matmas-verpr = '0'.
      wa_matmas-netpr = '0'.
      wa_matmas-ntgew = '0'.
      wa_matmas-lead_time = '0'.
      l_data-segnam  = c_segment_scc_matmas.
      l_data-sdata   = wa_matmas.
      APPEND l_data.
    ENDIF. "sy-tfill
  ENDIF.

********************************************************************************************************************************************
* Stock Information
  IF p_mes_type EQ c_mestyp_scc_stock.
    CLEAR it_werks[].
    CLEAR it_mska[].
    SELECT  werks FROM t024w INTO TABLE it_werks
       WHERE werks IN s_werks AND ekorg EQ p_ekorg.
* Select the materials which correspond to most of the selection crit.
"MOD-004 begin
*    SELECT      a~matnr c~werks d~lgort a~mtart a~matkl c~mmsta a~meins
*                a~prdha
*                c~dismm d~labst d~insme d~speme d~retme
*                d~umlme c~umlmc c~trame c~minbe c~bstfe c~eisbe c~lgrad
*                c~plifz c~maxlz c~mmstd c~nfmat c~prctr d~lgpbe
*                 INTO TABLE it_material
*          FROM mara AS a
*          INNER JOIN marc AS c
*              ON a~matnr = c~matnr
*          INNER JOIN yse_scc_used_mat AS b
*              ON c~matnr = b~matnr AND
*                 c~werks = b~werks
*          LEFT OUTER JOIN mard AS d
*             ON c~matnr = d~matnr
*            AND c~werks = d~werks
*          FOR ALL ENTRIES IN it_werks
*          WHERE c~werks = it_werks-werks AND
*                a~matnr IN s_matnrs AND
*                c~werks IN s_werks  AND
*                a~matkl IN s_matkls AND
*                a~mtart IN s_mtarts AND
*                a~lvorm EQ space AND
*                b~flag = 'P'.
**                d~labst <> 0.
**          AND a~matnr IN s_matnr
**          AND c~werks IN s_werkss.

      select b~matnr b~werks a~mtart a~matkl a~meins a~prdha
           d~lgort c~mmsta c~dismm d~labst d~insme d~speme d~retme
           d~umlme c~umlmc c~trame c~minbe c~bstfe c~eisbe c~lgrad
           c~plifz c~maxlz c~mmstd c~nfmat c~prctr d~lgpbe
      into corresponding fields of table it_material
        from yse_scc_used_mat as b
      inner join mara as a
      on a~matnr = b~matnr
      inner join marc as c
            on c~matnr = b~matnr
           and c~werks = b~werks
      left outer join mard as d
            on d~matnr = b~matnr
           and d~werks = b~werks
      for all entries in it_werks
      where b~matnr in s_matnrs and
            b~werks = it_werks-werks and
            b~flag = 'P' and
            a~matkl in s_matkls and
            a~mtart in s_mtarts and
            a~lvorm eq space.
"MOD-004 end

    LOOP AT it_material.
      lv_ind = sy-tabix.
      IF it_material-lgort = '1000' OR it_material-lgort = ' '.
        it_material-lgort = '1000'.
        MODIFY it_material INDEX lv_ind.
      ELSE.
        DELETE it_material INDEX lv_ind.
      ENDIF.
    ENDLOOP.

    sort it_material[] by matnr werks lgort. "MOD-004

* Get allocated stock
* Get order data for "stock back order" and "open sales orders" (allocated stock) ZOR/ZO03
    PERFORM get_order_data.
* Get Sales Order Stock
    PERFORM get_sales_order_stock.

* Get order data for ZRE1
    PERFORM get_order_data_zre1.
* Get service reservation data for "stock back order" and "open reservations" (allocated stock)
*    PERFORM get_service_data.

* Get Allocated Stock
    PERFORM get_allocated_stock.
*    PERFORM get_allocated_stock1.

    SORT it_mska by matnr werks lgort.

    LOOP AT it_material.
      CLEAR lv_kalab.
      READ TABLE it_alloc WITH KEY matnr = it_material-matnr
                                   werks = it_material-werks.
      IF sy-subrc EQ 0.
        lv_index = sy-tabix.

* Add Sales order stock
        READ TABLE it_mska WITH KEY matnr = it_material-matnr
                                    werks = it_material-werks
                                    lgort = it_material-lgort
                       BINARY SEARCH.
        IF sy-subrc EQ 0.
          lv_kalab = it_mska-kalab.
        ENDIF.
        it_alloc-unrestr_quantity = it_material-labst + lv_kalab.
        MODIFY it_alloc INDEX lv_index TRANSPORTING unrestr_quantity.
      ELSEIF it_material-lgort = '1000'.
        CLEAR it_alloc.
* Add Sales order stock
        READ TABLE it_mska WITH KEY matnr = it_material-matnr
                                    werks = it_material-werks
                                    lgort = it_material-lgort
                       BINARY SEARCH.
        IF sy-subrc EQ 0.
          lv_kalab = it_mska-kalab.
        ENDIF.
        it_alloc-matnr = it_material-matnr.
        it_alloc-werks = it_material-werks.
        it_alloc-lgort = it_material-lgort.
        it_alloc-unrestr_quantity = it_material-labst + lv_kalab.
        APPEND it_alloc.
      ENDIF.
    ENDLOOP.

    SORT it_alloc_zre1 BY matnr werks."MOD-004
    LOOP AT it_alloc.

      CLEAR lv_zre1.
      "MOD-004 begin
      READ TABLE it_alloc_zre1 WITH KEY matnr = it_alloc-matnr"it_material-matnr
                                     werks = it_alloc-werks"it_material-werks.
                                     BINARY SEARCH.
      "MOD-004 end

      IF sy-subrc EQ 0.
        lv_zre1 = it_alloc_zre1-alloc_quantity.
      ENDIF.

      CLEAR: lv_werks_stck, lv_fam_stck.
      lv_werks_stck = it_alloc-werks(2).
      SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam_stck
         WHERE werks = lv_werks_stck.
      IF sy-subrc = 0.
        wa_stock-fam = lv_fam_stck.
      ENDIF.

      CLEAR: lv_available_stck, lv_unrestr_stck.

      wa_stock-matnr = it_alloc-matnr.
      wa_stock-werks = it_alloc-werks.
      lv_available_stck = it_alloc-unrestr_quantity - it_alloc-alloc_quantity + lv_zre1.
      lv_unrestr_stck = it_alloc-unrestr_quantity.
      wa_stock-unrestr_stck = lv_unrestr_stck.
      wa_stock-available_stck = lv_available_stck.
      IF NOT lv_available_stck IS INITIAL.
        APPEND wa_stock TO it_stock.
      ENDIF.
    ENDLOOP.

* Fill IDOC Stock
    IF it_stock[] IS NOT INITIAL.
      CLEAR wa_stock.
      LOOP AT it_stock INTO wa_stock.
        CLEAR l_data.
        l_data-segnam  = c_segment_scc_stock.
        l_data-sdata   = wa_stock.
        APPEND l_data.
      ENDLOOP.
    ELSE.
      CLEAR l_data.
      CLEAR wa_stock.

      lv_ekorg = p_ekorg+0(2).
      SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam
        WHERE werks = lv_ekorg.
      wa_stock-fam = lv_fam.
      wa_stock-werks = c_9999.
      wa_stock-available_stck = '0'.
      wa_stock-unrestr_stck = '0'.
      l_data-segnam  = c_segment_scc_stock.
      l_data-sdata   = wa_stock.
      APPEND l_data.
    ENDIF.

  ENDIF.
*****************************************************************************************************************************
  IF p_mes_type EQ c_mestyp_scc_opo.

    IF p_inio = 'X'. " intial load?

* Purchase Orders
      CLEAR it_werks[].
      SELECT  werks FROM t024w INTO TABLE it_werks
         WHERE werks IN s_werks AND ekorg EQ p_ekorg.

      CLEAR it_opo[].
      SELECT ekko~lifnr AS lifnr
             ekko~reswk AS reswk
             ekko~bsart AS bsart
             ekpo~menge AS qo_menge
             ekpo~ebeln AS ebeln
             ekpo~ebelp AS ebelp
             ekpo~matnr AS matnr
             ekpo~werks AS werks
             ekpo~loekz AS loekz
      FROM ekpo
      INNER JOIN  ekko  ON ekpo~ebeln =  ekko~ebeln
      INNER JOIN  eket  ON ekpo~ebeln =  eket~ebeln
                      AND  ekpo~ebelp =  eket~ebelp
         INTO CORRESPONDING FIELDS OF TABLE it_opo
               FOR ALL ENTRIES IN it_werks
      WHERE ekpo~werks = it_werks-werks AND
            ekpo~matnr IN s_matnro AND
            ekpo~werks IN s_werks AND
            ekko~lifnr IN s_lifnro AND
            ekko~bsart IN s_bsarto AND
            ekko~ebeln IN s_ebelno AND
            (  ( ekko~bsart IN ('ZNB1', 'ZNB2') AND ( ekpo~lgort = '1000' OR ekpo~lgort = ' ' ) )  OR
               ( ekko~bsart EQ 'ZUB1' AND ekpo~lgort = '1000' )
            ) AND
            ekko~ekorg EQ p_ekorg AND
            eket~etenr = '0001'.

* Purchase Requisitions
      SELECT  werks FROM t024w INTO TABLE it_werks
            WHERE werks IN s_werks AND ekorg EQ p_ekorg.

      SELECT   eban~flief AS lifnr
*               ekko~reswk as reswk
               eban~bsart AS bsart
               eban~menge AS qo_menge
               eban~banfn AS ebeln
               eban~bnfpo AS ebelp
               eban~matnr AS matnr
               eban~werks AS werks
               eban~loekz AS loekz
       INTO CORRESPONDING FIELDS OF TABLE it_opo2
       FROM eban
        FOR ALL ENTRIES IN it_werks
         WHERE eban~werks = it_werks-werks
          AND eban~badat IN s_credao
          AND eban~werks IN s_werks
          AND eban~banfn IN s_banfno
          AND eban~matnr IN s_matnro
          AND eban~ekorg = p_ekorg
          AND eban~bsart IN ('ZNB1', 'ZNB2', 'ZNB3').

    ELSE.
* Select the created Purchase Requistions
      CLEAR it_opo2[].
      CLEAR it_werks[].
      SELECT  werks FROM t024w INTO TABLE it_werks
            WHERE werks IN s_werks AND ekorg EQ p_ekorg.

      SELECT   eban~flief AS lifnr
*               ekko~reswk as reswk
               eban~bsart AS bsart
               eban~menge AS qo_menge
               eban~banfn AS ebeln
               eban~bnfpo AS ebelp
               eban~matnr AS matnr
               eban~werks AS werks
               eban~loekz AS loekz
       INTO CORRESPONDING FIELDS OF TABLE it_opo2
       FROM eban
        FOR ALL ENTRIES IN it_werks
         WHERE eban~werks = it_werks-werks
          AND eban~badat IN s_credao
          AND eban~werks IN s_werks
          AND eban~banfn IN s_banfno
          AND eban~matnr IN s_matnro
          AND eban~ekorg = p_ekorg
          AND eban~bsart IN ('ZNB1', 'ZNB2', 'ZNB3').



* Select all change documents for Open Purchase Order (EKKO EKPO EKET)
      CLEAR i_cdhdr[].
      SELECT *
           INTO TABLE i_cdhdr
           FROM cdhdr
             WHERE ( objectclas = 'EINKBELEG' )
*             AND objectid   = dobject-objky
               AND ( udate IN s_credao ).
*             AND  objectid IN s_matnr.

      DESCRIBE TABLE i_cdhdr LINES sy-tfill.
      IF sy-tfill NE 0.
        SORT i_cdhdr BY udate utime.
* Fill internal table with changed documents
        CLEAR i_hdrpos[].
        SELECT  changenr objectclas objectid tabname tabkey fname chngind value_new value_old FROM cdpos INTO CORRESPONDING FIELDS OF TABLE i_hdrpos
          FOR ALL ENTRIES IN i_cdhdr
               WHERE objectclas  = i_cdhdr-objectclas
                 AND objectid    = i_cdhdr-objectid
                 AND changenr    = i_cdhdr-changenr
                 AND ( ( tabname = 'EKPO' AND ( fname = 'WERKS' OR fname = 'KEY') )
                    OR ( tabname = 'EKPO' AND ( fname = 'MATNR' OR fname = 'KEY') )
                    OR ( tabname = 'EKPO' AND ( fname = 'MENGE' OR fname = 'KEY') )
                    OR ( tabname = 'EKPO' AND ( fname = 'LOEKZ' OR fname = 'KEY') )
                    OR ( tabname = 'EKKO' AND ( fname = 'LIFNR' OR fname = 'KEY') )
                    OR ( tabname = 'EKET' AND ( fname = 'EINDT' OR fname = 'KEY') ) ).
      ENDIF.

*        IF sy-subrc = 0.
*          LOOP AT i_hdrpos.   " You can not join with cluster tables.
*            select single UDATE from cdhdr into i_hdrpos-UDATE
*              where changenr = i_hdrpos-changenr and
*                    objectclas = i_hdrpos-objectclas and
*                    objectid = i_hdrpos-objectid.
*            if sy-subrc = 0.
*              MODIFY i_hdrpos transporting UDATE.
*            endif.
*          ENDLOOP.
*        ENDIF.

* Select all change documents for Open Purchase requistion (EBAN)
      CLEAR i_cdhdr[].
      SELECT *
           INTO TABLE i_cdhdr
           FROM cdhdr
             WHERE ( objectclas = 'BANF' )
*             AND objectid   = dobject-objky
               AND ( udate IN s_credao ).
*             AND  objectid IN s_matnr.

      DESCRIBE TABLE i_cdhdr LINES sy-tfill.
      IF sy-tfill NE 0.
        SORT i_cdhdr BY udate utime.
* Fill internal table with changed documents
*        clear i_hdrpos[].
        SELECT  changenr objectclas objectid tabname tabkey fname chngind value_new value_old FROM cdpos APPENDING CORRESPONDING FIELDS OF TABLE i_hdrpos
          FOR ALL ENTRIES IN i_cdhdr
               WHERE objectclas  = i_cdhdr-objectclas
                 AND objectid    = i_cdhdr-objectid
                 AND changenr    = i_cdhdr-changenr
                 AND ( ( tabname = 'EBAN' AND ( fname = 'LOEKZ' OR fname = 'KEY') )
                    OR ( tabname = 'EBAN' AND ( fname = 'MENGE' OR fname = 'KEY') )
                    OR ( tabname = 'EBAN' AND ( fname = 'BADAT' OR fname = 'KEY') )
                    OR ( tabname = 'EBAN' AND ( fname = 'ERDAT' OR fname = 'KEY') )
                    ).
      ENDIF.

      DESCRIBE TABLE i_hdrpos LINES sy-tfill.
      IF sy-tfill NE 0.
        LOOP AT i_hdrpos.   " You can not join with cluster tables.
          SELECT SINGLE udate FROM cdhdr INTO i_hdrpos-udate
            WHERE changenr = i_hdrpos-changenr AND
                  objectclas = i_hdrpos-objectclas AND
                  objectid = i_hdrpos-objectid.
          IF sy-subrc = 0.
            MODIFY i_hdrpos TRANSPORTING udate.
          ENDIF.
        ENDLOOP.


        SORT i_hdrpos BY chngind udate tabname.
        LOOP AT i_hdrpos.

          CLEAR wa_yse_scc_opo_prcs.
          CLEAR: lv_ebeln, lv_ebelp, lv_etenr, lv_banfn, lv_bnfpo.
*
          IF i_hdrpos-tabname = 'EBAN'.
            lv_banfn = i_hdrpos-objectid.
            lv_bnfpo = i_hdrpos-tabkey+13(5).

            SELECT SINGLE * FROM yse_scc_opo_prcs INTO wa_yse_scc_opo_prcs
              WHERE
*                  CHGIND = i_hdrpos-CHNGIND AND
                    udate  = i_hdrpos-udate AND
                    ebeln = lv_banfn AND
                    ebelp = lv_bnfpo.
            IF sy-subrc <> 0.   " INSERT new Entry in YSE_SCC_OPO_PRCS
              CLEAR wa_yse_scc_opo_prcs.
*            wa_YSE_SCC_OPO_PRCS-CHGIND = i_hdrpos-CHNGIND.
              wa_yse_scc_opo_prcs-udate = i_hdrpos-udate.
              wa_yse_scc_opo_prcs-ebeln = lv_banfn.
              wa_yse_scc_opo_prcs-ebelp = lv_bnfpo.
*              SELECT SINGLE EKORG FROM t024w INTO wa_YSE_SCC_OPO_PRCS-EKORG
*                where WERKS = lv_WERKS and werks in s_werks and ekorg eq p_ekorg.
*              if sy-subrc = 0.
              wa_yse_scc_opo_prcs-eban = 'X'.
              INSERT yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
*              endif.
            ELSE. " UPDATE Entry in YSE_SCC_OPO_PRCS
              wa_yse_scc_opo_prcs-eban = 'X'.
              MODIFY yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
            ENDIF.
          ENDIF.

          IF i_hdrpos-tabname = 'EKKO'.
            lv_ebeln = i_hdrpos-objectid.
            SELECT SINGLE * FROM yse_scc_opo_prcs INTO wa_yse_scc_opo_prcs
             WHERE
*                   CHGIND = i_hdrpos-CHNGIND AND
                   udate = i_hdrpos-udate AND
                   ebeln = lv_ebeln.
            IF sy-subrc <> 0.   " INSERT new Entry in YSE_SCC_OPO_PRCS
              CLEAR wa_yse_scc_opo_prcs.
              SELECT ebelp  FROM ekpo INTO lv_ebelp
                WHERE ebeln = lv_ebeln.
                IF sy-subrc = 0.
*                 select ebelp  from eket into lv_etenr
*                  where ebeln = lv_ebeln and
*                        ebelp = lv_ebelp.
*               SELECT SINGLE EKORG FROM t024w INTO wa_YSE_SCC_OPO_PRCS-EKORG
*                where WERKS = lv_WERKS and werks in s_werks and ekorg eq p_ekorg.
*                 if sy-subrc = 0.
*                  wa_YSE_SCC_OPO_PRCS-CHGIND = i_hdrpos-CHNGIND.
                  wa_yse_scc_opo_prcs-udate = i_hdrpos-udate.
                  wa_yse_scc_opo_prcs-ebeln = lv_ebeln.
                  wa_yse_scc_opo_prcs-ebelp = lv_ebelp.
                  wa_yse_scc_opo_prcs-ekko = 'X'.
                  INSERT yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
*                 endselect.
*                 endif.
                ENDIF.
              ENDSELECT.
            ELSE.
              SELECT ebelp FROM ekpo INTO lv_ebelp
               WHERE ebeln = lv_ebeln.

                SELECT SINGLE * FROM yse_scc_opo_prcs INTO wa_yse_scc_opo_prcs
                WHERE
*                      CHGIND = i_hdrpos-CHNGIND AND
                      udate = i_hdrpos-udate AND
                      ebeln = lv_ebeln AND
                      ebelp = lv_ebelp.
                IF sy-subrc = 0.
                  wa_yse_scc_opo_prcs-ekko = 'X'.
                  MODIFY yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
                ELSE.
                  CLEAR wa_yse_scc_opo_prcs.
*               SELECT SINGLE EKORG FROM t024w INTO wa_YSE_SCC_OPO_PRCS-EKORG
*                where WERKS = lv_WERKS and werks in s_werks and ekorg eq p_ekorg.
*                 if sy-subrc = 0.
*                  wa_YSE_SCC_OPO_PRCS-CHGIND = i_hdrpos-CHNGIND.
                  wa_yse_scc_opo_prcs-udate = i_hdrpos-udate.
                  wa_yse_scc_opo_prcs-ebeln = lv_ebeln.
                  wa_yse_scc_opo_prcs-ebelp = lv_ebelp.
                  wa_yse_scc_opo_prcs-ekko = 'X'.
                  INSERT yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
*                 endif.
                ENDIF.
              ENDSELECT.
            ENDIF.
          ENDIF.
        ENDLOOP.

        IF i_hdrpos-tabname = 'EKPO'.
          lv_ebeln = i_hdrpos-objectid.
          lv_ebelp = i_hdrpos-tabkey+13(5).

          SELECT SINGLE * FROM yse_scc_opo_prcs INTO wa_yse_scc_opo_prcs
            WHERE
*                  CHGIND = i_hdrpos-CHNGIND AND
                  udate  = i_hdrpos-udate AND
                  ebeln = lv_ebeln AND
                  ebelp = lv_ebelp.
          IF sy-subrc <> 0.   " INSERT new Entry in YSE_SCC_MAT_PRCS
            CLEAR wa_yse_scc_opo_prcs.
*            wa_YSE_SCC_OPO_PRCS-CHGIND = i_hdrpos-CHNGIND.
            wa_yse_scc_opo_prcs-udate = i_hdrpos-udate.
            wa_yse_scc_opo_prcs-ebeln = lv_ebeln.
            wa_yse_scc_opo_prcs-ebelp = lv_ebelp.
*              SELECT SINGLE EKORG FROM t024w INTO wa_YSE_SCC_OPO_PRCS-EKORG
*                where WERKS = lv_WERKS and werks in s_werks and ekorg eq p_ekorg.
*              if sy-subrc = 0.
            wa_yse_scc_opo_prcs-ekpo = 'X'.
            INSERT yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
*              endif.
          ELSE. " UPDATE Entry in YSE_SCC_MAT_PRCS
            wa_yse_scc_opo_prcs-ekpo = 'X'.
            MODIFY yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
          ENDIF.
        ENDIF.

        IF i_hdrpos-tabname = 'EKET'.
          lv_ebeln = i_hdrpos-objectid.
          lv_ebelp = i_hdrpos-tabkey+13(5).
*        lv_etenr = i_hdrpos-TABKEY+18(4).


          SELECT SINGLE * FROM yse_scc_opo_prcs INTO wa_yse_scc_opo_prcs
            WHERE
*                  CHGIND = i_hdrpos-CHNGIND AND
                  udate  = i_hdrpos-udate AND
                  ebeln = lv_ebeln AND
                  ebelp = lv_ebelp.
*                ETENR = lv_etenr.

          IF sy-subrc <> 0.   " INSERT new Entry in YSE_SCC_MAT_PRCS
            CLEAR wa_yse_scc_opo_prcs.
*            wa_YSE_SCC_OPO_PRCS-CHGIND = i_hdrpos-CHNGIND.
            wa_yse_scc_opo_prcs-udate = i_hdrpos-udate.
            wa_yse_scc_opo_prcs-ebeln = lv_ebeln.
            wa_yse_scc_opo_prcs-ebelp = lv_ebelp.
*          wa_YSE_SCC_OPO_PRCS-ETENR = lv_etenr.
*              SELECT SINGLE EKORG FROM t024w INTO wa_YSE_SCC_OPO_PRCS-EKORG
*                where WERKS = lv_WERKS and werks in s_werks and ekorg eq p_ekorg.
*              if sy-subrc = 0.
            wa_yse_scc_opo_prcs-eket = 'X'.
            INSERT yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
*              endif.
          ELSE. " UPDATE Entry in YSE_SCC_MAT_PRCS
            wa_yse_scc_opo_prcs-eket = 'X'.
            MODIFY yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
          ENDIF.
        ENDIF.

* Received quantity

* Select all relevant goods receipts
        SELECT * INTO TABLE i_mkpf FROM mkpf
         WHERE ( cpudt IN s_credao )
         AND blart EQ 'WE'."#EC CI_NOFIELD
        IF sy-subrc = 0.

          SELECT * INTO TABLE i_mseg FROM mseg
          FOR ALL ENTRIES IN i_mkpf
           WHERE mblnr EQ i_mkpf-mblnr
            AND mjahr EQ i_mkpf-mjahr
            AND ( bwart EQ '101' OR bwart EQ '102').


          LOOP AT i_mseg.
            CLEAR lv_cpudt.
            SELECT SINGLE cpudt FROM mkpf INTO lv_cpudt
             WHERE mblnr EQ i_mseg-mblnr
              AND mjahr EQ i_mseg-mjahr.

            lv_ebeln = i_mseg-ebeln.
            lv_ebelp = i_mseg-ebelp.
            SELECT SINGLE * FROM yse_scc_opo_prcs INTO wa_yse_scc_opo_prcs
             WHERE
*                   CHGIND = 'U' AND
                   udate = lv_cpudt AND
                   ebeln = lv_ebeln AND
                   ebelp = lv_ebelp.
*                ETENR = lv_etenr.

            IF sy-subrc <> 0.   " INSERT new Entry in YSE_SCC_OPO_PRCS
              CLEAR wa_yse_scc_opo_prcs.
*              wa_YSE_SCC_OPO_PRCS-CHGIND = 'U'.
              wa_yse_scc_opo_prcs-udate = lv_cpudt.
              wa_yse_scc_opo_prcs-ebeln = lv_ebeln.
              wa_yse_scc_opo_prcs-ebelp = lv_ebelp.
*          wa_YSE_SCC_OPO_PRCS-ETENR = lv_etenr.
*              SELECT SINGLE EKORG FROM t024w INTO wa_YSE_SCC_OPO_PRCS-EKORG
*                where WERKS = lv_WERKS and werks in s_werks and ekorg eq p_ekorg.
*              if sy-subrc = 0.
              wa_yse_scc_opo_prcs-mseg = 'X'.
              INSERT yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
*              endif.
            ELSE. " UPDATE Entry in YSE_SCC_OPO_PRCS
              wa_yse_scc_opo_prcs-mseg = 'X'.
              MODIFY yse_scc_opo_prcs FROM wa_yse_scc_opo_prcs.
            ENDIF.
          ENDLOOP.
        ENDIF. " mkpf is filled

* fill internal table to be used to fill the IDOC
        SELECT * FROM yse_scc_opo_prcs INTO CORRESPONDING FIELDS OF TABLE it_yse_scc_opo_prcs
          WHERE udate IN s_credao.


      ENDIF. "sy-tfill

      DESCRIBE TABLE it_yse_scc_opo_prcs LINES sy-tfill.
      IF sy-tfill NE 0.
* Refine the table depending on the selections on the selection screen


*      fam TYPE werks_d,
*      lifnr TYPE lifnr,
*      bsart TYPE bsart,
*      eeind TYPE eeind,
*      ebeln TYPE ebeln,
*      ebelp TYPE ebelp,
*      qo_menge TYPE ZSCCMENG,
*      gr_menge TYPE ZSCCMENG_GR,
*      matnr TYPE matnr,
*      werks TYPE werks_d,
        CLEAR it_opo[].
        SELECT ekko~lifnr AS lifnr
               ekko~reswk AS reswk
               ekko~bsart AS bsart
               ekpo~menge AS qo_menge
               ekpo~ebeln AS ebeln
               ekpo~ebelp AS ebelp
               ekpo~matnr AS matnr
               ekpo~werks AS werks
               ekpo~loekz AS loekz
        FROM ekpo
        INNER JOIN  ekko  ON ekpo~ebeln =  ekko~ebeln
        INNER JOIN  eket  ON ekpo~ebeln =  eket~ebeln
                        AND  ekpo~ebelp =  eket~ebelp
           APPENDING corresponding fields of table it_opo
        FOR ALL ENTRIES IN  it_yse_scc_opo_prcs
        WHERE ekpo~ebeln =  it_yse_scc_opo_prcs-ebeln  AND
              ekpo~ebelp =  it_yse_scc_opo_prcs-ebelp AND
              ekpo~matnr IN s_matnro AND
              ekpo~werks IN s_werks AND
              ekko~lifnr IN s_lifnro AND
              ekko~bsart IN s_bsarto AND
              ekko~ebeln IN s_ebelno AND
             (  ( ekko~bsart IN ('ZNB1', 'ZNB2') AND ( ekpo~lgort = '1000' OR ekpo~lgort = ' ' ) )  OR
                ( ekko~bsart EQ 'ZUB1' AND ekpo~lgort = '1000' )
              )  AND
              ekko~ekorg EQ p_ekorg AND
              eket~etenr = '0001'.

        SELECT eban~flief AS lifnr
*               ekko~reswk as reswk
*               ekko~bsart as bsart
               eban~menge AS qo_menge
               eban~bsart AS bsart
               eban~banfn AS ebeln
               eban~bnfpo AS ebelp
               eban~matnr AS matnr
               eban~werks AS werks
               eban~loekz AS loekz
          FROM eban
           APPENDING CORRESPONDING FIELDS OF TABLE it_opo2
           FOR ALL ENTRIES IN  it_yse_scc_opo_prcs
           WHERE eban~banfn =  it_yse_scc_opo_prcs-ebeln  AND
                 eban~bnfpo =  it_yse_scc_opo_prcs-ebelp AND
                 eban~werks IN s_werks AND
                 eban~flief IN s_lifnro AND
                 eban~banfn IN s_banfno AND
                 eban~ekorg = p_ekorg AND
                 eban~bsart IN ('ZNB1', 'ZNB2', 'ZNB3').
      ENDIF.
    ENDIF.   " initial load or not
*****************************************FURTHER PROCESSING*********************************************************************
*      if sy-subrc = 0.
* Further Processing Purchase Order
    SORT it_opo BY ebeln ebelp.
    LOOP AT it_opo INTO wa_opo.
* FAM
      CLEAR: lv_werks_opo, lv_fam_opo.
      lv_werks_opo = wa_opo-werks(2).
      SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam_opo
       WHERE werks = lv_werks_opo.
      IF sy-subrc = 0.
        wa_opo-fam = lv_fam_opo.
      ENDIF.
* Received Quantity
      CLEAR: lv_menge_d, lv_menge_c.
      SELECT SUM( menge ) FROM mseg INTO lv_menge_d
        WHERE matnr = wa_opo-matnr AND
              ebeln = wa_opo-ebeln AND
              ebelp = wa_opo-ebelp AND
              bwart EQ '101'.
      SELECT SUM( menge ) FROM mseg INTO lv_menge_c
        WHERE matnr = wa_opo-matnr AND
              ebeln = wa_opo-ebeln AND
              ebelp = wa_opo-ebelp AND
              bwart EQ '102'.

      wa_opo-gr_menge = lv_menge_d - lv_menge_c.
* Transaction Type
*           if IT_YSE_SCC_OPO_PRCS-CHGIND = 'I' or IT_YSE_SCC_OPO_PRCS-CHGIND = 'A'.
*             wa_opo-trtype = 'A'.
*           else.
*             wa_opo-trtype = 'C'.
*           endif.
      MODIFY it_opo FROM wa_opo.
    ENDLOOP.

    IF p_inio = 'X'. " intial load? -> PO's that are closed QO = GR should not be send
      LOOP AT it_opo INTO wa_opo.
        SELECT SINGLE * FROM  yse_scc_used_mat
         WHERE matnr = wa_opo-matnr AND
             werks = wa_opo-werks AND
             flag = 'P'.
        IF sy-subrc = 0.

          CLEAR lv_eeind.
          SELECT SINGLE firstd FROM yse_scc_firstopo INTO lv_eeind
            WHERE ebeln = wa_opo-ebeln AND
                  ebelp = wa_opo-ebelp AND
                  firstd IN s_rqdato.
          IF sy-subrc = 0 OR ( sy-subrc <> 0 AND s_rqdato IS INITIAL ).
            IF wa_opo-qo_menge <> wa_opo-gr_menge.
              it_opo_c-eeind = lv_eeind.
              it_opo_c-fam  = wa_opo-fam.
*             it_opo_c-trtype = wa_opo-trtype.
              IF wa_opo-bsart = 'ZNB1' OR  wa_opo-bsart = 'ZNB2'.
                it_opo_c-lifnr = wa_opo-lifnr.
              ELSE.
                it_opo_c-lifnr = wa_opo-reswk.
              ENDIF.
              it_opo_c-bsart = wa_opo-bsart.
              it_opo_c-ebeln = wa_opo-ebeln.
              it_opo_c-ebelp =  wa_opo-ebelp.
* Deleted po lines ordered qty = 0

              it_opo_c-qo_menge = wa_opo-qo_menge.
              it_opo_c-gr_menge = wa_opo-gr_menge.
              it_opo_c-matnr = wa_opo-matnr.
              it_opo_c-werks = wa_opo-werks.
              IF wa_opo-loekz <> 'L'.
                APPEND it_opo_c.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ELSE.
      LOOP AT it_opo INTO wa_opo.
        SELECT SINGLE * FROM  yse_scc_used_mat
         WHERE matnr = wa_opo-matnr AND
               werks = wa_opo-werks AND
               flag = 'P'.
        IF sy-subrc = 0.
          CLEAR lv_eeind.
          SELECT SINGLE firstd FROM yse_scc_firstopo INTO lv_eeind
            WHERE ebeln = wa_opo-ebeln AND
                  ebelp = wa_opo-ebelp AND
                  firstd IN s_rqdato.
          IF sy-subrc = 0 OR ( sy-subrc <> 0 AND s_rqdato IS INITIAL ).
            it_opo_c-eeind = lv_eeind.
            it_opo_c-fam  = wa_opo-fam.
*             it_opo_c-trtype = wa_opo-trtype.
            IF wa_opo-bsart = 'ZNB1' OR  wa_opo-bsart = 'ZNB2'.
              it_opo_c-lifnr = wa_opo-lifnr.
            ELSE.
              it_opo_c-lifnr = wa_opo-reswk.
            ENDIF.
            it_opo_c-bsart = wa_opo-bsart.
            it_opo_c-ebeln = wa_opo-ebeln.
            it_opo_c-ebelp =  wa_opo-ebelp.
* Deleted po lines ordered qty = 0
            IF wa_opo-loekz = 'L'.
              it_opo_c-qo_menge = 0.
            ELSE.
              it_opo_c-qo_menge = wa_opo-qo_menge.
            ENDIF.
            it_opo_c-gr_menge = wa_opo-gr_menge.
            it_opo_c-matnr = wa_opo-matnr.
            it_opo_c-werks = wa_opo-werks.
            APPEND it_opo_c.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.


*      endif.
*      ENDLOOP.
**    ENDIF.

* Further Processing Purchase Requisition

    SORT it_opo2 BY ebeln ebelp.
    DELETE ADJACENT DUPLICATES FROM it_opo2 COMPARING ebeln ebelp.

    LOOP AT it_opo2 INTO wa_opo2.
* FAM
      CLEAR: lv_werks_opo, lv_fam_opo.
      lv_werks_opo = wa_opo2-werks(2).
      SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam_opo
       WHERE werks = lv_werks_opo.
      IF sy-subrc = 0.
        wa_opo2-fam = lv_fam_opo.
      ENDIF.

* Received Quantity
      CLEAR: lv_ebeln_pr, lv_loekz_pr.
      SELECT SINGLE ebeln loekz FROM eban INTO (lv_ebeln_pr, lv_loekz_pr)
        WHERE banfn = wa_opo2-ebeln AND
              bnfpo = wa_opo2-ebelp.
      IF NOT lv_ebeln_pr IS INITIAL OR NOT lv_loekz_pr IS INITIAL.
        wa_opo2-gr_menge = 0.
        wa_opo2-qo_menge = 0.
      ELSE.
        wa_opo2-gr_menge = 0.
      ENDIF.
      MODIFY it_opo2 FROM wa_opo2.
    ENDLOOP.

    CLEAR wa_opo2.
    LOOP AT it_opo2 INTO wa_opo2.

      SELECT SINGLE * FROM  yse_scc_used_mat
        WHERE matnr = wa_opo2-matnr AND
              werks = wa_opo2-werks AND
              flag = 'P'.
      IF sy-subrc = 0.
        CLEAR lv_firstd.
*       select single firstd from YSE_SCC_FIRSTOPO into lv_firstd
*         where ebeln = wa_opo2-ebeln and
*               ebelp = wa_opo2-ebelp and
*               firstd in s_rqdato.
        SELECT SINGLE lfdat FROM eban INTO lv_firstd
          WHERE banfn = wa_opo2-ebeln AND
                bnfpo = wa_opo2-ebelp AND
                lfdat IN s_rqdato.

        IF sy-subrc = 0 OR ( sy-subrc <> 0 AND s_rqdato IS INITIAL ).
          it_opo2_c-eeind = lv_firstd.
          it_opo2_c-fam  = wa_opo2-fam.
          it_opo2_c-lifnr = wa_opo2-lifnr.
          it_opo2_c-bsart = wa_opo2-bsart.
          it_opo2_c-ebeln = wa_opo2-ebeln.
          it_opo2_c-ebelp = wa_opo2-ebelp.
          it_opo2_c-qo_menge = wa_opo2-qo_menge.
          it_opo2_c-gr_menge = wa_opo2-gr_menge.
          it_opo2_c-matnr = wa_opo2-matnr.
          it_opo2_c-werks = wa_opo2-werks.
          IF p_inio = 'X'. " intial load? -> PO's that are closed QO = GR should not be send
            IF it_opo2_c-qo_menge <> 0.
              APPEND it_opo2_c.
            ENDIF.
          ELSE.
            APPEND it_opo2_c.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.


* Fill IDOC Open Purchase Order
    CLEAR wa_opo_c.
    LOOP AT it_opo_c INTO wa_opo_c.
      CLEAR l_data.
      l_data-segnam  = c_segment_scc_opo.
      l_data-sdata   = wa_opo_c.
      APPEND l_data.
    ENDLOOP.

* Fill IDOC Purchase Requisition
    CLEAR wa_opo2_c.
    LOOP AT it_opo2_c INTO wa_opo2_c.
      CLEAR l_data.
      l_data-segnam  = c_segment_scc_opo.
      l_data-sdata   = wa_opo2_c.
      APPEND l_data.
    ENDLOOP.

    IF l_data[] IS INITIAL.

      lv_ekorg = p_ekorg+0(2).
      SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam
        WHERE werks = lv_ekorg.


      CLEAR l_data.
      wa_opo_c-fam = lv_fam.
      wa_opo_c-ebeln = c_9999999999.
      wa_opo_c-eeind = sy-datum.
      wa_opo_c-qo_menge = '0'.
      wa_opo_c-gr_menge = '0'.
      l_data-segnam  = c_segment_scc_opo.
      l_data-sdata   = wa_opo_c.
      APPEND l_data.
    ENDIF.

  ENDIF.
*****************************************************************************************************************************
  IF p_mes_type EQ c_mestyp_scc_cud.

*  if p_inic = 'X'. " intial load?
**        clear it_cud[].
*      SELECT ekko~lifnr as lifnr
*             ekko~bsart as bsart
*             ekpo~menge as qo_menge
*             eket~eindt as eeind
*             ekpo~ebeln as ebeln
*             ekpo~ebelp as ebelp
*             ekpo~matnr as matnr
*             ekpo~werks as werks
*      FROM ekpo
*      INNER JOIN  ekko  ON ekpo~ebeln =  ekko~ebeln
*      INNER JOIN  eket  ON ekpo~ebeln =  eket~ebeln
*                      AND  ekpo~ebelp =  eket~ebelp
*         INTO CORRESPONDING FIELDS OF TABLE it_opo
*      WHERE ekpo~MATNR in s_matnro AND
*            ekpo~WERKS in s_werks AND
*            ekko~LIFNR in s_lifnro AND
*            ekko~BSART in s_bsarto AND
*            eket~EINDT in s_rqdato AND
*            ( ekko~BSART in ('ZNB1', 'ZNB2') OR
*              ( ekko~BSART eq 'ZUB1' and ekpo~lgort = '1000' ) ) AND
*            ekko~EKORG eq p_ekorg AND
*            eket~etenr = '0001'.
*  else.

* Select all sales orders for Customer Demand (VBAK VBAP)
    CLEAR it_cud_scc[].
    CLEAR it_vbakcud[].
    CLEAR it_werks[].
    SELECT  werks FROM t024w INTO TABLE it_werks
          WHERE werks IN s_werks AND ekorg EQ p_ekorg.
* Fill internal table it_vbakcud with the Sales documents which are created
    SELECT vbap~vbeln
     INTO CORRESPONDING FIELDS OF TABLE it_vbakcud
     FROM vbak
     INNER JOIN vbap ON vbap~vbeln EQ vbak~vbeln
      FOR ALL entries IN it_werks
       WHERE vbap~werks = it_werks-werks
        AND vbap~erdat IN s_credac
        AND ( vbak~auart = 'ZOR' OR vbak~auart = 'ZO03' )
        AND ( vbap~lgort  = '1000' OR vbap~lgort = ' ' )
        AND vbak~vkorg = p_ekorg
        AND vbap~werks IN s_werks
        AND vbap~matnr IN s_matnrc
        AND vbak~kunnr IN s_kunnrc
        AND vbak~vbeln IN s_vbelnc.


    IF p_inic <> 'X'. " process if not intial load

      CLEAR i_cdhdr[].
      SELECT *
           INTO TABLE i_cdhdr
           FROM cdhdr
             WHERE ( objectclas = 'VERKBELEG')
*             AND objectid   = dobject-objky
               AND ( udate IN s_credac ).
*             AND  objectid IN s_matnr.

      DESCRIBE TABLE i_cdhdr LINES sy-tfill.
      IF sy-tfill NE 0.
        SORT i_cdhdr BY udate utime.
* Fill internal table it_vbakcud with changed Sales Documents concerning WERK MENGE and MATNR
        CLEAR i_hdrpos[].
        SELECT changenr objectclas objectid tabname tabkey fname chngind value_new value_old
               FROM cdpos
               INTO CORRESPONDING FIELDS OF TABLE i_hdrpos
               FOR ALL ENTRIES IN i_cdhdr
               WHERE objectclas  = i_cdhdr-objectclas
                 AND objectid    = i_cdhdr-objectid
                 AND changenr    = i_cdhdr-changenr
                 AND ( ( tabname = 'VBAP' AND ( fname = 'WERKS' ) )
                    OR ( tabname = 'VBEP' AND ( fname = 'WMENG' ) )
                    OR ( tabname = 'VBAP' AND ( fname = 'MATNR' ) )
* Begin of insert MOD-001
                    OR ( tabname = 'VBUK' AND ( fname = 'CMGST' ) )
                    OR ( tabname = 'VBAK' AND ( fname = 'FAKSK' ) )
                    OR ( tabname = 'VBAK' AND ( fname = 'LIFSK' ) )
* End of insert MOD-001
                    ).
        IF sy-subrc = 0.
          LOOP AT i_hdrpos.   " You can not join with cluster tables.
            SELECT SINGLE udate FROM cdhdr INTO i_hdrpos-udate
              WHERE changenr = i_hdrpos-changenr AND
                    objectclas = i_hdrpos-objectclas AND
                    objectid = i_hdrpos-objectid.
            IF sy-subrc = 0.
              CLEAR it_vbakcud.
              it_vbakcud-vbeln = i_hdrpos-objectid.
              APPEND it_vbakcud.
              MODIFY i_hdrpos TRANSPORTING udate.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF.
* endif. " not initial load
* Fill internal table with the sales order wich have movements 261, 601, 602 and 651 on it
*select vbelv posnv bwart rfmng from vbfa into corresponding fields of table it_vbfa
      SELECT vbelv FROM vbfa APPENDING TABLE it_vbakcud
        WHERE matnr <> ' ' AND
              bwart IN ('261 ', '601', '602', '651') AND
              erdat IN s_credac AND
              matnr IN s_matnr AND
              vbelv IN s_vbelnc.


* Fill internal table with the sales order which have movement 262 on it
      CLEAR it_mkpf[].
      SELECT * FROM mkpf INTO TABLE it_mkpf
       WHERE budat IN s_credac.

      IF sy-subrc = 0.
        SELECT * FROM mseg INTO CORRESPONDING FIELDS OF TABLE it_mseg
          FOR ALL ENTRIES IN it_mkpf
          WHERE mblnr = it_mkpf-mblnr AND
                mjahr = it_mkpf-mjahr AND
*                ( lgort = '1000' or lgort = ' ' ) and
                matnr IN s_matnrc AND
                werks IN s_werks AND
                bwart = '262'    AND
                kzbew = ' '.                           "insert MOD-001

* Fill internal table with the sales order which have movement 261 on it(entered on SEO directly)
        SELECT * FROM mseg APPENDING CORRESPONDING FIELDS OF TABLE it_mseg
          FOR ALL ENTRIES IN it_mkpf
          WHERE mblnr = it_mkpf-mblnr AND
                mjahr = it_mkpf-mjahr AND
*                ( lgort = '1000' or lgort = ' ' ) and
                matnr IN s_matnrc AND
                werks IN s_werks AND
                bwart = '261' AND
                kzbew = ' '.

        LOOP AT it_mseg.

          SELECT vbeln FROM vbak APPENDING CORRESPONDING FIELDS OF TABLE it_vbakcud
            WHERE aufnr = it_mseg-aufnr.

        ENDLOOP.
      ENDIF.

    ENDIF. " not initial load

    SORT it_vbakcud.
    DELETE ADJACENT DUPLICATES FROM it_vbakcud.


* Retrieve all the Sales data for all the sales documents which have been changed or created
    LOOP AT it_vbakcud.
      SELECT  vbak~kunnr vbak~vbeln vbak~auart vbak~erdat vbap~posnr vbap~werks vbap~matnr vbap~kwmeng vbap~abgru vbap~aufnr vbap~route
       APPENDING CORRESPONDING FIELDS OF TABLE it_cud_scc
       FROM vbak
       INNER JOIN vbap ON vbap~vbeln EQ vbak~vbeln
       INNER JOIN yse_scc_used_mat
        ON vbap~matnr = yse_scc_used_mat~matnr AND
           vbap~werks = yse_scc_used_mat~werks
        FOR ALL entries IN it_werks
         WHERE vbap~werks = it_werks-werks
*          AND vbap~erdat IN s_credac "CD1K973406 SSCJWU
          AND ( vbak~auart = 'ZOR' OR vbak~auart = 'ZO03' )
          AND ( vbap~lgort  = '1000' OR vbap~lgort = ' ' )
          AND vbak~vkorg = p_ekorg
          AND vbap~werks IN s_werks
          AND vbap~matnr IN s_matnrc
          AND vbak~kunnr IN s_kunnrc
          AND vbak~vbeln IN s_vbelnc
          AND vbak~vbeln = it_vbakcud-vbeln
          AND yse_scc_used_mat~flag = 'P'.
    ENDLOOP.

    LOOP AT it_cud_scc.
      lv_index = sy-tabix.
      CLEAR: lv_rfmng_min, lv_rfmng_plus, lv_rfmng_262, lv_rfmng_261, lv_dur, lv_dur_days, lv_route, lv_ship_date.


* Qty delivered.
      IF NOT it_cud_scc-abgru IS INITIAL.
        it_cud_scc-gimeng = 0.
      ELSE.
        SELECT SUM( rfmng ) FROM vbfa INTO lv_rfmng_min
        WHERE matnr <> ' ' AND
              bwart IN ('602 ', '651') AND
              vbelv = it_cud_scc-vbeln AND
              matnr IN s_matnrc AND
              posnv = it_cud_scc-posnr AND
              matnr = it_cud_scc-matnr.


        SELECT SUM( rfmng ) FROM vbfa INTO lv_rfmng_plus
        WHERE matnr <> ' ' AND
              bwart IN ('601 ', '261') AND
              vbelv = it_cud_scc-vbeln AND
              posnv = it_cud_scc-posnr AND
              matnr IN s_matnrc AND
              matnr = it_cud_scc-matnr.

        SELECT SUM( menge ) FROM mseg INTO lv_rfmng_262
          WHERE aufnr = it_cud_scc-aufnr AND
*                 ( lgort = '1000' or lgort = ' ' ) and
               matnr IN s_matnrc AND
               matnr = it_cud_scc-matnr AND
*           posnv = it_cud_SCC-posnr and
               werks IN s_werks AND
               bwart = '262' AND
               kzbew = ' '.                            "insert MOD-001

        SELECT SUM( menge ) FROM mseg INTO lv_rfmng_261
          WHERE aufnr = it_cud_scc-aufnr AND
*                 ( lgort = '1000' or lgort = ' ' ) and
               matnr IN s_matnrc AND
               matnr = it_cud_scc-matnr AND
*           posnv = it_cud_SCC-posnr and
               werks IN s_werks AND
               bwart = '261' AND
               kzbew = ' '. " 261 entered on SEO itself( not via GI on outbound delivery = KZBEW = 'L')


        it_cud_scc-gimeng = it_cud_scc-gimeng  + lv_rfmng_plus - lv_rfmng_min - lv_rfmng_262 + lv_rfmng_261.
      ENDIF.
* Qty Ordered
      CLEAR lv_rfmng_min.
      IF NOT it_cud_scc-abgru IS INITIAL.

        it_cud_scc-kwmeng = 0.
      ELSE.
        SELECT SUM( rfmng ) FROM vbfa INTO lv_rfmng_min
         WHERE matnr <> ' ' AND
               bwart IN ('651') AND
               vbelv = it_cud_scc-vbeln AND
               posnv = it_cud_scc-posnr AND
               matnr IN s_matnrc AND
               matnr = it_cud_scc-matnr.
        IF sy-subrc = 0.
          it_cud_scc-kwmeng = it_cud_scc-kwmeng - lv_rfmng_min - lv_rfmng_262 + lv_rfmng_261.
        ENDIF.
      ENDIF.

* Calculate the GI date

      SELECT SINGLE firstd FROM yse_scc_firstd INTO it_cud_scc-gidate
         WHERE vbeln = it_cud_scc-vbeln AND
               posnr = it_cud_scc-posnr.
      IF sy-subrc <> 0.
        SUBMIT yse_scc_ini_firstdate
           WITH s_vbelnc = it_cud_scc-vbeln
           WITH p_ekorg = p_ekorg
           AND RETURN.
      ENDIF.

      SELECT SINGLE firstd FROM yse_scc_firstd INTO it_cud_scc-gidate
        WHERE vbeln = it_cud_scc-vbeln AND
              posnr = it_cud_scc-posnr AND
              firstd IN s_rqdatc.
      IF sy-subrc = 0 OR ( sy-subrc <> 0 AND s_rqdatc IS INITIAL ).

* FAM
        CLEAR: lv_werks_cud, lv_fam_cud.
        lv_werks_cud = it_cud_scc-werks(2).
        SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam_cud
         WHERE werks = lv_werks_cud.
        IF sy-subrc = 0.
          it_cud_scc-fam = lv_fam_cud.
        ENDIF.

        MODIFY it_cud_scc INDEX lv_index TRANSPORTING kwmeng gimeng gidate fam.
      ELSE.
        DELETE it_cud_scc INDEX lv_index.
      ENDIF.
    ENDLOOP.

* Only one line to be send when sales order lines with same material

    SORT it_cud_scc BY vbeln werks matnr gidate.
    LOOP AT it_cud_scc.

      READ TABLE it_cud_scc2
               WITH KEY vbeln = it_cud_scc-vbeln
                        werks = it_cud_scc-werks
                        matnr = it_cud_scc-matnr
                        gidate = it_cud_scc-gidate.
      lv_index3 = sy-tabix.

      IF sy-subrc = 0.
        it_cud_scc2-kwmeng = it_cud_scc2-kwmeng + it_cud_scc-kwmeng.
        it_cud_scc2-gimeng = it_cud_scc2-gimeng + it_cud_scc-gimeng.
        MODIFY it_cud_scc2 INDEX lv_index3 TRANSPORTING kwmeng gimeng.
      ELSE.
        it_cud_scc2 = it_cud_scc.
        APPEND it_cud_scc2.
      ENDIF.

    ENDLOOP.

* Fill IDOC Customer Demand Sales

* First fill header
    LOOP AT it_cud_scc2.
      it_cud_scc_hd-fam = it_cud_scc2-fam.
      it_cud_scc_hd-kunnr = it_cud_scc2-kunnr.
      it_cud_scc_hd-vbeln = it_cud_scc2-vbeln.
      it_cud_scc_hd-auart = it_cud_scc2-auart.
      it_cud_scc_hd-erdat = it_cud_scc2-erdat.
      APPEND it_cud_scc_hd.
    ENDLOOP.

    SORT it_cud_scc_hd BY vbeln.
    DELETE ADJACENT DUPLICATES FROM it_cud_scc_hd.

    IF it_cud_scc_hd[] IS INITIAL.
      CLEAR lv_empty.
      lv_empty = lv_empty + 1.
    ELSE.
      LOOP AT it_cud_scc_hd.

* Begin of insert MOD-001
        CLEAR lv_spstg.
        SELECT SINGLE spstg FROM vbuk INTO lv_spstg
          WHERE vbeln = it_cud_scc_hd-vbeln.
        IF lv_spstg = ' ' OR p_block <> 'X'.
* End of insert MOD-001
          CLEAR l_data[].
          wa_cud_scc_c_h-fam = it_cud_scc_hd-fam.
          wa_cud_scc_c_h-kunnr = it_cud_scc_hd-kunnr.
          wa_cud_scc_c_h-vbeln = it_cud_scc_hd-vbeln.
          wa_cud_scc_c_h-auart = it_cud_scc_hd-auart.
          wa_cud_scc_c_h-erdat = it_cud_scc_hd-erdat.
          l_data-segnam  = c_segment_scc_cud.
          l_data-sdata = wa_cud_scc_c_h.
          APPEND l_data.
          LOOP AT it_cud_scc2 WHERE vbeln = it_cud_scc_hd-vbeln.
*            IF sy-subrc EQ 0.
            wa_cud_scc_c_d-posnr       = it_cud_scc2-posnr.
            wa_cud_scc_c_d-matnr       = it_cud_scc2-matnr.
            wa_cud_scc_c_d-werks       = it_cud_scc2-werks.
            wa_cud_scc_c_d-kwmeng      = it_cud_scc2-kwmeng.
            wa_cud_scc_c_d-gimeng      = it_cud_scc2-gimeng.
            wa_cud_scc_c_d-gidate      = it_cud_scc2-gidate.
            wa_cud_scc_c_d-vbeln      = it_cud_scc2-vbeln.
            l_data-segnam              = c_segment_scc_cudl.
            l_data-sdata               = wa_cud_scc_c_d.
            APPEND l_data.
*            ENDIF.
          ENDLOOP.
          CLEAR i_edidd_data[].
          IF NOT l_data[] IS INITIAL.
*      LOOP AT l_data.

            i_edidd_data[] = l_data[].

            CALL FUNCTION 'MASTER_IDOC_DISTRIBUTE'
              EXPORTING
                master_idoc_control            = wa_edidc
              TABLES
                communication_idoc_control     = i_edidc_control_comm
                master_idoc_data               = i_edidd_data
              EXCEPTIONS
                error_in_idoc_control          = 1
                error_writing_idoc_status      = 2
                error_in_idoc_data             = 3
                sending_logical_system_unknown = 4
                OTHERS                         = 5.
            IF sy-subrc EQ 0.
              CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'.

              CALL FUNCTION 'EDI_DOCUMENT_DEQUEUE_LATER'
                EXPORTING
                  docnum                 = i_edidc_control_comm-docnum
                EXCEPTIONS
                  idoc_is_not_to_dequeue = 1
                  OTHERS                 = 2.

              WRITE : / 'Idoc type',p_mes_type, 'generated ', i_edidd_data-sdata.
            ELSE.
              WRITE : / 'Idoc type',p_mes_type, ' in Error ', i_edidd_data-sdata.
            ENDIF.
            CLEAR:   i_edidd_data.
            REFRESH: i_edidd_data.
*      ENDLOOP.

          ELSE.
            WRITE : / 'Idoc type ',p_mes_type, ' No data found '.
          ENDIF.
* Begin of insert MOD-001
        ENDIF. " blocked or not
* End of insert MOD-001
      ENDLOOP.
    ENDIF.


***********************************************************************************************************************
** Fill internal table with changed documents Purchase Documents (EKKO EKPO)
*
*
* Fill internal table it_ekkocud with the Purchase Documents which are created
    CLEAR it_cud_scc_mm[].
    SELECT ekpo~ebeln
     INTO CORRESPONDING FIELDS OF TABLE it_ekkocud
     FROM ekko
     INNER JOIN ekpo ON ekko~ebeln EQ ekpo~ebeln
      FOR ALL entries IN it_werks
       WHERE ekko~reswk = it_werks-werks
        AND ekpo~aedat IN s_credac
        AND ( ekko~bsart = 'ZUB1' )
*          and ( ekpo~lgort  = '1000' or ekpo~lgort = ' ' )
        AND ekko~ekorg = p_ekorg
        AND ekko~reswk IN s_werks
        AND ekpo~matnr IN s_matnrc
        AND ekpo~werks IN s_kunnrc
        AND ekko~ebeln IN s_ebelnc.


    IF p_inic <> 'X'. " process if not intial load?
      CLEAR i_cdhdr[].
      SELECT *
           INTO TABLE i_cdhdr
           FROM cdhdr
             WHERE ( objectclas = 'EINKBELEG')
*             AND objectid   = dobject-objky
               AND ( udate IN s_credac ).
*             AND  objectid IN s_matnr.


      DESCRIBE TABLE i_cdhdr LINES sy-tfill.
      IF sy-tfill NE 0.
        SORT i_cdhdr BY udate utime.
* Fill internal table it_ekkocud with changed Purchase Documents concerning WERK MENGE and MATNR
        CLEAR i_hdrpos[].
        SELECT  changenr objectclas objectid tabname tabkey fname chngind value_new value_old FROM cdpos INTO CORRESPONDING FIELDS OF TABLE i_hdrpos
          FOR ALL ENTRIES IN i_cdhdr
               WHERE objectclas  = i_cdhdr-objectclas
                 AND objectid    = i_cdhdr-objectid
                 AND changenr    = i_cdhdr-changenr
                 AND ( ( tabname = 'EKPO' AND ( fname = 'WERKS' ) )
                    OR ( tabname = 'EKPO' AND ( fname = 'MENGE' ) )
                    OR ( tabname = 'EKPO' AND ( fname = 'MATNR' ) ) ).
        IF sy-subrc = 0.
          LOOP AT i_hdrpos.   " You can not join with cluster tables.
            SELECT SINGLE udate FROM cdhdr INTO i_hdrpos-udate
              WHERE changenr = i_hdrpos-changenr AND
                    objectclas = i_hdrpos-objectclas AND
                    objectid = i_hdrpos-objectid.
            IF sy-subrc = 0.
              CLEAR it_ekkocud.
              it_ekkocud-ebeln = i_hdrpos-objectid.
              APPEND it_ekkocud.
              MODIFY i_hdrpos TRANSPORTING udate.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF.

* Fill internal table with the sales order which have movement 262 on it
      CLEAR it_mkpf[].
      SELECT * FROM mkpf INTO TABLE it_mkpf
       WHERE budat IN s_credac.
      IF sy-subrc = 0.
        CLEAR it_mseg[].
        SELECT * FROM mseg INTO CORRESPONDING FIELDS OF TABLE it_mseg
          FOR ALL ENTRIES IN it_mkpf
          WHERE mblnr = it_mkpf-mblnr AND
                mjahr = it_mkpf-mjahr AND
*                ( lgort = '1000' or lgort = ' ' ) and
                matnr IN s_matnrc AND
                werks IN s_werks AND
                ebeln IN s_ebelnc AND
                shkzg = 'H' AND
                bwart = '641'.

        LOOP AT it_mseg.

          SELECT ebeln FROM ekpo APPENDING CORRESPONDING FIELDS OF TABLE it_ekkocud
            WHERE ebeln = it_mseg-ebeln.

        ENDLOOP.
      ENDIF.
    ENDIF. " not initial load
    SORT it_ekkocud.
    DELETE ADJACENT DUPLICATES FROM it_ekkocud.


* Retrieve all the Sales data for all the sales documents which have been changed or created
    LOOP AT it_ekkocud.

      SELECT  ekko~reswk ekko~ebeln ekko~bsart ekpo~aedat ekpo~ebelp ekpo~werks ekpo~matnr ekpo~menge
       APPENDING CORRESPONDING FIELDS OF TABLE it_cud_scc_mm
       FROM ekko
       INNER JOIN ekpo ON ekpo~ebeln EQ ekko~ebeln
        INNER JOIN yse_scc_used_mat
        ON ekpo~matnr = yse_scc_used_mat~matnr AND
           ekko~reswk = yse_scc_used_mat~werks
        FOR ALL entries IN it_werks
         WHERE ekko~reswk = it_werks-werks
          AND ekpo~aedat IN s_credac
          AND ( ekko~bsart = 'ZUB1')
*            and ( ekpo~lgort  = '1000' or ekpo~lgort = ' ' )
          AND ekko~ekorg = p_ekorg
          AND ekko~reswk IN s_werks
          AND ekpo~werks IN s_kunnrc
          AND ekpo~matnr IN s_matnrc
          AND ekko~ebeln IN s_ebelnc
          AND ekko~ebeln = it_ekkocud-ebeln
          AND ekpo~loekz <> 'L'
          AND yse_scc_used_mat~flag = 'P'.
    ENDLOOP.

    LOOP AT it_cud_scc_mm.

      lv_index = sy-tabix.
      CLEAR: lv_rfmng_min, lv_rfmng_plus, lv_rfmng_262, lv_dur, lv_dur_days, lv_route, lv_ship_date.

* Only process if the Supplying Plant is a Central Warehouse
      CLEAR lv_whtype.
      SELECT SINGLE whtype FROM yse_scc_planttyp INTO lv_whtype
        WHERE ekorg = p_ekorg AND werks = it_cud_scc_mm-reswk.

      IF lv_whtype = c_cw.

* Qty delivered.

        CLEAR lv_rfmng_641.

        SELECT SUM( menge ) FROM mseg INTO lv_rfmng_641
          WHERE ebeln = it_cud_scc_mm-ebeln AND
                ebelp = it_cud_scc_mm-ebelp AND
*                 ( lgort = '1000' or lgort = ' ' ) and
               matnr IN s_matnrc AND
               matnr = it_cud_scc_mm-matnr AND
*           posnv = it_cud_SCC-posnr and
               werks IN s_werks AND
               shkzg = 'H' AND
               bwart = '641'.

        it_cud_scc_mm-gimeng = lv_rfmng_641.


*
** Calculate the GI date
*  SELECT SINGLE traztd
*           INTO lv_dur
*           FROM tvro
*           WHERE route = it_CUD_SCC-route.
**   If duration of the route found
*    IF sy-subrc EQ 0.
**           Convert the internal format to days
*      CALL FUNCTION 'YSE_CONVERSION_EXIT_TSTRG_OUT'
*        EXPORTING
*          input  = lv_dur
*        IMPORTING
*          output = lv_dur_days.
*    ENDIF.
*
* lv_calc_date = sy-datum - lv_dur_days.
*
*CALL FUNCTION 'DATE_CONVERT_TO_FACTORYDATE' "Calendar function: Returns factory calendar date for a date
*  EXPORTING
*    correct_option = '-'        " scal-indicator  Flag how workday should be calculated
*    date =       lv_calc_date              " scal-date     Date to be converted into factory calendar date
*    factory_calendar_id =  '99'     " scal-fcalid   Factory calendar ID
*  IMPORTING
*    date =       it_CUD_SCC-GIDATE.              " scal-date     Date to be converted into factory calendar date

        SELECT SINGLE firstd FROM yse_scc_firstdpo INTO it_cud_scc_mm-gidate
          WHERE ebeln = it_cud_scc_mm-ebeln AND
                ebelp = it_cud_scc_mm-ebelp AND
                firstd IN s_rqdatc.
        IF sy-subrc = 0 OR ( sy-subrc <> 0 AND s_rqdatc IS INITIAL ).
* FAM
          CLEAR: lv_werks_cud, lv_fam_cud.
          lv_werks_cud = it_cud_scc_mm-reswk(2).
          SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam_cud
          WHERE werks = lv_werks_cud.
          IF sy-subrc = 0.
            it_cud_scc_mm-fam = lv_fam_cud.
          ENDIF.

          MODIFY it_cud_scc_mm INDEX lv_index TRANSPORTING menge gimeng gidate fam.
        ELSE.
          DELETE it_cud_scc_mm INDEX lv_index.
        ENDIF.
      ELSE.
        DELETE it_cud_scc_mm INDEX lv_index.
      ENDIF.

    ENDLOOP.


* Only one line to be send when sales order lines with same material

    SORT it_cud_scc_mm BY ebeln reswk matnr gidate.
    LOOP AT it_cud_scc_mm.

      READ TABLE it_cud_scc2_mm
               WITH KEY ebeln = it_cud_scc_mm-ebeln
                        reswk = it_cud_scc_mm-reswk
                        matnr = it_cud_scc_mm-matnr
                        gidate = it_cud_scc_mm-gidate .
      lv_index3 = sy-tabix.

      IF sy-subrc = 0.
        it_cud_scc2_mm-menge = it_cud_scc2_mm-menge + it_cud_scc_mm-menge.
        it_cud_scc2_mm-gimeng = it_cud_scc2_mm-gimeng + it_cud_scc_mm-gimeng.
        MODIFY it_cud_scc2_mm INDEX lv_index3 TRANSPORTING menge gimeng.
      ELSE.
        it_cud_scc2_mm = it_cud_scc_mm.
        APPEND it_cud_scc2_mm.
      ENDIF.

    ENDLOOP.

* Fill IDOC Customer Demand Stock Transfer
    CLEAR it_cud_scc_hd[].
    CLEAR wa_cud_scc_c_h.
    CLEAR wa_cud_scc_c_d.
* First fill header
    LOOP AT it_cud_scc2_mm.
      it_cud_scc_hd-fam = it_cud_scc2_mm-fam.
      it_cud_scc_hd-kunnr = it_cud_scc2_mm-werks.
      it_cud_scc_hd-vbeln = it_cud_scc2_mm-ebeln.
      it_cud_scc_hd-auart = it_cud_scc2_mm-bsart.
      it_cud_scc_hd-erdat = it_cud_scc2_mm-aedat.
      APPEND it_cud_scc_hd.
    ENDLOOP.

    SORT it_cud_scc_hd BY vbeln.
    DELETE ADJACENT DUPLICATES FROM it_cud_scc_hd COMPARING vbeln.

    IF it_cud_scc_hd[] IS INITIAL.
      lv_empty = lv_empty + 1.
    ELSE.
*    clear wa_opo_c.
      LOOP AT it_cud_scc_hd.
        CLEAR l_data[].
        wa_cud_scc_c_h-fam = it_cud_scc_hd-fam.
        wa_cud_scc_c_h-kunnr = it_cud_scc_hd-kunnr.
        wa_cud_scc_c_h-vbeln = it_cud_scc_hd-vbeln.
        wa_cud_scc_c_h-auart = it_cud_scc_hd-auart.
        wa_cud_scc_c_h-erdat = it_cud_scc_hd-erdat.
        l_data-segnam  = c_segment_scc_cud.
        l_data-sdata = wa_cud_scc_c_h.
        APPEND l_data.
        LOOP AT it_cud_scc2_mm WHERE ebeln = it_cud_scc_hd-vbeln.
*            IF sy-subrc EQ 0.
          wa_cud_scc_c_d-posnr       = it_cud_scc2_mm-ebelp.
          wa_cud_scc_c_d-matnr       = it_cud_scc2_mm-matnr.
          wa_cud_scc_c_d-werks       = it_cud_scc2_mm-reswk.
          wa_cud_scc_c_d-kwmeng      = it_cud_scc2_mm-menge.
          wa_cud_scc_c_d-gimeng      = it_cud_scc2_mm-gimeng.
          wa_cud_scc_c_d-gidate      = it_cud_scc2_mm-gidate.
          wa_cud_scc_c_d-vbeln       = it_cud_scc2_mm-ebeln.
          l_data-segnam              = c_segment_scc_cudl.
          l_data-sdata               = wa_cud_scc_c_d.
          APPEND l_data.
*            ENDIF.
        ENDLOOP.
        CLEAR i_edidd_data[].
        IF NOT l_data[] IS INITIAL.
*      LOOP AT l_data.

          i_edidd_data[] = l_data[].

          CALL FUNCTION 'MASTER_IDOC_DISTRIBUTE'
            EXPORTING
              master_idoc_control            = wa_edidc
            TABLES
              communication_idoc_control     = i_edidc_control_comm
              master_idoc_data               = i_edidd_data
            EXCEPTIONS
              error_in_idoc_control          = 1
              error_writing_idoc_status      = 2
              error_in_idoc_data             = 3
              sending_logical_system_unknown = 4
              OTHERS                         = 5.
          IF sy-subrc EQ 0.
            CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'.

            CALL FUNCTION 'EDI_DOCUMENT_DEQUEUE_LATER'
              EXPORTING
                docnum                 = i_edidc_control_comm-docnum
              EXCEPTIONS
                idoc_is_not_to_dequeue = 1
                OTHERS                 = 2.

            WRITE : / 'Idoc type',p_mes_type, 'generated ', i_edidd_data-sdata.
          ELSE.
            WRITE : / 'Idoc type',p_mes_type, ' in Error ', i_edidd_data-sdata.
          ENDIF.
          CLEAR:   i_edidd_data.
          REFRESH: i_edidd_data.
*      ENDLOOP.

        ELSE.
          WRITE : / 'Idoc type ',p_mes_type, ' No data found '.
        ENDIF.

      ENDLOOP.

    ENDIF.

    IF lv_empty = 2.

      lv_ekorg = p_ekorg+0(2).
      SELECT SINGLE fam FROM yse_scc_fam INTO lv_fam
        WHERE werks = lv_ekorg.

      CLEAR l_data.
      CLEAR wa_cud_scc_c_h.
      CLEAR wa_cud_scc_c_d.

      wa_cud_scc_c_h-fam = lv_fam.
      wa_cud_scc_c_h-vbeln = c_9999999999.
      wa_cud_scc_c_h-erdat = sy-datum.
      l_data-segnam  = c_segment_scc_cud.
      l_data-sdata = wa_cud_scc_c_h.
      APPEND l_data.
      wa_cud_scc_c_d-posnr = '000010'.
      wa_cud_scc_c_d-gidate      = sy-datum.
      wa_cud_scc_c_d-kwmeng = '0'.
      wa_cud_scc_c_d-gimeng = '0'.
      l_data-segnam              = c_segment_scc_cudl.
      l_data-sdata               = wa_cud_scc_c_d.
      APPEND l_data.

      i_edidd_data[] = l_data[].

      CALL FUNCTION 'MASTER_IDOC_DISTRIBUTE'
        EXPORTING
          master_idoc_control            = wa_edidc
        TABLES
          communication_idoc_control     = i_edidc_control_comm
          master_idoc_data               = i_edidd_data
        EXCEPTIONS
          error_in_idoc_control          = 1
          error_writing_idoc_status      = 2
          error_in_idoc_data             = 3
          sending_logical_system_unknown = 4
          OTHERS                         = 5.
      IF sy-subrc EQ 0.
        CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'.

        CALL FUNCTION 'EDI_DOCUMENT_DEQUEUE_LATER'
          EXPORTING
            docnum                 = i_edidc_control_comm-docnum
          EXCEPTIONS
            idoc_is_not_to_dequeue = 1
            OTHERS                 = 2.
      ENDIF.
    ENDIF.

*   endif. " not initial load
  ENDIF.

  CLEAR:   i_edidd_data.
  REFRESH: i_edidd_data.

ENDFORM.                      " FILL_DATA


*&---------------------------------------------------------------------*
*&      Form  UPDATE_TABLE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*

FORM  get_eine.
  DATA: lv_infnr TYPE infnr,
        lv_netpr TYPE netpr,
        lv_waers TYPE waers,
        lv_norbm TYPE norbm.


  CLEAR: lv_waers, lv_norbm, lv_evers, lv_netpr, lv_aplfz.
  SELECT SINGLE infnr FROM eina INTO lv_infnr
      WHERE matnr = it_yse_scc_mat_prcs-matnr AND
            lifnr = wa_matmas-lifnr.

*  select single waers norbm evers from EINE into (lv_waers, lv_norbm, lv_evers)
*      where infnr = lv_infnr and
*            ekorg = IT_YSE_SCC_MAT_PRCS-EKORG and
*            werks = IT_YSE_SCC_MAT_PRCS-WERKS.
  SELECT SINGLE netpr aplfz waers norbm evers FROM eine INTO (lv_netpr, lv_aplfz, lv_waers, lv_norbm, lv_evers )
      WHERE infnr = lv_infnr AND
            ekorg = it_yse_scc_mat_prcs-ekorg AND
            werks = it_yse_scc_mat_prcs-werks AND
            esokz = '0' AND
            prdat > sy-datum.

  wa_matmas-netpr = lv_netpr.
  wa_matmas-norbm = lv_norbm.
  wa_matmas-waers = lv_waers.
ENDFORM.                    "GET_EINE


*&---------------------------------------------------------------------*
*&      Form  GET_MARA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_mara.

  DATA:   lv_pgc(4)   TYPE c,
          lv_vkorg TYPE vkorg,
          lv_bukrs TYPE bukrs,
          lv_plc_temp(10) TYPE c,
          lv_prctr TYPE marc-prctr,
          lv_gewei TYPE gewei,
          lv_ntgew TYPE ntgew.

  DATA: it_plc         TYPE k9rcd11000010    OCCURS 0 WITH HEADER LINE.


  CLEAR: lv_matkl, lv_gewei, lv_ntgew, lv_vkorg, lv_pgc, lv_prctr.

  SELECT SINGLE bismt gewei ntgew prdha matkl FROM mara INTO (wa_matmas-bismt, lv_gewei, lv_ntgew, wa_matmas-prdha, lv_matkl)
             WHERE matnr =  wa_matmas-matnr.
  wa_matmas-gewei = lv_gewei.
  wa_matmas-ntgew = lv_ntgew.

* Get PLC Data

  SELECT SINGLE vkorg FROM t001w INTO lv_vkorg
                WHERE werks EQ wa_matmas-werks.


  lv_pgc = wa_matmas-prdha+4(4).

  SELECT SINGLE prctr INTO lv_prctr
                           FROM yse_prctr_deriv WHERE pgc = lv_pgc
                                                AND vtweg = '01'.
  IF sy-subrc = 0.

*.. Derive segment from profit center
    CLEAR lv_bukrs.
    SELECT SINGLE bukrs INTO lv_bukrs FROM t001k
      WHERE bwkey = wa_matmas-werks.

    CALL FUNCTION 'YSE_CONVERT_PRCTR_BL'
      EXPORTING
        prctr_in    = lv_prctr
        bukrs       = lv_bukrs
      IMPORTING
        segment_out = lv_plc_temp.

    CLEAR it_plc[].
    SELECT      *
*         FROM K9RCD11000009
           FROM k9rcd11000010                               "20080417
           INTO TABLE it_plc.

    LOOP AT it_plc WHERE sour1_from LE lv_plc_temp
                     AND sour1_to   GE lv_plc_temp
                     AND valid_from LE sy-datum.
      wa_matmas-plc = it_plc-target1.
      EXIT.
    ENDLOOP.
  ENDIF.
ENDFORM.                    "GET_MARA

*&---------------------------------------------------------------------*
*&      Form  GET_DMAKT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_dmakt.

  DATA:   lv_pgc(4)   TYPE c,
          lv_vkorg TYPE vkorg,
          lv_bukrs TYPE bukrs,
          lv_plc_temp(10) TYPE c,
          lv_prctr TYPE marc-prctr.
  DATA: it_plc         TYPE k9rcd11000010    OCCURS 0 WITH HEADER LINE,
        lv_check TYPE i,
        lv_descr TYPE text256.


  SELECT SINGLE maktx FROM makt INTO wa_matmas-maktx
             WHERE matnr =  wa_matmas-matnr AND spras = 'E'.

  CLEAR lv_check.
  CLEAR lv_descr.
  lv_descr = wa_matmas-maktx.
  PERFORM latin_check IN PROGRAM yam_common_routines
                                  USING   lv_descr
                                  CHANGING lv_check.
  IF NOT lv_check IS INITIAL.
    CLEAR wa_matmas-maktx.
  ENDIF.

ENDFORM.                    "GET_DMAKT


*&---------------------------------------------------------------------*
*&      Form  GET_MARC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_marc.
  DATA: lv_mmsta TYPE mmsta,
        lv_nfmat TYPE nfmat,
        lv_ersda TYPE ersda.

  CLEAR: lv_mmsta, lv_nfmat.
  SELECT SINGLE mmsta nfmat FROM marc INTO (lv_mmsta, lv_nfmat)
    WHERE matnr = wa_matmas-matnr AND
          werks = wa_matmas-werks.
  IF lv_mmsta = 'A1'.
    wa_matmas-nfmat = lv_nfmat.
  ENDIF.

  IF lv_mmsta IS INITIAL.
    wa_matmas-repl = '0'.
  ELSEIF lv_mmsta = 'A1' AND NOT lv_nfmat IS INITIAL.
    wa_matmas-repl = '1'.
  ELSEIF lv_mmsta = 'A1' AND  lv_nfmat IS INITIAL.
    wa_matmas-repl = '2'.
  ELSEIF lv_mmsta = 'A2'.
    wa_matmas-repl = '3'.
  ENDIF.

  SELECT SINGLE ersda FROM msta INTO lv_ersda
    WHERE matnr = wa_matmas-matnr  AND
          werks = wa_matmas-werks AND
          statm = 'E'.
  IF sy-subrc = 0.
    wa_matmas-plant_credat = lv_ersda.
  ENDIF.

ENDFORM.                    "GET_MARC


*&---------------------------------------------------------------------*
*&      Form  GET_MBEW
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_mbew.
  DATA: lv_verpr TYPE verpr,
        lv_stprs TYPE stprs.

  CLEAR: lv_verpr, lv_stprs.
  SELECT SINGLE verpr stprs FROM mbew INTO (lv_verpr, lv_stprs)
    WHERE matnr = wa_matmas-matnr AND
          bwkey = wa_matmas-werks.
  IF wa_matmas-werks(2) = 'CN'.
    wa_matmas-verpr = lv_stprs.
  ELSE.
    wa_matmas-verpr = lv_verpr.
  ENDIF.
ENDFORM.                    "GET_MBEW


*&---------------------------------------------------------------------*
*&      Form  GET_EORD
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_eord.

  DATA: lv_lifnr TYPE lifnr.

  CLEAR lv_lifnr.
  SELECT SINGLE lifnr FROM eord INTO lv_lifnr
    WHERE matnr = wa_matmas-matnr AND
          werks = wa_matmas-werks AND
          bdatu > sy-datum AND
          flifn = 'X'.
  IF sy-subrc = 0.
    wa_matmas-lifnr = lv_lifnr.
  ENDIF.

ENDFORM.                    "GET_EORD


*&---------------------------------------------------------------------*
*&      Form  get_allocated_stock
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_allocated_stock.

* Get Safety stock
*  PERFORM get_safety_stock.

* Get open sales orders
  PERFORM get_open_sales_orders.

* Get returns (ZRE1) open sales orders
  PERFORM get_returns_zre1.

* Get open reservations
*  PERFORM get_open_reservations.

* Get open transport req
  PERFORM get_open_transport_req.

* Get open transport orders
* Cf. Function get_allocated stock > perform find_open_transport_orders
  PERFORM get_open_transport_orders.

ENDFORM.                    " GET_ALLOCATED_STOCK

*&---------------------------------------------------------------------*
*&      Form  GET_ALLOCATED_STOCK1
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*form GET_ALLOCATED_STOCK1 .
*  DATA : BEGIN OF IT_VBBE OCCURS 0,
*         VBELN LIKE VBBE-VBELN,
*         POSNR LIKE VBBE-POSNR,
*         MATNR LIKE VBBE-MATNR,
*         WERKS LIKE VBBE-WERKS,
*         VBTYP LIKE VBBE-VBTYP,
*         VMENG LIKE VBBE-VMENG,
*         END OF IT_VBBE.
*  DATA : WA_VBBE LIKE IT_VBBE.
*
*  DATA : BEGIN OF IT_LIKP OCCURS 0,
*         VBELN LIKE LIKP-VBELN,
*         LFART LIKE LIKP-LFART,
*         END OF IT_LIKP.
*  DATA : WA_LIKP LIKE IT_LIKP.
*
*  DATA : BEGIN OF IT_LIPS OCCURS 0,
*          VBELN LIKE LIPS-VBELN,
*          POSNR LIKE LIPS-POSNR,
*          PSTYV LIKE LIPS-PSTYV,
*         END OF IT_LIPS.
*  DATA : WA_LIPS LIKE IT_LIPS.
*
*
*  SELECT VBELN POSNR MATNR WERKS VBTYP VMENG FROM VBBE
*               INTO TABLE IT_VBBE
*               FOR ALL ENTRIES IN it_material
*                 WHERE MATNR = it_material-MATNR
*                   AND WERKS = it_material-werks.
*  IF SY-SUBRC = 0.
*    SORT IT_VBBE BY MATNR WERKS.
*  ENDIF.
*
*  CHECK NOT IT_VBBE[] IS INITIAL.
*  SELECT VBELN LFART  FROM LIKP
*               INTO TABLE IT_LIKP
*                FOR ALL ENTRIES IN IT_VBBE
*                 WHERE VBELN = IT_VBBE-VBELN.
*  IF SY-SUBRC = 0.
*    SORT IT_LIKP BY VBELN.
*    DELETE ADJACENT DUPLICATES from it_likp COMPARING ALL FIELDS.
*  ENDIF.
*
*  REFRESH IT_ALLOC.
*  CLEAR IT_ALLOC.
*  LOOP AT IT_VBBE INTO WA_VBBE.
*    READ TABLE it_material WITH KEY matnr = WA_VBBE-matnr
*                                      werks = WA_VBBE-werks
*                             BINARY SEARCH.
*    IF sy-subrc EQ 0.
*      it_alloc-werks          = WA_VBBE-werks.
*      it_alloc-matnr          = WA_VBBE-matnr.
*      it_alloc-alloc_quantity = WA_VBBE-VMENG.
*      COLLECT it_alloc.
*    ENDIF.
*  ENDLOOP.
*
*  LOOP AT IT_VBBE INTO WA_VBBE.
*    CLEAR WA_LIKP.
*    READ TABLE it_LIKP INTO WA_LIKP WITH KEY VBELN = WA_VBBE-VBELN
*                            BINARY SEARCH.
*    IF SY-SUBRC = 0 AND WA_LIKP-LFART = 'ZL03'.
*      it_alloc-werks          = WA_VBBE-werks.
*      it_alloc-matnr          = WA_VBBE-matnr.
*      it_alloc-alloc_quantity = WA_VBBE-VMENG * -1.
*      COLLECT it_alloc.
*    ENDIF.
*  ENDLOOP.
*
*  CHECK NOT IT_VBBE[] IS INITIAL.
*  SELECT VBELN
*          POSNR
*          PSTYV
*          FROM LIPS
*               INTO TABLE IT_LIPS
*                FOR ALL ENTRIES IN IT_VBBE
*                 WHERE VBELN = IT_VBBE-VBELN
*                   AND POSNR = IT_VBBE-POSNR.
*  IF SY-SUBRC = 0.
*    SORT IT_LIPS BY VBELN POSNR.
*  ENDIF.
*
*  LOOP AT IT_VBBE INTO WA_VBBE.
*    CLEAR WA_LIPS.
*    READ TABLE it_LIPS INTO WA_LIPS WITH KEY VBELN = WA_VBBE-VBELN
*                                             POSNR = WA_VBBE-POSNR
*                                             BINARY SEARCH.
*    IF SY-SUBRC = 0 AND WA_VBBE-VBTYP = 'J' AND WA_LIPS-PSTYV = 'ZDTC'.
*      it_alloc-werks          = WA_VBBE-werks.
*      it_alloc-matnr          = WA_VBBE-matnr.
*      it_alloc-alloc_quantity = WA_VBBE-VMENG * -1.
*      COLLECT it_alloc.
*    ENDIF.
*  ENDLOOP.
*
*endform.                    " GET_ALLOCATED_STOCK1

*&---------------------------------------------------------------------*
*&      Form  get_safety_stock
*&---------------------------------------------------------------------*
*FORM get_safety_stock .
*
** Only consider safety stock if "safety stock indicator" is flagged
**  CHECK p_saf = 'X'.
** Only consider safety stock if storage location = 1000
**  CHECK P_LGORT = '1000'.
*  IF '1000' IN s_lgorts.
*
** Safety stock has already been fetched from MARC, just copy it over into IT_ALLOC_EXT
** Put material with it's safety stock in allocations table
*    it_alloc-lgort          = '1000'.
*    LOOP AT it_material.
*      it_alloc-matnr          = it_material-matnr.
*      it_alloc-werks          = it_material-werks.
*      it_alloc-alloc_quantity = it_material-eisbe.
*      COLLECT it_alloc.
*    ENDLOOP.
*  ENDIF.
*ENDFORM.                    " get_safety_stock


*&---------------------------------------------------------------------*
*&      Form  GET_open_sales_orders
*&---------------------------------------------------------------------*
FORM get_open_sales_orders .

* Salesorder items have been selected before
  clear: it_alloc[].
* Add order quantities to allocations table
  SORT it_vbap BY matnr.
  LOOP AT it_vbap WHERE abgru EQ space.
*   When the sales item's StLoc is initial, treat it is if it were
*   StLoc 1000
* Begin of insert MOD-001
    CLEAR lv_spstg.
    SELECT SINGLE spstg FROM vbuk INTO lv_spstg
     WHERE vbeln = it_vbap-vbeln.
    IF lv_spstg = ' ' OR p_block <> 'X'.
* End of insert MOD-001
      IF it_vbap-lgort IS INITIAL.
        it_vbap-lgort = '1000'.
      ENDIF.
*      SORT it_material BY matnr werks lgort."MOD-004
      READ TABLE it_material WITH KEY matnr = it_vbap-matnr
                                      werks = it_vbap-werks
                                      lgort = it_vbap-lgort
                              BINARY SEARCH.
      IF sy-subrc EQ 0.
        it_alloc-lgort          = it_material-lgort.
        it_alloc-werks          = it_vbap-werks.
        it_alloc-matnr          = it_vbap-matnr.
        it_alloc-alloc_quantity = it_vbap-kwmeng.
        COLLECT it_alloc.
*     To collect the Open Qty for Stock Back Ordered
*      COLLECT it_alloc INTO it_stbo_so.
      ENDIF.
* Begin of insert MOD-001
    ENDIF.
* End of insert MOD-001
  ENDLOOP.

* Get delivered quantities for the above selected order items
  IF NOT it_vbap[] IS INITIAL.
    SELECT      b~vbeln b~posnr b~matnr b~lgort b~lfimg b~werks
           INTO TABLE it_lips
           FROM vbfa AS a
           JOIN lips AS b
             ON a~vbeln EQ b~vbeln
            AND a~posnn EQ b~posnr
           JOIN vbuk AS c
             ON a~vbeln EQ c~vbeln
            FOR ALL ENTRIES IN it_vbap
          WHERE a~vbelv = it_vbap-vbeln
            AND a~posnv = it_vbap-posnr
            AND a~vbtyp_n = 'J'  " Deliveries
            AND c~wbstk = 'C'.
  ENDIF.

* Subtract remaining delivered quantities from allocation table
  LOOP AT it_lips.
*   StLoc 1000
    IF it_lips-lgort IS INITIAL.
      it_lips-lgort = '1000'.
    ENDIF.
*    SORT it_material BY matnr werks lgort."MOD-004

    READ TABLE it_material WITH KEY matnr = it_lips-matnr
                                    werks = it_lips-werks
                                    lgort = it_lips-lgort
                            BINARY SEARCH.
    IF sy-subrc EQ 0.
      it_alloc-lgort          = it_lips-lgort.
      it_alloc-werks          = it_lips-werks.
      it_alloc-matnr          = it_lips-matnr.
      it_alloc-alloc_quantity = it_lips-lfimg * ( -1 ).
      COLLECT it_alloc.
*     To collect the Open Qty for Stock Back Ordered
*      COLLECT it_alloc INTO it_stbo_so.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " GET_open_sales_orders

*&---------------------------------------------------------------------*
*&      Form  GET_open_sales_orders
*&---------------------------------------------------------------------*
FORM get_returns_zre1 .

* Salesorder items have been selected before

* Add order quantities to allocations table
  SORT it_vbap_zre1 BY matnr.
  LOOP AT it_vbap_zre1.
*   When the sales item's StLoc is initial, treat it is if it were
*   StLoc 1000
* Begin of insert MOD-001
    CLEAR lv_spstg.
    SELECT SINGLE spstg FROM vbuk INTO lv_spstg
     WHERE vbeln = it_vbap_zre1-vbeln.
    IF lv_spstg = ' ' OR p_block <> 'X'.
* End of insert MOD-001
      IF it_vbap_zre1-lgort IS INITIAL.
        it_vbap_zre1-lgort = '1000'.
      ENDIF.
*      SORT it_material BY matnr werks lgort."MOD-004
      READ TABLE it_material WITH KEY matnr = it_vbap_zre1-matnr
                                      werks = it_vbap_zre1-werks
                                     lgort = it_vbap_zre1-lgort
                             BINARY SEARCH.
      IF sy-subrc EQ 0.
        it_alloc_zre1-lgort          = it_vbap_zre1-lgort.
        it_alloc_zre1-werks          = it_vbap_zre1-werks.
        it_alloc_zre1-matnr          = it_vbap_zre1-matnr.
        it_alloc_zre1-alloc_quantity = it_vbap_zre1-kwmeng.
        COLLECT it_alloc_zre1.
*     To collect the Open Qty for Stock Back Ordered
*      COLLECT it_alloc INTO it_stbo_so.
      ENDIF.
* Begin of insert MOD-001
    ENDIF.
* End of insert MOD-001
  ENDLOOP.

  CLEAR it_lips_zre1[].
* Get delivered quantities for the above selected order items
  IF NOT it_vbap_zre1[] IS INITIAL.
    SELECT      b~vbeln b~posnr b~matnr b~lgort b~lfimg b~werks
           INTO TABLE it_lips_zre1
           FROM vbfa AS a
           JOIN lips AS b
             ON a~vbeln EQ b~vbeln
            AND a~posnn EQ b~posnr
           JOIN vbuk AS c
             ON a~vbeln EQ c~vbeln
            FOR ALL ENTRIES IN it_vbap_zre1
          WHERE a~vbelv = it_vbap_zre1-vbeln
            AND a~posnv = it_vbap_zre1-posnr
            AND a~vbtyp_n = 'T'  " Return Deliveries
            AND c~wbstk = 'C'.
  ENDIF.

* Subtract remaining delivered quantities from allocation table
  LOOP AT it_lips_zre1.
*   StLoc 1000
    IF it_lips_zre1-lgort IS INITIAL.
      it_lips_zre1-lgort = '1000'.
    ENDIF.
*    SORT it_material BY matnr werks lgort."MOD-004
    READ TABLE it_material WITH KEY matnr = it_lips_zre1-matnr
                                    werks = it_lips_zre1-werks
                                    lgort = it_lips_zre1-lgort
                           BINARY SEARCH.
    IF sy-subrc EQ 0.
      it_alloc_zre1-lgort          = it_lips_zre1-lgort.
      it_alloc_zre1-werks          = it_lips_zre1-werks.
      it_alloc_zre1-matnr          = it_lips_zre1-matnr.
      it_alloc_zre1-alloc_quantity = it_lips_zre1-lfimg * ( -1 ).
      COLLECT it_alloc_zre1.
*     To collect the Open Qty for Stock Back Ordered
*      COLLECT it_alloc INTO it_stbo_so.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " GET_returns_ZRE1

*&---------------------------------------------------------------------*
*&      Form  GET_open_reservations
*&---------------------------------------------------------------------*
*FORM get_open_reservations .
*
** Service details selected before, but whithout condition >> XWAOK EQ 'X' <<
*
** Add open reservation quantities to allocations table
*  SORT it_resb BY matnr werks lgort.
*  LOOP AT it_resb WHERE xwaok EQ 'X'.
*    READ TABLE it_material
*               WITH KEY matnr = it_resb-matnr
*                        werks = it_resb-werks
*                        lgort = it_resb-lgort
*               BINARY SEARCH.
*    IF sy-subrc EQ 0.
*      it_alloc-matnr          = it_resb-matnr.
*      it_alloc-werks          = it_resb-werks.
*      it_alloc-lgort          = it_resb-lgort.
*      it_alloc-alloc_quantity = it_resb-bdmng - it_resb-enmng.
*      COLLECT it_alloc.
**     To collect the Open Qty for Stock Back Ordered
**      COLLECT it_alloc INTO it_stbo_so.
*    ENDIF.
*  ENDLOOP.
*
*
*ENDFORM.                    " GET_open_reservations

*&---------------------------------------------------------------------*
*&      Form  get_open_transport_req
*&---------------------------------------------------------------------*
FORM get_open_transport_req .

* Only consider open transport req if storage location = 1000
*  CHECK p_lgort = '1000'.

*  IF '1000' IN s_lgorts.
*
*    SELECT      matnr reswk menge
*           INTO TABLE it_eban
*           FROM eban
*           FOR ALL ENTRIES IN it_material
*           WHERE matnr = it_material-matnr AND
*                 reswk = it_material-werks
*            AND bsart EQ c_po_replenishment
*            AND pstyp EQ c_pstyp_stock_tr      "STOCK TRANSFER
*            AND statu EQ 'N'
*            AND loekz EQ space
*            AND ebakz EQ space
**            AND reswk IN s_werkss " so_werks
*            AND ( lgort EQ '1000'
*                 or lgort eq ' ').
*
** Add open transport req quant's to allocations table
*    LOOP AT it_eban.
*      READ TABLE it_material WITH KEY matnr = it_eban-matnr
*                                      werks = it_eban-reswk
*                             BINARY SEARCH.
*      it_alloc-lgort = '1000'.
*      IF sy-subrc EQ 0.
*        it_alloc-matnr = it_eban-matnr.
*        it_alloc-werks = it_eban-reswk.
*        it_alloc-alloc_quantity = it_eban-menge.
*        COLLECT it_alloc.
*      ENDIF.
*    ENDLOOP.
*  ENDIF.

ENDFORM.                    " GET_open_transport_req


*&---------------------------------------------------------------------*
*&      Form  GET_OPEN_TRANSPORT_ORDERS
*&---------------------------------------------------------------------*
FORM get_open_transport_orders .

* Only consider open transport orders if storage location = 1000
*  CHECK p_lgort = '1000'.

  IF '1000' IN s_lgorts.

* Select from ekpo/ekko
    IF NOT it_material[] IS INITIAL.
      SELECT      b~ebeln b~ebelp b~matnr b~lgort b~menge a~reswk
             INTO TABLE it_ekpo2
             FROM ekko AS a
            INNER JOIN ekpo AS b
               ON a~ebeln = b~ebeln
              FOR ALL ENTRIES IN it_material
            WHERE b~matnr EQ it_material-matnr AND
                  a~reswk EQ it_material-werks
              AND (    a~bsart EQ 'ZUB1'
                    OR a~bsart EQ 'ZNB4' )
              AND a~reswk IN s_werks
              AND b~loekz EQ space.

      LOOP AT it_ekpo2.
        lv_index_st = sy-tabix.
        CLEAR lv_whtype.
        SELECT SINGLE whtype FROM yse_scc_planttyp INTO lv_whtype
          WHERE ekorg = p_ekorg AND werks = it_ekpo2-reswk.
        IF lv_whtype <> c_cw.
          DELETE it_ekpo2 INDEX lv_index_st.
        ENDIF.
      ENDLOOP.

* Don't continue open transport orders if no rows returned
      CHECK sy-subrc EQ 0.
      IF it_ekpo2[] IS NOT INITIAL.
* Select receipted quantities for the open transport order items
        SELECT      ebeln ebelp matnr menge belnr bwart
               INTO TABLE it_ekbe2
               FROM ekbe
               FOR ALL ENTRIES IN it_ekpo2
              WHERE ebeln EQ it_ekpo2-ebeln
                AND ebelp EQ it_ekpo2-ebelp
                AND vgabe = '6'.

* Add transport orders to allocation table
        LOOP AT it_ekpo2.
          it_alloc-matnr = it_ekpo2-matnr.
          it_alloc-alloc_quantity = it_ekpo2-menge.
          COLLECT it_alloc.
        ENDLOOP.

* Subtract receipted qty's from allocation table
        LOOP AT it_ekbe2.
          it_alloc-matnr = it_ekbe2-matnr.
          IF it_ekbe2-bwart EQ '641'.
            it_alloc-alloc_quantity = it_ekbe2-menge * ( -1 ).
          ELSEIF it_ekbe2-bwart EQ '642'.
            it_alloc-alloc_quantity = it_ekbe2-menge.
          ENDIF.
          COLLECT it_alloc.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    " GET_OPEN_TRANSPORT_ORDERS

*&---------------------------------------------------------------------*
*&      Form  get_order_data ZOR/ZO03
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_order_data .

*  RANGES:
*    r_lgort FOR vbap-lgort.
*
** Fill R_LGORT: If StLoc (LGORT) is 1000, also include lines with LGORT = '    '
**  r_lgort-sign   = 'I'.
**  r_lgort-option = 'EQ'.
**  r_lgort-low    = p_lgort.
**  APPEND r_lgort.
**  IF p_lgort = '1000'.
**    r_lgort-low  = '    '.
**    APPEND r_lgort.
**  ENDIF.
*
*  r_lgort[]  = s_lgorts[].

*>>>>>> bEGIN OF MOD 005 EXTUVE   20090602
*  IF '1000' IN s_lgort.
*    r_lgort-sign   = 'I'.
*    r_lgort-option = 'EQ'.
*    r_lgort-low  = '    '.
*    APPEND r_lgort.
*  ENDIF.
*>>>>>> eND OF MOD 005 EXTUVE   20090602

  CLEAR it_vbap[]."MOD-004
* Get open order item quantities
  SELECT      vbap~vbeln vbap~posnr matnr kwmeng werks lgort abgru
         INTO TABLE it_vbap
         FROM vbak
        INNER JOIN vbap
           ON vbak~vbeln EQ vbap~vbeln
        FOR ALL entries IN it_material
        WHERE vbap~matnr EQ it_material-matnr
          AND vbap~werks EQ it_material-werks
          AND (    lgort eq it_material-lgort"IN r_lgort"MOD-004
                OR lgort EQ ' ' )
*          AND pstyv IN s_pstyv
          AND ( vbak~auart = 'ZOR' OR vbak~auart = 'ZO03' )
          AND vbtyp EQ 'C'.

ENDFORM.                    " GET_ORDER_DATA


*&---------------------------------------------------------------------*
*&      Form  get_order_data returns ZRE1
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_order_data_zre1 .

*  RANGES:
*    r_lgort FOR vbap-lgort.
*
** Fill R_LGORT: If StLoc (LGORT) is 1000, also include lines with LGORT = '    '
**  r_lgort-sign   = 'I'.
**  r_lgort-option = 'EQ'.
**  r_lgort-low    = p_lgort.
**  APPEND r_lgort.
**  IF p_lgort = '1000'.
**    r_lgort-low  = '    '.
**    APPEND r_lgort.
**  ENDIF.
*
*  r_lgort[]  = s_lgorts[].

*>>>>>> bEGIN OF MOD 005 EXTUVE   20090602
*  IF '1000' IN s_lgort.
*    r_lgort-sign   = 'I'.
*    r_lgort-option = 'EQ'.
*    r_lgort-low  = '    '.
*    APPEND r_lgort.
*  ENDIF.
*>>>>>> eND OF MOD 005 EXTUVE   20090602

* Get open order item quantities
"MOD-004 begin
  CLEAR it_vbap_zre1[].
  SELECT      vbap~vbeln vbap~posnr matnr kwmeng werks lgort abgru
         INTO TABLE it_vbap_zre1
         FROM vbak
        INNER JOIN vbap
           ON vbak~vbeln EQ vbap~vbeln
        FOR ALL entries IN it_material
        WHERE vbap~matnr EQ it_material-matnr
          AND vbap~werks EQ it_material-werks
          AND (    lgort eq  it_material-lgort"IN r_lgort
                OR lgort EQ ' ' )
*          AND pstyv IN s_pstyv
          AND vbak~auart = 'ZRE1'
          AND vbtyp EQ 'H'.
"MOD-004 end
ENDFORM.                    " GET_ORDER_DATA


*&---------------------------------------------------------------------*
*&      Form  get_sales_order_stock
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_sales_order_stock.

"MOD-004 Begin
*  SELECT      matnr werks lgort SUM( e~kalab )
*         INTO TABLE it_mska
*         FROM mska AS e
*         WHERE
*              werks IN s_werks
*          AND matnr IN s_matnrs
*          AND lgort EQ '1000'
*          AND sobkz EQ 'E'
*          AND kalab <> 0
*        GROUP BY matnr werks lgort.

  clear: it_mska[].
  loop at it_material into wa_material.
    clear: wa_mska.
    select sum( kalab )
          into wa_mska-kalab from mska
      where matnr = wa_material-matnr
          and werks = wa_material-werks
          and lgort eq wa_material-lgort
          and sobkz eq 'E'
          and kalab <> 0.
    if sy-subrc = 0.
      wa_mska-matnr = wa_material-matnr.
      wa_mska-werks = wa_material-werks.
      wa_mska-lgort = wa_material-lgort.
      append wa_mska to it_mska.
    endif.
  endloop.
"MOD-004 end
ENDFORM.                    "get_sales_order_stock

*&---------------------------------------------------------------------*
*&      Form  GET_SERVICE_DATA
*&---------------------------------------------------------------------*
FORM get_service_data .

* Get reservation data
  SELECT      matnr werks lgort bdmng enmng vmeng umrez umren xwaok
         INTO TABLE it_resb
         FROM resb
        FOR ALL ENTRIES IN it_material
        WHERE matnr = it_material-matnr AND
              werks = it_material-werks
*          AND lgort EQ p_lgort
          AND (    lgort IN s_lgorts
                OR lgort EQ ' ' )
          AND xloek EQ space
          AND (    xwaok EQ 'X'
           OR xwaok EQ space ).

ENDFORM.                    " GET_SERVICE_DATA
