*&---------------------------------------------------------------------*
*& Report  ZRIMRG_ANALYSE   -check                                     *
*&---------------------------------------------------------------------*
*& Version:  (1.0  from 13.07.2005)                                    *
*&            1.1  from 18.01.2006                                     *
*&---------------------------------------------------------------------*
*& Purpose:                                                            *
*& --------                                                            *
*& Check consistency of measurement documents of pointers using the    *
*& following rule:                                                     *
*&                                                                     *
*&   Current total counter = total counter predecessor +               *
*&                             current difference                      *
*&                                                                     *
*& Requisites for this report:                                         *
*& ---------------------------                                         *
*& - The documents of the following measurement points are taken into  *
*&   account:                                                          *
*&   o Point is active (optional)                                      *
*&   o Point is not marked for deletion                                *
*&   o Point is no reference point                                     *
*&   o Point is a counter                                              *
*&   o Counter doesn't runs backwards (optional)                       *
*& - The report doesn't check the initial document because of          *
*&   technical conditions.                                             *
*& - The external set of total counter reading is ignored.             *
*&                                                                     *
*& Parameters of the program:                                          *
*& --------------------------                                          *
*& PD_MPOINT Number of the measuring point where you want to correct   *
*&           the measuring documents                                   *
*& PD_INACT  Analyse inactive counters as well                         *
*&           Default: Yes                                              *
*& PD_RV     Analyse counters which runs backwards                     *
*&           Default: Yes                                              *
*& PD_DATE   Start analyses with the creation date of documents given  *
*&           here.                                                     *
*&           Using the report to find inconsistencies created by note  *
*&           806624
*& PD_LG_CF  Show possible conflicts in the log                        *
*&           The document is listed in the log which breaks the rule   *
*&           mentioned above.                                          *
*&           Default: No                                               *
*& PD_LG_ST  Statistic of points with possible inconsistencies         *
*&           Default: Yes                                              *
*& PD_LG_MP  Analyse maintenance plans also in all points under a root *
*&           point. to get all maintenace plans under a root point     *
*&           pd_ever has to be checked                                 *
*&           Default: Yes                                              *
*& PD_EVER   Only used for maintenance plans. In case data of a        *
*&           inconsitent document is transfered to subordinate points  *
*&           these points are displayed for the transfer relation      *
*&           valid for the mesuring date of the wrong document.        *
*&           This will generally happen when you mark PD_LG_MP.        *
*&           Sometimes it is necessary to get a list of points ever    *
*&           assigned to the point with the inconsitency. These points *
*&           are used as well for a maint. plan analyses then.         *
*&           PD_EVER can be unflaged when measurement documents are    *
*&           created ONLY by entering difference! If you are not sure  *
*&           concerning your habit entering difference or counter      *
*&           reading flag PD_EVER                                      *
*&           DEFAULT: Yes                                              *
*&                                                                     *
*& Used abbreviations in the log:                                      *
*& ------------------------------                                      *
*& POINT     Number of Measuring Point                                 *
*& MDOCM     Number of Measurement Document                            *
*& IDATE     Date of the Measurement                                   *
*& ITIME     Time of Measurement                                       *
*& READG     Measurement Reading/Total Counter Reading in SI Unit      *
*& READGI    Indicator: Associated Number Field Contains a Value       *
*& CNTRR     Counter Reading in SI Unit                                *
*& CNTRRI    Indicator: Associated Number Field Contains a Value       *
*& CDIFF     Counter Reading Difference in SI Unit                     *
*& CDIFFI    Indicator: Associated Number Field Contains a Value       *
*& IDIFF     Indicator: Counter Reading Entered as Difference          *
*& EXCHG     Indicator: Counter Replaced                               *
*& TOTEX     Indicator: Total Counter Reading Set Externally           *
*& CANCL     Reversal Indicator                                        *
*&                                                                     *
*& Meaning of indicators in the log:                                   *
*& ---------------------------------                                   *
*& The indicators are used to show data conflicts found by analyses    *
*& and important data content of documents to be corrected.            *
*& N M XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...  *
*& Indicator N:     '#A' = Data of analyses                            *
*&           M:     'E'  = Error found in Document                     *
*&---------------------------------------------------------------------*
REPORT zrimrg_analyse LINE-SIZE 200.

TYPES:
  imptt_rec_type TYPE imptt,
  imptt_tab_type TYPE STANDARD TABLE OF imptt_rec_type,

  imrg_rec_type TYPE imrg,
  imrg_tab_type TYPE STANDARD TABLE OF imrg_rec_type,

  imph_rec_type TYPE imph,
  imph_tab_type TYPE STANDARD TABLE OF imph_rec_type,

  BEGIN OF imptt_lst_rec_type,
    point TYPE imptt-point,     " Counter with inconsitency
    transfers_data TYPE c,      " Counter transfers data
    by_transfer TYPE c,         " Counter receives data
    conflicts TYPE i,           " Number of conflicts
    inact TYPE c,               " Counter inactive
    rv TYPE c,                  " Counter runs backwards
    rootp TYPE imptt-point,     " Root counter
  END OF imptt_lst_rec_type,

  imptt_lst_tab_type TYPE STANDARD TABLE OF imptt_lst_rec_type,

  mmpt_rec_type TYPE mmpt,

  mmpt_tab_type TYPE STANDARD TABLE OF mmpt_rec_type,

  mpla_rec_type TYPE mpla,

  mpla_tab_type TYPE STANDARD TABLE OF mpla_rec_type,

  jest_rec_type TYPE jest,

  jest_tab_type TYPE STANDARD TABLE OF jest_rec_type,

  BEGIN OF log_rec_type,
    cat       TYPE c,
    action    TYPE c,
    point     TYPE imptt-point,
    mdocm     TYPE imrg-mdocm,
    idate     TYPE imrg-idate,
    itime     TYPE imrg-itime,
    gener     TYPE imrg-gener,
    rootd     TYPE imrg-rootd,
    readg     TYPE imrg-readg,
    readgi    TYPE imrg-readgi,
    cntrr     TYPE imrg-cntrr,
    cntrri    TYPE imrg-cntrri,
    cdiff     TYPE imrg-cdiff,
    cdiffi    TYPE imrg-cdiffi,
    idiff     TYPE imrg-idiff,
    exchg     TYPE imrg-exchg,
    totex     TYPE imrg-totex,
    cancl     TYPE imrg-cancl,
    text(100) TYPE c,
  END OF log_rec_type,
  log_tab_type TYPE STANDARD TABLE OF log_rec_type,

  BEGIN OF wa_points,
    point TYPE imptt-point,
    level TYPE i,
  END OF wa_points,
  t_points TYPE STANDARD TABLE OF wa_points.


DATA:
l_point TYPE imptt-point,                "measuring point
l_start_date TYPE imrg-erdat,            "date of creation

l_imptt_tab TYPE imptt_tab_type,         "table measuring points
l_imptt_rec TYPE imptt_rec_type,         "record measuring points
l_imptt_records TYPE i,                  "Number of records in IMPTT

l_imrg_tab TYPE imrg_tab_type,           "table measuring docs
l_imrg_rec TYPE imrg_rec_type,           "record measuring docs

l_log_rec TYPE log_rec_type,             "Log record
l_log_tab TYPE log_tab_type,             "Log table

l_by_trans TYPE c,                       "Point receives data by
                                       "transfer from other
                                       "points

l_transfers_data TYPE c,                 "Point sends documents to
                                       "other points

l_confl TYPE i,                          "Ammount of conflicts
                                       "found at point

l_retcode TYPE c,                        "General return value

l_stat_points_total TYPE i,              "Amount effected points

l_imptt_lst_rec TYPE imptt_lst_rec_type, "point in question
l_imptt_lst_tab TYPE imptt_lst_tab_type, "list of points in question

l_mmpt_rec TYPE mmpt_rec_type,           "Maint. plans
l_mmpt_tab TYPE mmpt_tab_type,
l_mpla_rec TYPE mpla_rec_type,
l_mpla_tab TYPE mpla_tab_type,
l_stat_mpla TYPE i,
l_stat_mpla_act TYPE i,

l_jest_rec TYPE jest_rec_type,           "Status of maint. plans
l_jest_tab TYPE jest_tab_type,

l_cf_header TYPE c.

CONSTANTS:
  c_invhi TYPE imph-invhi           VALUE '00000000000',
  c_intvl                           VALUE '1',
  c_yes   LIKE iref-iind VALUE 'X',
  c_no    LIKE iref-iind VALUE ' '.

************************************************************************

SELECT-OPTIONS:
  pt_point FOR l_point.                  "Measuring points to test
SELECTION-SCREEN SKIP.

PARAMETERS:
  pd_inact  TYPE iref-iind DEFAULT c_yes,
  pd_rv     TYPE iref-iind DEFAULT c_yes.


SELECTION-SCREEN SKIP.
PARAMETERS:
  pd_date   TYPE imrg-erdat.

SELECTION-SCREEN SKIP.

PARAMETERS:
  pd_lg_cf TYPE iref-iind DEFAULT c_no,
  pd_lg_st TYPE iref-iind DEFAULT c_yes.

SELECTION-SCREEN SKIP.

PARAMETERS:
  pd_lg_mp  TYPE iref-iind DEFAULT c_yes,
  pd_ever TYPE iref-iind DEFAULT c_yes.

************************************************************************

START-OF-SELECTION.

* Reset:
  l_imptt_records = 0.
  CLEAR l_log_rec.
  PERFORM log_append
              USING
                 l_log_rec
                 c_yes
              CHANGING
                 l_log_tab.
  l_stat_points_total = 0.
  l_start_date = pd_date.

*-----------------------------------------------------------------------

* Write header:
  PERFORM log_header.

*-----------------------------------------------------------------------

* Read points:
  PERFORM imptt_get
              TABLES
                 pt_point
              USING
                 pd_inact
                 pd_rv
              CHANGING
                 l_imptt_tab
                 l_retcode.
  IF NOT l_retcode IS INITIAL.
* No points found.
    ULINE.
    WRITE: / 'No points found!'.
    EXIT.
  ELSE.
* Points found.
*   Analyse points:
    IF NOT l_imptt_tab[] IS INITIAL.
      LOOP AT l_imptt_tab INTO l_imptt_rec.
*       Analyse point:
        CLEAR: l_by_trans, l_transfers_data, l_confl, l_retcode.
        REFRESH l_imrg_tab[].
        PERFORM imrg_analyse
                    USING
                      l_imptt_rec
                      l_imrg_tab
                      c_no
                      c_yes
                      l_start_date
                    CHANGING
                      l_log_tab
                      l_by_trans
                      l_transfers_data
                      l_confl
                      l_retcode.
        IF NOT l_retcode IS INITIAL
        OR l_confl = 0.
*        No documents or conflict found
          CONTINUE. " Next point ...
        ENDIF.
        IF l_retcode IS INITIAL
        AND l_confl > 0.

*        Documents with conflict found.
          l_stat_points_total = l_stat_points_total + 1.
*          Statistic of points with possible inconsitensies in case of
*          problems:
          CLEAR l_imptt_lst_rec.
          l_imptt_lst_rec-point = l_imptt_rec-point.
*          Point transfers data to other:
          IF NOT l_transfers_data IS INITIAL.
            l_imptt_lst_rec-transfers_data = 'Y'.
          ELSE.
            l_imptt_lst_rec-transfers_data = 'N'.
          ENDIF.
*          Point gets data by transfer:
          IF NOT l_by_trans IS INITIAL.
            l_imptt_lst_rec-by_transfer = 'Y'.
          ELSE.
            l_imptt_lst_rec-by_transfer = 'N'.
          ENDIF.
*          Number of conflicts:
          l_imptt_lst_rec-conflicts = l_confl.
*          Counter inactive:
          IF NOT l_imptt_rec-inact IS INITIAL.
            l_imptt_lst_rec-inact = 'Y'.
          ELSE.
            l_imptt_lst_rec-inact = 'N'.
          ENDIF.
*          Counter runs backwards:
          IF NOT l_imptt_rec-indrv IS INITIAL.
            l_imptt_lst_rec-rv = 'Y'.
          ELSE.
            l_imptt_lst_rec-rv = 'N'.
          ENDIF.
*          Append to list:
          APPEND l_imptt_lst_rec TO l_imptt_lst_tab.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.

*-----------------------------------------------------------------------

* Write conflict:
  IF NOT pd_lg_cf IS INITIAL
  AND NOT l_log_tab IS INITIAL.
    l_cf_header = c_yes.
    PERFORM log_write
            USING
              l_log_tab
              l_cf_header.
  ENDIF.

*-----------------------------------------------------------------------

* Show statistics of points with possible inconsitencies:
  IF NOT pd_lg_st IS INITIAL.
    ULINE.
    WRITE: / 'Statistic:'.
    WRITE: / '----------'.
    WRITE: / 'Quantity of possible effected points:',
           l_stat_points_total.
    SKIP.
    IF l_stat_points_total > 0.
      WRITE AT / 'Point:'.
      WRITE AT 20 'Tranfers data:'.
      WRITE AT 40 'Get data by transfer:'.
      WRITE AT 70 'Number of possible conflicts:'.
      WRITE AT 102 'Point inactive:'.
      WRITE AT 118 'Point runs backwards:'.
      LOOP AT l_imptt_lst_tab INTO l_imptt_lst_rec.
        WRITE AT / l_imptt_lst_rec-point.
        WRITE AT 20 l_imptt_lst_rec-transfers_data.
        WRITE AT 40 l_imptt_lst_rec-by_transfer.
        WRITE AT 70 l_imptt_lst_rec-conflicts.
        WRITE AT 102 l_imptt_lst_rec-inact.
        WRITE AT 118 l_imptt_lst_rec-rv.
      ENDLOOP.
    ENDIF.
  ENDIF.

*-----------------------------------------------------------------------

* Analyse maintenance plans:
  IF NOT pd_lg_mp IS INITIAL
  AND l_stat_points_total > 0.
    PERFORM imptt_explode_for_mpla
              USING
                 l_log_tab
                 pd_ever
              CHANGING
                 l_imptt_lst_tab.
    SORT l_imptt_lst_tab BY point rootp.
    DELETE ADJACENT DUPLICATES FROM l_imptt_lst_tab COMPARING point.
    CLEAR l_stat_mpla.
    CLEAR l_stat_mpla_act.
    ULINE.
    WRITE: / 'Maint. plans possibly effected:'.
    WRITE: / '-------------------------------'.
    LOOP AT l_imptt_lst_tab INTO l_imptt_lst_rec.
      REFRESH l_mmpt_tab.
      SELECT * FROM mmpt INTO TABLE l_mmpt_tab
        WHERE point = l_imptt_lst_rec-point.
      IF sy-subrc IS INITIAL.
        LOOP AT l_mmpt_tab INTO l_mmpt_rec.
          WRITE: / 'Point: ', l_imptt_lst_rec-point,
                   'Maint. plan:', l_mmpt_rec-warpl.
          SELECT SINGLE * FROM mpla INTO l_mpla_rec
            WHERE warpl = l_mmpt_rec-warpl.
          IF sy-subrc IS INITIAL.
            l_stat_mpla = l_stat_mpla + 1.
            REFRESH l_jest_tab.
            SELECT * FROM jest INTO TABLE l_jest_tab
              WHERE objnr = l_mpla_rec-objnr
              AND inact = space
              AND stat = 'I0320'.
            IF sy-subrc IS INITIAL.
              WRITE: 'Maint. plan inactive'.
*             Output Rootpoint
              IF NOT l_imptt_lst_rec-rootp IS INITIAL.
                WRITE AT 80: 'Rootpoint: '.
                WRITE: l_imptt_lst_rec-rootp.
              ELSE.
*             No root document exist, no output
              ENDIF.
            ELSE.
              WRITE: 'Maint. plan active'.
              l_stat_mpla_act = l_stat_mpla_act + 1.
*             Output Rootpoint
              IF NOT l_imptt_lst_rec-rootp IS INITIAL.
                WRITE AT 80: 'Rootpoint: '.
                WRITE: l_imptt_lst_rec-rootp.
              ELSE.
*             No root document exist, no output
              ENDIF.
            ENDIF.
          ELSE.
            WRITE: 'No maint. plan entry found!'.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDLOOP.
    WRITE: / 'Number of possibly effected maint. plans:     ',
      l_stat_mpla.
    WRITE: / 'From which are number of active maint. plans: ',
      l_stat_mpla_act.
  ENDIF.

* End of report ZRIMRG_ANALYSE

*&---------------------------------------------------------------------*
*&      Form  IMPTT_GET
*&---------------------------------------------------------------------*
* Select measuring points which are
* - not inactive
* - not marked for deletion
* - no reference points
* - counters
* - counter doesn't runs backwards
*----------------------------------------------------------------------*
*  -->  T_POINT      Number of measurment points to select
*  -->  I_WITH_INACT With inactive points
*  -->  I_WITH_RV    With counters running backwards
*  <--  E_IMPTT_TAB  Data of selected points
*  <--  E_RETCODE    '1'   = No Points found
*                    SPACE = Points found
*----------------------------------------------------------------------*
FORM imptt_get
  TABLES
    t_point
  USING
    value(i_with_inact) TYPE c
    value(i_with_rv) TYPE c
  CHANGING
    e_imptt_tab TYPE imptt_tab_type
    e_retcode TYPE c.

  RANGES:
    l_inact FOR imptt-inact,
    l_rv FOR imptt-indrv.

* Reset:
  CLEAR e_retcode.
  REFRESH e_imptt_tab.

* Set selection criteria:
  IF i_with_inact IS INITIAL.
    CLEAR l_inact.
    REFRESH l_inact.
    l_inact-low    = space.
    l_inact-option = 'EQ'.
    l_inact-sign   = 'I'.
    APPEND l_inact.
  ELSE.
    CLEAR l_inact.
    REFRESH l_inact.
  ENDIF.
  IF i_with_rv IS INITIAL.
    CLEAR l_rv.
    REFRESH l_rv.
    l_rv-low    = space.
    l_rv-option = 'EQ'.
    l_rv-sign   = 'I'.
    APPEND l_rv.
  ELSE.
    CLEAR l_rv.
    REFRESH l_rv.
  ENDIF.

* Select data:
  SELECT * FROM imptt
      INTO TABLE e_imptt_tab
    WHERE point IN t_point
      AND inact IN l_inact
      AND lvorm = space
      AND refmp = space
      AND indct <> space
      AND indrv IN l_rv.
  IF l_imptt_tab IS INITIAL.
    e_retcode = '1'.
  ELSE.
    SORT e_imptt_tab BY point.
    CLEAR e_retcode.
  ENDIF.

ENDFORM.                    " IMPTT_GET

*&---------------------------------------------------------------------*
*&      Form  IMRG_ANALYSE
*&---------------------------------------------------------------------*
* Analyse data of point
*
* Analyses whether the chain of measurment documents of points comes
* in conflict with the following rule:
* Current total counter = Total counter predecessor +
*                           current difference
*----------------------------------------------------------------------*
*  -->  I_IMPTT_REC        Data of point to analyse
*  -->  I_IMRG_TAB         Document data of point
*  -->  I_ANALYSE_AFTER    Analyse after correction
*  -->  I_LOG_CONFL        Log conflicts in log
*  -->  I_START_DATE       Analyse starting with this date of creation
*  <->  E_LOG_TAB          Log table
*  <--  E_BY_TRANS         Document found creaded by data transfer
*                          X = Yes, Space = No
*  <--  E_TRANSFERS_DATA   Point transfers data to other points
*                          X = Yes, Space = No
*  <--  E_CONFL            Number of conflicts
*  <--  E_RETCODE          SPACE Documents found generally
*                          1     No documents found generally
*----------------------------------------------------------------------*
FORM imrg_analyse
  USING
    value(i_imptt_rec) TYPE imptt
    value(i_imrg_tab) TYPE imrg_tab_type
    value(i_analyse_after) TYPE c
    value(i_log_confl) TYPE c
    value(i_start_date) TYPE imrg-erdat
  CHANGING
    e_log_tab TYPE log_tab_type
    e_by_trans TYPE c
    e_transfers_data TYPE c
    e_confl TYPE i
    e_retcode TYPE c.

  DATA:
    l_start_analyse TYPE c,
    l_imrg_tab TYPE imrg_tab_type,
    l_imrg_pre_rec TYPE imrg_rec_type,
    l_imrg_suc_rec TYPE imrg_rec_type,
    l_readg_pre TYPE imrg-readg,
    l_readg_suc TYPE imrg-readg,
    l_cntrr_pre TYPE imrg-cntrr,
    l_cntrr_suc TYPE imrg-cntrr,
    l_confl_readg TYPE c,
    l_confl_cntrr TYPE c,
    l_imph_rec TYPE imph_rec_type,
    l_log_rec TYPE log_rec_type.

* Reset:
  CLEAR l_start_analyse.
  CLEAR l_imrg_pre_rec.
  CLEAR l_imrg_suc_rec.
  l_readg_pre = 0.
  l_readg_suc = 0.
  CLEAR e_by_trans.
  CLEAR e_transfers_data.
  e_confl = 0.
  CLEAR e_retcode.

  IF i_imrg_tab[] IS INITIAL.
*   Select measurement documents of the point which are not canceled:
    SELECT * FROM imrg
      INTO TABLE l_imrg_tab
      WHERE point = i_imptt_rec-point
        AND cancl = space.
    IF NOT sy-subrc IS INITIAL.
*   Nothing found.
      e_retcode = '1'.
      EXIT.
    ELSE.
*   Documents found.
      CLEAR e_retcode.
    ENDIF.
  ELSE.
    l_imrg_tab[] = i_imrg_tab[].
  ENDIF.

* Point transfer data to other points:
  SELECT SINGLE *
    FROM imph
    INTO l_imph_rec
    WHERE trans = i_imptt_rec-point
      AND cancl = space.
  IF sy-subrc IS INITIAL.
    e_transfers_data = c_yes.
  ENDIF.

* Sort by INVTS (Inverted time stamp) to get a chronological order:
  SORT l_imrg_tab BY invts DESCENDING mdocm ASCENDING.

* Check data:
  LOOP AT l_imrg_tab INTO l_imrg_suc_rec.

    IF NOT l_imrg_suc_rec-rootd IS INITIAL.
*   Document was created by transfer
      e_by_trans = c_yes.
    ENDIF.

    IF NOT l_imrg_suc_rec-cancl IS INITIAL.
*   Documents canceled:
*     Ignore, next document:
      CONTINUE.
    ENDIF.

*   Start of analyses depends on creation date:
    IF l_start_analyse IS INITIAL.
      IF i_start_date IS INITIAL.
        l_start_analyse = c_yes.
*       continue with form ...
      ELSE.
        IF l_imrg_suc_rec-erdat >= i_start_date.
          l_start_analyse = c_yes.
*         continue with form ...
        ELSE.
*         Rememenber current record as predecessor:
          l_imrg_pre_rec = l_imrg_suc_rec.
*         Next document:
          CONTINUE.
        ENDIF.
      ENDIF.
    ELSE.
*     continue with form ...
    ENDIF.

    IF NOT l_imrg_suc_rec-totex IS INITIAL.
*   External set of total counter reading.
*     Ignore external set of total counter reading. But remember
*     current record as predecessor:
      l_imrg_pre_rec = l_imrg_suc_rec.
*     Next document:
      CONTINUE.
    ENDIF.

    IF l_imrg_pre_rec IS INITIAL.
*   No predecessor available at the moment.
*     Generally ignore initial document!
*     But remember current record as predecessor:
      l_imrg_pre_rec = l_imrg_suc_rec.
*     Next document:
      CONTINUE.
    ELSE.
*   Predecessor available.
*     1. Conflict on READG:
*     Reset conflict flag:
      CLEAR l_confl_readg.
*     Current total counter of predecessor:
      l_readg_pre = l_imrg_pre_rec-readg.
*     Theoretical total counter of successor:
      IF i_imptt_rec-indrv IS INITIAL.
*       Counter runs forward.
        l_readg_suc = l_readg_pre + l_imrg_suc_rec-cdiff.
      ELSE.
*       Counter runs backwards.
        l_readg_suc = l_readg_pre - l_imrg_suc_rec-cdiff.
      ENDIF.
*     Compare theoratical total counter with the
*     current total counter of the successor
      CALL FUNCTION 'CHECK_EQUALITY_13DECS'
        EXPORTING
          iv_float_1         = l_readg_suc
          iv_float_2         = l_imrg_suc_rec-readg
        EXCEPTIONS
          float_1_eq_float_2 = 1
          float_1_gt_float_2 = 2
          float_1_lt_float_2 = 3.
      IF sy-subrc > 1.
        l_confl_readg = c_yes.
      ELSE.
        CLEAR l_confl_readg.
      ENDIF.
*     2. Conflict on CNTRR after TOTEX only when READG = 0:
*     Reset conflict flag:
      CLEAR l_confl_cntrr.
      IF NOT l_imrg_pre_rec-totex IS INITIAL
      AND l_imrg_pre_rec-readg = 0
      AND l_imrg_suc_rec-exchg IS INITIAL.
*     Predecessor found where TOTEX = X and READG = 0
*     and successors EXCHG = SPACE.
*       Theoretical counter of successor:
        PERFORM get_cntrr_by_cdiff
                    USING
                        l_imptt_rec
                        l_imrg_pre_rec
                        l_imrg_suc_rec
                    CHANGING
                        l_cntrr_suc.
*       Compare theoratical counter with the
*       current counter of the successor
        CALL FUNCTION 'CHECK_EQUALITY_13DECS'
          EXPORTING
            iv_float_1         = l_cntrr_suc
            iv_float_2         = l_imrg_suc_rec-cntrr
          EXCEPTIONS
            float_1_eq_float_2 = 1
            float_1_gt_float_2 = 2
            float_1_lt_float_2 = 3.
        IF sy-subrc = 1.
          CLEAR l_confl_cntrr.
        ELSE.
          l_confl_cntrr = c_yes.
        ENDIF.
      ENDIF.
*     Evaluate conflict flags:
      IF NOT l_confl_readg IS INITIAL
      OR NOT l_confl_cntrr IS INITIAL.
*     Something went wrong:
*       Log:
        IF NOT i_log_confl IS INITIAL
        OR NOT i_analyse_after IS INITIAL.
          IF e_confl = 0
          AND NOT i_analyse_after IS INITIAL.
            CLEAR l_log_rec.
            l_log_rec-cat = 'E'.
            l_log_rec-text = 'Data conflict after correction found!'.
            PERFORM log_append
                        USING
                            l_log_rec
                            c_no
                        CHANGING
                            e_log_tab.
          ENDIF.
          CLEAR l_log_rec.
          l_log_rec-cat = 'A'.
          l_log_rec-action = 'E'.
          l_log_rec-point  = l_imrg_suc_rec-point.
          l_log_rec-mdocm  = l_imrg_suc_rec-mdocm.
          l_log_rec-idate  = l_imrg_suc_rec-idate.
          l_log_rec-itime  = l_imrg_suc_rec-itime.
          l_log_rec-gener  = l_imrg_suc_rec-gener.
          l_log_rec-rootd  = l_imrg_suc_rec-rootd.
          l_log_rec-readg  = l_imrg_suc_rec-readg.
          l_log_rec-readgi = l_imrg_suc_rec-readgi.
          l_log_rec-cntrr  = l_imrg_suc_rec-cntrr.
          l_log_rec-cntrri = l_imrg_suc_rec-cntrri.
          l_log_rec-cdiff  = l_imrg_suc_rec-cdiff.
          l_log_rec-cdiffi = l_imrg_suc_rec-cdiffi.
          l_log_rec-idiff  = l_imrg_suc_rec-idiff.
          l_log_rec-exchg  = l_imrg_suc_rec-exchg.
          l_log_rec-totex  = l_imrg_suc_rec-totex.
          l_log_rec-cancl  = l_imrg_suc_rec-cancl.
          PERFORM log_append
                      USING
                        l_log_rec
                        c_no
                      CHANGING
                        e_log_tab.
        ENDIF.
*       Increase conflict counter:
        e_confl = e_confl + 1.
      ELSE.
*       Do nothing ...
      ENDIF.
*     Remember current record as predecessor.
      l_imrg_pre_rec = l_imrg_suc_rec.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " IMRG_ANALYSE

*&---------------------------------------------------------------------*
*&      Form  GET_CNTRR_BY_CDIFF
*&---------------------------------------------------------------------*
*  Determine desired counter reading
*----------------------------------------------------------------------*
* --> I_IMPTT_REC    Current point
* --> I_IMRG_PRE_REC Predecessing document
* --> I_IMRG_SUC_REC Successing document
* <-- E_CNTRR        Desired counter reading value
*----------------------------------------------------------------------*
FORM get_cntrr_by_cdiff
  USING
    value(i_imptt_rec) TYPE imptt
    value(i_imrg_pre_rec) TYPE imrg
    value(i_imrg_suc_rec) TYPE imrg
  CHANGING
    e_cntrr TYPE imrg-cntrr.

  IF i_imptt_rec-indrv IS INITIAL.
    e_cntrr = i_imrg_pre_rec-cntrr + i_imrg_suc_rec-cdiff.
    IF NOT i_imptt_rec-cjumpi IS INITIAL
    AND i_imptt_rec-cjump NE 0.
      DO.
        IF e_cntrr LT i_imptt_rec-cjump.
          EXIT.
        ELSE.
          e_cntrr = e_cntrr - i_imptt_rec-cjump.
        ENDIF.
      ENDDO.
    ENDIF.
  ELSE.
    e_cntrr = i_imrg_pre_rec-cntrr - i_imrg_suc_rec-cdiff.
    IF NOT i_imptt_rec-cjumpi IS INITIAL
    AND i_imptt_rec-cjump NE 0.
      DO.
        IF e_cntrr GE 0.
          EXIT.
        ELSE.
          e_cntrr = e_cntrr + i_imptt_rec-cjump.
        ENDIF.
      ENDDO.
    ENDIF.
  ENDIF.

ENDFORM.                    " GET_CNTRR_BY_CDIFF

*&---------------------------------------------------------------------*
*&      Form  LOG_APPEND
*&---------------------------------------------------------------------*
* Append log data
*----------------------------------------------------------------------*
*  -->  I_LOG_REC    Log record
*  -->  I_RESET      Reset log
*  <--  E_LOG_TAB    Log table
*----------------------------------------------------------------------*
FORM log_append
  USING
    value(i_log_rec) TYPE log_rec_type
    value(i_reset) TYPE c
  CHANGING
    e_log_tab TYPE log_tab_type.
  IF NOT i_reset IS INITIAL.
    REFRESH e_log_tab.
  ENDIF.
  IF NOT i_log_rec IS INITIAL.
    APPEND i_log_rec TO e_log_tab.
  ENDIF.
ENDFORM.                    " LOG_APPEND

*&---------------------------------------------------------------------*
*&      Form  LOG_WRITE
*&---------------------------------------------------------------------*
* Write log data
*----------------------------------------------------------------------*
*  -->  I_LOG_TAB    Log table
*----------------------------------------------------------------------*
FORM log_write
  USING
    value(i_log_tab) TYPE log_tab_type
    value(i_write_header) TYPE c.
  DATA:
    l_log_rec TYPE log_rec_type,
    l_point_d TYPE imptt-point,
    l_point_a TYPE imptt-point.


* Reset:
  CLEAR l_point_d.
  CLEAR l_point_a.

* Header:
  IF NOT i_write_header IS INITIAL.
    ULINE.
    WRITE:      /   'Possible effected measurement documents:'.
    WRITE:      /   '----------------------------------------'.
    WRITE:   AT /5  'POINT:' ,
             AT 25  'MDOCM:' ,
             AT 50  'READG:' ,
             AT 75  'READGI:',
             AT 85  'CNTRR:' ,
             AT 110 'CNTRRI:',
             AT 120 'CDIFF:' ,
             AT 145 'CDIFFI:',
             AT 155 'IDIFF:' ,
             AT 165 'EXCHG:' ,
             AT 175 'TOTEX:' ,
             AT 185 'CANCL:' .
  ENDIF.

  LOOP AT i_log_tab INTO l_log_rec.

*   Show Information:
    IF l_log_rec-cat = 'I'.
      WRITE: AT / l_log_rec-cat,
             AT 5 l_log_rec-text.
      IF NOT l_log_rec-point IS INITIAL.
        WRITE: 'Point: ', l_log_rec-point.
      ENDIF.
      IF NOT l_log_rec-mdocm IS INITIAL .
        WRITE: 'Docum.: ', l_log_rec-mdocm.
      ENDIF.
    ENDIF.

*   Show Error:
    IF l_log_rec-cat = 'E'.
      WRITE: AT / l_log_rec-cat,
             AT 5 l_log_rec-text.
      IF NOT l_log_rec-point IS INITIAL.
        WRITE: 'Point: ', l_log_rec-point.
      ENDIF.
      IF NOT l_log_rec-mdocm IS INITIAL.
        WRITE: 'Docum.: ', l_log_rec-mdocm.
      ENDIF.
    ENDIF.

*   Show analyses:
    IF l_log_rec-cat = 'A'.
      WRITE: AT /5  l_log_rec-point,
             AT 25  l_log_rec-mdocm,
             AT 50  l_log_rec-readg,
             AT 75  l_log_rec-readgi,
             AT 85  l_log_rec-cntrr,
             AT 110 l_log_rec-cntrri,
             AT 120 l_log_rec-cdiff,
             AT 145 l_log_rec-cdiffi,
             AT 155 l_log_rec-idiff,
             AT 165 l_log_rec-exchg,
             AT 175 l_log_rec-totex,
             AT 185 l_log_rec-cancl.
      l_point_a = l_log_rec-point.
*     Note:
*        ACTION = E Error found in Document
    ENDIF.

    IF l_log_rec-cat = 'S'. "Skip line
      SKIP.
    ENDIF.

    IF l_log_rec-cat = 'U'. "Underline
      ULINE.
    ENDIF.

  ENDLOOP.
ENDFORM.                    " LOG_WRITE

*&---------------------------------------------------------------------*
*&      Form  LOG_HEADER
*&---------------------------------------------------------------------*
*  Log header
*----------------------------------------------------------------------*
FORM log_header.

  WRITE: / 'Administrative data:'.
  WRITE: / '--------------------'.
  WRITE: / '- System: ', sy-sysid.
  WRITE: / '- Client: ', sy-mandt.
  WRITE: / '- Date:   ', sy-datum.
  WRITE: / '- Time:   ', sy-uzeit.
  WRITE: / '- User:   ', sy-uname.

ENDFORM.                    " LOG_HEADER

*&---------------------------------------------------------------------*
*&      Form  imptt_list_get
*&---------------------------------------------------------------------*
*       Get all points to analyse
*       Only those points are relevant which
*       - are counters and
*       - create interval documnets when measurement data transfer
*         happend
*----------------------------------------------------------------------*
*  -->  i_point            number of root point
*  -->  i_ever             points ever assigned
*  -->  i_date             points assigned at date
*  -->  i_time             ... and time
*  -->  i_intvl_only       points with interval characteristic only
*  -->  i_one_point_only   only one point given in i_point
*  <--  c_t_points         list of points to analyse
*  <--  c_retval           return value (SPACE = no errors)
*----------------------------------------------------------------------*
FORM imptt_list_get
  USING
    value(i_point) TYPE imptt-point
    value(i_ever) TYPE c
    value(i_date) TYPE imrg-idate
    value(i_time) TYPE imrg-itime
    value(i_intvl_only) TYPE c
    value(i_one_point_only) TYPE c
  CHANGING
    c_t_points TYPE t_points
    c_retval TYPE c.

  DATA:
    l_wa_iflot LIKE iflot,
    l_wa_equi LIKE  equi,
    l_wa_imptt LIKE imptt,
    l_wa_points TYPE wa_points,
    l_invts TYPE imrg-invts,
    l_t_points_buf TYPE t_points.

  FIELD-SYMBOLS:
    <l_fs_point> TYPE wa_points,        "point to be checked
    <l_fs_point_buf> TYPE wa_points.    "point to be checked (with

*-----------------------------------------------------------------------

*  Reset data:
  REFRESH c_t_points.
  CLEAR c_retval.

*-----------------------------------------------------------------------

  IF NOT i_point IS INITIAL.
* Log:
*    WRITE: / 'Explode point: ', i_point, ' Date: ', i_date, ' Time:',
* i_time.
*   Select:
    SELECT SINGLE *
      FROM imptt
      INTO l_wa_imptt
      WHERE point = i_point.
    IF sy-subrc IS INITIAL.
      l_wa_points-point = i_point.
      l_wa_points-level = 0.
      INSERT l_wa_points INTO TABLE c_t_points.
    ELSE.
*     Nothing found:
      c_retval = '1'.
    ENDIF.
  ENDIF.

*-----------------------------------------------------------------------

* Points found so far?
  IF NOT c_retval IS INITIAL.
    EXIT.
  ENDIF.

*-----------------------------------------------------------------------

* Invert time stamp (so available):
  IF NOT i_date IS INITIAL.
    CALL FUNCTION 'TIMESTAMP_INVERT_11_DIGITS'
      EXPORTING
        idate         = i_date
        itime         = i_time
      IMPORTING
        timestamp_inv = l_invts.
  ENDIF.

*-----------------------------------------------------------------------

  IF NOT i_one_point_only IS INITIAL
  AND NOT i_point IS INITIAL.
*   Do nothing.
  ELSE.
*   Get all related points:
    LOOP AT c_t_points INTO l_wa_points WHERE level = 0.
*   Get the children of the point
      PERFORM imptt_children_get
        USING
          l_wa_points-point
          0
          i_ever
          l_invts
        CHANGING
          c_t_points.
    ENDLOOP.
*   Delete duplicate points, keep highest level:
    SORT c_t_points BY point ASCENDING level DESCENDING.
    DELETE ADJACENT DUPLICATES FROM c_t_points COMPARING point.
  ENDIF.

*-----------------------------------------------------------------------

* Determine points in list c_t_points which are counters
* and are able to create interval documents:

  IF NOT i_intvl_only IS INITIAL.
*   Only points with counter and interval characteristic:
    SELECT point FROM imptt
      INTO CORRESPONDING FIELDS OF TABLE l_t_points_buf
      FOR ALL ENTRIES IN c_t_points
      WHERE point = c_t_points-point
      AND indct = c_yes
      AND modtr = c_intvl.
  ELSE.
*   Only points with counter characteristic:
    SELECT point FROM imptt
      INTO CORRESPONDING FIELDS OF TABLE l_t_points_buf
      FOR ALL ENTRIES IN c_t_points
      WHERE point = c_t_points-point
      AND indct = c_yes.
  ENDIF.
  IF sy-subrc IS INITIAL.
*   Match the result from l_t_points_buf with level and i_t_points:
*   - sort properly first:
    SORT l_t_points_buf BY point.
    SORT c_t_points BY point.
*   - take over data of level in l_t_points_buf:
    LOOP AT l_t_points_buf ASSIGNING <l_fs_point_buf>.
      READ TABLE c_t_points
        WITH KEY point =  <l_fs_point_buf>-point
        ASSIGNING <l_fs_point>
        BINARY SEARCH.
      IF sy-subrc IS INITIAL.
        <l_fs_point_buf>-level = <l_fs_point>-level.
      ENDIF.
    ENDLOOP.
*   Refresh original table:
    REFRESH c_t_points.
*   Take over data to original table from local buffer:
    c_t_points = l_t_points_buf.
*   Sort c_t_points properly:
    SORT c_t_points BY level point.
*   Refresh buffer table:
    REFRESH l_t_points_buf.
  ELSE.
*   No counter with interval documents found:
    c_retval = '1'.
  ENDIF.

ENDFORM.                    " imptt_list_get

*----------------------------------------------------------------------*
*       FORM imptt_children_get                                       *
*----------------------------------------------------------------------*
*       determine child point in a point structure
*----------------------------------------------------------------------*
*  -->  i_point               point to start
*  -->  i_level               current level
*  -->  i_ever                list points ever assigned to i_point
*  -->  i_invts               list points assigend to i_point at the
*                             time stamp imrg-invts
*  <->  c_t_point             list of points to analyse
*----------------------------------------------------------------------*
FORM imptt_children_get
  USING
    i_point LIKE imptt-point
    i_level TYPE i
    i_ever TYPE c
    i_invts TYPE imrg-invts
  CHANGING
    c_t_points TYPE t_points.

  DATA:
    l_imph_rec LIKE imph,
    l_wa_points TYPE wa_points,
    l_level TYPE i.

* Increase level:
  l_level = i_level + 1.

* get the children of the point:
  IF NOT i_ever IS INITIAL.
*   Select all points ever assigned:
    SELECT * FROM imph INTO l_imph_rec
    WHERE trans = i_point.
*   Insert found point:
      CLEAR l_wa_points.
      l_wa_points-point = l_imph_rec-point.
      l_wa_points-level = l_level.
      INSERT l_wa_points INTO TABLE c_t_points.
*     Call the form imptt_children_get for each child recursively
      PERFORM imptt_children_get
        USING
          l_imph_rec-point
          l_level
          i_ever
          i_invts
        CHANGING
          c_t_points.
    ENDSELECT.
  ELSE.
*   Select points concerning time stamp:
    IF i_invts IS INITIAL.
*     Current assignment:
      SELECT * FROM imph INTO l_imph_rec
      WHERE trans = i_point
      AND invhi = c_invhi.
*     Insert found point:
        CLEAR l_wa_points.
        l_wa_points-point = l_imph_rec-point.
        l_wa_points-level = l_level.
        INSERT l_wa_points INTO TABLE c_t_points.
*       Call the form imptt_children_get for each child recursively
        PERFORM imptt_children_get
          USING
            l_imph_rec-point l_level i_ever i_invts
          CHANGING
            c_t_points.
      ENDSELECT.
    ELSE.
*     Assignment at time stamp:
      SELECT * FROM imph INTO l_imph_rec
      WHERE trans = i_point
      AND invlo > i_invts
      AND invhi <= i_invts.
*     Note: select refers to function MEASUREM_COPY_CHAIN_EXPLODE
*     Insert found point:
        CLEAR l_wa_points.
        l_wa_points-point = l_imph_rec-point.
        l_wa_points-level = l_level.
        INSERT l_wa_points INTO TABLE c_t_points.
*       Call the form imptt_children_get for each child recursively
        PERFORM imptt_children_get
          USING
            l_imph_rec-point l_level i_ever i_invts
          CHANGING
            c_t_points.
      ENDSELECT.
    ENDIF.
  ENDIF.

ENDFORM.                    " imptt_children_get

*&---------------------------------------------------------------------*
*&      Form  IMPTT_EXPLODE_FOR_MPLA
*&---------------------------------------------------------------------*
*       Explode point structure for maintenance plans analyses
*----------------------------------------------------------------------*
*  --> i_log_tab  Log table with inconsisten documents
*  --> i_ever     Find all points ever assigned
*  <-> c_imptt_lst_tab Points with possible inconsistencies.
*----------------------------------------------------------------------*
FORM imptt_explode_for_mpla
  USING
      i_log_tab TYPE log_tab_type
      i_ever TYPE iref-iind  "if assigned exploding point at all times
  CHANGING
      c_imptt_lst_tab TYPE imptt_lst_tab_type.

  DATA: l_imptt_lst_rec TYPE imptt_lst_rec_type,
        l_imptt_lst_tab_buf TYPE imptt_lst_tab_type,
        l_imptt_lst_rec_buf TYPE imptt_lst_rec_type,
        l_points_tab TYPE t_points,
        l_points_rec TYPE wa_points,
        l_retval TYPE c,
        l_log_rec TYPE log_rec_type,
        l_tabix TYPE sy-tabix.

* Sort properly:
  SORT i_log_tab BY point ASCENDING.
* Get points that transfer data:
  LOOP AT c_imptt_lst_tab INTO l_imptt_lst_rec
                          WHERE transfers_data = 'Y'.
*   Get first inconsistency in log:
    READ TABLE i_log_tab INTO l_log_rec
                         WITH KEY point = l_imptt_lst_rec-point
                         BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      l_tabix = sy-tabix.
*     Start Loop at point l_tabix (first relevant point):
      LOOP AT i_log_tab INTO l_log_rec
                        FROM l_tabix.
        IF l_log_rec-point = l_imptt_lst_rec-point.
*         Only such points shall be proceed whose inconsistent document
*         is a root document. Generally the explosion of the subordinate
*         points happens for the measuring date/time of the inconsistent
*         document:
          IF l_log_rec-cat = 'A'
          AND l_log_rec-action = 'E'
          AND l_log_rec-gener <> 'T'
          AND l_log_rec-rootd IS INITIAL.
            REFRESH l_points_tab.
*           Explode points:
            PERFORM imptt_list_get
                        USING
                            l_log_rec-point
                            i_ever
                            l_log_rec-idate
                            l_log_rec-itime
                            space " i_intvl_only
                            space " i_one_point_only
                        CHANGING
                           l_points_tab
                           l_retval.
            IF l_retval IS INITIAL.
*             Only points which are not same as root point in buffer
              LOOP AT l_points_tab INTO l_points_rec
              WHERE point <> l_log_rec-point.
                CLEAR l_imptt_lst_rec_buf.
                l_imptt_lst_rec_buf-point = l_points_rec-point.
*               Save root point to each point
                l_imptt_lst_rec_buf-rootp = l_imptt_lst_rec-point.
                APPEND l_imptt_lst_rec_buf TO l_imptt_lst_tab_buf.
              ENDLOOP.
            ENDIF.
          ENDIF.
        ELSE.
*         No entry available anymore
          EXIT. "loop
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

* Append results to original table:
  IF NOT l_imptt_lst_tab_buf IS INITIAL.
    SORT l_imptt_lst_tab_buf BY point rootp.
    DELETE ADJACENT DUPLICATES FROM l_imptt_lst_tab_buf
      COMPARING ALL FIELDS.
    LOOP AT l_imptt_lst_tab_buf INTO l_imptt_lst_rec_buf.
      APPEND l_imptt_lst_rec_buf TO l_imptt_lst_tab.
    ENDLOOP.
  ENDIF.

ENDFORM.                    " IMPTT_EXPLODE_FOR_MPLA

*Selection text£º
*PD_DATE:D       .
*PD_EVER:D       .
*PD_INACT:D       .
*PD_LG_CF:D       .
*PD_LG_MP:D       .
*PD_LG_ST:D       .
*PD_RV:D       .
*PT_POINT:D       .
