************************************************************************
*----------------------------------------------------------------------*
* Change history of ALV Development
* Program description : FI Consistency check.
* Author: VIJAY JOGLEKAR (C5053256)
* Short description of the program:
*    - FI consistency check.
*    - Conversion done using : REUSE_ALV_LIST_DISPLAY, Append ALV.
*    - Program Start Date    : 29-Mar-2004.
*              End   Date    : 19-Apr-2004.
*----------------------------------------------------------------------*
************************************************************************
REPORT zrfindex MESSAGE-ID fb LINE-SIZE 160 NO STANDARD PAGE HEADING.
*ENHANCEMENT-POINT RFINDEX_G4 SPOTS ES_RFINDEX STATIC.
*ENHANCEMENT-POINT RFINDEX_G5 SPOTS ES_RFINDEX.
*ENHANCEMENT-POINT RFINDEX_G6 SPOTS ES_RFINDEX STATIC.
*ENHANCEMENT-POINT RFINDEX_G7 SPOTS ES_RFINDEX.
************************************************************************
* SET EXTENDED CHECK OFF.
TABLES: bkpf, bseg, bsis, bsas, bsid, bsad, bsik, bsak, t001, skb1,
        lfb1, knb1, rfblg, t009, glt0, knc1, lfc1, knc3, lfc3,
        t030, trdir, bsim.

************************************************************************
*                         RFINDEX aus ALR
*                          02.03.2000
*                        by Rainer Soltek                              *
*                       SAP Release >= 4.0 (3.1)                       *
************************************************************************
*      Please make the following adjustments if necessary:
*      Release 3.0*:
*   !  Try to compile and if it doesn't work
*      Insert/delete Coding blocks marked with '3.0' and '4.0'
*      Reason: In 3.0 there's no field Bseg-xnegp
*      Release <= 4.0:
*   !  Insert/Delete Coding blocks marked with '4.0'
*       and try to compile them.

************************************************************************
*      General restrictions:
*    -Fixpoint arithmetic in the reports attributes must be switched off
*    -Don't forget to copy text-elements otherwise compiling errors    *
*     may occur                                                        *
************************************************************************
*                Types Variables and Constants                         *
************************************************************************
*      ------------  declare types here  ---------------

* ----- begin of delete block <= 4.0 -----
DATA: huge_amount TYPE wertv13.             " <-- insert asteric 4.0
* ------ end of delete block <= 4.0 ------
* ----- begin of insert block <= 4.0 -----
*   data: huge_amount LIKE RGVALUE-WERTV10.   " <-- remove asteric 4.0
* ------ end of insert block <= 4.0 ------
* ******************************************************************** *
TYPES:
*      Used for internal SKB1, must be read for any new companycode.
       BEGIN OF ty_skb1,
          saknr LIKE skb1-saknr,
          xopvw LIKE skb1-xopvw,
          xkres LIKE skb1-xkres,
          mitkz LIKE skb1-mitkz,
          xbilk LIKE ska1-xbilk,
          gvtyp LIKE ska1-gvtyp,
          zuawa LIKE skb1-zuawa,
          xsalh LIKE skb1-xsalh,
          wmeth LIKE skb1-wmeth,
       END OF ty_skb1,
*      Used for internal KNB1, must be read for any new companycode.
       BEGIN OF ty_knb1,
         kunnr LIKE bseg-kunnr,
       END OF ty_knb1,
*      Used for internal LFB1, must be read for any new companycode.
       BEGIN OF ty_lfb1,
         lifnr LIKE bseg-lifnr,
       END OF ty_lfb1,
*      Used for Period/Postingdate scheck.
       BEGIN OF ty_monat,
          gjahr LIKE bkpf-gjahr,
          monat LIKE bkpf-monat,
          fiday LIKE bkpf-budat,
          laday LIKE bkpf-budat,
       END OF ty_monat,
*      Used for Ty_error_log
       BEGIN OF tt_error,
          check  TYPE i,
          error  TYPE i,
          create TYPE i,
          delete TYPE i,
          update TYPE i,
          modify TYPE i,
          clear  TYPE i,
       END OF tt_error,
*      Used  for structured Error Output
       BEGIN OF ty_error_log,
          bsis TYPE tt_error,
          bsas TYPE tt_error,
          bsid TYPE tt_error,
          bsad TYPE tt_error,
          bsik TYPE tt_error,
          bsak TYPE tt_error,
          bseg TYPE tt_error,
          bkpf TYPE tt_error,
          bsim TYPE tt_error,
       END OF ty_error_log,
*      Used for Zero-balance check
       BEGIN OF ty_currency,
         dmbtr LIKE huge_amount, "glt0-hsl01,  "bseg-dmbtr,
         dmbe2 LIKE huge_amount, "  "bseg-dmbe2,
         dmbe3 LIKE huge_amount, "  "bseg-dmbe3,
         wrbtr LIKE huge_amount, "  "bseg-wrbtr,
       END OF ty_currency,
*      Used for Clearing check
       BEGIN OF ty_clear,
         koart LIKE bseg-bukrs,
         bukrs LIKE bseg-bukrs,
         konto LIKE bseg-hkont,
         hkont LIKE bseg-hkont,
         gsber LIKE bseg-gsber,
         umsks LIKE bseg-umsks,
         umskz LIKE bseg-umskz,
         augdt LIKE bseg-augdt,
         augbl LIKE bseg-augbl,
         pswsl LIKE bseg-pswsl,
         dmbtr LIKE huge_amount,
         dmbe2 LIKE huge_amount,
         dmbe3 LIKE huge_amount,
         pswbt LIKE huge_amount,
         arcnt TYPE i,
         ebseg TYPE i,
       END OF ty_clear,
*      Used for Clearing Check
       BEGIN OF ty_clear_sako,
*         hkont like bseg-hkont,
         gsber LIKE bseg-gsber,
         pswsl LIKE bseg-pswsl,
         augdt LIKE bseg-augdt,
         augbl LIKE bseg-augbl,
         dmbtr LIKE huge_amount,
         dmbe2 LIKE huge_amount,
         dmbe3 LIKE huge_amount,
         pswbt LIKE huge_amount,
         arcnt TYPE i,
         mbseg TYPE i,
         rbseg TYPE i,
       END OF ty_clear_sako,
*      Used for Clearing Check
       BEGIN OF ty_clear2,
         bstat LIKE bkpf-bstat,
         koart LIKE bseg-bukrs,
         bukrs LIKE bseg-bukrs,
         konto LIKE bseg-hkont,
         hkont LIKE bseg-hkont,
         kunnr LIKE bseg-kunnr,
         lifnr LIKE bseg-lifnr,
         gsber LIKE bseg-gsber,
         umsks LIKE bseg-umsks,
         umskz LIKE bseg-umskz,
         augdt LIKE bseg-augdt,
         augbl LIKE bseg-augbl,
         belnr LIKE bseg-belnr,
         gjahr LIKE bseg-gjahr,
         buzei LIKE bseg-buzei,
         pswsl LIKE bseg-pswsl,
         shkzg LIKE bseg-shkzg,
         dmbtr LIKE bseg-dmbtr,
         dmbe2 LIKE huge_amount,
         dmbe3 LIKE huge_amount,
         pswbt LIKE huge_amount,
         xarch LIKE bsis-xarch,
         arcnt TYPE i,
         ebseg TYPE i,
       END OF ty_clear2,
*      Used for Clearing Check
       BEGIN OF ty_clear3,
          ikey  TYPE ty_clear,
          ibseg TYPE ty_clear2,
          index TYPE ty_clear2,
       END OF ty_clear3,
*      Doc key fields
       BEGIN OF ty_beln,
         bukrs LIKE bseg-bukrs,
         belnr LIKE bseg-belnr,
         gjahr LIKE bseg-gjahr,
         ertxt(100) TYPE c,
       END OF ty_beln,
*      Used for Output of X_BSEG-Errors
       BEGIN OF ty_bsegerror,
         bukrs LIKE bseg-bukrs,
         belnr LIKE bseg-belnr,
         gjahr LIKE bseg-gjahr,
         buzei LIKE bseg-buzei,
         recon LIKE bseg-zuonr,
         konto LIKE bseg-hkont,
         estng(100) TYPE c,
         umsks LIKE bseg-umsks,
         umskz LIKE bseg-umskz,
         augdt LIKE bseg-augdt,
         augbl LIKE bseg-augbl,
         zuonr LIKE bseg-zuonr,
         dmbtr LIKE huge_amount,
         wrbtr LIKE huge_amount,
         pswbt LIKE huge_amount,
         zbseg LIKE bseg,
         ybseg LIKE bseg,
       END OF ty_bsegerror,
*      Used for Docs/Transaction Figures
       BEGIN OF ty_trans,
         accnt LIKE bseg-hkont,
         rldnr LIKE glt0-rldnr,
         shbkz LIKE knc3-shbkz,
         gsber LIKE bseg-gsber,
         gjahr LIKE bseg-gjahr,
         monat LIKE bkpf-monat,
         pswsl LIKE bseg-pswsl,
         tslsb LIKE huge_amount,
         hslsb LIKE huge_amount,
         kslsb LIKE huge_amount,
         tslhb LIKE huge_amount,
         hslhb LIKE huge_amount,
         kslhb LIKE huge_amount,
         tslsv LIKE huge_amount,
         hslsv LIKE huge_amount,
         kslsv LIKE huge_amount,
         tslhv LIKE huge_amount,
         hslhv LIKE huge_amount,
         kslhv LIKE huge_amount,
         tslsd LIKE huge_amount,
         hslsd LIKE huge_amount,
         kslsd LIKE huge_amount,
         tslhd LIKE huge_amount,
         hslhd LIKE huge_amount,
         kslhd LIKE huge_amount,
         iiale TYPE i,
       END OF ty_trans,
*      Used for Repair of Transaction Figures
       BEGIN OF ty_reptr,
         name  LIKE bseg-bukrs,
         bukrs LIKE bseg-bukrs,
         accnt LIKE bseg-hkont,
         rldnr LIKE glt0-rldnr,
         shbkz LIKE knc3-shbkz,
         gsber LIKE bseg-gsber,
         gjahr LIKE bseg-gjahr,
         monat LIKE bkpf-monat,
         shkzg LIKE bseg-shkzg,
         pswsl LIKE bseg-pswsl,
         delta LIKE huge_amount,
         rpmax LIKE glt0-rpmax,
       END OF ty_reptr,
*      Association of Bseg-dmbe2/3 and Ledger
       BEGIN OF ty_curtab,
         rldnr LIKE glt0-rldnr,
         usetsl TYPE i,
         usehsl TYPE i,
         useksl TYPE i,
         map1 TYPE i,
         map2 TYPE i,
         map3 TYPE i,
         curr1 LIKE t882-curr1,
         curr2 LIKE t882-curr2,
         curt1 LIKE t001a-curtp,
         curt2 LIKE t001a-curtp,
       END OF ty_curtab,
       BEGIN OF ty_f070_bseg,
        shkzg LIKE bseg-shkzg,
*       ----- Begin of delete block <= 3.0 -----
        xnegp LIKE bseg-xnegp,    " <-- insert asteric  3.0
*       ------ end of delete block <= 3.0 ------
        umskz LIKE bseg-umskz,
        xumsw LIKE bseg-xumsw,
        koart LIKE bseg-koart,
        pswsl LIKE bseg-pswsl,
        gsber LIKE bseg-gsber,
        hkont LIKE bseg-hkont,
        kunnr LIKE bseg-kunnr,
        lifnr LIKE bseg-lifnr,
        pswbt LIKE bseg-pswbt,
        wrbtr LIKE bseg-wrbtr,
        dmbtr LIKE bseg-dmbtr,
        dmbe2 LIKE bseg-dmbe2,
        dmbe3 LIKE bseg-dmbe3,
       END OF ty_f070_bseg,
       BEGIN OF ty_f070_bkpf,
        belnr LIKE bkpf-belnr,
        gjahr LIKE bkpf-gjahr,
        cpudt LIKE bkpf-cpudt,
        cputm LIKE bkpf-cputm,
        monat LIKE bkpf-monat,
        bukrs LIKE bkpf-bukrs,
       END OF ty_f070_bkpf,
      BEGIN OF ty_bsxx,
        gjahr LIKE bsis-gjahr,
        accnt LIKE bsis-hkont,
        umskz LIKE bsik-umskz,
        gsber LIKE bsis-gsber,
        shkzg LIKE bsis-shkzg,
        bschl LIKE bsis-bschl,
        monat LIKE bsis-monat,
        pswsl LIKE bsis-pswsl,
        xnegp LIKE bsis-xnegp,
        xumsw LIKE bseg-xumsw,
        pswbt LIKE huge_amount,
        dmbtr LIKE huge_amount,
        dmbe2 LIKE huge_amount,
        dmbe3 LIKE huge_amount,
        iiale TYPE i,
      END OF ty_bsxx,
      BEGIN OF ty_err_f190,
        koart LIKE bseg-koart,
        accnt LIKE bseg-hkont,
        ermsg(50) TYPE c,
      END OF ty_err_f190,
      BEGIN OF ty_ops,
       accnt LIKE bseg-hkont,
       umskz LIKE bseg-umskz,
       hkont LIKE bseg-hkont,
       dmbtr LIKE huge_amount,
       iiale TYPE i,
       END OF ty_ops,
      BEGIN OF ty_waers,
        hw1 LIKE bkpf-waers,
        hw2 LIKE bkpf-waers,
        hw3 LIKE bkpf-waers,
      END OF ty_waers.
* cb
* interne tabelle f¨¹r das hervorheben der wichtigsten felder
* f¨¹r die verschiedenen optionen (X_BSEG etc.)

DATA: BEGIN OF i_highlight OCCURS 100,
      choice(10),
      dyn_field(10),
      END OF i_highlight.

* interne tabelle in der alle angew#hlten optionen gespeichert
* werden
DATA : BEGIN OF choice_tab OCCURS 10,
       choice(10),
       END OF choice_tab.
*cb

************************************************************************
*    -------------------     Constants   ------------------------      *
CONSTANTS:
      true TYPE i VALUE 1,
      false TYPE i VALUE 0,
      c_progress_small TYPE i VALUE 100,
      c_progress_large TYPE i VALUE 1000,
      e_index_ok TYPE i VALUE 0,
      e_index_zuonr TYPE i VALUE 1,
      e_index_noindex TYPE i VALUE 4,
      c_max TYPE i VALUE 1000,
      c_init_accnt_no LIKE bseg-hkont VALUE 'ASDWQAS'.

************************************************************************
*      --------------   Define global data here  -------------------   *
DATA:
      c_f070(9) TYPE c,
      c_f190(9) TYPE c,
      c_fbila(9) TYPE c,
      it001 LIKE t001 OCCURS 20 WITH HEADER LINE,  " <-- Buchungskreise
      itbsl LIKE tbsl OCCURS 20 WITH HEADER LINE,  " <-- Posting Keys
      no_ty_bsegerror TYPE ty_bsegerror,"<-- Dummyvariable f¨¹r structure
      tmonat TYPE ty_monat OCCURS 10 WITH HEADER LINE, "#EC NEEDED " <-- Periodenver
      no_ty_clear TYPE ty_clear, "#EC NEEDED " <-- DUMMYVARIABLE F#R STRUCTURE ...
      no_ty_clear3 TYPE ty_clear3, "#EC NEEDED " <-- DUMMYVARIABLE F#R STRUCTURE ...
      no_ty_ops TYPE ty_ops OCCURS 0 WITH HEADER LINE,      "#EC NEEDED
      bseg_written TYPE i VALUE 0, " <-- Hilfsvariable f¨¹r Listausgabe
      account_written,  " <-- Hilfsvariable f¨¹r Listausgabe
      expert, " <-- Expertenmodus
      h_clear TYPE ty_clear, " <-- Hidebereich f¨¹r Ausgleichsvorg#nge
      h_beln TYPE ty_beln, " <--  Hidebereich f¨¹r Call Tr. FB03
      h_beln2 TYPE ty_beln, " <--  Hidebereich f¨¹r Call Tr. FB03
      no_skb1 TYPE ty_skb1, " <-- DUMMYVARIABLE F#R STRUCTURE ...
      no_knb1 TYPE ty_knb1, " <-- DUMMYVARIABLE F#R STRUCTURE ...
      no_lfb1 TYPE ty_lfb1, " <-- DUMMYVARIABLE F#R STRUCTURE ...
      no_curtab TYPE ty_curtab,  " <-- DUMMYVARIABLE F#R STRUCTURE ...
      no_err_f190 TYPE ty_err_f190 OCCURS 0 WITH HEADER LINE, "#EC NEEDED
*      tcurtab type ty_curtab occurs 0 with header line,
      string100(100), " <-- Dummyvariable f¨¹r like
      odd TYPE i,
      starttime LIKE sy-uzeit,
      startdate LIKE sy-datum,
      tvz TYPE ty_trans OCCURS 0 WITH HEADER LINE, "#EC NEEDED " <-- Dummy f. VZ
      tdelta TYPE ty_reptr OCCURS 0 WITH HEADER LINE, "<-- Rep. VZ
      excute_tr TYPE i,
      tab_name_input LIKE dd02l-tabname OCCURS 10 WITH HEADER LINE, "#EC NEEDED
      no_clear_sako TYPE ty_clear_sako,                     "#EC NEEDED
      gd_glt0_update_allowed TYPE char1,
      gd_fagl_functions_present TYPE char1.
* -------------------------------------------------------------------- *
** BEGIN of CHANGES                                           C5053256
* -------------------------------------------------------------------- *
** Output table declaration for the List.
c_f070 = 'Belege'(336).
c_f190 = 'Indices'(003).
c_fbila = 'Saldo'(341).
TYPE-POOLS : slis, kkblo.
DATA: gd_ok_code          LIKE  sy-ucomm.
*
DATA: gt_outtab_list1 TYPE STANDARD TABLE OF fagl_s_rfindex_list1
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gs_outtab_list1 TYPE fagl_s_rfindex_list1.
*
DATA: gt_outtab_list2 TYPE STANDARD TABLE OF fagl_s_rfindex_list2
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gs_outtab_list2 TYPE fagl_s_rfindex_list2.
*
DATA: gt_outtab_list3 TYPE STANDARD TABLE OF fagl_s_rfindex_list1
               INITIAL SIZE 0 WITH HEADER LINE.             "#EC NEEDED
*
DATA: gs_outtab_list3 TYPE fagl_s_rfindex_list1.
*
DATA: gt_outtab_list4 TYPE STANDARD TABLE OF fagl_s_rfindex_list2
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gs_outtab_list4 TYPE fagl_s_rfindex_list2.
*
DATA: gt_outtab_doc1  TYPE STANDARD TABLE OF fagl_s_rfindex_doc_list1
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gs_outtab_doc1  TYPE  fagl_s_rfindex_doc_list1.
*
DATA: gt_outtab_doc2  TYPE STANDARD TABLE OF fagl_s_rfindex_doc_list2
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gs_outtab_doc2  TYPE  fagl_s_rfindex_doc_list2.
*
DATA: gs_outtab_list11 TYPE fagl_s_rfindex_list1.
*
DATA: gs_outtab_list12 TYPE fagl_s_rfindex_list1.
*
DATA: gs_outtab_list21 TYPE fagl_s_rfindex_list1.
*
DATA: gs_outtab_list22 TYPE fagl_s_rfindex_doc_list2.
*
DATA: gs_outtab_list23 TYPE fagl_s_rfindex_list1.
*
DATA: gs_outtab_list24 TYPE fagl_s_rfindex_list2.
*
DATA: gs_outtab_list25 TYPE fagl_s_rfindex_list1.
*
DATA: gs_outtab_list29 TYPE fagl_s_rfindex_doc_list3.
*
DATA: gt_outtab_list11 TYPE STANDARD TABLE OF fagl_s_rfindex_list1
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list12 TYPE STANDARD TABLE OF fagl_s_rfindex_list1
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list21 TYPE STANDARD TABLE OF fagl_s_rfindex_list1
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list22 TYPE STANDARD TABLE OF fagl_s_rfindex_doc_list2
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list23 TYPE STANDARD TABLE OF fagl_s_rfindex_list1
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list24 TYPE STANDARD TABLE OF fagl_s_rfindex_list2
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list25 TYPE STANDARD TABLE OF fagl_s_rfindex_list1
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list26 TYPE STANDARD TABLE OF fagl_s_rfindex_list1
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list27 TYPE STANDARD TABLE OF fagl_s_rfindex_list1
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list28 TYPE STANDARD TABLE OF fagl_s_rfindex_list2
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_list29 TYPE STANDARD TABLE OF fagl_s_rfindex_doc_list3
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gt_outtab_doc3  TYPE STANDARD TABLE OF fagl_s_rfindex_doc_list3
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gs_outtab_doc3  TYPE  fagl_s_rfindex_doc_list3.
*
DATA: gt_outtab_doc4  TYPE STANDARD TABLE OF fagl_s_rfindex_doc_list4
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gs_outtab_doc4  TYPE  fagl_s_rfindex_doc_list4.
*
DATA: gt_outtab_summ1 TYPE STANDARD TABLE OF fagl_s_rfindex_list_summ
               INITIAL SIZE 0 WITH HEADER LINE.
*
DATA: gs_outtab_summ1 TYPE fagl_s_rfindex_list_summ.
*
DATA: BEGIN OF gt_outtab_led OCCURS 10,
      led_bukrs TYPE  bukrs,
      led_desc  TYPE  char80,
      END OF gt_outtab_led.
*
DATA: BEGIN OF gt_foot_line OCCURS 10,
      list_no      TYPE  i,
      line_print   TYPE  char80,
      END OF gt_foot_line.
*
DATA: gv_repid          TYPE syrepid VALUE sy-repid,   "Report ID
      gv_tabix          TYPE sy-tabix,                      "#EC NEEDED
      gv_counter_outtab TYPE i,
      gv_width          TYPE i,                             "#EC NEEDED
      gv_tab_lines      TYPE i,
      gv_first_list     TYPE c,
      gv_hkont          TYPE hkont,
      gv_table_cnt      TYPE i,
*
      gv_head(80)       TYPE c,
      gv_head_1(80)     TYPE c,
      gv_head_2(80)     TYPE c,                             "#EC NEEDED
*
      gv_head_line1(100) TYPE c,
      gv_head_line2(100) TYPE c,
      gv_head_line3(100) TYPE c,
      gv_head_line4(100) TYPE c,                            "#EC NEEDED
      gv_head_line5(100) TYPE c,                            "#EC NEEDED
      gv_head_line6(100) TYPE c,                            "#EC NEEDED
      gv_head_line7(100) TYPE c,                            "#EC NEEDED
      gv_head_line8(100) TYPE c,                            "#EC NEEDED
*
      gv_foot_line1(100) TYPE c,                            "#EC NEEDED
      gv_foot_line2(100) TYPE c,                            "#EC NEEDED
      gv_foot_line3(100) TYPE c,                            "#EC NEEDED
      gv_foot_line4(100) TYPE c,                            "#EC NEEDED
      gv_foot_line5(100) TYPE c,                            "#EC NEEDED
      gv_foot_line6(100) TYPE c,                            "#EC NEEDED
      gv_foot_line7(100) TYPE c,                            "#EC NEEDED
      gv_foot_line8(100) TYPE c,                            "#EC NEEDED
*
      gv_char_cnt1(10)  TYPE c,
      gv_char_cnt2(10)  TYPE c,
      gv_char_cnt3(10)  TYPE c,
      gv_tenth_cnt      TYPE c,
      gv_line_print     TYPE c,
      gv_print_stat     TYPE c,
      gv_execute(4)     TYPE c,
      gv_header         TYPE slis_tabname,
      gv_item           TYPE slis_tabname.
*
CONSTANTS:gc_checked(1)  TYPE c VALUE 'X',  "Constant for Checked val X
          gc_yes(1)      TYPE c VALUE 'Y',  "Constant for Checked val Y
          gc_save(1)     TYPE c VALUE 'X',  "#EC NEEDED  "Save Variant.
          gc_structure_list1 TYPE dd02l-tabname
                      VALUE 'FAGL_S_RFINDEX_LIST1',
          gc_structure_list2 TYPE dd02l-tabname
                      VALUE 'FAGL_S_RFINDEX_LIST2',
          gc_structure_list3 TYPE dd02l-tabname
                      VALUE 'FAGL_S_RFINDEX_DOC_LIST1',
          gc_structure_list4 TYPE dd02l-tabname
                      VALUE 'FAGL_S_RFINDEX_DOC_LIST2',
          gc_structure_list5 TYPE dd02l-tabname
                      VALUE 'FAGL_S_RFINDEX_DOC_LIST3',
          gc_structure_list6 TYPE dd02l-tabname
                      VALUE 'FAGL_S_RFINDEX_DOC_LIST4',
          gc_structure_summ  TYPE dd02l-tabname
                      VALUE 'FAGL_S_RFINDEX_LIST_SUMM',
          gc_pf_status    TYPE slis_formname
                          VALUE 'HANDLE_EVENT_PF_STATUS',
          gc_top_of_page  TYPE dd02l-tabname
                          VALUE 'TOP_OF_PAGE',
          gc_handle_top_of_page  TYPE dd02l-tabname
                          VALUE 'HANDLE_EVENT_TOP_OF_PAGE',
          gc_end_of_list  TYPE dd02l-tabname
                          VALUE 'END_OF_LIST',
          gc_handle_end_of_list TYPE dd02l-tabname
                          VALUE 'HANDLE_EVENT_END_OF_LIST',
          gc_after_line_output TYPE dd02l-tabname
                          VALUE 'HANDLE_AFTER_LINE_OUTPUT',
          gc_before_line_output TYPE dd02l-tabname
                          VALUE 'HANDLE_BEFORE_LINE_OUTPUT',
          gc_user_command TYPE slis_formname
                          VALUE 'HANDLE_EVENT_USER_COMMAND',
          gc_group_level_change TYPE dd02l-tabname
                          VALUE 'HANDLE_GROUP_LEVEL_CHANGE', "#EC NEEDED
          gc_first_list    TYPE i VALUE  1,   "Condition For First List
          gc_second_list   TYPE i VALUE  2,   "Condition For Second List
          gc_third_list    TYPE i VALUE  3,
          gc_forth_list    TYPE i VALUE  4,
          gc_fifth_list    TYPE i VALUE  5,
          gc_sixth_list    TYPE i VALUE  6,
          gc_seventh_list  TYPE i VALUE  7,
          gc_eighth_list   TYPE i VALUE  8,
          gc_ninenth_list  TYPE i VALUE  9,
          gc_tenth_list    TYPE i VALUE  10,
          gc_eleventh_list TYPE i VALUE  11,
          gc_twelvth_list  TYPE i VALUE  12,                "#EC NEEDED
          gc_12th_list     TYPE i VALUE  12,
          gc_13th_list     TYPE i VALUE  13,
          gc_14th_list     TYPE i VALUE  14,                "#EC NEEDED
          gc_15th_list     TYPE i VALUE  15,                "#EC NEEDED
          gc_16th_list     TYPE i VALUE  16,                "#EC NEEDED
          gc_17th_list     TYPE i VALUE  17,
          gc_23rd_list     TYPE i VALUE  23,
          gc_25th_list     TYPE i VALUE  25,
          gc_26th_list     TYPE i VALUE  26,
          gc_27th_list     TYPE i VALUE  27,
          gc_31st_list     TYPE i VALUE  31,
          gc_32nd_list     TYPE i VALUE  32,
          gc_33rd_list     TYPE i VALUE  33,
          gc_34th_list     TYPE i VALUE  34,
          gc_35th_list     TYPE i VALUE  35,
          gc_36th_list     TYPE i VALUE  36,
          gc_37th_list     TYPE i VALUE  37,
          gc_len132        TYPE i VALUE 150,  "Constant 132 Cols
          gc_header1       TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST1', "/ Header Table name
          gc_item1         TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST2', "/ Item Table Name
          gc_header_doc1   TYPE slis_tabname
                           VALUE 'GT_OUTTAB_DOC1', "/ Header Table name
          gc_item_doc1     TYPE slis_tabname
                           VALUE 'GT_OUTTAB_DOC2', "/ Item Table Name
          gc_header11      TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST11',
          gc_item12        TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST12',
          gc_header21      TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST21',
          gc_item22        TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST22',
          gc_header23      TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST23',
          gc_item24        TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST24',
          gc_header27      TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST27',
          gc_item28        TYPE slis_tabname
                           VALUE 'GT_OUTTAB_LIST28',
          gc_l             TYPE c VALUE 'L',
          gc_len140        TYPE i VALUE 140. "#EC NEEDED  "Constant 140 Cols

CONSTANTS: gc_handle1  TYPE slis_handl VALUE 'HAN1',        "#EC NEEDED
           gc_handle2  TYPE slis_handl VALUE 'HAN2'.        "#EC NEEDED
*...  End of New Definition For ALV.
* -------------------------------------------------------------------- *
** END of CHANGES                                             C5053256
* -------------------------------------------------------------------- *
************************************************************************
SELECTION-SCREEN BEGIN OF BLOCK a01 WITH FRAME TITLE text-002.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
PARAMETERS: x_bseg AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 4(20) text-010 FOR FIELD x_bseg.

SELECTION-SCREEN POSITION 25.
PARAMETERS: x_index AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 28(20) text-011 FOR FIELD x_index.

SELECTION-SCREEN POSITION 50.
PARAMETERS: x_rfblg AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 53(21) text-012 FOR FIELD x_rfblg.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.

SELECTION-SCREEN POSITION 1.
PARAMETERS: x_heade AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 4(20) text-013 FOR FIELD x_heade.

SELECTION-SCREEN POSITION 25.
PARAMETERS: x_clear AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 28(17) text-014 FOR FIELD x_clear.

SELECTION-SCREEN POSITION 50.
PARAMETERS: x_f070 AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 53(24) text-021 FOR FIELD x_f070.

SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.

SELECTION-SCREEN POSITION 1.
PARAMETERS: x_f190 AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 4(18) text-022 FOR FIELD x_f190.

SELECTION-SCREEN POSITION 25.
PARAMETERS: x_opdate AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 28(20) text-023 FOR FIELD x_opdate.

SELECTION-SCREEN POSITION 50.
PARAMETERS: x_duplic AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 53(23) text-024 FOR FIELD x_duplic.

SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
PARAMETERS: x_bila AS CHECKBOX MODIF ID kil.
SELECTION-SCREEN COMMENT 4(20) text-025 FOR FIELD x_bila.
SELECTION-SCREEN POSITION 25.
*    parameters: x_count no-display modif id kil.
*    selection-screen comment 28(20) text-026.

SELECTION-SCREEN END OF LINE.


SELECTION-SCREEN END OF BLOCK a01.

* check or Repair mode
SELECTION-SCREEN BEGIN OF BLOCK a05 WITH FRAME TITLE text-005.
PARAMETERS: repair AS CHECKBOX MODIF ID inc,
            x_delind AS CHECKBOX MODIF ID inc,
            x_delhd AS CHECKBOX MODIF ID inc,
            x_repvz AS CHECKBOX MODIF ID inc.
SELECTION-SCREEN END OF BLOCK a05.

* Protocoll details
SELECTION-SCREEN BEGIN OF BLOCK a07 WITH FRAME TITLE text-007.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
PARAMETERS: protox RADIOBUTTON GROUP a009 DEFAULT 'X'.
SELECTION-SCREEN COMMENT 3(17) text-015  FOR FIELD protox.
SELECTION-SCREEN POSITION 25.
PARAMETERS: protoc RADIOBUTTON GROUP a009.
SELECTION-SCREEN COMMENT 27(11) text-016 FOR FIELD protoc.
SELECTION-SCREEN POSITION 50.
PARAMETERS: protos RADIOBUTTON GROUP a009.
SELECTION-SCREEN COMMENT 52(19) text-017 FOR FIELD protos.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK a07.
SELECTION-SCREEN BEGIN OF BLOCK a02 WITH FRAME TITLE text-001.
SELECT-OPTIONS: p_bukrs FOR bseg-bukrs MEMORY ID buk,
                p_gjahr FOR bseg-gjahr MEMORY ID gjr,
                p_monat FOR bkpf-monat,
                p_budat FOR bkpf-budat,
                p_cpudt FOR bkpf-cpudt,
                p_waers FOR bkpf-waers,
                p_blart FOR bkpf-blart.

SELECTION-SCREEN END OF BLOCK a02.
* Check from bseg -> Index
SELECTION-SCREEN BEGIN OF BLOCK a03 WITH FRAME TITLE text-006.
SELECT-OPTIONS: p_belnr FOR bseg-belnr,
                p_xblnr FOR bkpf-xblnr.

SELECTION-SCREEN END OF BLOCK a03.
* Check from account to bseg
SELECTION-SCREEN BEGIN OF BLOCK a04 WITH FRAME TITLE text-004.
PARAMETERS x_sako AS CHECKBOX.
SELECT-OPTIONS p_hkont FOR skb1-saknr MEMORY ID sak.
PARAMETERS x_debi AS CHECKBOX.
SELECT-OPTIONS p_kunnr FOR knb1-kunnr MEMORY ID kun.
PARAMETERS x_kredi AS CHECKBOX.
SELECT-OPTIONS p_lifnr FOR lfb1-lifnr MEMORY ID lif.
PARAMETERS x_matnr AS CHECKBOX.
SELECT-OPTIONS p_matnr FOR bsim-matnr MEMORY ID mat.

SELECTION-SCREEN SKIP.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
PARAMETERS: p_any RADIOBUTTON GROUP a010 DEFAULT 'X'.
SELECTION-SCREEN COMMENT 3(11) text-018 FOR FIELD p_any.
SELECTION-SCREEN POSITION 25.
PARAMETERS: p_oi RADIOBUTTON GROUP a010.
SELECTION-SCREEN COMMENT 27(13) text-019 FOR FIELD p_oi.
SELECTION-SCREEN POSITION 50.
PARAMETERS: p_cl RADIOBUTTON GROUP a010.
SELECTION-SCREEN COMMENT 52(20) text-020 FOR FIELD p_cl.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK a04.
* for Clearing_check
SELECTION-SCREEN BEGIN OF BLOCK a08 WITH FRAME TITLE text-008.
SELECT-OPTIONS: p_augbl FOR bseg-augbl,
                p_augdt FOR bseg-augdt,
                p_gsber FOR bseg-gsber,
                p_pswsl FOR bseg-pswsl,
                p_umsks FOR bseg-umsks,
                p_umskz FOR bseg-umskz.
PARAMETERS: c_bseg AS CHECKBOX.
SELECTION-SCREEN END OF BLOCK a08.
INCLUDE rfindex_sched.

* -------------------------------------------------------------------- *
* macro for highlightening of screen-fields
* s. initialization event.
* -------------------------------------------------------------------- *
DEFINE highlight.

  i_highlight-choice = '&1'.     " ausgew#hlte option
* -----------------------
  i_highlight-dyn_field = '&2'.   " 1. relevantes feld
  append i_highlight .
  i_highlight-dyn_field = '&3'.
  append i_highlight .
  i_highlight-dyn_field = '&4'.
  append i_highlight .
  i_highlight-dyn_field = '&5'.   " 4. relevantes feld
  append i_highlight .

END-OF-DEFINITION.


* -------------------------------------------------------------------- *
*                            Events                                    *
* -------------------------------------------------------------------- *
* -------------------------------------------------------------------- *
*                            Initialization                            *
* -------------------------------------------------------------------- *

* cb
INITIALIZATION.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
  gv_repid = sy-repid.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
  SELECT SINGLE * FROM trdir WHERE name = sy-repid.
  IF sy-subrc = 0.
    IF trdir-fixpt = 'X'.
*       clear trdir-FIXPT.
*       update trdir.
*       commit work.
      MESSAGE a000 WITH 'Festpunktarithmetik mu# deaktiviert werden'(384).
      EXIT.
    ENDIF.
  ENDIF.

* aufruf des makros 'highlight':
* highlight 'FLAG' '1. relevantes Feld' ... '4. relevantes Feld'
* immer nur 4 relevante Felder angeben, Rest mit P_DUMMY auff¨¹llen !
* makro eventuell #fters aufrufen !
*
* das makro muss f¨¹r alle optionen aufgerufen werden die
* die funktionalit#t des hervorhebens haben sollen.
* ausserdem muss die routine 'MAKE_YOUR_CHOICE' angepasst werden.

  highlight x_bseg p_bukrs p_belnr p_gjahr p_monat.
  highlight x_bseg p_debi p_kredi p_sako p_budat.
  highlight x_bseg p_cpudt p_waers p_xblnr p_xblnr.
  highlight x_bseg p_blart p_dummy p_dummy p_dummy.

  highlight x_f190 p_bukrs p_gjahr p_monat p_sako.
  highlight x_f190 p_debi p_kredi p_dummy p_dummy.

  highlight x_f070 p_bukrs p_gjahr p_monat p_sako.
  highlight x_f070 p_debi p_kredi p_dummy p_dummy.

  highlight x_bila p_bukrs p_gjahr p_monat p_sako.
  highlight x_bila p_debi p_kredi p_dummy p_dummy.

  highlight x_index p_bukrs p_gjahr p_monat p_sako.
  highlight x_index p_debi p_kredi p_belnr p_dummy.

  highlight x_opdate p_bukrs p_gjahr p_monat p_dummy.
  highlight x_opdate p_sako p_debi p_kredi p_dummy.

  highlight x_rfblg p_bukrs p_gjahr p_belnr p_dummy.

  highlight x_heade p_bukrs p_gjahr p_belnr p_xblnr.
  highlight x_heade p_monat p_budat p_cpudt p_waers.
  highlight x_heade p_blart  p_dummy p_dummy p_dummy.

  highlight x_clear p_sako p_debi p_kredi c_bseg.
  highlight x_clear p_bukrs p_gsber p_pswsl p_dummy.
  highlight x_clear p_augbl p_augdt p_umsks p_umskz.

  highlight x_duplic p_bukrs p_gjahr p_monat p_sako.
  highlight x_duplic p_debi p_kredi p_belnr p_dummy.

  SORT i_highlight BY choice.

* die routine 'MAKE_YOUR_CHOICE' muss angepasst werden !
* nicht vergessen !

*cb

************************************************************************
* ----------------- AT SELECTION-SCREEN OUTPUT ----------------------- *
************************************************************************
AT SELECTION-SCREEN OUTPUT.
  LOOP AT SCREEN.
    IF screen-group1 = 'INC'.
    expert = 1.
      IF expert = true.
        screen-invisible = false.
      ELSE.
*              clear repair.
*              clear x_repvz.
*              clear x_delhd.
*              clear x_delind.
        screen-invisible = true.
      ENDIF.
      MODIFY SCREEN.
    ENDIF.
*----------------------------------------------------------
* cb  logik f¨¹r das hervorheben relevanter eingabefelder
*----------------------------------------------------------
* 'normale' darstellung einschalten f¨¹r alle felder...
    screen-intensified = false.
    screen-display_3d =  false.
    MODIFY SCREEN.

    LOOP AT choice_tab.        " interne tabelle in der alle optionen
      " (x_bseg etc. ) gespeichert werden.
      LOOP AT i_highlight WHERE choice EQ choice_tab-choice.
        IF screen-name CS i_highlight-dyn_field.
*     'besondere' darstellung ein !
*      funktioniert nicht f¨¹r checkboxes und radiobuttons....
          screen-display_3d = true.
          screen-intensified = true.
          MODIFY SCREEN.     " nicht vergessen !
        ENDIF.
      ENDLOOP. " of loop at i_highlight.
    ENDLOOP. " of loop at choice_tab.
*----------------------------------------------------------------
* cb  ende der logik f¨¹r das hervorheben relevanter eingabefelder
*----------------------------------------------------------------
* cb
  ENDLOOP.

AT SELECTION-SCREEN ON p_bukrs.
  SELECT SINGLE bukrs INTO t001-bukrs FROM t001 WHERE bukrs IN p_bukrs. "#EC *
  IF sy-subrc NE 0.
    MESSAGE e000 WITH 'Buchungskreis existiert nicht'(385).
  ENDIF.

************************************************************************
* ------------------ AT LINE-SELECTION ------------------------------- *
************************************************************************
** BEGIN OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
**AT LINE-SELECTION.
**  CLEAR h_clear.
**  CLEAR h_beln2.
**  CLEAR excute_tr.
**  CASE sy-lsind.
**    WHEN 1.
**      READ LINE sy-lilli INDEX sy-listi.
**      PERFORM line_selection_1.
**    WHEN 2.
**      PERFORM line_selection_2.
**  ENDCASE.
**--------------------------------------------------------------------**
** END OF CHANGES                                               C5053256
************************************************************************
* ----------------- AT SELECTION-SCREEN ------------------------------ *
************************************************************************
AT SELECTION-SCREEN.
  PERFORM set_expert CHANGING expert.
* cb
  PERFORM make_your_choice.
  PERFORM check_flags.
  PERFORM authority_check.
* cb
************************************************************************
* ----------------- AT START-OF-SELECTION ---------------------------- *
* ---------------- (Start of main program) --------------------------- *
************************************************************************
START-OF-SELECTION.
* -------------------------------------------------------------------- *
*                    Check repair flags
* -------------------------------------------------------------------- *
  PERFORM set_properties_fagl.


  DATA ret TYPE i.
  PERFORM want_repair CHANGING ret.
  IF ret = false.
    EXIT.
  ENDIF.
  GET TIME.
  starttime = sy-uzeit.
  startdate = sy-datum.
* -------------------------------------------------------------------- *
*               Fill Company code table (IT001)                        *
* -------------------------------------------------------------------- *
  PERFORM fill_it001.
*  PERFORM CHECK_AUTHORITY_IT001 CHANGING RET.
*  IF RET = FALSE.
*    EXIT.
*  ENDIF.

* Start_off
* -------------------------------------------------------------------- *
*                  Check from BSEG to Account
* -------------------------------------------------------------------- *
* Schedman #ffnen
  PERFORM scm_init.
  PERFORM clear_alv_tables.
  perform authority_check.
  IF x_bseg = 'X' OR x_heade = 'X'.
**--------------------------------------------------------------------**
**  BEGIN OF CHANES                                             C505325
**--------------------------------------------------------------------**
**  The Logic for execution of the List(option wise) changes.
**  As the next list is to be called in the end_of_list of the
**  Previous list.  The changes for ALV Conversio are marked by >>**<<
**    PERFORM bseg_vs_index.
    gv_counter_outtab = gc_first_list.
    PERFORM flow_logic_for_alv.
  ENDIF.
* -------------------------------------------------------------------- *
*                  Check from Account to BSEG                          *
* -------------------------------------------------------------------- *
**  IF x_index = 'X'.
**    PERFORM index_vs_bseg.
  IF x_index = 'X' AND gv_counter_outtab IS INITIAL.
    MOVE  gc_third_list   TO gv_counter_outtab.
    PERFORM flow_logic_for_alv.
  ENDIF.
* -------------------------------------------------------------------- *
*                  Check from RFBLG to BKPF                            *
* -------------------------------------------------------------------- *
  IF x_rfblg = 'X' AND gv_counter_outtab IS INITIAL.
**  IF x_rfblg = 'X'.
**    IF  sy-dbsys NE 'ORACLE' OR sy-saprl LE '31I'.
**      PERFORM rfblg_vs_bkpf.
**    ELSE.
**      PERFORM rfblg_vs_bkpf_fast.
**    ENDIF.
    gv_counter_outtab = gc_17th_list.
    PERFORM flow_logic_for_alv.
  ENDIF.
* -------------------------------------------------------------------- *
*                  Check Clearings                                     *
* -------------------------------------------------------------------- *
  IF x_clear = 'X' AND gv_counter_outtab IS INITIAL.
**    PERFORM clearing_check.
    gv_counter_outtab = gc_sixth_list.
    PERFORM flow_logic_for_alv.
  ENDIF.
* -------------------------------------------------------------------- *
*                  Check Bseg - Transaction Figures                    *
* -------------------------------------------------------------------- *
  IF x_f070 = 'X' AND gv_counter_outtab IS INITIAL.
**    PERFORM f070.
    gv_counter_outtab = gc_eighth_list.
    PERFORM flow_logic_for_alv.
  ENDIF.
* -------------------------------------------------------------------- *
*                  Check Index - Transaction Figures                   *
* -------------------------------------------------------------------- *
  IF x_f190 = 'X' AND gv_counter_outtab IS INITIAL.
**    PERFORM f190.
    gv_counter_outtab = gc_eleventh_list.
    PERFORM flow_logic_for_alv.
  ENDIF.
* -------------------------------------------------------------------- *
*                  Check Open items at date                            *
* -------------------------------------------------------------------- *
  IF x_opdate = 'X' AND gv_counter_outtab IS INITIAL.
**    PERFORM offene_posten.
    gv_counter_outtab = gc_31st_list.
    PERFORM flow_logic_for_alv.
  ENDIF.
* -------------------------------------------------------------------- *
*                  Find duplicate Indexes                              *
* -------------------------------------------------------------------- *
  IF x_duplic = 'X' AND gv_counter_outtab IS INITIAL.
**    PERFORM duplicate_indexes.
    gv_counter_outtab = gc_23rd_list.
    PERFORM flow_logic_for_alv.
  ENDIF.
* -------------------------------------------------------------------- *
* Check Balance and find missing account master data
* -------------------------------------------------------------------- *
  IF x_bila = 'X' AND gv_counter_outtab IS INITIAL.
**    PERFORM fbila.
    gv_counter_outtab = gc_25th_list.
    PERFORM flow_logic_for_alv.
  ENDIF.
**--------------------------------------------------------------------**
** END OF CHANGES                                               C5053256
**--------------------------------------------------------------------**
* Schedman beenden
  PERFORM scm_close.
* -------------------------------------------------------------------- *
* Count table entries (BKPF, RFBLG, BSIS, BSAS, BSID, BSAD, BSIK, BSAK)
* -------------------------------------------------------------------- *
* if x_count = 'X'.
*   perform count_table_entries.
* endif.

**------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
** ------------------------------------------------------------------
**                  Finally write program runtime
** ------------------------------------------------------------------
**
**  GET TIME.
**  NEW-LINE.
**  ULINE (35).
**  WRITE:/ sy-vline, (11) 'Started at', startdate, starttime, sy-vline.
**  WRITE:/ sy-vline, (11) 'Stopped at', sy-datum, sy-uzeit, sy-vline.
**  starttime = sy-uzeit - starttime.
**  startdate = sy-datum - startdate.
**  WRITE:/ sy-vline, (11) 'Runtime', startdate, starttime, sy-vline.
**  NEW-LINE.
**  ULINE (35).
**
**********************************************************************
** END OF CHANGES                                             C5053256
**------------------------------------------------------------------**
*                  End of main program                                 *
* **********************************************************************
* -------------------------------------------------------------------- *
*      Makro to append Errorstatements Index -> Bseg                   *
* -------------------------------------------------------------------- *
  DEFINE append_error.
    if error_line is initial.
      concatenate
        error_line
        &1
        into error_line separated by space.
    else.
      concatenate
        error_line
        &1
        into error_line separated by ', '.
    endif.
  END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*              6 help makros to increase counts                        *
* -------------------------------------------------------------------- *
  DEFINE add_any.
    if name = 'BSIS'.
      add 1 to p_error_log-bsis-&1.
    elseif name = 'BSAS'.
      add 1 to p_error_log-bsas-&1.
    elseif name = 'BSID'.
      add 1 to p_error_log-bsid-&1.
    elseif name = 'BSAD'.
      add 1 to p_error_log-bsad-&1.
    elseif name = 'BSIK'.
      add 1 to p_error_log-bsik-&1.
    elseif name = 'BSAK'.
      add 1 to p_error_log-bsak-&1.
    elseif name = 'BSEG'.
      add 1 to p_error_log-bseg-&1.
    elseif name = 'BKPF'.
      add 1 to p_error_log-bkpf-&1.
    elseif name = 'BSIM'.
      add 1 to p_error_log-bsim-&1.

    endif.
  END-OF-DEFINITION.
  DEFINE add_check.
    add_any check.
  END-OF-DEFINITION.
  DEFINE add_error.
    add_any error.
  END-OF-DEFINITION.
  DEFINE add_delete.
    add_any delete.
  END-OF-DEFINITION.
  DEFINE add_insert.
    add_any create.
  END-OF-DEFINITION.
  DEFINE add_update.
    add_any update.
  END-OF-DEFINITION.
  DEFINE add_modify.
    add_any modify.
  END-OF-DEFINITION.

* ----------------------------------------------------------------------
*     Makro to compare single BSEG-fields with Index-fields
* ----------------------------------------------------------------------
  DEFINE compare_single.
    if bseg-&1 <> p_index-&1.
      append_error '&1'.
      p_state = 'X'.
    endif.
  END-OF-DEFINITION.

* ----------------------------------------------------------------------
*     Makro to compare single BKPF-fields with Index-fields
* ----------------------------------------------------------------------
  DEFINE compare__single.
    if b_kopf-&1 <> p_kopf-&1.
      append_error '&1'.
      if p_state is initial.
        p_state = 'X'.
      endif.
    endif.
  END-OF-DEFINITION.

* ----------------------------------------------------------------------
*     Makro to compare two fields
* ----------------------------------------------------------------------
  DEFINE compare_double.
    if &1 <> &2.
      append_error '&1 <> &2'.
      if p_state is initial.
        p_state = 'X'.
      endif.
    endif.
  END-OF-DEFINITION.
* -------------------------------------------------------------------- *
*                       Index change.                                  *
* -------------------------------------------------------------------- *
  DEFINE index_change.
    data str_&1&3 like string100.
    &1 (&2) from &3.
    if sy-subrc = 0.
      concatenate '&1_' &2 into str_&1&3.
      append_error str_&1&3.
      add_&1.
    else.
      concatenate '&1_' &2 '_FAILED' into str_&1&3.
      append_error str_&1&3.
    endif.
  END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*                       Index insert.                                  *
* -------------------------------------------------------------------- *
  DEFINE index_insert.
    index_change insert &1 &2.
  END-OF-DEFINITION.
* -------------------------------------------------------------------- *
*                       Index delete.                                  *
* -------------------------------------------------------------------- *
  DEFINE index_delete.
    index_change delete &1 &2.
  END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*                       Index update.                                  *
* -------------------------------------------------------------------- *
  DEFINE index_update.
    index_change update &1 &2.
  END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*                       Index modify.                                  *
* -------------------------------------------------------------------- *
  DEFINE index_modify.
    index_change modify &1 &2.
  END-OF-DEFINITION.


* -------------------------------------------------------------------- *
*    Makro/Perf to output a line at 'Find missing header' (X_heade)    *
* -------------------------------------------------------------------- *
*  DEFINE write_error_x_heade.
*    if &4 = false.
*      uline (100).
*      write:/ '|',
*          (20) &1 color col_key no-gap,
*          (76) ' ' color col_key intensified off no-gap,
*          100 '|'.
*      &4 = true.
*    endif.
*    write:/ '|',
*           (20) &2 color col_normal no-gap.
*    write: (1) ' ' color col_normal intensified off no-gap,
*           (75) &3 color col_normal intensified off no-gap,
*          100 '|'.
*
*  END-OF-DEFINITION.
* -------------------------------------------------------------------- *
*                  Find duplicate Indexes (cb)
* -------------------------------------------------------------------- *
  DEFINE find_duplicate_index.
    data: accnt like bseg-hkont,
          odd type i value 1,
          dbcnt like sy-dbcnt,
          acctyp(9) type c,
          msg like string100.
    if '&1' = 'S'.
      acctyp = 'Sachkonto'(040).
    elseif '&1' = 'D'.
      acctyp = 'Kunde'(042).
    elseif '&1' = 'K'.
      acctyp = 'Lieferant'(043).
    endif.
* &1    'K'      'S'     'D'      account type
* &2  'LIFNR'  'HKONT'  'KUNNR'
**** &3  'KREDI'  'SAKO'   'DEBI'  (corresponding to &2)

    select  bsi&1~bukrs bsi&1~belnr  bsi&1~gjahr bsi&1~buzei bsi&1~&2
* hier muss bsi&1-&2 mit '~' stehen ! (Tile = DB-Feld)
               into (bsi&1-bukrs, bsi&1-belnr, bsi&1-gjahr, bsi&1-buzei,
                       bsi&1-&2  )
* hier muss bsi&1-&2 mit '-' stehen ! (Bindestrich = WORKAREA)
                       from bsi&1 inner join bsa&1 on
                       bsi&1~bukrs = bsa&1~bukrs and
                    bsi&1~&2    = bsa&1~&2    and  " hkont, lifnr, kunnr
                       bsi&1~gjahr = bsa&1~gjahr and
                       bsi&1~belnr = bsa&1~belnr and
                       bsi&1~buzei = bsa&1~buzei
                       where bsi&1~bukrs  in p_bukrs and
                             bsi&1~&2    in  p_&2    and
                             bsi&1~belnr in  p_belnr and
                             bsi&1~gjahr in  p_gjahr and
                             bsi&1~monat in  p_monat.
      perform execute_progress using sy-dbcnt '&2' .
* Bemerkung: beim left inner join ist vollkommen egal wo die bedingungen
* stehen, in der where klausel oder in der join-bedingung !!
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                      C5053256
**--------------------------------------------------------------------**
*      clear : gs_outtab_list1, gt_outtab_list1.
**--------------------------------------------------------------------**
** END   OF CHANGES                                      C5053256
**--------------------------------------------------------------------**
      if sy-dbcnt = 1.
        concatenate 'im Vergleich'(107) 'BSI&1' 'vs'(110) 'BSA&1' into msg separated by space.
        move msg to gs_outtab_list1-err_msg.
**        perform write_dbl_index_header using msg.
**--------------------------------------------------------------------**
** END   OF CHANGES                                      C5053256
**--------------------------------------------------------------------**
      endif.
      if accnt ne bsi&1-&2.
        if dbcnt > 0.
**-------------------------------------------------------------------**
** BEGIN OF CHANGES                                       C5053256
**-------------------------------------------------------------------**
**          format color col_total.
**          format intensified on.
**
**          write:/ sy-vline no-gap,
**                  dbcnt no-gap,
**                (10) 'Fehler auf'(105) no-gap,
**                (10)  acctyp no-gap,
**                (11)  accnt no-gap,
**                (36) 'Duplicate Indexes comp. BSI&1 vs BSA&1'
**                                            no-gap right-justified,
**
**                80 sy-vline no-gap.
          move : 'Fehler auf'(105)   to gs_outtab_list1-recon. "#EC *
          move : dbcnt               to gs_outtab_list1-ercnt,
                 accnt               to gs_outtab_list1-hkont,
                 acctyp              to gs_outtab_list1-gltype.
          concatenate 'Doppelte Indices Vgl'(106) 'BSI&1' 'vs' 'BSA&1' into gs_outtab_list1-ddtext.
          append gs_outtab_list1     to gt_outtab_list1.
**-------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**-------------------------------------------------------------------**
        endif.
        clear dbcnt.
        accnt =  bsi&1-&2.
        odd = 1.
**-------------------------------------------------------------------**
** BEGIN OF CHANGES                                       C5053256
**-------------------------------------------------------------------**
**   new-line. uline (80).
**        format color col_heading.
**        format intensified on.
**        write:/ sy-vline no-gap,
**           (13) 'Company Code' no-gap,
**            (5)  bsi&1-bukrs no-gap,
**            (10)  acctyp no-gap,
**           (11)  accnt no-gap,
**           (39) 'Duplicate Indexes comp. BSI&1 vs BSA&1'
**                                        no-gap right-justified,
**             80 sy-vline no-gap.
**        format color off.
**  new-line. uline (80).
        concatenate 'Doppelte Indices Vgl'(106) 'BSI&1' 'vs' 'BSA&1' into gs_outtab_list1-err_msg.
        move : bsi&1-bukrs         to gs_outtab_list1-bukrs,
               dbcnt               to gs_outtab_list1-ercnt,
               accnt               to gs_outtab_list1-hkont,
               acctyp              to gs_outtab_list1-gltype. "#EC *
**-------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**-------------------------------------------------------------------**
      endif.
**      format color col_normal.
**      format intensified = odd.
      add 1 to dbcnt.
      if protox = 'X'.
**-------------------------------------------------------------------**
** BEGIN OF CHANGES                                          C5053256
**-------------------------------------------------------------------**
        clear : gs_outtab_list2.
**        write:/ sy-vline no-gap,
**           (11) bsi&1-belnr no-gap,
**           (5)  bsi&1-gjahr no-gap,
**           (62)  bsi&1-buzei no-gap,
**             80  sy-vline no-gap.
        move : bsi&1-bukrs          to gs_outtab_list2-bukrs,
               accnt                to gs_outtab_list2-hkont.
        move : bsi&1-belnr          to gs_outtab_list2-belnr,
               bsi&1-gjahr          to gs_outtab_list2-gjahr,
               bsi&1-buzei          to gs_outtab_list2-buzei.
        append gs_outtab_list2       to gt_outtab_list2.
**-------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**-------------------------------------------------------------------**
      endif.
      if odd = 0.
        odd = 1.
      else.
        odd = 0.
      endif.
    endselect.
    if dbcnt > 0.
**-------------------------------------------------------------------**
** BEGIN OF CHANGES                                          C5053256
**-------------------------------------------------------------------**
**      format color col_total.
**      format intensified on.
**      write:/ sy-vline no-gap,
**              dbcnt no-gap,
**            (10) 'Fehler auf'(105) no-gap,
**            (10)  acctyp no-gap,
**            (11)  accnt no-gap,
**            (36) 'Duplicate Indexes comp. BSI&1 vs BSA&1'
**                                no-gap right-justified,
**            80 sy-vline no-gap.
**      new-line. uline (80).
      concatenate 'Doppelte Indices Vgl'(106) 'BSI&1' 'vs' 'BSA&1' into gs_outtab_list1-ddtext.
      move : dbcnt               to gs_outtab_list1-ercnt,
             accnt               to gs_outtab_list1-konto,
             'Fehler auf'(105)   to gs_outtab_list1-recon.
      append gs_outtab_list1     to gt_outtab_list1.
**-------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**-------------------------------------------------------------------**
    endif.

* delete workarea at the end of selection.

    clear bsi&1.
**    format color off.
**    format intensified on.
  END-OF-DEFINITION.


  DEFINE find_duplicate_index_2.
    data: accnt like bseg-hkont,
          odd type i value 1,
          dbcnt like sy-dbcnt,
          acctyp(9) type c,
          count type i,
          error type i,
          msg like string100.
    if '&1' = 'S'.
      acctyp = 'Sachkonto'(040).
    elseif '&1' = 'D'.
      acctyp = 'Kunde'(042).
    elseif '&1' = 'K'.
      acctyp = 'Lieferant'(043).
    endif.
* &1   BSIS, BSAS, BSID, BSAD, BSIK oder BSAK
* &2  'LIFNR'  'HKONT'  'KUNNR'
* &3  'KREDI'  'SAKO'   'DEBI'  (corresponding to &2)
    select  &1~bukrs
            &1~belnr
            &1~gjahr
            &1~buzei
            &1~&2
            count( * )
* hier muss bsi&1-&2 mit '~' stehen ! (Tile = DB-Feld)
                 into (&1-bukrs,
                       &1-belnr,
                       &1-gjahr,
                       &1-buzei,
                       &1-&2,
                       count)
* hier muss bsi&1-&2 mit '-' stehen ! (Bindestrich = WORKAREA)
                       from &1
                       where &1~bukrs  in p_bukrs and
                             &1~&2    in  p_&2    and
                             &1~belnr in  p_belnr and
                             &1~gjahr in  p_gjahr and
                             &1~monat in  p_monat

*           ---- begin of delete block <= 4.0 -----
            group by bukrs &2 belnr buzei gjahr " <-- insert asteric 4.0
            having count( * ) > 1.              " <-- insert asteric 4.0
*           ---- end of delete block <= 4.0 -----

*           ---- begin of insert block <= 4.0 -----
*            group by bukrs &2 belnr buzei gjahr."<-- remove asteric 4.0
*           ---- end of insert block <= 4.0 ------

      perform execute_progress using error '&2' .
* Bemerkung: beim left inner join ist vollkommen egal wo die bedingungen
* stehen, in der where klausel oder in der join-bedingung !!
      if count ne 1.
        if error = 0.
          concatenate 'in'(109) '&1' into msg separated by space.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**          perform write_dbl_index_header using msg.
*          clear : gs_outtab_list1, gt_outtab_list1.
          move msg to gv_head_line1.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
*  error = 1.
        endif.
        add 1 to error.
        if accnt ne &1-&2.
          if dbcnt > 0.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**            format color col_total.
**            format intensified on.
**
**            write:/ sy-vline no-gap,
**                    dbcnt no-gap,
**                  (10) 'Fehler auf'(105) no-gap,
**                  (10)  acctyp no-gap,
**                  (11)  accnt no-gap,
**                  (36) 'Duplicate Indexes in &1' no-gap
**                           right-justified,
**                  80 sy-vline no-gap.
            move : dbcnt           to  gs_outtab_list1-ercnt,
                   &1-bukrs        to  gs_outtab_list1-bukrs,
                   acctyp          to  gs_outtab_list1-gltype.
            move   'Fehler auf'(105)     to  gs_outtab_list1-recon. "#EC *
            move:   accnt           to  gs_outtab_list1-konto,
                    accnt           to  gs_outtab_list1-hkont.
            concatenate 'Doppelte Indices in'(108) '&1' into  gs_outtab_list1-ddtext separated by space.
            append gs_outtab_list1 to  gt_outtab_list1.
*            clear  gs_outtab_list1.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
          endif.
          clear dbcnt.
          accnt =  &1-&2.
          odd = 1.
*   new-line. uline (80).
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**          format color col_heading.
**          format intensified on.
**          write:/ sy-vline no-gap,
**             (13) 'Company Code' no-gap,
**              (5) &1-bukrs no-gap,
**             (10) acctyp no-gap,
**             (11) accnt no-gap,
**             (39) 'Duplicate Indexes in &1' no-gap right-justified,
**               80 sy-vline no-gap.
**          format color off.
          move : &1-bukrs        to  gs_outtab_list1-bukrs,
                 acctyp          to  gs_outtab_list1-gltype,
                 accnt           to  gs_outtab_list1-hkont,
                 accnt           to  gs_outtab_list1-konto.
          concatenate 'Doppelte Indices in'(108) '&1' into  gs_outtab_list1-err_msg separated by space.

**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
        endif.
        format color col_normal.
        format intensified = odd.
        add 1 to dbcnt.
        if protox = 'X'.
**-------------------------------------------------------------------**
** BEGIN OF CHANGES                                          C5053256
**-------------------------------------------------------------------**
*          clear : gs_outtab_list1-belnr,
*                  gs_outtab_list1-gjahr,
*                  gs_outtab_list1-buzei.
**          write:/ sy-vline no-gap,
**             (11) &1-belnr no-gap,
**             (5)  &1-gjahr no-gap,
**             (4)  &1-buzei no-gap,
**             (58) count no-gap,
**               80 sy-vline no-gap.
          move : &1-belnr          to gs_outtab_list2-belnr,
                 &1-gjahr          to gs_outtab_list2-gjahr,
                 &1-buzei          to gs_outtab_list2-buzei,
                 &1-bukrs          to gs_outtab_list2-bukrs,
                 accnt             to gs_outtab_list2-hkont,
                 count             to gs_outtab_list2-arcnt.
          append gs_outtab_list2   to gt_outtab_list2.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
        endif.
        if odd = 0.
          odd = 1.
        else.
          odd = 0.
        endif.
      endif.
    endselect.
    if dbcnt > 0.
**-------------------------------------------------------------------**
** BEGIN OF CHANGES                                          C5053256
**-------------------------------------------------------------------**
**      format color col_total.
**      format intensified on.
**      write:/ sy-vline no-gap,
**              dbcnt no-gap,
**            (10) 'Fehler auf'(105) no-gap,
**            (10)  acctyp no-gap,
**            (11)  accnt no-gap,
**            (36) 'Duplicate Indexes in &1' no-gap right-justified,
**            80 sy-vline no-gap.
**      new-line. uline (80).
      move : dbcnt           to  gs_outtab_list1-ercnt,
             acctyp          to  gs_outtab_list1-gltype,
             &1-bukrs        to  gs_outtab_list1-bukrs.
      move: 'Fehler auf'(105)      to  gs_outtab_list1-recon. "#EC *
      move:  accnt           to  gs_outtab_list1-hkont,
             accnt           to  gs_outtab_list1-konto.
      concatenate 'Doppelte Indices in'(108) '&1' into  gs_outtab_list1-ddtext separated by space.
      append gs_outtab_list1 to  gt_outtab_list1.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
    endif.

* delete workarea at the end of selection.

    clear &1.
**    format color off.
**    format intensified on.
  END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*         Write Statement for 'Find missing heder'                     *
* -------------------------------------------------------------------- *
FORM write_error_heade USING
                             p_stmnt LIKE string100
                       CHANGING
                                pp_stmnt LIKE string100.

  bseg_written = true.
  CONCATENATE pp_stmnt p_stmnt INTO pp_stmnt SEPARATED BY '; '.
ENDFORM.                    "write_error_heade
* -------------------------------------------------------------------- *
*                 F070: get Cursor to BKPF                             *
* -------------------------------------------------------------------- *
FORM get_bkpf USING bkrs LIKE bseg-bukrs
                    minday LIKE bkpf-budat
                    maxday LIKE bkpf-budat
           CHANGING pcursor TYPE cursor.
  IF minday IS INITIAL OR maxday IS INITIAL.
*   This if branch is not reached anymore
    OPEN CURSOR WITH HOLD pcursor FOR SELECT
    belnr gjahr cpudt cputm monat FROM bkpf
       WHERE bukrs EQ bkrs
         AND bstat EQ space
         AND gjahr IN p_gjahr
         AND monat IN p_monat.

  ELSE.
*   Normal if branch always reached
    OPEN CURSOR WITH HOLD pcursor FOR SELECT
    belnr gjahr cpudt cputm monat FROM bkpf
       WHERE bukrs EQ bkrs
         AND bstat EQ space
         AND budat GE minday
         AND budat LE maxday
         AND gjahr IN p_gjahr
         AND monat IN p_monat.
*         order by gjahr monat.

  ENDIF.
ENDFORM.                    "get_bkpf

* -------------------------------------------------------------------- *
*       F070: Build up G/L Transaction Figures (Docs).                 *
* -------------------------------------------------------------------- *
DEFINE set_amounts.
* &1 = 1, 2 or 3.
* &2 = S or H.
  case curtab-map&1.
    when '2'.
      bel-hsl&2b = dmbe&1.
      bel-hsl&2d = dmbe&1.
    when '3'.
      bel-ksl&2b = dmbe&1.
      bel-ksl&2d = dmbe&1.
  endcase.
END-OF-DEFINITION.
* -------------------------------------------------------------------- *

FORM sako_vz_bsxs TABLES bel STRUCTURE tvz curtab STRUCTURE no_curtab
                   USING bsx TYPE ty_bsxx.

  CLEAR bel.
  bel-accnt = bsx-accnt.
  bel-gsber = bsx-gsber.
  bel-monat = bsx-monat.
  bel-gjahr = bsx-gjahr.
  bel-pswsl = bsx-pswsl.

  DATA: pswbt LIKE huge_amount.
  DATA: dmbe1 LIKE huge_amount.
  DATA: dmbe2 LIKE huge_amount.
  DATA: dmbe3 LIKE huge_amount.
  CASE bsx-shkzg.  " <-- Vorzeichen setzen
    WHEN 'S'.
      pswbt = bsx-pswbt.
      dmbe1 = bsx-dmbtr.
      dmbe2 = bsx-dmbe2.
      dmbe3 = bsx-dmbe3.
    WHEN OTHERS.
      pswbt = - bsx-pswbt.
      dmbe1 = - bsx-dmbtr.
      dmbe2 = - bsx-dmbe2.
      dmbe3 = - bsx-dmbe3.
  ENDCASE.
  LOOP AT curtab.
    CLEAR: bel-tslsb, bel-hslsb, bel-kslsb, bel-tslhb, bel-hslhb,
           bel-kslhb, bel-tslsd, bel-hslsd, bel-kslsd, bel-tslhd,
           bel-hslhd, bel-kslhd.
    CHECK curtab-map1 > 0 OR curtab-map2 > 0 OR curtab-map3 > 0.
    bel-rldnr = curtab-rldnr.
*    ibseg-xnegp must commented out for Release 3.0
*   ----- begin of insert block <= 3.0 ------
*   IF bsx-shkzg eq 'S'.          " <-- remove asteric 3.0
*   ----- end of insert block <= 3.0 ------
*   ----- begin of delete block <= 3.0 ------
    IF ( bsx-shkzg EQ 'S' AND bsx-xnegp EQ space ) " insert asteric 3.0
    OR ( bsx-shkzg EQ 'H' AND bsx-xnegp NE space )." insert asteric 3.0
*   ----- end of delete block <= 3.0 ------
      bel-tslsb = pswbt.
      bel-tslsd = pswbt.
      set_amounts 1 s.
      set_amounts 2 s.
      set_amounts 3 s.
    ELSE.
      bel-tslhb = pswbt.
      bel-tslhd = pswbt.
      set_amounts 1 h.
      set_amounts 2 h.
      set_amounts 3 h.
    ENDIF.
    COLLECT bel.
  ENDLOOP.
ENDFORM.                    "sako_vz_bsxs

* -------------------------------------------------------------------- *
*         F070: Build up Sub-ledger Transaction Figures.               *
* -------------------------------------------------------------------- *
FORM nb_vz_bsxi TABLES bel STRUCTURE tvz USING ibsid TYPE ty_bsxx.
  CLEAR bel.
  DATA: dmbtr LIKE huge_amount.
  bel-accnt = ibsid-accnt.
  bel-monat = ibsid-monat.
  bel-gjahr = ibsid-gjahr.
  bel-shbkz = ibsid-umskz.
  dmbtr = ibsid-dmbtr.
* ****** Sales are mapped to tsls-fields ********
  IF ibsid-xumsw = 'X' AND ibsid-umskz IS INITIAL.
    IF ibsid-shkzg = 'S'.
      bel-tslsb = dmbtr.
      bel-tslsd = dmbtr.
    ELSE.
      bel-tslsb = - dmbtr.
      bel-tslsd = - dmbtr.
    ENDIF.
  ENDIF. " Sales on TSLS field
* ***********************************************
  IF NOT ibsid-umskz IS INITIAL.
    bel-monat = '01'.
  ENDIF.

* ----- begin of delete block <= 3.0 -----
  IF ibsid-xnegp = 'X'.                       " <--   insert asteric 3.0
    dmbtr =   - dmbtr.                      " <--   insert asteric 3.0
  ENDIF.                                      " <--   insert asteric 3.0
* ------ end of delete block <= 3.0 ------

* ----- begin of insert block <= 3.0 -----
* IF ibsid-shkzg = 'S'.                       " <--   remove asteric 3.0
* ------ end of insert block <= 3.0 ------

* ----- begin of delete block <= 3.0 -----
  IF ( ibsid-shkzg = 'S' AND ibsid-xnegp = space ) "<-insert asteric 3.0
  OR ( ibsid-shkzg = 'H' AND ibsid-xnegp = 'X' ).  "<-insert asteric 3.0
* ------ end of delete block <= 3.0 ------

    bel-hslsb = dmbtr.
    bel-hslsd = dmbtr.
  ELSE.
    bel-hslhb = dmbtr.
    bel-hslhd = dmbtr.
  ENDIF.
  COLLECT bel.
ENDFORM.                    "nb_vz_bsxi
* -------------------------------------------------------------------- *
*  F070: Select line items in BSEG zu build up Txn.Fig. of doc. side   *
* -------------------------------------------------------------------- *
FORM vzb TABLES critbel STRUCTURE h_beln
                curtab STRUCTURE no_curtab
                s_bel STRUCTURE tvz
                d_bel STRUCTURE tvz
                k_bel STRUCTURE tvz
                d_shb STRUCTURE tvz
                k_shb STRUCTURE tvz
         USING  pbkpf TYPE ty_f070_bkpf
                shbflag TYPE c
      CHANGING  p_used TYPE c.
  DATA: ibseg TYPE ty_f070_bseg OCCURS 4 WITH HEADER LINE,
        errors_all TYPE i,                                  "#EC NEEDED
        ddmbtr LIKE huge_amount,
        ddmbe3 LIKE huge_amount,
        ddmbe2 LIKE huge_amount,
        dwrbtr LIKE huge_amount,
        wabsxs TYPE ty_bsxx,
        wabsxd TYPE ty_bsxx,
        wabsxk TYPE ty_bsxx.

  SELECT shkzg
* ----- begin of delete block <= 3.0 -----
         xnegp                               " <--   insert asteric 3.0
* ------ end of delete block <= 3.0 ------
         umskz xumsw koart pswsl gsber hkont kunnr lifnr
         pswbt wrbtr dmbtr dmbe2 dmbe3
         FROM bseg INTO TABLE ibseg WHERE bukrs = pbkpf-bukrs
                                        AND belnr = pbkpf-belnr
                                        AND gjahr = pbkpf-gjahr.
* *********************** Caution !!!! ******************************* *
* The order of the selected fields in the select statement is important
* It must be the same as in the type definition of ty_bseg_f070.
* ******************************************************************** *
  DESCRIBE TABLE critbel LINES sy-tfill.
  IF sy-batch IS INITIAL.
    PERFORM execute_progress USING sy-tfill 'BKPF'.
  ENDIF.
* **********************
* perform the line items
* **********************
  LOOP AT ibseg.
*   ********************************
*   Used for zero-balance check
*   ********************************
    IF ibseg-shkzg = 'S'.
      ADD ibseg-dmbtr TO ddmbtr.
      ADD ibseg-dmbe2 TO ddmbe2.
      ADD ibseg-dmbe3 TO ddmbe3.
      ADD ibseg-wrbtr TO dwrbtr.
    ELSEIF ibseg-shkzg = 'H'.
      SUBTRACT ibseg-dmbtr FROM ddmbtr.
      SUBTRACT ibseg-dmbe2 FROM ddmbe2.
      SUBTRACT ibseg-dmbe3 FROM ddmbe3.
      SUBTRACT ibseg-wrbtr FROM dwrbtr.
    ENDIF.
*      clear wabsxs.
    MOVE: pbkpf-gjahr TO wabsxs-gjahr,
          ibseg-hkont TO wabsxs-accnt,
          ibseg-gsber TO wabsxs-gsber,
          ibseg-shkzg TO wabsxs-shkzg,

          pbkpf-monat TO wabsxs-monat,
          ibseg-pswsl TO wabsxs-pswsl,
          ibseg-xumsw TO wabsxs-xumsw,

* ----- begin of delete block 3.0 -----
          ibseg-xnegp TO wabsxs-xnegp,      " <--   insert asteric 3.0
* ------ end of delete block 3.0 ------

          ibseg-pswbt TO wabsxs-pswbt,
          ibseg-dmbtr TO wabsxs-dmbtr,
          ibseg-dmbe2 TO wabsxs-dmbe2,
          ibseg-dmbe3 TO wabsxs-dmbe3.



*   ***********************************
*   1.)Build up G/L txn figs
*   ***********************************
    IF x_sako = 'X' AND ibseg-hkont IN p_hkont.
      p_used = 'X'.
      PERFORM sako_vz_bsxs TABLES s_bel curtab USING wabsxs.
*      perform sako_vz tables s_bel curtab using ibseg pbkpf.
    ENDIF.
*   ***********************************
*   ***********************************
*   2.)Build up customers txn figs
*   ***********************************
    IF ibseg-koart = 'D' AND x_debi = 'X' AND ibseg-kunnr IN p_kunnr.
      p_used = 'X'.
*     a) for Normal transactions
*      perform nb_vz tables d_bel using ibseg ibseg-kunnr pbkpf.
      wabsxd = wabsxs.
      wabsxd-accnt = ibseg-kunnr.
      wabsxd-umskz = ibseg-umskz.
      IF wabsxd-umskz IS INITIAL.
        PERFORM nb_vz_bsxi TABLES d_bel USING wabsxd.
      ELSE.
        IF shbflag = 'X'.
*         b) for Special G/L transactions if check runs for all periods
*          perform nb_vz_shb tables d_shb using ibseg ibseg-kunnr pbkpf.
          PERFORM nb_vz_bsxi TABLES d_shb USING wabsxd.
        ENDIF.
      ENDIF.
    ENDIF.
*   ***********************************
*   ***********************************
*   3.)Build up Vendors txn figs
*   ***********************************
    IF ibseg-koart = 'K' AND x_kredi = 'X' AND ibseg-lifnr IN p_lifnr.
      p_used = 'X'.
      wabsxk = wabsxs.
      wabsxk-accnt = ibseg-lifnr.
      wabsxk-umskz = ibseg-umskz.
*     a) for Normal transactions
      IF wabsxk-umskz IS INITIAL.
        PERFORM nb_vz_bsxi TABLES k_bel USING wabsxk.
*        perform nb_vz tables k_bel using ibseg ibseg-lifnr pbkpf.
      ELSE.
        IF shbflag = 'X'.
*         b) for Special G/L transactions if check runs for all periods
*          perform nb_vz_shb tables k_shb using ibseg ibseg-lifnr pbkpf.
          PERFORM nb_vz_bsxi TABLES k_shb USING wabsxk.
        ENDIF.
      ENDIF.
    ENDIF.
*   ***********************************
  ENDLOOP.
* **************************************************************
* After one doc. is checked: is it unbalanced or no line items ?
* -> append it to critbel table
* **************************************************************
  IF sy-subrc <> 0 OR ddmbtr <> 0 OR ddmbe2 <> 0 OR ddmbe3 <> 0
     OR dwrbtr <> 0.
    CLEAR critbel.
    IF sy-subrc <> 0.
      critbel-ertxt = 'Belegkopf ohne Positionen'(386).
    ELSE.
      critbel-ertxt = 'Beleg saldiert nicht zu null oder falsches BSEG-SHKZG'(387).
    ENDIF.
    MOVE-CORRESPONDING pbkpf TO critbel.                    "#EC ENHOK
    APPEND critbel.
  ENDIF.
ENDFORM.                    "vzb
* -------------------------------------------------------------------- *
*  F070: Makro to fill internal Txn. Fig. table (G/L, GLT0 side)       *
* -------------------------------------------------------------------- *
DEFINE pro_monat.
  if &1 in p_monat and &1 <= glt0-rpmax.
    clear: vz.
    vz-gjahr = glt0-ryear.
    vz-accnt = glt0-racct.
    vz-gsber = glt0-rbusa.
    vz-monat = &1.
    vz-pswsl = glt0-rtcur.
    vz-rldnr = glt0-rldnr.
    if glt0-drcrk = 'S'.
      vz-tslsv = glt0-tsl&1.
      vz-tslsd = - glt0-tsl&1.
      if curtab-usehsl = 1.
        vz-hslsv = glt0-hsl&1.
        vz-hslsd = - glt0-hsl&1.
      endif.
      if curtab-useksl = 1.
        vz-kslsv = glt0-ksl&1.
        vz-kslsd = - glt0-ksl&1.
      endif.
    else.
      vz-tslhv = glt0-tsl&1.
      vz-tslhd = - glt0-tsl&1.
      if curtab-usehsl = 1.
        vz-hslhv = glt0-hsl&1.
        vz-hslhd = - glt0-hsl&1.
      endif.
      if curtab-useksl = 1.
        vz-kslhv = glt0-ksl&1.
        vz-kslhd = - glt0-ksl&1.
      endif.
    endif.
    if vz-tslsv <> 0 or vz-hslsv <> 0 or vz-kslsv <> 0
    or vz-tslhv <> 0 or vz-hslhv <> 0 or vz-kslhv <> 0.
      collect vz.
    endif.
  endif.
END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*  F070: Makro to fill internal Txn. Fig. table (Sub-ledger, KNC1,LFC1)
* -------------------------------------------------------------------- *
DEFINE pro_monat2_all.
* &1 = LFC1 oder KNC1
* &2 = LIFNR oder KUNNR
  if p_monat is initial and compare_mode = c_fbila.
    clear: vz.
    vz-gjahr = &1-gjahr.
    vz-accnt = &1-&2.
    vz-monat = 99.

    vz-hslsv  = &1-umsav.     " <-- SOLL auf   HSLS
    vz-hslsd  = - &1-umsav.     " <-- SOLL auf   HSLS

    if vz-hslsv <> 0 or vz-hslhv <> 0 or vz-tslsv <> 0.
      collect vz.
    endif.
  endif.


  pro_monat2 01 &1 &2.
  pro_monat2 02 &1 &2.
  pro_monat2 03 &1 &2.
  pro_monat2 04 &1 &2.
  pro_monat2 05 &1 &2.
  pro_monat2 06 &1 &2.
  pro_monat2 07 &1 &2.
  pro_monat2 08 &1 &2.
  pro_monat2 09 &1 &2.
  pro_monat2 10 &1 &2.
  pro_monat2 11 &1 &2.
  pro_monat2 12 &1 &2.
  pro_monat2 13 &1 &2.
  pro_monat2 14 &1 &2.
  pro_monat2 15 &1 &2.
  pro_monat2 16 &1 &2.
END-OF-DEFINITION.
DEFINE pro_monat2.
  if &1 in p_monat.
    clear: vz.
    vz-gjahr = &2-gjahr.
    vz-accnt = &2-&3.
    vz-monat = &1.

    vz-hslsv  = &2-um&1s.     " <-- SOLL auf   HSLS
    vz-hslhv  = &2-um&1h.     " <-- HABEN auf  HSLH
    vz-tslsv  = &2-um&1u.     " <-- Umsatz auf TSLS

    vz-hslsd  = - &2-um&1s.     " <-- SOLL auf   HSLS
    vz-hslhd  = - &2-um&1h.     " <-- HABEN auf  HSLH
    vz-tslsd  = - &2-um&1u.     " <-- Umsatz auf TSLS

    if vz-hslsv <> 0 or vz-hslhv <> 0 or vz-tslsv <> 0.
      collect vz.
    endif.
  endif.
END-OF-DEFINITION.
* -------------------------------------------------------------------- *
*  F070: Makro to fill int. Txn. Fig. tab. (Sub-led. Sp.G/L, KNC3,LFC3)
* -------------------------------------------------------------------- *
DEFINE pro_monat3.
  if p_monat is initial.
    if compare_mode = c_fbila.
      clear: vz.
      vz-gjahr = &1-gjahr.
      vz-accnt = &1-&2.
      vz-monat = 99.
      vz-shbkz = &1-shbkz.

      vz-hslsv  = &1-saldv.     " <-- SOLL auf   HSLS
      vz-hslsd  = - &1-saldv.
      if vz-hslsv <> 0 or vz-hslhv <> 0.
        collect vz.
      endif.
    endif.
  endif.
  clear: vz.
  vz-gjahr = &1-gjahr.
  vz-accnt = &1-&2.
  vz-monat = '01'.
  vz-shbkz = &1-shbkz.

  vz-hslsv  = &1-solll.     " <-- SOLL auf   HSLS
  vz-hslhv  = &1-habnl.     " <-- HABEN auf  HSLH
  vz-hslsd  =  - &1-solll.     " <-- SOLL auf   HSLS
  vz-hslhd  =  - &1-habnl.     " <-- HABEN auf  HSLH



  if vz-hslsv <> 0 or vz-hslhv <> 0.
    collect vz.
  endif.
END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*  F070: Fill int. tab. mapping GLT0 (G/L Txn Fig.)                    *
* -------------------------------------------------------------------- *

FORM vz_s_fill TABLES vz STRUCTURE tvz
                      curtab STRUCTURE no_curtab
               USING  bkrs LIKE bseg-bukrs compare_mode LIKE c_f070.
  IF x_sako = 'X'.
    LOOP AT curtab.
      IF curtab-usehsl IS INITIAL AND curtab-useksl IS INITIAL.
        CONTINUE.
      ENDIF.
      DATA lt_fagl_t_glt0 TYPE fagl_t_glt0.
      IF gd_fagl_functions_present = 'X'.
        DATA lt_ryear TYPE fagl_range_t_ryear.
        DATA lt_racct TYPE fagl_range_t_racct.
        FIELD-SYMBOLS: <ls_ryear> TYPE fagl_range_ryear.
        FIELD-SYMBOLS: <ls_racct> TYPE fagl_range_racct.
        CLEAR: lt_ryear, lt_racct, lt_fagl_t_glt0.
        REFRESH: lt_ryear, lt_racct, lt_fagl_t_glt0.
        LOOP AT p_gjahr.
          APPEND INITIAL LINE TO lt_ryear ASSIGNING <ls_ryear>.
          MOVE-CORRESPONDING p_gjahr TO <ls_ryear>.
        ENDLOOP.
        LOOP AT p_hkont.
          APPEND INITIAL LINE TO lt_racct ASSIGNING <ls_racct>.
          MOVE-CORRESPONDING p_hkont TO <ls_racct>.         "#EC ENHOK
        ENDLOOP.


        CALL FUNCTION 'FAGL_GET_GLT0'
          EXPORTING
            i_glt0_rldnr  = curtab-rldnr
            i_rrcty       = '0'
            i_rvers       = '001'
            i_bukrs       = bkrs
            i_rpmax       = '016'
            i_range_ryear = lt_ryear
            i_range_racct = lt_racct
          IMPORTING
            et_glt0       = lt_fagl_t_glt0.
      ELSE.
        SELECT * FROM glt0 INTO TABLE lt_fagl_t_glt0
                           WHERE rrcty = '0'
                             AND rvers = '001'
                             AND bukrs = bkrs
                             AND rldnr = curtab-rldnr
                             AND ryear IN p_gjahr
                             AND racct IN p_hkont
                             AND rpmax = '016'.
      ENDIF.
      FIELD-SYMBOLS <ls_fagl_t_glt0> TYPE glt0.
      LOOP AT lt_fagl_t_glt0 ASSIGNING <ls_fagl_t_glt0>.
        glt0 = <ls_fagl_t_glt0>.
        IF compare_mode = c_fbila.
          IF p_monat IS INITIAL.
            CLEAR: vz.
            vz-gjahr = glt0-ryear.
            vz-accnt = glt0-racct.
            vz-gsber = glt0-rbusa.
            vz-monat = 99.
            vz-pswsl = glt0-rtcur.
            vz-rldnr = glt0-rldnr.
            IF glt0-drcrk = 'S'.
              vz-tslsv = glt0-tslvt.
              vz-tslsd = - glt0-tslvt.
              IF curtab-usehsl = 1.
                vz-hslsv = glt0-hslvt.
                vz-hslsd = - glt0-hslvt.
              ENDIF.
              IF curtab-useksl = 1.
                vz-kslsv = glt0-kslvt.
                vz-kslsd = - glt0-kslvt.
              ENDIF.
            ELSE.
              vz-tslhv = glt0-tslvt.
              vz-tslhd = - glt0-tslvt.
              IF curtab-usehsl = 1.
                vz-hslhv = glt0-hslvt.
                vz-hslhd = - glt0-hslvt.
              ENDIF.
              IF curtab-useksl = 1.
                vz-kslhv = glt0-kslvt.
                vz-kslhd = - glt0-kslvt.
              ENDIF.
            ENDIF.
            IF vz-tslsv <> 0 OR vz-hslsv <> 0 OR vz-kslsv <> 0
            OR vz-tslhv <> 0 OR vz-hslhv <> 0 OR vz-kslhv <> 0.
              COLLECT vz.
            ENDIF.
          ENDIF.

        ENDIF.
        pro_monat 01.
        pro_monat 02.
        pro_monat 03.
        pro_monat 04.
        pro_monat 05.
        pro_monat 06.
        pro_monat 07.
        pro_monat 08.
        pro_monat 09.
        pro_monat 10.
        pro_monat 11.
        pro_monat 12.
        pro_monat 13.
        pro_monat 14.
        pro_monat 15.
        pro_monat 16.
      ENDLOOP.                                              "GLT0-loop

    ENDLOOP. "Curtab

  ENDIF.
ENDFORM.                    "vz_s_fill

* -------------------------------------------------------------------- *
*  F070: Fill int. tab. mapping KNC3 (Spec. G/L Txn Fig. Customers)    *
* -------------------------------------------------------------------- *
FORM vz_d_fill_shb TABLES vz STRUCTURE tvz
                   USING  bkrs LIKE bseg-bukrs compare_mode LIKE c_f070.
  IF x_debi = 'X'.
    SELECT * FROM knc3 WHERE kunnr IN p_kunnr
                         AND bukrs = bkrs
                         AND gjahr IN p_gjahr.
      pro_monat3 knc3 kunnr.
    ENDSELECT.
  ENDIF.
ENDFORM.                    "vz_d_fill_shb
* -------------------------------------------------------------------- *
*  F070: Fill int. tab. mapping LFC3 (Spec. G/L Txn Fig. Vendors)      *
* -------------------------------------------------------------------- *
FORM vz_k_fill_shb TABLES vz STRUCTURE tvz
                   USING  bkrs LIKE bseg-bukrs compare_mode LIKE c_f070.

  IF x_kredi = 'X'.
    SELECT * FROM lfc3 WHERE lifnr IN p_lifnr
                         AND bukrs = bkrs
                         AND gjahr IN p_gjahr.
      pro_monat3 lfc3 lifnr.
    ENDSELECT.
  ENDIF.
ENDFORM.                    "vz_k_fill_shb

* -------------------------------------------------------------------- *
*      F070: Fill int. tab. mapping KNC1 (Txn Fig. Customers)          *
* -------------------------------------------------------------------- *
FORM vz_d_fill TABLES vz STRUCTURE tvz
               USING  bkrs LIKE bseg-bukrs compare_mode LIKE c_f070.
  IF x_debi = 'X'.
    SELECT * FROM knc1 WHERE kunnr IN p_kunnr
                         AND bukrs = bkrs
                         AND gjahr IN p_gjahr.
      pro_monat2_all knc1 kunnr.
    ENDSELECT.
  ENDIF.
ENDFORM.                    "vz_d_fill

* -------------------------------------------------------------------- *
*      F070: Fill int. tab. mapping LFC1 (Txn Fig. Vendors)            *
* -------------------------------------------------------------------- *
FORM vz_k_fill TABLES vz STRUCTURE tvz
               USING bkrs LIKE bseg-bukrs compare_mode LIKE c_f070.
  IF x_kredi = 'X'.
    SELECT * FROM lfc1 WHERE lifnr IN p_lifnr
                          AND bukrs EQ bkrs
                          AND gjahr IN p_gjahr.
      pro_monat2_all lfc1 lifnr.
    ENDSELECT.
  ENDIF.

ENDFORM.                    "vz_k_fill
* -------------------------------------------------------------------- *
*    F190-Helper to fill account error-table for sub-ledgers and to
*    to remove not needed entries from the *b-tables
* -------------------------------------------------------------------- *
DEFINE to_xxb1.
* **********************
* &1 = kb, db, dsb, ksb.
* &2 = iknb1, ilfb1.
* &3 = lifnr, kunnr
* &4 = Koart K, D
* &5 = Messagestring
* *********************
  loop at &1.

*    clear: &1-tslsv, &1-tslsd.
*    modify &1.
*   ****************************
*   No Difference -> not needed
*   ****************************
    if compare_mode ne 'Saldo'(341).
      if &1-tslsd = 0 and &1-hslsd = 0 and &1-kslsd = 0 and
             &1-tslhd = 0 and &1-hslhd = 0 and &1-kslhd = 0.
        delete &1.
        continue.
      endif.
    endif.
    if compare_mode eq 'Saldo'(341).
      if &1-hslsv = 0 and &1-hslhv = 0 and &1-kslsv = 0 and &1-kslhv = 0.
        delete &1.
        continue.
      endif.
    endif.
*   ******************************
*   Read the internal Master Table
*   ******************************
    read table &2 with key &3 = &1-accnt binary search.

    if sy-subrc <> 0.
*       *************************************************
*       Entry has no KNB1/LFB1 entry -> Error, write into
*       error_f190 table
*       *************************************************
      error_f190-koart = '&4'.
      error_f190-ermsg = '&5'.
      error_f190-accnt = &1-accnt.
      collect error_f190.
      continue.
    endif.

  endloop.
END-OF-DEFINITION.
************************************************************************
* -------------------------------------------------------------------- *
*                Main Form to list the balance.                        *
* -------------------------------------------------------------------- *
************************************************************************
FORM fbila.
  LOOP AT it001.
    PERFORM f070_bukrs USING it001 c_fbila.                 "#EC *
  ENDLOOP.
ENDFORM.                    "fbila

************************************************************************
* -------------------------------------------------------------------- *
*          Main Form to compare Docs to Txn Figures.                   *
* -------------------------------------------------------------------- *
************************************************************************
FORM f070.
  IF NOT sy-batch = 'X' AND x_sako IS INITIAL AND x_debi IS INITIAL
  AND x_kredi IS INITIAL.
    CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
      EXPORTING
        titel     = 'Es wird kein Konto gepr¨¹ft'(370)
        textline1 = 'Es mu# mindestens ein Konto selektiert werden'(371)
        textline2 = 'Bitte nicht vergessen eine Kontoart auszuw#hlen'(372).
  ENDIF.

  IF x_sako = 'X' AND  gd_glt0_update_allowed NE 'X'.
    CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
      EXPORTING
        titel     = 'Best#tigen'(373)
        textline1 = 'Neues Hauptbuch ist aktiv'(374)
        textline2 = 'GLT0 kann nicht angepasst werden'(375).
  ENDIF.

** begin of changes
  CLEAR : gv_tenth_cnt.
** end of changes.

  CHECK x_sako = 'X' OR x_debi = 'X' OR x_kredi = 'X'.

  PERFORM initialize_progress.
* ***************************************
* ***** tdelta is a global table !!!! ***
* ***************************************
  CLEAR: tdelta.
  REFRESH: tdelta.

  LOOP AT it001.
    PERFORM f070_bukrs USING it001 c_f070.                  "#EC *
  ENDLOOP.   " <-- Big loop over IT001

  IF NOT sy-batch  = 'X'.
    DESCRIBE TABLE tdelta LINES sy-tfill.
    CLEAR excute_tr.
    IF sy-tfill > 0.
      excute_tr = 1.
** BEGIN OF CHANGES                                    C5053256
      gv_tenth_cnt = gc_checked.
**      WRITE:/ sy-vline,
**              '@15@' AS ICON HOTSPOT,
**              'Repair Transaction Figures now ? Company Codes',
**              'with critical documents will not be affected',
**              115 sy-vline.
      HIDE excute_tr.
**      NEW-LINE.
**      ULINE (115).
** END OF CHANGES                                       C5053256
    ELSE.
** BEGIN OF CHANGES                                    C5053256
**      CLEAR : GV_TENTH_CNT.
**      WRITE:/ sy-vline,
**             'No repairable Differences found',
**              115 sy-vline.
**      NEW-LINE. ULINE (115).
** END OF CHANGES                                       C5053256
    ENDIF.
  ELSE.
    IF x_repvz = 'X'.
      PERFORM vz_korrigieren.
    ENDIF.
  ENDIF.
ENDFORM.                                                    "f070
* -------------------------------------------------------------------- *
* F070 compare an individual CC.
* -------------------------------------------------------------------- *
FORM f070_bukrs USING pit001 LIKE t001 compare_mode LIKE c_f070.
  DATA: datenow LIKE sy-datum,
        timenow LIKE sy-uzeit,
        minday LIKE sy-datum,
        maxday LIKE sy-datum,
        stop_flag TYPE i,
        shb TYPE c,
        canrep TYPE c,
        critbel TYPE ty_beln OCCURS 2 WITH HEADER LINE,  " Critical docs
        curtab TYPE ty_curtab OCCURS 2 WITH HEADER LINE, " Currency Info
        sb TYPE ty_trans OCCURS 100 WITH HEADER LINE,   " GLT0 from Docs
        db TYPE ty_trans OCCURS 100 WITH HEADER LINE,   " KNC1 from Docs
        kb TYPE ty_trans OCCURS 100 WITH HEADER LINE,   " LFC1 from Docs
        dsb TYPE ty_trans OCCURS 100 WITH HEADER LINE,  " KNC3 from Docs
        ksb TYPE ty_trans OCCURS 100 WITH HEADER LINE,  " LFC3 from Docs
        iskb1 TYPE ty_skb1 OCCURS 10 WITH HEADER LINE,
        iknb1 TYPE ty_knb1 OCCURS 10 WITH HEADER LINE,
        ilfb1 TYPE ty_lfb1 OCCURS 10 WITH HEADER LINE,
        error_f190 TYPE ty_err_f190 OCCURS 0 WITH HEADER LINE.

* **************************
* Store actual date/time now
* **************************
  GET TIME.
  datenow = sy-datum.
  timenow = sy-uzeit.
  stop_flag = false. " wird true wenn aktuell gebuchte Belege gefunden
* *********************************************************************
* Determine first and last day of the period range to check at cc level.
* In case of an error initial value will be returned -> Terminate check
* for this CC.
* *********************************************************************
  IF compare_mode NE c_fbila.                               "#EC *
    PERFORM get_min_max_day USING pit001 CHANGING minday maxday.
    IF minday IS INITIAL OR maxday IS INITIAL.
      EXIT.
    ENDIF.
  ENDIF.
  PERFORM stammsaetze_lesen TABLES iskb1 iknb1 ilfb1 USING it001. "#EC *

  PERFORM verkehrsz_lesen TABLES sb db kb dsb ksb curtab
                                 error_f190 iskb1 iknb1 ilfb1
                           USING pit001 compare_mode
                        CHANGING shb.

  CASE compare_mode.                                        "#EC *
    WHEN c_f070.                                            "#EC *
      PERFORM belege_lesen TABLES sb db kb dsb ksb curtab critbel
                            USING pit001 minday maxday
                                  datenow timenow shb
                         CHANGING stop_flag.                "#EC *
*      ******************************************************
*             remove entries without differences
*      ******************************************************
      to_xxb1 sb iskb1 saknr s missing_master_data_for_bseg_hkont.
      to_xxb1 db iknb1 kunnr d missing_master_data_for_bseg_kunnr.
      to_xxb1 dsb iknb1 kunnr d missing_master_data_for_bseg_kunnr.
      to_xxb1 kb ilfb1 lifnr k missing_master_data_for_bseg_lifnr.
      to_xxb1 ksb ilfb1 lifnr k missing_master_data_for_bseg_lifnr.

    WHEN c_f190.                                            "#EC *
      PERFORM indices_lesen TABLES sb db kb dsb ksb curtab
                                   error_f190 iskb1 iknb1 ilfb1
                             USING pit001 minday maxday shb.
  ENDCASE.


* ******************************************************************
* Compare Calculated Txn.Figs. to real Txn.Figs. / Balance analysis
* ******************************************************************
  CLEAR canrep. " Flag wird gesetzt, wenn Critbel[] initial ist

  IF stop_flag = false. " No Posting during run, only set in F070 mode

    DESCRIBE TABLE critbel LINES sy-tfill.
    IF sy-tfill = 0 AND compare_mode = c_f070.  "#EC * " No crit. docs.
      canrep = 'X'.
    ENDIF.

    PERFORM vergleichen TABLES sb db kb dsb ksb curtab
                         USING pit001 canrep shb compare_mode.
  ENDIF." <-- Stop_Flag  not set

  PERFORM konto_fehler_ausgeben TABLES error_f190.
  PERFORM write_crit_beln TABLES critbel.


ENDFORM.                                                    "F070_bukrs
* -------------------------------------------------------------------- *
* F070: Read the Transaction Figures to collect amounts
* -------------------------------------------------------------------- *
FORM verkehrsz_lesen TABLES sb STRUCTURE tvz
                            db STRUCTURE tvz
                            kb STRUCTURE tvz
                            dsb STRUCTURE tvz
                            ksb STRUCTURE tvz
                            curtab STRUCTURE no_curtab
                            error_f190 STRUCTURE no_err_f190
                            iskb1 STRUCTURE no_skb1
                            iknb1 STRUCTURE no_knb1
                            ilfb1 STRUCTURE no_lfb1
                      USING pit001 LIKE t001 compare_mode LIKE c_f070
                   CHANGING shb_flag TYPE c.
* *******************************************************
* Determine the ledgers to be checked / fill table curtab
* *******************************************************
  PERFORM ledger_lesen TABLES curtab USING pit001.
* *****************************************************
* Fill int. Txn Fig. tables over database Txn Fig.tables
* *****************************************************
  PERFORM vz_s_fill TABLES sb curtab USING pit001-bukrs compare_mode.
  to_xxb1 sb iskb1 saknr s missing_master_data_for_glt0_racct.
  LOOP AT sb.
    READ TABLE iskb1 WITH KEY saknr = sb-accnt BINARY SEARCH.
*    **********************************************
*    Posted with foreign currency and XSALH = 'X' ?
*    **********************************************
    IF sy-subrc = 0 AND iskb1-xsalh = 'X' AND sb-pswsl NE pit001-waers.
      error_f190-koart = 'S'.
      DATA buf(16) TYPE c VALUE 'XSALH=X_&_RTCUR='.
      DATA buf2(21) TYPE c.
      buf2 = sb-pswsl.
      CONCATENATE buf buf2 INTO buf2.
      error_f190-ermsg = buf2.
      error_f190-accnt = sb-accnt.
      COLLECT error_f190.
    ENDIF.
*    ******************************************
*    No line item display -> Not needed anymore
*    ******************************************
    IF compare_mode = c_f190 AND sy-subrc = 0.
      IF sy-subrc = 0 AND iskb1-xkres IS INITIAL.
        DELETE sb.
        CONTINUE.
      ENDIF.
    ENDIF.
  ENDLOOP.

  PERFORM vz_d_fill TABLES db USING pit001-bukrs compare_mode.
  to_xxb1 db iknb1 kunnr d missing_master_data_for_knc1_kunnr.
  PERFORM vz_k_fill TABLES kb USING pit001-bukrs compare_mode.
  to_xxb1 kb ilfb1 lifnr k missing_master_data_for_lfc1_lifnr.
* ********************************************************
* Can Sp.G/L Txn be checked. If yes, then read KNC3/LFC3 *
* ********************************************************
  PERFORM kann_shb_pruefen USING pit001-periv CHANGING shb_flag.
  IF shb_flag = 'X'.
    PERFORM vz_d_fill_shb TABLES dsb USING pit001-bukrs compare_mode.
    to_xxb1 dsb iknb1 kunnr d missing_master_data_for_knc3_kunnr.
    PERFORM vz_k_fill_shb TABLES ksb USING pit001-bukrs compare_mode.
    to_xxb1 ksb ilfb1 lifnr k missing_master_data_for_lfc3_lifnr.
  ENDIF.
ENDFORM.                    "Verkehrsz_lesen
* -------------------------------------------------------------------- *
* F070: Read the Indices to collect amounts
* -------------------------------------------------------------------- *
FORM indices_lesen TABLES sb STRUCTURE tvz
                          db STRUCTURE tvz
                          kb STRUCTURE tvz
                          dsb STRUCTURE tvz
                          ksb STRUCTURE tvz
                          curtab STRUCTURE no_curtab
                          error_f190 STRUCTURE no_err_f190
                          iskb1 STRUCTURE no_skb1
                          iknb1 STRUCTURE no_knb1
                          ilfb1 STRUCTURE no_lfb1
                   USING pit001 LIKE t001
                         minday LIKE sy-datum
                         maxday LIKE sy-datum
                         shb_flag TYPE c.

  DATA compare_mode LIKE c_f190.
  compare_mode = c_f190.
*  ****************************************************************
*  Read the BSIS/BSAS entries to build up transaction figures (G/L)
*  ****************************************************************

  IF x_sako = 'X'.
    PERFORM fill_f190s TABLES sb curtab
               USING pit001-bukrs minday maxday 'BSIS'.
    PERFORM fill_f190s TABLES sb curtab
               USING pit001-bukrs minday maxday 'BSAS'.
    PERFORM loeschen_pruefen_f190s TABLES sb iskb1 error_f190.
  ENDIF.

*  *****************************************************************
*  Read the BSID/BSAD entries to build up transaction figures (Cust)
*  *****************************************************************
  IF x_debi = 'X'.
    PERFORM fill_f190d TABLES db dsb
               USING pit001-bukrs minday maxday shb_flag 'BSID'.
    PERFORM fill_f190d TABLES db dsb
               USING pit001-bukrs minday maxday shb_flag 'BSAD'.

    to_xxb1 db iknb1 kunnr d missing_master_data_for_index_kunnr.
    to_xxb1 dsb iknb1 kunnr d missing_master_data_for_index_kunnr.

  ENDIF.

*  *****************************************************************
*  Read the BSIK/BSAK entries to build up transaction figures (Vend)
*  *****************************************************************
  IF x_kredi = 'X'.
    PERFORM fill_f190k TABLES kb ksb
               USING pit001-bukrs minday maxday shb_flag 'BSIK'.
    PERFORM fill_f190k TABLES kb ksb
               USING pit001-bukrs minday maxday shb_flag 'BSAK'.

    to_xxb1 kb ilfb1 lifnr k missing_master_data_for_index_lifnr.
    to_xxb1 ksb ilfb1 lifnr k missing_master_data_for_index_lifnr.

  ENDIF.

ENDFORM.                    "Indices_lesen
* -------------------------------------------------------------------- *
* F070: Read the documents to collect amounts
* -------------------------------------------------------------------- *
FORM belege_lesen TABLES sb STRUCTURE tvz
                         db STRUCTURE tvz
                         kb STRUCTURE tvz
                         dsb STRUCTURE tvz
                         ksb STRUCTURE tvz
                         curtab STRUCTURE no_curtab
                         critbel STRUCTURE h_beln
                   USING pit001 LIKE t001
                         minday LIKE sy-datum
                         maxday LIKE sy-datum
                         datenow LIKE sy-datum
                         timenow LIKE sy-uzeit
                         shb_flag TYPE c
                CHANGING stop_flag TYPE i.

  DATA: dcursor TYPE cursor,
        wa_bkpf TYPE ty_f070_bkpf,
        doc_used TYPE c.

* ************************
* Get the Cursor to BKPF *
* ************************
  PERFORM get_bkpf USING pit001-bukrs minday maxday CHANGING dcursor.
* ***************************************************************
* Loop over BKPF Cursor and build up calc. Txn. Figs. over BSEG *
* ***************************************************************
  DO.
*     ***************************************
*     assigning the cursor to the workarea
*     (bukrs is filled below)
*     ***************************************
    FETCH NEXT CURSOR dcursor INTO wa_bkpf.
    IF sy-subrc <> 0.
*        ********************************
*        the last entry is reached
*        -> exit do loop and close cursor
*        ********************************
      CLOSE CURSOR dcursor.
      EXIT.
    ENDIF.
    wa_bkpf-bukrs = pit001-bukrs.
*     **************************************************************
*     Collecting the amounts from the bseg-entries of one bkpf-entry
*     **************************************************************
    PERFORM vzb TABLES critbel curtab sb db kb dsb ksb
                 USING wa_bkpf shb_flag CHANGING doc_used.
    IF doc_used = 'X'.
*        **************************************************************
*        The document was needed for one of to accounts to be checked *
*        then check BKPF-CPUTM... . If this date/time is after        *
*        DATENOW/TIMENOW this is an exit condition                    *
*        **************************************************************
      PERFORM datum_pruefen USING pit001 wa_bkpf datenow timenow
                         CHANGING stop_flag.
      IF stop_flag = true.
        CLOSE CURSOR dcursor.
        EXIT.
      ENDIF.
    ENDIF.

  ENDDO.
ENDFORM.                    "Belege_lesen
* -------------------------------------------------------------------- *
* F070/190            Do the comparisons
* -------------------------------------------------------------------- *
FORM vergleichen TABLES sb STRUCTURE tvz
                        db STRUCTURE tvz
                        kb STRUCTURE tvz
                        dsb STRUCTURE tvz
                        ksb STRUCTURE tvz
                        curtab STRUCTURE no_curtab
                  USING pit001 LIKE t001
                        canrep TYPE c
                        shb TYPE c
                        from TYPE any.
  CASE from.
    WHEN c_f070 OR c_f190.
      IF x_debi = 'X'.
        PERFORM nb_vgl TABLES db curtab USING pit001 'KNC1' from canrep.
      ENDIF.

      IF x_kredi = 'X'.
        PERFORM nb_vgl TABLES kb curtab USING pit001 'LFC1' from canrep.
      ENDIF.

      IF x_sako = 'X'.
        PERFORM hb_vgl TABLES sb curtab USING pit001 canrep from 'A'.
      ENDIF.

      IF x_debi = 'X'.
        PERFORM shb_vgl TABLES dsb USING pit001 'KNC3' from canrep shb.
      ENDIF.

      IF x_kredi = 'X'.
        PERFORM shb_vgl TABLES ksb USING pit001 'LFC3' from canrep shb.
      ENDIF.
    WHEN c_fbila.
      IF x_sako = 'X'.
        PERFORM list_balance TABLES sb curtab USING pit001 'A' 'GLT0'.
      ENDIF.
      IF x_debi = 'X'.
        PERFORM list_balance TABLES db curtab USING pit001 'A' 'KNC1'.
        PERFORM list_balance TABLES dsb curtab USING pit001 'A' 'KNC3'.
      ENDIF.
      IF x_kredi = 'X'.
        PERFORM list_balance TABLES kb curtab USING pit001 'A' 'LFC1'.
        PERFORM list_balance TABLES ksb curtab USING pit001 'A' 'LFC3'.
      ENDIF.

  ENDCASE.
ENDFORM.                    "vergleichen
* -------------------------------------------------------------------- *
* F070: check date < start-time
* -------------------------------------------------------------------- *
FORM datum_pruefen USING pit001 LIKE t001
                         pbkpf  TYPE ty_f070_bkpf
                         datenow LIKE sy-datum
                         timenow LIKE sy-uzeit
                CHANGING pstop TYPE i.
  IF ( ( pbkpf-cpudt = datenow AND pbkpf-cputm > timenow ) OR
     ( pbkpf-cpudt > datenow ) ).
*       ***************************************************************
*       Found doc. line itm, that points to an accnt being checked with
*       a cputm/cpudt > actual date/time -> terminate check for this CC
*       ***************************************************************
**    NEW-LINE.ULINE (115).
    WRITE:/ sy-vline NO-GAP,
    (13) 'Buchungskreis'(388) COLOR COL_POSITIVE NO-GAP,
    (4)  pit001-bukrs COLOR COL_POSITIVE NO-GAP,
    (1) ' ' COLOR COL_POSITIVE NO-GAP,
    (95) pit001-butxt COLOR COL_POSITIVE NO-GAP,
    sy-vline NO-GAP.
    WRITE:/ sy-vline NO-GAP,
           (113) 'Lauf abgebrochen - es wurde w#hrend des Laufs gebucht'(389)
                  COLOR COL_NEGATIVE NO-GAP,
            sy-vline NO-GAP.
    FORMAT COLOR COL_NORMAL.
    WRITE:/ sy-vline NO-GAP,
            (12) 'Pr¨¹f-Datum:'(391) NO-GAP,
            datenow NO-GAP,
            (12) ' Pr¨¹f-Zeit'(392) NO-GAP,
            timenow NO-GAP,
            (68) ' Beleg der den Abbruch verursacht hat:'(390) NO-GAP,
            115 sy-vline NO-GAP.
    WRITE:/ sy-vline NO-GAP,
            (5)  pbkpf-bukrs NO-GAP,
            (11) pbkpf-belnr NO-GAP,
            (5)  pbkpf-gjahr NO-GAP,
            (10) pbkpf-cpudt NO-GAP,
            (1)  ' ' NO-GAP,
            (81)  pbkpf-cputm NO-GAP LEFT-JUSTIFIED,
            115 sy-vline.
**    NEW-LINE. ULINE (115).
    FORMAT COLOR OFF.
    pstop = true.
  ENDIF.

ENDFORM.                    "Datum_Pruefen

************************************************************************
* -------------------------------------------------------------------- *
*          Main Form to compare Indexes to Txn Figures.                *
* -------------------------------------------------------------------- *
************************************************************************

FORM f190.
  IF NOT sy-batch = 'X' AND x_sako IS INITIAL AND x_debi IS INITIAL
  AND x_kredi IS INITIAL.
    CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
      EXPORTING
        titel     = 'Es wird kein Konto gepr¨¹ft'(370)
        textline1 = 'Es mu# mindestens ein Konto selektiert werden'(371)
        textline2 = 'Bitte nicht vergessen eine Kontoart auszuw#hlen'(372).

  ENDIF.

  CHECK x_sako = 'X' OR x_debi = 'X' OR x_kredi = 'X'.

  PERFORM initialize_progress.

  LOOP AT it001.
    PERFORM f070_bukrs USING it001 c_f190.                  "#EC *
  ENDLOOP.   " <-- Big loop over IT001

ENDFORM.                                                    "f190
* -------------------------------------------------------------------- *
* F190: Check and Delete not needed G/L entries
* -------------------------------------------------------------------- *
FORM loeschen_pruefen_f190s TABLES sb STRUCTURE tvz
                                       iskb1 STRUCTURE no_skb1
                                       error_f190 STRUCTURE no_err_f190.
  LOOP AT sb.
*    ***********************************
*    No Difference -> not needed anymore
*    ***********************************
    IF sb-tslsd = 0 AND sb-hslsd = 0 AND sb-kslsd = 0 AND
       sb-tslhd = 0 AND sb-hslhd = 0 AND sb-kslhd = 0.
      DELETE sb.
      CONTINUE.
    ENDIF.

*    ******************************
*    Read the internal Master Table
*    ******************************
    READ TABLE iskb1 WITH KEY saknr = sb-accnt BINARY SEARCH.

*    *********************************************
*    Index found, but no line item display in SKB1
*    *********************************************
    IF sy-subrc = 0 AND iskb1-xkres IS INITIAL.
      error_f190-koart = 'S'.
      error_f190-ermsg = 'NO_LINE_ITEM_DISPLAY'.
      error_f190-accnt = sb-accnt.
      COLLECT error_f190.
      DELETE sb.
      CONTINUE.
    ENDIF.

*    *********************************
*    Index found, but no entry in SKB1
*    *********************************
    IF sy-subrc <> 0.
      error_f190-koart = 'S'.
      error_f190-ermsg = 'NO_SKB1_ENTRY_FOR_INDEX_HKONT'.
      error_f190-accnt = sb-accnt.
      COLLECT error_f190.
      DELETE sb.
    ENDIF.

  ENDLOOP.

ENDFORM.                    "Loeschen_Pruefen_f190s
* -------------------------------------------------------------------- *
*   F190: Write Acounts found without entries in SKB1 KNB1 LFB1.
* -------------------------------------------------------------------- *
FORM konto_fehler_ausgeben TABLES error_f190 STRUCTURE no_err_f190.
  DATA odd TYPE i.
  SORT error_f190 BY koart accnt ermsg.
  DESCRIBE TABLE error_f190 LINES sy-tfill.
  IF sy-tfill > 0.
* -------------------------------------------------------------------- *
** BEGIN of CHANGES                                            C5053256
* -------------------------------------------------------------------- *
**    FORMAT COLOR COL_HEADING.
**    FORMAT INTENSIFIED = odd.
**    NEW-LINE. ULINE (115).
**    WRITE :/ sy-vline NO-GAP,
**             'Critical Accounts (Koart/Accountno/Message)' NO-GAP,
    gv_head = text-338.
**             115 sy-vline NO-GAP.
**    NEW-LINE. ULINE (115).
* -------------------------------------------------------------------- *
** END of CHANGES                                              C5053256
* -------------------------------------------------------------------- *
  ENDIF.
  REFRESH : gt_outtab_doc3.
  LOOP AT error_f190.
**    FORMAT INTENSIFIED = odd.
**    AT NEW accnt.
**      FORMAT COLOR COL_KEY.
**      WRITE:/ sy-vline NO-GAP,
**              (1) error_f190-koart NO-GAP,
**              sy-vline NO-GAP,
**              (10) error_f190-accnt NO-GAP,
**              sy-vline NO-GAP.
**
**    ENDAT.
**    FORMAT COLOR COL_NORMAL.
**    DATA len TYPE i.
**    len = STRLEN( error_f190-ermsg ) .
**    len = len + 1.
**    WRITE: AT (len) error_f190-ermsg NO-GAP.
**
    CLEAR: gs_outtab_doc3, gt_outtab_doc3.
    MOVE : error_f190-koart  TO gs_outtab_doc3-koart,
           error_f190-accnt  TO gs_outtab_doc3-hkont,
           error_f190-ermsg  TO gs_outtab_doc3-err_msg.
    APPEND gs_outtab_doc3 TO gt_outtab_doc3.
    AT END OF accnt.
**      WRITE: 115 sy-vline.
      IF odd = 0. odd = 1. ELSE. odd = 0. ENDIF.
    ENDAT.
  ENDLOOP.
**  FORMAT COLOR OFF.
**  FORMAT INTENSIFIED ON.
**-----------------------------------------------------------**
** END OF CHANGES                                    C5053256
**-----------------------------------------------------------**
ENDFORM.                    "konto_fehler_ausgeben

* -------------------------------------------------------------------- *
*              F190 Fill from index site (G/L accnt)
* -------------------------------------------------------------------- *
FORM fill_f190s TABLES sb STRUCTURE tvz
                       curtab STRUCTURE no_curtab
                 USING bkrs LIKE bseg-bukrs
                       minday LIKE bkpf-budat
                       maxday LIKE bkpf-budat
                       name TYPE any.
  DATA: errors TYPE i,
        wa_bsis TYPE ty_bsxx.

  SELECT hkont gjahr gsber shkzg monat pswsl xnegp
         SUM( pswbt ) SUM( dmbtr ) SUM( dmbe2 ) SUM( dmbe3 )
    INTO (wa_bsis-accnt, wa_bsis-gjahr, wa_bsis-gsber,
          wa_bsis-shkzg, wa_bsis-monat, wa_bsis-pswsl,
          wa_bsis-xnegp, wa_bsis-pswbt, wa_bsis-dmbtr,
          wa_bsis-dmbe2, wa_bsis-dmbe3)
    FROM (name) WHERE bukrs = bkrs
                  AND hkont IN p_hkont
                  AND gjahr IN p_gjahr
                  AND monat IN p_monat
                  AND budat >= minday
                  AND budat <= maxday
                  AND bstat = space
     GROUP BY hkont gjahr pswsl gsber monat shkzg xnegp.
    IF sy-batch IS INITIAL.
      PERFORM execute_progress USING errors name.
    ENDIF.
    PERFORM sako_vz_bsxs TABLES sb curtab USING wa_bsis.
  ENDSELECT.
ENDFORM.                                                    "fill_f190s
* -------------------------------------------------------------------- *
*            F190 helper to select BSID/BSAD and BSIK/BSAK
* -------------------------------------------------------------------- *
DEFINE get_fill_sub.
* *****************
* &1 = KUNNR, LIFNR
* &2 = debi, kredi
* *****************
  select &1
         gjahr
         umskz
         shkzg
         bschl
         monat
         xnegp
         sum( dmbtr )
  into (wa_bsis-accnt,
        wa_bsis-gjahr,
        wa_bsis-umskz,
        wa_bsis-shkzg,
        wa_bsis-bschl,
        wa_bsis-monat,
        wa_bsis-xnegp,
        wa_bsis-dmbtr)
  from (name) where bukrs = bkrs
              and &1 in p_&1
              and gjahr in p_gjahr
              and monat in p_monat
              and budat >= minday
              and budat <= maxday
              and bstat = space
    group by &1 gjahr umskz monat shkzg bschl xnegp.
*      ******* Get the information for Sales *******
    if wa_bsis-bschl ne save_bschl.
      clear save_bschl.
      read table itbsl with key bschl = wa_bsis-bschl binary search.
      if sy-subrc = 0.
        save_bschl = itbsl-bschl.
      endif.
    endif.
    if not save_bschl is initial.
      wa_bsis-xumsw = itbsl-xumsw.
    endif.
*      *********************************************
    if sy-batch is initial.
      perform execute_progress using errors name.
    endif.
    if wa_bsis-umskz is initial.
      perform nb_vz_bsxi tables sb using wa_bsis.
    elseif shb = 'X'.
      perform nb_vz_bsxi tables ssb using wa_bsis.
    endif.
  endselect.


END-OF-DEFINITION.
* -------------------------------------------------------------------- *
*              F190 Fill from index site (customers)
* -------------------------------------------------------------------- *
FORM fill_f190d TABLES sb STRUCTURE tvz
                       ssb STRUCTURE tvz
                 USING bkrs LIKE bseg-bukrs
                       minday LIKE bkpf-budat
                       maxday LIKE bkpf-budat
                       shb TYPE c
                       name TYPE any.
  DATA: errors TYPE i,
       wa_bsis TYPE ty_bsxx,
       save_bschl LIKE bseg-bschl.
  get_fill_sub kunnr.

ENDFORM.                                                    "fill_f190d
* -------------------------------------------------------------------- *
*              F190 Fill from index site (vendors)
* -------------------------------------------------------------------- *
FORM fill_f190k TABLES sb STRUCTURE tvz
                       ssb STRUCTURE tvz
                 USING bkrs LIKE bseg-bukrs
                       minday LIKE bkpf-budat
                       maxday LIKE bkpf-budat
                       shb TYPE c
                       name TYPE any.
  DATA: errors TYPE i,
       wa_bsis TYPE ty_bsxx,
       save_bschl LIKE bseg-bschl.
  get_fill_sub lifnr.

ENDFORM.                                                    "fill_f190k

* -------------------------------------------------------------------- *
*                 Can Sp.G/L.Txn.Figs. be checked
* -------------------------------------------------------------------- *
FORM kann_shb_pruefen USING periv LIKE t001-periv
                           CHANGING shbflag TYPE c.
* Bedingung: alle Perioden von 1-RPMAX m¨¹ssen innerhalb des ¨¹ber
* p_monat vom Benutzer angegeben Bereichs liegen ->SonderhauptVZ k#nnen
* nur f¨¹r komplette Gesch#ftsjahre gepr¨¹ft werden !!!
* Wenn die Bedingung erf¨¹llt ist, dann wird 'X' zur¨¹ckgegeben
* andernfalls der Initial-Wert
  DATA: rpmax LIKE glt0-rpmax VALUE 16.
  PERFORM get_rpmax USING periv
                    CHANGING rpmax.
  IF  ( 01 IN p_monat OR 01 > rpmax ) AND
      ( 02 IN p_monat OR 02 > rpmax ) AND
      ( 03 IN p_monat OR 03 > rpmax ) AND
      ( 04 IN p_monat OR 04 > rpmax ) AND
      ( 05 IN p_monat OR 05 > rpmax ) AND
      ( 06 IN p_monat OR 06 > rpmax ) AND
      ( 07 IN p_monat OR 07 > rpmax ) AND
      ( 08 IN p_monat OR 08 > rpmax ) AND
      ( 09 IN p_monat OR 09 > rpmax ) AND
      ( 10 IN p_monat OR 10 > rpmax ) AND
      ( 11 IN p_monat OR 11 > rpmax ) AND
      ( 12 IN p_monat OR 12 > rpmax ) AND
      ( 13 IN p_monat OR 13 > rpmax ) AND
      ( 14 IN p_monat OR 14 > rpmax ) AND
      ( 15 IN p_monat OR 15 > rpmax ) AND
      ( 16 IN p_monat OR 16 > rpmax ).
    shbflag = 'X'.
  ELSE.
    CLEAR shbflag.
  ENDIF.
ENDFORM.                    "kann_shb_pruefen
* -------------------------------------------------------------------- *
*                F070: Write Critical Documents                        *
* -------------------------------------------------------------------- *
FORM write_crit_beln TABLES critbel STRUCTURE h_beln.
  SORT critbel BY bukrs belnr gjahr.
  STATICS: old_tfill LIKE sy-tfill.
  DESCRIBE TABLE critbel LINES sy-tfill.
**-------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**-------------------------------------------------------------------**
  REFRESH : gt_outtab_doc4.
  IF sy-tfill > 0.
**    NEW-LINE.
**    ULINE (115).
**    WRITE:/ sy-vline NO-GAP,
**  (113)
** 'Documents without Bseg or unbalanced Documents, Repair not possible'
**                                         COLOR COL_NEGATIVE NO-GAP,
**    sy-vline NO-GAP.
**    NEW-LINE.
**    ULINE (115).
    move 'Belege ohne Positionen oder nicht saldiwerende Belege gefunden, Reparartur nicht m#glich'(393)
    TO gv_head.
    LOOP AT critbel.
      CLEAR   : gt_outtab_doc4, gs_outtab_doc4.
**      WRITE:/ sy-vline NO-GAP COLOR COL_NORMAL,
**              (5) critbel-bukrs COLOR COL_NORMAL NO-GAP,
**              (11) critbel-belnr COLOR COL_NORMAL NO-GAP,
**              (5) critbel-gjahr COLOR COL_NORMAL NO-GAP,
**              (92) critbel-ertxt COLOR COL_NORMAL NO-GAP,
**              115 sy-vline COLOR COL_NORMAL NO-GAP.
      MOVE : critbel-bukrs  TO  gs_outtab_doc4-bukrs,
             critbel-belnr  TO  gs_outtab_doc4-belnr,
             critbel-gjahr  TO  gs_outtab_doc4-gjahr,
             critbel-ertxt  TO  gs_outtab_doc4-err_msg.
      APPEND gs_outtab_doc4 TO  gt_outtab_doc4.
    ENDLOOP.

**    NEW-LINE.
**    ULINE (115).
**
  ELSE.
**    NEW-LINE.
**    ULINE (115).
    DESCRIBE TABLE tdelta LINES sy-tfill.
    IF sy-tfill > old_tfill.
      old_tfill = sy-tfill.
**      WRITE:/ sy-vline NO-GAP,
**     (113) 'No critical Documents found. Repair is possible'
**                               COLOR COL_POSITIVE NO-GAP,
**      sy-vline NO-GAP.
**      NEW-LINE.
**      ULINE (115).
      CLEAR : gs_outtab_doc4, gt_outtab_doc4.
      MOVE 'Keine kritischen Belege gefunden, Reparatur m#glich'(394)
         TO  gv_head_1.
**      APPEND gs_outtab_doc4  TO gt_outtab_doc4.
**-------------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**-------------------------------------------------------------------**
    ENDIF.
  ENDIF.
ENDFORM.                    "write_crit_beln

* -------------------------------------------------------------------- *
*            F070: Determine Ledgers used by a given CC                *
* -------------------------------------------------------------------- *
FORM ledger_lesen TABLES curtab STRUCTURE no_curtab
                   USING  pit001 LIKE t001.

  CLEAR curtab. REFRESH curtab.
  DATA:
*        curt LIKE t001a-curtp OCCURS 3 WITH HEADER LINE,"#EC NEEDED
        xgledtab LIKE gledtab OCCURS 2 WITH HEADER LINE,
*        savetabix LIKE sy-tabix,"#EC NEEDED
*        curtab_wa LIKE curtab,
        ls_x001 TYPE x001,
        ld_tabix LIKE sy-tabix.

  CALL FUNCTION 'FI_CURRENCY_INFORMATION'
    EXPORTING
      i_bukrs                = pit001-bukrs
      i_land1                = pit001-land1
      i_rcomp                = pit001-rcomp
    IMPORTING
      e_x001                 = ls_x001
    EXCEPTIONS
      currency_2_not_defined = 1
      currency_3_not_defined = 2
      OTHERS                 = 3.
  IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

* Curtab:
*         rldnr LIKE glt0-rldnr,
*         usetsl TYPE i,
*         usehsl TYPE i,
*         useksl TYPE i,
*         map1 TYPE i,
*         map2 TYPE i,
*         map3 TYPE i,
*         curr1 LIKE t882-curr1,
*         curr2 LIKE t882-curr2,
*         curt1 LIKE t001a-curtp,
*         curt2 LIKE t001a-curtp,

* X001:
*BUKRS
*BASW2
*BASW3
*KUTY2
*KUTY3
*HWAE2
*HWAE3
*UMRD2
*UMRD3
*CURT2
*CURT3





* Kurstyp 10 ist Hausw#hrung, immer auf DMBTR <-> Ledger 00 / HSL*
* Kurstyp 30 ist Konzernw#hrung, immer auf DMBE2 <-> Ledger 00 / KSL*
* Kurstyp ??:
* DMBE3 <-> Ledger ?? / KSL oder HSL -> 'G_GIVE_LEDGERS_FOR_GLT0'
* -> Index 1 aus Ergebnistabelle gef¨¹llt von 'G_GIVE_LEDGERS_FOR_GLT0'
* DMBE3 <-> Ledger = XGLEDTAB-RLDNR aber auf HSL- oder KSL-Felder ?
* Antwort: entsprechend XGLEDTAB-CURRNUMBER (2 = HSL 3 = KSL)
* Welche Felder werden ¨¹berhaupt gebraucht:
* PSWBT immer
* DMBTR immer
* DMBE2, wenn T001A-CURTP nicht initial ist
* DMBE3, wenn T001A-CURTP2 nicht initial ist
* CURTAB: MAPDMBE1-3: Wertebereich (2=HSL und 3=KSL)
* Pro ledgernummer eine Zeile:
* -> bseg-dmb*-felder werden f¨¹r das jeweilige Ledger auf HSL oder
*    KSL Felder in der GLT0 abgebildet.
* Zuordnung gilt jeweils pro Ledger:
* curtab-map1: (=2) DMBTR auf HSL Felder
* curtab-map1: (=3) DMBTR auf KSL Felder

* curtab-map2: (=2) DMBE2 auf HSL Felder
* curtab-map2: (=3) DMBE2 auf KSL Felder

* curtab-map3: (=2) DMBE3 auf HSL Felder
* curtab-map3: (=3) DMBE3 auf KSL Felder

*   Ledger '00' aubauen
  CLEAR curtab.
  curtab-rldnr = '00'.
  curtab-usetsl = 1.
  curtab-usehsl = 1.
  curtab-map1 = 2.
  curtab-curr1 = it001-waers.
  curtab-curt1 = '10'.
  IF ls_x001-curt2 = '30'.
    curtab-useksl = 1.
    curtab-curt2 = '30'.
    curtab-map2  = 3.
    curtab-curr2 = ls_x001-hwae2.
  ENDIF.
  IF ls_x001-curt3 = '30'.
    curtab-useksl = 1.
    curtab-curt2 = '30'.
    curtab-curr2 = ls_x001-hwae3.
    curtab-map3  = 3.
  ENDIF.
  APPEND curtab.
* Andere Ledger:
  IF ls_x001-curt2 NE '00' AND
     ls_x001-curt2 NE '10' AND
     ls_x001-curt2 NE '30' AND
     ls_x001-curt2 NE space AND
     NOT ls_x001-curt2 IS INITIAL.
*   2.Hausw#hrung:
    CLEAR xgledtab. REFRESH xgledtab.
    CALL FUNCTION 'G_GIVE_LEDGERS_FOR_GLT0'
      EXPORTING
        bukrs  = pit001-bukrs
        curtp  = ls_x001-curt2
      TABLES
        ledtab = xgledtab.
    DESCRIBE TABLE xgledtab LINES sy-tfill.
    IF sy-tfill GE 1.
      SORT xgledtab.
      READ TABLE xgledtab INDEX 1.
      CLEAR curtab.
      CLEAR ld_tabix.
      READ TABLE curtab WITH KEY rldnr = xgledtab-rldnr.
      IF sy-subrc = 0.
        ld_tabix = sy-tabix.
      ENDIF.
      curtab-rldnr = xgledtab-rldnr.
      IF xgledtab-currnumber = 3.
*       Betr#ge stehen in den KSL-Feldern
*        -> KSL verwenden
        curtab-useksl = 1.
*        -> DMBE2 ist auf KSL-Feldern abgebildet
        curtab-map2  = 3.
*       W#hrungstyp / W#hrung der KSL-Felder (KSL auf CURT2/CURR2 aus
*       aus der HW2 ¨¹bernommen
        curtab-curt2 = ls_x001-curt2.
        curtab-curr2 = ls_x001-hwae2.

      ELSEIF xgledtab-currnumber = 2.
*       Betr#ge stehen in den HSL-Feldern
*        -> HSL verwenden
        curtab-usehsl = 1.
*        -> DMBE2 ist auf HSL-Feldern abgebildet
        curtab-map2  = 2.
*       W#hrungstyp / W#hrung der HSL-Felder (HSL auf CURT1/CURR1 aus
*       aus der HW2 ¨¹bernommen
        curtab-curt1 = ls_x001-curt2.
        curtab-curr1 = ls_x001-hwae2.
      ENDIF.

      IF ld_tabix GT 0.
        MODIFY curtab INDEX ld_tabix.
      ELSE.
        APPEND curtab.
      ENDIF.
    ENDIF.
  ENDIF.
  IF ls_x001-curt3 NE '00' AND
     ls_x001-curt3 NE '10' AND
     ls_x001-curt3 NE '30' AND
     ls_x001-curt3 NE space AND
     NOT ls_x001-curt3 IS INITIAL.
*   3.Hausw#hrung:
    CLEAR xgledtab. REFRESH xgledtab.
    CALL FUNCTION 'G_GIVE_LEDGERS_FOR_GLT0'
      EXPORTING
        bukrs  = pit001-bukrs
        curtp  = ls_x001-curt3
      TABLES
        ledtab = xgledtab.
    DESCRIBE TABLE xgledtab LINES sy-tfill.
    IF sy-tfill GE 1.
      SORT xgledtab.
      READ TABLE xgledtab INDEX 1.
      CLEAR curtab.
      CLEAR ld_tabix.
      READ TABLE curtab WITH KEY rldnr = xgledtab-rldnr.
      IF sy-subrc = 0.
        ld_tabix = sy-tabix.
      ENDIF.
      curtab-rldnr = xgledtab-rldnr.
      IF xgledtab-currnumber = 3.
*       Betr#ge stehen in den KSL-Feldern
*        -> KSL verwenden
        curtab-useksl = 1.
*        -> DMBE3 ist auf KSL-Feldern abgebildet
        curtab-map3  = 3.
*       W#hrungstyp / W#hrung der KSL-Felder (KSL auf CURT2/CURR2 aus
*       aus der HW3 ¨¹bernommen
        curtab-curt2 = ls_x001-curt3.
        curtab-curr2 = ls_x001-hwae3.

      ELSEIF xgledtab-currnumber = 2.
*       Betr#ge stehen in den HSL-Feldern
*        -> HSL verwenden
        curtab-usehsl = 1.
*        -> DMBE3 ist auf HSL-Feldern abgebildet
        curtab-map3  = 2.
*       W#hrungstyp / W#hrung der HSL-Felder (HSL auf CURT1/CURR1 aus
*       aus der HW3 ¨¹bernommen
        curtab-curt1 = ls_x001-curt3.
        curtab-curr1 = ls_x001-hwae3.
      ENDIF.
      IF ld_tabix GT 0.
        MODIFY curtab INDEX ld_tabix.
      ELSE.
        APPEND curtab.
      ENDIF.
    ENDIF.
  ENDIF.
*
*
*  curt = '10'.
*  APPEND curt.
*
*  SELECT SINGLE * FROM t001a WHERE bukrs = pit001-bukrs.
*  IF sy-subrc = 0.
*    IF NOT t001a-curtp IS INITIAL.
*      curt = t001a-curtp.
*      APPEND curt.
*    ENDIF.
*    IF NOT t001a-curtp2 IS INITIAL.
*      curt = t001a-curtp2.
*      APPEND curt.
*    ENDIF.
*  ENDIF.
** ab hier sind die maximal 3 Kurstypen bekannt.
*  LOOP AT curt.
*    CLEAR curtab.
*    savetabix = sy-tabix.
*    IF curt = '10'.
*      curtab-rldnr = '00'.
*      curtab-usetsl = 1.
*      curtab-usehsl = 1.
*      curtab-map1 = 2.
*      curtab-curr1 = it001-waers.
*      curtab-curt1 = curt.
**      bukrs_waers-HW1 = it001-waers.
*      COLLECT curtab.
*      CONTINUE.
*    ENDIF.
*    IF curt = '30'.
*      READ TABLE curtab INDEX 1.
*      SELECT SINGLE curr2 INTO t882-curr2
*                          FROM t882 WHERE bukrs = it001-bukrs
*                                      AND rldnr = '00'.
*      IF sy-subrc = 0.
**        bukrs_waers-HW2 = t882-curr2.
*        curtab-curr2 = t882-curr2.
*        curtab-curt2 = curt.
*        curtab-rldnr = '00'.
*        curtab-useksl = 1.
*        IF savetabix = 2.
*          curtab-map2 = 3.
*        ELSE.
*          curtab-map3 = 3.
*        ENDIF.
*        MODIFY curtab INDEX 1.
*      ENDIF.
*      CONTINUE.
*    ENDIF.
*    CALL FUNCTION 'G_GIVE_LEDGERS_FOR_GLT0'
*      EXPORTING
*        bukrs  = pit001-bukrs
*        curtp  = curt
*      TABLES
*        ledtab = xgledtab.
**   wenn mehrere Legders vorhanden - nimm das erste
*    DESCRIBE TABLE xgledtab LINES sy-tfill.
*    IF sy-tfill GT 1. SORT xgledtab. ENDIF.
*    READ TABLE xgledtab INDEX 1.
**   wenn kein ledger gef¨¹hrt wird muss das reported werden
*    IF sy-tfill = 0.
*      WRITE:/ 'Company Code', pit001-bukrs,
*              'No Ledger found for Currency Type', curt.
*      EXIT.
*    ENDIF.
*    READ TABLE curtab WITH KEY rldnr =  xgledtab-rldnr.
*
*
*
*
*    curtab-rldnr = xgledtab-rldnr.
*
*    SELECT SINGLE curr1 curr2 INTO (t882-curr1, t882-curr2) FROM t882
*                                            WHERE bukrs = it001-bukrs
*                                             AND rldnr = xgledtab-rldnr
*  .
*
*
*
*    IF savetabix = 2.
*
*      curtab-map2 = xgledtab-currnumber.
*      IF xgledtab-currnumber = 3.
*        curtab-useksl = 1.
*        curtab-curr2 = t882-curr2.
*        curtab-curt2 = curt.
*      ELSEIF xgledtab-currnumber = 2.
*        curtab-curr1 = t882-curr1.
*        curtab-curt1 = curt.
*        curtab-usehsl = 1.
*      ENDIF.
*    ENDIF.
*    IF savetabix = 3.
*      curtab-map3 = xgledtab-currnumber.
*      IF xgledtab-currnumber = 3.
*        curtab-curr2 = t882-curr2.
*        curtab-curt2 = curt.
*        curtab-useksl = 1.
*      ELSEIF xgledtab-currnumber = 2.
*        curtab-curr1 = t882-curr1.
*        curtab-curt1 = curt.
*        curtab-usehsl = 1.
*      ENDIF.
*    ENDIF.
*    curtab_wa = curtab.
*    DELETE curtab WHERE rldnr = curtab_wa-rldnr.
*    curtab = curtab_wa.
*    COLLECT curtab.
*  ENDLOOP.
* BUKRS_CURTAB[] = curtab[].
  SORT curtab BY rldnr.
* sort BUKRS_CURTAB by rldnr.
ENDFORM.                    "ledger_lesen

* -------------------------------------------------------------------- *
*            F070: Determine Ledgers used by a given CC                *
* -------------------------------------------------------------------- *
*FORM ledger_lesen_alt TABLES curtab STRUCTURE no_curtab
*                   USING  pit001 LIKE t001.
*  CLEAR curtab. REFRESH curtab.
*  DATA: curt LIKE t001a-curtp OCCURS 3 WITH HEADER LINE,
*        xgledtab LIKE gledtab OCCURS 2 WITH HEADER LINE,
*        savetabix LIKE sy-tabix,
*        curtab_wa LIKE curtab.
** Kurstyp 10 ist Hausw#hrung, immer auf DMBTR <-> Ledger 00 / HSL*
** Kurstyp 30 ist Konzernw#hrung, immer auf DMBE2 <-> Ledger 00 / KSL*
** Kurstyp ??:
** DMBE3 <-> Ledger ?? / KSL oder HSL -> 'G_GIVE_LEDGERS_FOR_GLT0'
** -> Index 1 aus Ergebnistabelle gef¨¹llt von 'G_GIVE_LEDGERS_FOR_GLT0'
** DMBE3 <-> Ledger = XGLEDTAB-RLDNR aber auf HSL- oder KSL-Felder ?
** Antwort: entsprechend XGLEDTAB-CURRNUMBER (2 = HSL 3 = KSL)
** Welche Felder werden ¨¹berhaupt gebraucht:
** PSWBT immer
** DMBTR immer
** DMBE2, wenn T001A-CURTP nicht initial ist
** DMBE3, wenn T001A-CURTP2 nicht initial ist
** CURTAB: MAPDMBE1-3: Wertebereich (2=HSL und 3=KSL)
** Pro ledgernummer eine Zeile:
** -> bseg-dmb*-felder werden f¨¹r das jeweilige Ledger auf HSL oder
**    KSL Felder in der GLT0 abgebildet.
** Zuordnung gilt jeweils pro Ledger:
** curtab-map1: (=2) DMBTR auf HSL Felder
** curtab-map1: (=3) DMBTR auf KSL Felder
*
** curtab-map2: (=2) DMBE2 auf HSL Felder
** curtab-map2: (=3) DMBE2 auf KSL Felder
*
** curtab-map3: (=2) DMBE3 auf HSL Felder
** curtab-map3: (=3) DMBE3 auf KSL Felder
*
*  curt = '10'.
*  APPEND curt.
*  SELECT SINGLE * FROM t001a WHERE bukrs = pit001-bukrs.
*  IF sy-subrc = 0.
*    IF NOT t001a-curtp IS INITIAL.
*      curt = t001a-curtp.
*      APPEND curt.
*    ENDIF.
*    IF NOT t001a-curtp2 IS INITIAL.
*      curt = t001a-curtp2.
*      APPEND curt.
*    ENDIF.
*  ENDIF.
** ab hier sind die maximal 3 Kurstypen bekannt.
*  LOOP AT curt.
*    CLEAR curtab.
*    savetabix = sy-tabix.
*    IF curt = '10'.
*      curtab-rldnr = '00'.
*      curtab-usetsl = 1.
*      curtab-usehsl = 1.
*      curtab-map1 = 2.
*      curtab-curr1 = it001-waers.
*      curtab-curt1 = curt.
**      bukrs_waers-HW1 = it001-waers.
*      COLLECT curtab.
*      CONTINUE.
*    ENDIF.
*    IF curt = '30'.
*      READ TABLE curtab INDEX 1.
*      SELECT SINGLE curr2 INTO t882-curr2
*                          FROM t882 WHERE bukrs = it001-bukrs
*                                      AND rldnr = '00'.
*      IF sy-subrc = 0.
**        bukrs_waers-HW2 = t882-curr2.
*        curtab-curr2 = t882-curr2.
*        curtab-curt2 = curt.
*        curtab-rldnr = '00'.
*        curtab-useksl = 1.
*        IF savetabix = 2.
*          curtab-map2 = 3.
*        ELSE.
*          curtab-map3 = 3.
*        ENDIF.
*        MODIFY curtab INDEX 1.
*      ENDIF.
*      CONTINUE.
*    ENDIF.
*    CALL FUNCTION 'G_GIVE_LEDGERS_FOR_GLT0'
*      EXPORTING
*        bukrs  = pit001-bukrs
*        curtp  = curt
*      TABLES
*        ledtab = xgledtab.
**   wenn mehrere Legders vorhanden - nimm das erste
*    DESCRIBE TABLE xgledtab LINES sy-tfill.
*    IF sy-tfill GT 1. SORT xgledtab. ENDIF.
*    READ TABLE xgledtab INDEX 1.
**   wenn kein ledger gef¨¹hrt wird muss das reported werden
*    IF sy-tfill = 0.
*      WRITE:/ 'Company Code', pit001-bukrs,
*              'No Ledger found for Currency Type', curt.
*      EXIT.
*    ENDIF.
*    READ TABLE curtab WITH KEY rldnr =  xgledtab-rldnr.
*
*    data ls_x001 type X001.
*    CALL FUNCTION 'FI_CURRENCY_INFORMATION'
*      EXPORTING
*        i_bukrs                      = pit001-bukrs
**       I_LAND1                      = ' '
**       I_RCOMP                      = ' '
*     IMPORTING
*       E_X001                       = ls_x001
*     EXCEPTIONS
*       CURRENCY_2_NOT_DEFINED       = 1
*       CURRENCY_3_NOT_DEFINED       = 2
*       OTHERS                       = 3
*              .
*    IF sy-subrc <> 0.
** MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
**         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
*    ENDIF.
*
*
*    curtab-rldnr = xgledtab-rldnr.
*
*    SELECT SINGLE curr1 curr2 INTO (t882-curr1, t882-curr2) FROM t882
*                                            WHERE bukrs = it001-bukrs
*                                             AND rldnr = xgledtab-
* rldnr.
*
*
*
*    IF savetabix = 2.
*
*      curtab-map2 = xgledtab-currnumber.
*      IF xgledtab-currnumber = 3.
*        curtab-useksl = 1.
*        curtab-curr2 = t882-curr2.
*        curtab-curt2 = curt.
*      ELSEIF xgledtab-currnumber = 2.
*        curtab-curr1 = t882-curr1.
*        curtab-curt1 = curt.
*        curtab-usehsl = 1.
*      ENDIF.
*    ENDIF.
*    IF savetabix = 3.
*      curtab-map3 = xgledtab-currnumber.
*      IF xgledtab-currnumber = 3.
*        curtab-curr2 = t882-curr2.
*        curtab-curt2 = curt.
*        curtab-useksl = 1.
*      ELSEIF xgledtab-currnumber = 2.
*        curtab-curr1 = t882-curr1.
*        curtab-curt1 = curt.
*        curtab-usehsl = 1.
*      ENDIF.
*    ENDIF.
*    curtab_wa = curtab.
*    DELETE curtab WHERE rldnr = curtab_wa-rldnr.
*    curtab = curtab_wa.
*    COLLECT curtab.
*  ENDLOOP.
** BUKRS_CURTAB[] = curtab[].
*  SORT curtab BY rldnr.
** sort BUKRS_CURTAB by rldnr.
*ENDFORM.                    "ledger_lesen
*
* -------------------------------------------------------------------- *
*              F070: Write a GLT0-Difference                           *
* -------------------------------------------------------------------- *
FORM write_f070_sako TABLES curtab STRUCTURE no_curtab
                      USING tb TYPE ty_trans
                            ii TYPE i
                            level TYPE c.                   "#EC NEEDED
  DATA: b LIKE huge_amount,
        v LIKE huge_amount,
        ld LIKE huge_amount,
        sh TYPE c,
        thk(7) TYPE c,
        mo(2) TYPE c,
        cc TYPE i,
        waers LIKE bkpf-waers.
  STATICS: s_curtab LIKE no_curtab.
*  STATICS: current_account LIKE bseg-hkont VALUE c_init_accnt_no."#EC NEEDED
*  STATICS: current_rldnr LIKE glt0-rldnr VALUE '__'."#EC NEEDED
*  STATICS: current_year LIKE bseg-gjahr VALUE '0000'."#EC NEEDED
*  STATICS: current_gsber LIKE bseg-gsber VALUE '____'."#EC NEEDED
*  STATICS: current_pswsl LIKE bseg-pswsl VALUE '____'.

  IF tb-accnt = c_init_accnt_no.
*    current_account = c_init_accnt_no.
*    current_rldnr = '__'.
*    current_year = '0000'.
*    current_gsber = '____'.
*    current_pswsl = '____'.
    EXIT.
  ENDIF.
***************************************************


  IF s_curtab-rldnr NE tb-rldnr.
    READ TABLE curtab WITH KEY rldnr = tb-rldnr.
    IF sy-subrc = 0.
      s_curtab = curtab.
    ENDIF.
  ENDIF.
  mo = tb-monat.
  IF tb-monat IS INITIAL.
    mo = '**'.
  ENDIF.
  CASE ii.
    WHEN 1.
      b = tb-tslsb.v = tb-tslsv.sh = 'S'.thk = 'TSL'.ld = tb-tslsd. cc = 1.
    WHEN 2.
      b = tb-hslsb.v = tb-hslsv.sh = 'S'.thk = 'HSL'.ld = tb-hslsd. cc = 4.
    WHEN 3.
      b = tb-kslsb.v = tb-kslsv.sh = 'S'.thk = 'KSL'.ld = tb-kslsd. cc = 4.
    WHEN 4.
      b = tb-tslhb.v = tb-tslhv.sh = 'H'.thk = 'TSL'.ld = tb-tslhd. cc = 1.
    WHEN 5.
      b = tb-hslhb.v = tb-hslhv.sh = 'H'.thk = 'HSL'.ld = tb-hslhd. cc = 4.
    WHEN 6.
      b = tb-kslhb.v = tb-kslhv.sh = 'H'.thk = 'KSL'.ld = tb-kslhd. cc = 4.
  ENDCASE.
  CASE thk.
    WHEN 'TSL'.
      waers = tb-pswsl.
    WHEN 'HSL'.
      waers = s_curtab-curr1.
    WHEN 'KSL'.
      waers = s_curtab-curr2.
  ENDCASE.
  CONCATENATE thk mo INTO thk.
  FORMAT COLOR = cc.
  IF ii = 3 OR ii = 6 OR ii = 1 OR ii = 4.
    FORMAT INTENSIFIED OFF.
  ENDIF.
**--------------------------------------------------------**
** BEGIN OF CHANGES                               C5053256
**--------------------------------------------------------**
  CLEAR : gt_outtab_doc2, gs_outtab_doc2.
* highest level, rests all sublevels.
**  IF current_account NE tb-accnt
**  OR current_rldnr NE tb-rldnr
**  OR current_year NE tb-gjahr
**  OR current_gsber NE tb-gsber
**  OR current_pswsl NE tb-pswsl.
**    IF current_account NE tb-accnt.
**      NEW-LINE. ULINE (115).
**    ENDIF.
**    WRITE:/ sy-vline NO-GAP.
**    WRITE:  tb-accnt NO-GAP.
**    WRITE 13(5) tb-rldnr NO-GAP.
**    WRITE 19(5) tb-gjahr NO-GAP.
**    WRITE 25(5) tb-gsber NO-GAP.
**    WRITE 31(5) tb-pswsl NO-GAP.
**  ELSE.
**    WRITE:/ sy-vline NO-GAP.
**  ENDIF.

**  IF current_account NE tb-accnt.
**    current_account = tb-accnt.
**    current_rldnr = '__'.
**    current_year = '0000'.
**    current_gsber = '____'.
**    current_pswsl = '____'.
**  ENDIF.
**  IF current_rldnr NE tb-rldnr.
**    current_rldnr = tb-rldnr.
**
**    current_year = '0000'.
**    current_gsber = '____'.
**    current_pswsl = '____'.
**  ENDIF.
**  IF current_year NE tb-gjahr.
**    current_year = tb-gjahr.
**
**    current_gsber = '____'.
**    current_pswsl = '____'.
**  ENDIF.
**  IF current_gsber NE tb-gsber.
**    current_gsber = tb-gsber.
**
**    current_pswsl = '____'.
**  ENDIF.
**  IF current_pswsl NE tb-pswsl.
**    current_pswsl = tb-pswsl.
**
**  ENDIF.
  CONCATENATE thk '_' sh INTO thk.
**  WRITE:
**    37(9) thk NO-GAP, sy-vline NO-GAP.
**
**  IF sh = 'S'.
**    FORMAT INTENSIFIED ON.
**  ELSE.
**    FORMAT INTENSIFIED OFF.
**  ENDIF.
**  IF level = 'A'.
**    FORMAT COLOR COL_NORMAL.
**  ELSE.
**    FORMAT COLOR COL_TOTAL.
**  ENDIF.
**  WRITE:
**      (22) b NO-GAP CURRENCY waers, sy-vline NO-GAP,
**      (22) v NO-GAP CURRENCY waers, sy-vline NO-GAP,
**      (22) d NO-GAP CURRENCY waers, sy-vline NO-GAP.
**  FORMAT INTENSIFIED ON.
**  FORMAT COLOR OFF.
  MOVE : gs_outtab_doc1-bukrs    TO gs_outtab_doc2-bukrs,
         gs_outtab_doc1-b_tbl    TO gs_outtab_doc2-b_tbl,
         gs_outtab_doc1-lev      TO gs_outtab_doc2-lev,
         tb-accnt                TO gs_outtab_doc2-hkont,
         tb-rldnr                TO gs_outtab_doc2-rldnr,
         tb-gjahr                TO gs_outtab_doc2-gjahr,
         tb-gsber                TO gs_outtab_doc2-gsber,
         tb-pswsl                TO gs_outtab_doc2-pswsl.
  MOVE   thk   TO gs_outtab_doc2-fld.
  MOVE : b     TO gs_outtab_doc2-docamt,
         waers TO gs_outtab_doc2-waers_doc,
         v     TO gs_outtab_doc2-tblamt,
         waers TO gs_outtab_doc2-waers_tbl,
         ld     TO gs_outtab_doc2-difamt,
         waers TO gs_outtab_doc2-waers_dif.
  APPEND gs_outtab_doc2 TO gt_outtab_doc2.
**--------------------------------------------------------**
** END OF CHANGES                                 C5053256
**--------------------------------------------------------**
ENDFORM.                    "write_f070_sako

* -------------------------------------------------------------------- *
*             FBila: Write                                             *
* -------------------------------------------------------------------- *
FORM write_f070_bila TABLES curtab STRUCTURE no_curtab
                      USING tb TYPE ty_trans
                            ii TYPE i
                            level TYPE c
                            comp_type TYPE c.               "#EC NEEDED
  DATA: s LIKE huge_amount,
        h LIKE huge_amount,
        ld LIKE huge_amount,
        thk(7) TYPE c,
        mo(2) TYPE c,
        cc TYPE i,
        waers LIKE bkpf-waers.
  STATICS: s_curtab LIKE no_curtab.
*  STATICS: current_account LIKE bseg-hkont VALUE c_init_accnt_no.
*  STATICS: current_rldnr LIKE glt0-rldnr VALUE '__'.
*  STATICS: current_year LIKE bseg-gjahr VALUE '0000'.
*  STATICS: current_gsber LIKE bseg-gsber VALUE '____'.
*  STATICS: current_pswsl LIKE bseg-pswsl VALUE '____'.
*  STATICS: current_shbkz LIKE bseg-umskz VALUE '_'.

  IF tb-accnt = c_init_accnt_no.
*    current_account = c_init_accnt_no.
*    current_rldnr = '__'.
*    current_year = '0000'.
*    current_gsber = '____'.
*    current_pswsl = '____'.
*    current_shbkz = '_'.
    EXIT.
  ENDIF.
***************************************************


* if s_curtab-rldnr ne tb-rldnr.
  READ TABLE curtab WITH KEY rldnr = tb-rldnr.
  IF sy-subrc = 0.
    s_curtab = curtab.
  ENDIF.
*endif.
  mo = tb-monat.
  IF tb-monat IS INITIAL.
    mo = '**'.
  ENDIF.
  IF tb-monat = 99.
    mo = 'VT'.
  ENDIF.
  CASE ii.
    WHEN 1.
      s = tb-hslsv.
      h = tb-hslhv.
      thk = 'HSL'.
      IF comp_type = 'S'.
        ld = s + h.
      ELSE.
        ld = s - h.
      ENDIF.
      cc = 4.
    WHEN 2.
      s = tb-kslsv.
      h = tb-kslhv.
      thk = 'KSL'.
      IF comp_type = 'S'.
        ld = s + h.
      ELSE.
        ld = s - h.
      ENDIF.

      cc = 4.
  ENDCASE.
  CASE thk.
    WHEN 'TSL'.
      waers = tb-pswsl.
    WHEN 'HSL'.
      waers = s_curtab-curr1.
    WHEN 'KSL'.
      waers = s_curtab-curr2.
  ENDCASE.
  CONCATENATE thk mo INTO thk.
  FORMAT COLOR = cc.
  IF ii = 3 OR ii = 6 OR ii = 1 OR ii = 4.
    FORMAT INTENSIFIED OFF.
  ENDIF.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
  CLEAR : gs_outtab_doc2, gt_outtab_doc2.
  MOVE  : gs_outtab_doc1-bukrs   TO gs_outtab_doc2-bukrs,
          gs_outtab_doc1-b_tbl   TO gs_outtab_doc2-b_tbl,
          gs_outtab_doc1-lev     TO gs_outtab_doc2-lev.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
* highest level, rests all sublevels.
**  IF current_account NE tb-accnt
**  OR current_rldnr NE tb-rldnr
**  OR current_year NE tb-gjahr
**  OR current_gsber NE tb-gsber
**  OR current_pswsl NE tb-pswsl
**  OR current_shbkz NE tb-shbkz.
**    IF current_account NE tb-accnt.
**      NEW-LINE. ULINE (115).
**    ENDIF.
**    WRITE:/ sy-vline NO-GAP.
**    WRITE:  tb-accnt NO-GAP.
**    WRITE 13(5) tb-rldnr NO-GAP.
**    WRITE 19(5) tb-gjahr NO-GAP.
  IF comp_type NE 'M'.
    MOVE tb-gsber       TO gs_outtab_doc2-gsber.
**      WRITE 25(5) tb-gsber NO-GAP.
  ELSE.
**      WRITE 25(5) tb-shbkz NO-GAP.
    MOVE tb-shbkz       TO gs_outtab_doc2-shbkz.
  ENDIF.
  MOVE tb-pswsl       TO gs_outtab_doc2-pswsl.
**    WRITE 31(5) tb-pswsl NO-GAP.
**  ELSE.
**    WRITE:/ sy-vline NO-GAP.
**  ENDIF.

**  IF current_account NE tb-accnt.
**    current_account = tb-accnt.
**    current_rldnr = '__'.
**    current_year = '0000'.
**    current_gsber = '____'.
**    current_pswsl = '____'.
**    current_shbkz = '_'.
**  ENDIF.
**  IF current_rldnr NE tb-rldnr.
**    current_rldnr = tb-rldnr.
**
**    current_year = '0000'.
**    current_gsber = '____'.
**    current_pswsl = '____'.
**    current_shbkz = '_'.
**  ENDIF.
**  IF current_year NE tb-gjahr.
**    current_year = tb-gjahr.
**
**    current_gsber = '____'.
**    current_pswsl = '____'.
**    current_shbkz = '_'.
**  ENDIF.
**  IF current_gsber NE tb-gsber.
**    current_gsber = tb-gsber.
**
**    current_pswsl = '____'.
**  ENDIF.
**  IF current_pswsl NE tb-pswsl.
**    current_pswsl = tb-pswsl.
**
**  ENDIF.
**  IF current_shbkz NE tb-shbkz.
**    current_shbkz = tb-shbkz.
**  ENDIF.

*  concatenate thk '_' sh into thk.
  IF comp_type = 'M'.

    CLEAR thk.
    IF tb-monat = '01'.
      thk = 'Jahr'(395).
    ELSEIF tb-monat = '99'.
      thk = 'Vortrag'(396).
    ELSE.
      thk = '*'.
    ENDIF.
  ENDIF.
**  WRITE:
**    37(9) thk NO-GAP, sy-vline NO-GAP.

*  if sh = 'S'.
*    format intensified on.
*  else.
*    format intensified off.
*  endif.
**  IF level = 'A'.
**    FORMAT COLOR COL_NORMAL.
**  ELSE.
**    FORMAT COLOR COL_TOTAL.
**  ENDIF.
**  WRITE:
**      (22) s NO-GAP CURRENCY waers, sy-vline NO-GAP,
**      (22) h NO-GAP CURRENCY waers, sy-vline NO-GAP,
**      (22) d NO-GAP CURRENCY waers, sy-vline NO-GAP.
**  FORMAT INTENSIFIED ON.
**  FORMAT COLOR OFF.
  MOVE : tb-accnt      TO gs_outtab_doc2-hkont,
         tb-rldnr      TO gs_outtab_doc2-rldnr,
         tb-gjahr      TO gs_outtab_doc2-gjahr.
  MOVE : thk           TO gs_outtab_doc2-fld,
         s             TO gs_outtab_doc2-docamt,
         waers         TO gs_outtab_doc2-waers_doc,
         h             TO gs_outtab_doc2-tblamt,
         waers         TO gs_outtab_doc2-waers_tbl,
         ld            TO gs_outtab_doc2-difamt,
         waers         TO gs_outtab_doc2-waers_dif.
  APPEND gs_outtab_doc2 TO gt_outtab_doc2.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
ENDFORM.                    "write_f070_bila
* -------------------------------------------------------------------- *
* FBILA: List the balance.
* -------------------------------------------------------------------- *

FORM list_balance TABLES tb STRUCTURE tvz
                         curtab STRUCTURE no_curtab
                   USING pt001 LIKE t001
                         recursion_level TYPE c
                         compare_tab TYPE any.


  DATA: stringbuf(100) TYPE c,
        firster TYPE i,
        lastaccnt LIKE bseg-hkont,
        re_init LIKE tvz,
        colltab LIKE tvz OCCURS 10 WITH HEADER LINE,
        comp_type TYPE c.
  re_init-accnt = c_init_accnt_no.


  IF compare_tab = 'GLT0'.
    SORT tb BY accnt rldnr gjahr gsber pswsl monat.
    comp_type = 'S'.
  ELSE.
    SORT tb BY accnt gjahr shbkz monat.
    IF compare_tab CA '1'.
      comp_type = 'N'.
    ELSEIF  compare_tab CA '3'.
      comp_type = 'M'.
    ENDIF.
  ENDIF.
  IF  ( protox IS INITIAL AND comp_type = 'S'
       AND ( recursion_level = 'A' OR recursion_level = 'B' ) ) OR
   ( protox IS INITIAL AND recursion_level = 'A' AND comp_type NE 'S' ).
*      continue.
*       new-line.
*       uline (115).

  ELSE.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**    IF recursion_level NE 'A'.
**      NEW-LINE.
**      ULINE (115).
**    ENDIF.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
  ENDIF.
  IF recursion_level = 'A'.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**    FORMAT COLOR COL_POSITIVE.
**    NEW-LINE.
**    ULINE (115).
**    WRITE:/ sy-vline NO-GAP,
**           (13) 'Company Code' NO-GAP,
**           (4)  pt001-bukrs NO-GAP,
**           (1) ' ' NO-GAP,
**           (85) pt001-butxt NO-GAP,
**           (10) 'Balance' NO-GAP RIGHT-JUSTIFIED,
**           sy-vline NO-GAP.
    CLEAR   : gt_outtab_led.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
    IF comp_type = 'S'.
      PERFORM list_ledgers TABLES curtab.
    ENDIF.
**    FORMAT COLOR OFF.
  ENDIF.

  IF  ( protox IS INITIAL AND comp_type = 'S'
       AND ( recursion_level = 'A' OR recursion_level = 'B' ) ) OR
   ( protox IS INITIAL AND recursion_level = 'A' AND comp_type NE 'S' ).
*      continue.
  ELSE.

    CONCATENATE 'Vergleich'(397) 'Saldo'(398) compare_tab 'Ebene'(399)
           recursion_level INTO stringbuf SEPARATED BY space.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**    WRITE:/ sy-vline NO-GAP,
**           (113) stringbuf COLOR COL_TOTAL NO-GAP,
**            sy-vline NO-GAP.
    CLEAR : gs_outtab_doc1, gt_outtab_doc1.
    MOVE  : pt001-bukrs     TO gs_outtab_doc1-bukrs,
            pt001-butxt     TO gs_outtab_doc1-butxt,
            compare_tab     TO gs_outtab_doc1-b_tbl,
            recursion_level TO gs_outtab_doc1-lev,
            stringbuf       TO gs_outtab_doc1-ddtext.
    APPEND   gs_outtab_doc1  TO gt_outtab_doc1.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
  ENDIF.

  PERFORM write_f070_bila TABLES curtab
                   USING re_init 1 recursion_level comp_type.

  LOOP AT tb.
    IF firster = 0.
      firster = 1.
      IF  ( protox IS INITIAL AND comp_type = 'S' AND
          ( recursion_level = 'A' OR recursion_level = 'B' ) ) OR
          ( protox IS INITIAL AND recursion_level = 'A' AND
          ( comp_type NE 'S' ) ).
      ELSE.
        PERFORM accnt_header_bila USING comp_type.
      ENDIF.
    ELSE.
      IF lastaccnt <> tb-accnt.
*         ******** Reinit statics in 'write_f070_bila' *********
        PERFORM write_f070_bila TABLES curtab
                          USING re_init 1 recursion_level comp_type.
*         ******************************************************
      ENDIF.
    ENDIF.
    IF tb-hslsv NE 0 OR tb-hslhv NE 0 OR tb-kslsv NE 0 OR tb-kslhv NE 0.
      PERFORM rekursion_vorbereiten_bila TABLES tb colltab
                                   USING recursion_level comp_type.

      lastaccnt = tb-accnt.

      IF  ( protox IS INITIAL AND comp_type = 'S' AND
          ( recursion_level = 'A' OR recursion_level = 'B' ) ) OR
          ( protox IS INITIAL AND recursion_level = 'A' AND
          ( comp_type NE 'S' ) ).
        CONTINUE.
      ENDIF.
      IF tb-hslsv NE 0 OR tb-hslhv NE 0.
        PERFORM write_f070_bila TABLES curtab
                               USING tb 1 recursion_level comp_type.
      ENDIF.
      IF comp_type = 'S' AND ( tb-kslsv NE 0 OR tb-kslhv NE 0 ) .
        PERFORM write_f070_bila TABLES curtab
                               USING tb 2 recursion_level comp_type.
      ENDIF.
    ENDIF.
  ENDLOOP.


  IF ( recursion_level = 'D' AND comp_type = 'S' )
  OR ( recursion_level = 'C' AND comp_type NE 'S' ) .
*    ******* after the last step of recursion: exit *******
    EXIT.
  ELSE.
    DESCRIBE TABLE tb LINES sy-tfill.
    IF sy-tfill > 0.
*   ******** Jump into recursion ********
      DATA: next_recursion_level TYPE c.
      IF recursion_level = 'A'.
        next_recursion_level = 'B'.
      ELSEIF recursion_level = 'B'.
        next_recursion_level = 'C'.
      ELSEIF recursion_level = 'C'.
        next_recursion_level = 'D'.
      ENDIF.

      PERFORM list_balance TABLES colltab curtab
                      USING pt001 next_recursion_level compare_tab.
    ELSE.
      IF protox = 'X'.
**        WRITE: 95(20) 'No Data' COLOR COL_TOTAL NO-GAP.
      ELSE.
**--------------------------------------------------------------------**
** BEGIN of CHANGES                                           C5053256
**--------------------------------------------------------------------**
**        CONCATENATE 'Comparison' 'Balance' compare_tab 'Level'
**               recursion_level INTO stringbuf SEPARATED BY space.
**        WRITE:/ sy-vline NO-GAP,
**               (113) stringbuf COLOR COL_TOTAL NO-GAP,
**                sy-vline NO-GAP.
**        WRITE: 95(20) 'No Data' COLOR COL_TOTAL NO-GAP.
        CLEAR : gs_outtab_doc1, gt_outtab_doc1.
        MOVE  : pt001-bukrs     TO gs_outtab_doc1-bukrs,
                pt001-butxt     TO gs_outtab_doc1-butxt,
                compare_tab     TO gs_outtab_doc1-b_tbl,
                recursion_level TO gs_outtab_doc1-lev,
                stringbuf       TO gs_outtab_doc1-ddtext.
        APPEND   gs_outtab_doc1  TO gt_outtab_doc1.
**--------------------------------------------------------------------**
** END of CHANGES                                              C5053256
**--------------------------------------------------------------------**
      ENDIF.
    ENDIF.
  ENDIF.


ENDFORM.                    "list_balance
* -------------------------------------------------------------------- *
* FBILA: Write ledger info
* -------------------------------------------------------------------- *
FORM list_ledgers TABLES pcurtab STRUCTURE no_curtab.
  DATA: curt_txt LIKE dd07t-ddtext.
  LOOP AT pcurtab.
    IF pcurtab-usehsl = 1.
      CLEAR curt_txt.
      SELECT SINGLE ddtext INTO curt_txt FROM dd07t
                               WHERE domname = 'CURTP'
                                   AND ddlanguage = sy-langu
                                   AND as4local = 'A'
                                   AND domvalue_l = pcurtab-curt1. "#EC *
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                         C5053256
**--------------------------------------------------------------------**
**     WRITE :/ sy-vline NO-GAP,
**               'Ledger',
**               pcurtab-rldnr,
**               '-'.
**      WRITE : 'HSL-Fields: Currency',
**               pcurtab-curr1,
**               'Currency Type',
**               pcurtab-curt1,
**               (50) curt_txt.
**      WRITE : 115 sy-vline.
      CLEAR : gt_outtab_led.
      CONCATENATE 'Ledger'(410) pcurtab-rldnr '-'
                  'HSL-Felder: Currency'(411) pcurtab-curr1
                  'W#hrungstyp'(412) pcurtab-curt1 curt_txt
      INTO   gt_outtab_led-led_desc SEPARATED BY space.
      MOVE   it001-bukrs  TO gt_outtab_led-led_bukrs.
      APPEND gt_outtab_led.
**--------------------------------------------------------------------**
** END OF CHANGES                                              C5053256
**--------------------------------------------------------------------**
    ENDIF.
    IF pcurtab-useksl = 1.
      CLEAR curt_txt.
      SELECT SINGLE ddtext INTO curt_txt FROM dd07t
                               WHERE domname = 'CURTP'
                                   AND ddlanguage = sy-langu
                                   AND as4local = 'A'
                                   AND domvalue_l = pcurtab-curt2. "#EC *

**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                         C5053256
**--------------------------------------------------------------------**
**      WRITE :/ sy-vline NO-GAP,
**               'Ledger',
**               pcurtab-rldnr,
**               '-'.
**
**      WRITE : 'KSL-Fields: Currency',
**               pcurtab-curr2,
**               'Currency Type',
**               pcurtab-curt2,
**               (50) curt_txt.
**      WRITE : 115 sy-vline.
      CLEAR: gt_outtab_led.
      CONCATENATE 'Ledger'(410) pcurtab-rldnr '-'
                  'KSL-Felder: Currency'(413) pcurtab-curr1
                  'W#hrungstyp'(412) pcurtab-curt1 curt_txt
      INTO   gt_outtab_led-led_desc SEPARATED BY space.
      MOVE   it001-bukrs  TO gt_outtab_led-led_bukrs.
      APPEND gt_outtab_led.
**--------------------------------------------------------------------**
** END OF CHANGES                                              C5053256
**--------------------------------------------------------------------**
    ENDIF.
  ENDLOOP.
ENDFORM.                    "list_ledgers

* -------------------------------------------------------------------- *
* FBILA: Write account header
* -------------------------------------------------------------------- *
FORM accnt_header_bila USING compare_mode TYPE c.           "#EC NEEDED
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                      C5053256
**--------------------------------------------------------------------**
**  FORMAT COLOR COL_NORMAL.
**  IF compare_mode = 'S'.
**    WRITE:/ sy-vline NO-GAP,
**     (11) 'Account' NO-GAP,
**     (6) 'RLDNR' NO-GAP,
**     (6) 'GJAHR' NO-GAP,
**     (6) 'GSBER' NO-GAP,
**     (6) 'RTCUR' NO-GAP,
**     (9) 'Field' NO-GAP,
**     (22) 'Debit' NO-GAP RIGHT-JUSTIFIED,
**     (23) 'Credit' NO-GAP RIGHT-JUSTIFIED,
**     (23) 'Balance' NO-GAP RIGHT-JUSTIFIED,
**     (1) ' ' COLOR COL_NORMAL NO-GAP,
**   sy-vline NO-GAP.
**  ELSEIF compare_mode = 'N'.
**    WRITE:/ sy-vline NO-GAP,
**     (11) 'Account' NO-GAP,
**     (6)  ' ' NO-GAP,
**     (18) 'GJAHR' NO-GAP,
**     (9) 'Field' NO-GAP,
**     (22) 'Debit' NO-GAP RIGHT-JUSTIFIED,
**     (23) 'Credit' NO-GAP RIGHT-JUSTIFIED,
**     (23) 'Balance' NO-GAP RIGHT-JUSTIFIED,
**     (1) ' ' COLOR COL_NORMAL NO-GAP,
**     sy-vline NO-GAP.
**  ELSEIF  compare_mode = 'M'.
**    WRITE:/ sy-vline NO-GAP,
**     (17) 'Account' COLOR COL_NORMAL NO-GAP,
**      (6) 'GJAHR' COLOR COL_NORMAL NO-GAP,
**     (12) 'SHBKZ' COLOR COL_NORMAL NO-GAP,
**      (9) 'Field' COLOR COL_NORMAL NO-GAP,
**     (22) 'Debit' NO-GAP RIGHT-JUSTIFIED,
**     (23) 'Credit' NO-GAP RIGHT-JUSTIFIED,
**     (23) 'Balance' NO-GAP RIGHT-JUSTIFIED,
**     (1) ' ' COLOR COL_NORMAL NO-GAP,
**     sy-vline NO-GAP.
**  ENDIF.
**  FORMAT COLOR OFF.
**--------------------------------------------------------------------**
** END OF CHANGES                                      C5053256
**--------------------------------------------------------------------**
ENDFORM.                    "accnt_header_bila

* -------------------------------------------------------------------- *
* F070: Compare calc. Txn.Figs. to real Txn.Figs (G/L)
* -------------------------------------------------------------------- *

FORM hb_vgl TABLES tb STRUCTURE tvz
                 curtab STRUCTURE no_curtab
                 USING  pt001 LIKE t001
                        canrep TYPE c
                        compare_from TYPE any
                        recursion_level TYPE c.
  DATA: rpmax LIKE glt0-rpmax VALUE 16,
        colltab LIKE tvz OCCURS 10 WITH HEADER LINE,
        re_init LIKE tvz.

  re_init-accnt = c_init_accnt_no.
  PERFORM get_rpmax USING pt001-periv
                    CHANGING rpmax.
**-------------------------------------------------------------**
**  BEGIN OF CHANGES                                   C5053256
**-------------------------------------------------------------**
**  NEW-LINE.
**  ULINE (115).
  IF ( x_kredi IS INITIAL AND x_debi IS INITIAL )
     AND recursion_level = 'A'.
**    FORMAT COLOR COL_POSITIVE.
**    WRITE:/ sy-vline NO-GAP,
**         (13) 'Company Code' NO-GAP,
**         (4)  pt001-bukrs NO-GAP,
**         (1) ' ' NO-GAP,
**         (85) pt001-butxt NO-GAP,
**         (10) compare_from NO-GAP RIGHT-JUSTIFIED,
**         sy-vline NO-GAP.
    PERFORM list_ledgers TABLES curtab.
**    FORMAT COLOR OFF.
  ENDIF.
  DATA stringbuf(100) TYPE c.
  CONCATENATE 'Vergleich'(397) compare_from '- GLT0' 'Ebene'(399) recursion_level
                                                 INTO stringbuf
               SEPARATED BY space.
**  WRITE:/ sy-vline NO-GAP,
**          (113) stringbuf COLOR COL_TOTAL NO-GAP,
**          sy-vline NO-GAP.
  MOVE : pt001-bukrs         TO gs_outtab_doc1-bukrs,
         pt001-butxt         TO gs_outtab_doc1-butxt,
         'GLT01'             TO gs_outtab_doc1-b_tbl,
         recursion_level     TO gs_outtab_doc1-lev,
         stringbuf           TO gs_outtab_doc1-ddtext.
**-------------------------------------------------------------**
**  END OF CHANGES                                     C5053256
**-------------------------------------------------------------**
  DATA: buffer1 LIKE huge_amount, buffer2 LIKE huge_amount,
        buffer3 LIKE huge_amount, buffer4 LIKE huge_amount,
        buffer5 LIKE huge_amount, buffer6 LIKE huge_amount,
        err_cnt TYPE i VALUE 0, firster TYPE i,
        lastaccnt LIKE bseg-hkont.
  SORT tb BY accnt rldnr gjahr gsber pswsl monat.

*   ***** Reinitialize the statics variables in write_f070_sako ****** *
  PERFORM write_f070_sako TABLES curtab USING re_init 1 recursion_level.
*   ****************************************************************** *
  LOOP AT tb.
    CLEAR: buffer1, buffer2, buffer3, buffer4, buffer5, buffer6.

    buffer1 = tb-tslsd.  "TB-tsls - TV-tsls.
    buffer2 = tb-hslsd.  "TB-hsls - TV-hsls.
    buffer3 = tb-kslsd.  "TB-ksls - TV-ksls.
    buffer4 = tb-tslhd.  "TB-tslh - TV-tslh.
    buffer5 = tb-hslhd.  "TB-hslh - TV-hslh.
    buffer6 = tb-kslhd.  "TB-kslh - TV-kslh.
    IF buffer1 <> 0 OR buffer2 <> 0 OR buffer3 <> 0
    OR buffer4 <> 0 OR buffer5 <> 0 OR buffer6 <> 0.
      PERFORM rekursion_vorbereiten TABLES tb colltab
                                     USING recursion_level 'S'.

      IF firster = 0.
        firster = 1.
**--------------------------------------------------------------**
**  BEGIN OF CHANGES                                   C5053256
**--------------------------------------------------------------**
**        FORMAT COLOR COL_NORMAL.
**        WRITE:/ sy-vline NO-GAP,
**
**         (11) 'Account' NO-GAP,
**         (6) 'RLDNR' NO-GAP,
**         (6) 'GJAHR' NO-GAP,
**         (6) 'GSBER' NO-GAP,
**         (6) 'PSWSL' NO-GAP,
**         (9) 'Field' NO-GAP,
**         (22) compare_from NO-GAP RIGHT-JUSTIFIED,
**         (23) 'GLT0' NO-GAP RIGHT-JUSTIFIED,
**         (23) 'Difference' NO-GAP RIGHT-JUSTIFIED,
**         (1) ' ' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP.
**        FORMAT COLOR OFF.
        CLEAR : gs_outtab_doc2.
        MOVE : pt001-bukrs         TO gs_outtab_doc2-bukrs,
               'GLT01'             TO gs_outtab_doc2-b_tbl,
               recursion_level     TO gs_outtab_doc2-lev.
**--------------------------------------------------------------**
**  END OF CHANGES                                     C5053256
**--------------------------------------------------------------**
      ELSE.
        IF lastaccnt <> tb-accnt.
*         ******** Reinit statics in 'write_f070_sako' *********
          PERFORM write_f070_sako TABLES curtab
                                   USING re_init 1 recursion_level.
*         ******************************************************
        ENDIF.
      ENDIF.
      lastaccnt = tb-accnt.
    ENDIF.    " any of buffer1-6 <> 0.
    IF buffer1 <> 0.
      ADD 1 TO err_cnt.
      PERFORM write_f070_sako TABLES curtab USING tb 1 recursion_level.
      IF canrep = 'X'.
        PERFORM differenzen_sammeln
                           USING tb pt001-bukrs 'TSL' 'S' buffer1 rpmax.
      ENDIF.
    ENDIF.
    IF buffer2 <> 0.
      ADD 1 TO err_cnt.
      PERFORM write_f070_sako TABLES curtab USING tb 2 recursion_level.
      IF canrep = 'X'.
        PERFORM differenzen_sammeln
                        USING tb pt001-bukrs 'HSL' 'S' buffer2 rpmax.
      ENDIF.

    ENDIF.
    IF buffer3 <> 0.
      ADD 1 TO err_cnt.
      PERFORM write_f070_sako TABLES curtab USING tb 3 recursion_level.
      IF canrep = 'X'.
        PERFORM differenzen_sammeln
                         USING tb pt001-bukrs 'KSL' 'S' buffer3 rpmax.
      ENDIF.
    ENDIF.
    IF buffer4 <> 0.
      ADD 1 TO err_cnt.
      PERFORM write_f070_sako TABLES curtab USING tb 4 recursion_level.
      IF canrep = 'X'.
        PERFORM differenzen_sammeln
                        USING tb pt001-bukrs 'TSL' 'H' buffer4 rpmax.
      ENDIF.
    ENDIF.
    IF buffer5 <> 0.
      ADD 1 TO err_cnt.
      PERFORM write_f070_sako TABLES curtab USING tb 5 recursion_level.
      IF canrep = 'X'.
        PERFORM differenzen_sammeln
                           USING tb pt001-bukrs 'HSL' 'H' buffer5 rpmax.
      ENDIF.
    ENDIF.
    IF buffer6 <> 0.
      ADD 1 TO err_cnt.
      PERFORM write_f070_sako TABLES curtab USING tb 6 recursion_level.
      IF canrep = 'X'.
        PERFORM differenzen_sammeln
                     USING tb pt001-bukrs 'KSL' 'H' buffer6 rpmax.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF err_cnt = 0.
* -------------------------------------------------------------------- *
* BEGIN OF CHANGES                                           C5053256
* -------------------------------------------------------------------- *
**    WRITE: 95(20) 'No Differences found' COLOR COL_TOTAL NO-GAP.
    move: 'Keine Differenzen gefunden'(415) TO gs_outtab_doc1-err_msg.
    APPEND gs_outtab_doc1      TO gt_outtab_doc1.
    CLEAR : gs_outtab_doc1-err_msg.
* -------------------------------------------------------------------- *
** END OF CHANGES                                           C5053256
* -------------------------------------------------------------------- *
  ELSE.
* -------------------------------------------------------------------- *
** BEGIN OF CHANGES                                         C5053256
* -------------------------------------------------------------------- *
    APPEND gs_outtab_doc1      TO gt_outtab_doc1.
* -------------------------------------------------------------------- *
** END OF CHANGES                                           C5053256
* -------------------------------------------------------------------- *
    IF recursion_level = 'D'.
*    ******* after the last step of recursion: exit *******
      EXIT.
    ELSE.

*   ******** Jump into recursion ********
      DATA: next_recursion_level TYPE c.
      IF recursion_level = 'A'.
        next_recursion_level = 'B'.
      ELSEIF recursion_level = 'B'.
        next_recursion_level = 'C'.
      ELSEIF recursion_level = 'C'.
        next_recursion_level = 'D'.
      ENDIF.

      PERFORM hb_vgl TABLES colltab curtab
                      USING pt001 '' compare_from next_recursion_level.
    ENDIF.
  ENDIF.
ENDFORM.                    "hb_vgl
* -------------------------------------------------------------------- *
* F070, F190 Prepare recursion step
* -------------------------------------------------------------------- *
FORM rekursion_vorbereiten TABLES tb STRUCTURE tvz
                                  colltab STRUCTURE tvz
                           USING  rekursions_stufe TYPE c
                                  mode TYPE c.              "#EC NEEDED
  colltab = tb.
  CASE mode.
    WHEN 'S'.
*     ************ G/L-accounts *********************
      IF colltab-hslsd = 0.
        CLEAR: colltab-hslsb, colltab-hslsv.
      ENDIF.
      IF colltab-hslhd = 0.
        CLEAR: colltab-hslhb, colltab-hslhv.
      ENDIF.
      IF colltab-kslsd = 0.
        CLEAR: colltab-kslsb, colltab-kslsv.
      ENDIF.
      IF colltab-kslhd = 0.
        CLEAR: colltab-kslhb, colltab-kslhv.
      ENDIF.
      CLEAR: colltab-tslsd, colltab-tslsb, colltab-tslsv,
             colltab-tslhd, colltab-tslhb, colltab-tslhv.

      CASE rekursions_stufe.
        WHEN 'A'.
          colltab-pswsl = '*****'.
          colltab-gsber = '*****'.
          COLLECT colltab.

        WHEN 'B'.
          colltab-accnt = '**********'.
          COLLECT colltab.

        WHEN 'C'.
          colltab-monat = '**'.
          colltab-shbkz = '**'.
          COLLECT colltab.
      ENDCASE.

    WHEN 'N'.
*     **************** Subledger normal transactions
      IF colltab-hslsd = 0.
        CLEAR: colltab-hslsb,
               colltab-hslsv.
      ENDIF.
      IF colltab-hslhd = 0.
        CLEAR: colltab-hslhb,
               colltab-hslhv.
      ENDIF.
      IF tb-tslsd = 0.
        CLEAR: colltab-tslsb,
               colltab-tslsv.
      ENDIF.

      CASE rekursions_stufe.

        WHEN 'B'.
          colltab-monat = '**'. " important for normal txns
          colltab-shbkz = '**'. " important for spec. G/L txns
          COLLECT colltab.

        WHEN '' OR 'X'.
          colltab-accnt = '**********'.
          COLLECT colltab.

      ENDCASE.
  ENDCASE.
ENDFORM.                    "rekursion_vorbereiten
* -------------------------------------------------------------------- *
* FBILA Prepare recursion step
* -------------------------------------------------------------------- *

FORM rekursion_vorbereiten_bila TABLES tb STRUCTURE tvz
                                  colltab STRUCTURE tvz
                           USING  rekursions_stufe TYPE c
                                  mode TYPE c.              "#EC NEEDED
  colltab = tb.
  CASE mode.
    WHEN 'S'.
*     ************ G/L-accounts *********************
      IF colltab-hslsd = 0.
*         clear: colltab-hslsb, colltab-hslsv.
      ENDIF.
      IF colltab-hslhd = 0.
*         clear: colltab-hslhb, colltab-hslhv.
      ENDIF.
      IF colltab-kslsd = 0.
*         clear: colltab-kslsb, colltab-kslsv.
      ENDIF.
      IF colltab-kslhd = 0.
*         clear: colltab-kslhb, colltab-kslhv.
      ENDIF.
      CLEAR: colltab-tslsd, colltab-tslsb, colltab-tslsv,
             colltab-tslhd, colltab-tslhb, colltab-tslhv.

      CASE rekursions_stufe.
        WHEN 'A'.
          colltab-pswsl = '*****'.
          colltab-gsber = '*****'.
          COLLECT colltab.

        WHEN 'B'.
          colltab-accnt = '**********'.
          COLLECT colltab.

        WHEN 'C'.
          colltab-monat = '**'.
          colltab-shbkz = '**'.
          COLLECT colltab.
      ENDCASE.

    WHEN 'N' OR 'M'.
*     **************** Subledger normal transactions
      IF colltab-hslsd = 0.
*        clear: colltab-hslsb,
*               colltab-hslsv.
      ENDIF.
      IF colltab-hslhd = 0.
*        clear: colltab-hslhb,
*               colltab-hslhv.
      ENDIF.
      IF tb-tslsd = 0.
*       clear: colltab-tslsb,
*              colltab-tslsv.
      ENDIF.

      CASE rekursions_stufe.

        WHEN 'B'.
          colltab-monat = '**'. " important for normal txns
          colltab-shbkz = '**'. " important for spec. G/L txns
          COLLECT colltab.

        WHEN 'A'.
          colltab-accnt = '**********'.
          COLLECT colltab.

      ENDCASE.
  ENDCASE.
ENDFORM.                    "rekursion_vorbereiten_bila

* -------------------------------------------------------------------- *
* F070: Compare calc. Txn.Figs. to real Txn.Figs (Sub-ledger)          *
* -------------------------------------------------------------------- *
FORM nb_vgl TABLES tb STRUCTURE tvz
                   curtab STRUCTURE no_curtab
            USING  pt001 LIKE t001
                   name LIKE string100
                   compare_from TYPE any
                   canrep TYPE c.

  DATA: buffer1 LIKE huge_amount, buffer2 LIKE huge_amount,
        buffer5 LIKE huge_amount,
        err_cnt TYPE i VALUE 0,
        firster TYPE i,
        bkrs LIKE t001-bukrs,
        lastaccnt LIKE bseg-hkont,
        colltab LIKE tvz OCCURS 10 WITH HEADER LINE.
  bkrs = pt001-bukrs.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**  NEW-LINE.
**  ULINE (115).
  IF ( name = 'KNC1' OR x_debi IS INITIAL  ) AND canrep CA ' X'.
**    FORMAT COLOR COL_POSITIVE.
**    WRITE:/ sy-vline NO-GAP,
**          (13) 'Company Code' NO-GAP,
**          (4)  bkrs NO-GAP,
**          (1) ' ' NO-GAP,
**          (85) pt001-butxt NO-GAP,
**          (10) compare_from NO-GAP RIGHT-JUSTIFIED,
**          sy-vline NO-GAP.
    CLEAR   : gt_outtab_led.
    REFRESH : gt_outtab_led.
    PERFORM list_ledgers TABLES curtab.
**    FORMAT COLOR OFF.
  ENDIF.
  DATA stringbuf(100) TYPE c.
  DATA lev TYPE c.
  IF canrep CA ' X'.
    lev = 'A'.
  ELSE.
    lev = canrep.
  ENDIF.

  CONCATENATE 'Vergleich'(397) compare_from '-' name 'Ebene'(399) lev
               INTO stringbuf SEPARATED BY space.

**  WRITE:/ sy-vline NO-GAP,
**          (113) stringbuf COLOR COL_TOTAL NO-GAP,
**          sy-vline NO-GAP.
  MOVE:   bkrs        TO gs_outtab_doc1-bukrs,
          pt001-butxt TO gs_outtab_doc1-butxt,
          name        TO gs_outtab_doc1-b_tbl,
          lev         TO gs_outtab_doc1-lev,
          stringbuf   TO gs_outtab_doc1-ddtext.
**------------------------------------------------------------------**
** END OF CHANGES                                            C5053256
**------------------------------------------------------------------**
  SORT tb BY accnt gjahr monat.
  LOOP AT tb.
    CLEAR: buffer1, buffer2, buffer5.
    buffer1 = tb-tslsd. "TB-tsls - TV-tsls.
    buffer2 = tb-hslsd. "TB-hsls - TV-hsls.
    buffer5 = tb-hslhd. "TB-hslh - TV-hslh.
    IF buffer1 <> 0 OR buffer2 <> 0 OR buffer5 <> 0.
*     ***********************
      PERFORM rekursion_vorbereiten TABLES tb colltab
                                   USING canrep 'N'.
*     ***********************
      IF firster = 0.
        firster = 1.
**------------------------------------------------------------------**
** BEGIN OF CHANGES                                         C5053256
**------------------------------------------------------------------**
**        FORMAT COLOR COL_NORMAL.
**        WRITE:/ sy-vline NO-GAP,
**         (11) 'Account' NO-GAP,
**         (6)  ' ' NO-GAP,
**         (18) 'GJAHR' NO-GAP,
**         (9) 'Field' NO-GAP,
**         (22) compare_from NO-GAP RIGHT-JUSTIFIED,
**         (23) name NO-GAP RIGHT-JUSTIFIED,
**         (23) 'Difference' NO-GAP RIGHT-JUSTIFIED,
**         (1) ' ' NO-GAP,
**         sy-vline NO-GAP.
**        NEW-LINE.
**        ULINE (115).
**        FORMAT COLOR OFF.
      ELSE.
        IF lastaccnt <> tb-accnt.
**          NEW-LINE.
**          ULINE (115).
        ENDIF.
      ENDIF.
      lastaccnt = tb-accnt.
**------------------------------------------------------------------**
** END OF CHANGES                                            C5053256
**------------------------------------------------------------------**
    ENDIF.
    IF buffer1 <> 0.
      ADD 1 TO err_cnt.
      PERFORM write_f070_nb USING tb 1 lev pt001.
      IF canrep = 'X'.
        PERFORM differenzen_sammeln USING tb bkrs name 'U' buffer1 16.
      ENDIF.
    ENDIF.
    IF buffer2 <> 0.
      ADD 1 TO err_cnt.
      PERFORM write_f070_nb USING tb 2 lev pt001.
      IF canrep = 'X'.
        PERFORM differenzen_sammeln USING tb bkrs name 'S' buffer2 16.
      ENDIF.
    ENDIF.
    IF buffer5 <> 0.
      ADD 1 TO err_cnt.
      PERFORM write_f070_nb USING tb 3 lev pt001.
      IF canrep = 'X'.
        PERFORM differenzen_sammeln USING tb bkrs name 'H' buffer5 16.
      ENDIF.
    ENDIF.

  ENDLOOP.
  IF err_cnt = 0.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**    WRITE: 95(20) 'No Differences found' COLOR COL_TOTAL NO-GAP.
    move: 'Keine Differenzen gefunden'(437) TO gs_outtab_doc1-err_msg.
    APPEND  gs_outtab_doc1  TO gt_outtab_doc1.
    CLEAR : gs_outtab_doc1-err_msg.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
  ELSE.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
    APPEND  gs_outtab_doc1  TO gt_outtab_doc1.
**--------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
    IF canrep = 'C'.
      EXIT.
    ENDIF.
    IF canrep = '' OR canrep = 'X'.
      PERFORM nb_vgl TABLES colltab curtab
                      USING pt001 name compare_from 'B'.
    ELSEIF canrep = 'B'.
      PERFORM nb_vgl TABLES colltab curtab
                      USING pt001 name compare_from 'C'.
    ENDIF.
  ENDIF.
ENDFORM.                    "nb_vgl
* -------------------------------------------------------------------- *
* F070: Write the diffs for sub-ledger normal transactions
* -------------------------------------------------------------------- *
FORM write_f070_nb USING tb LIKE tvz mode TYPE i level TYPE c
                         pit001 LIKE t001.                  "#EC NEEDED

  FORMAT INTENSIFIED ON.

  DATA: mon(2) TYPE c,
        shu TYPE c,
        amntb LIKE huge_amount,
        amntv LIKE huge_amount,
        amntd LIKE huge_amount,
        fld(6) TYPE c.
  mon = tb-monat.
  IF tb-monat IS INITIAL.
    mon = '**'.
  ENDIF.
  IF mode = 1.
    FORMAT COLOR COL_HEADING.
    shu = 'U'.
    amntb = tb-tslsb.
    amntv = tb-tslsv.
    amntd = tb-tslsd.
  ELSEIF mode = 2.
    FORMAT COLOR COL_KEY.
    shu = 'S'.
    amntb = tb-hslsb.
    amntv = tb-hslsv.
    amntd = tb-hslsd.
  ELSEIF mode = 3.
    FORMAT COLOR COL_KEY.
    FORMAT INTENSIFIED OFF.
    shu = 'H'.
    amntb = tb-hslhb.
    amntv = tb-hslhv.
    amntd = tb-hslhd.
  ENDIF.
  CONCATENATE 'UM' mon '_' shu INTO fld.

**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**  WRITE:/ sy-vline NO-GAP,
**          (11) tb-accnt NO-GAP,
**          (6) ' ' NO-GAP,
**          (18) tb-gjahr NO-GAP,
**          (9) fld NO-GAP, sy-vline NO-GAP.
**  IF level = 'A'.
**    FORMAT COLOR COL_NORMAL.
**  ELSE.
**    FORMAT COLOR COL_TOTAL.
**  ENDIF.
**  IF shu = 'S'.
**    FORMAT INTENSIFIED OFF.
**  ELSE.
**    FORMAT INTENSIFIED ON.
**  ENDIF.
**  WRITE:  (22) amntb CURRENCY pit001-waers NO-GAP, sy-vline NO-GAP,
**          (22) amntv CURRENCY pit001-waers NO-GAP, sy-vline NO-GAP,
**          (22) amntd CURRENCY pit001-waers NO-GAP, sy-vline NO-GAP.
**  FORMAT INTENSIFIED ON.
**  FORMAT COLOR OFF.
  CLEAR : gs_outtab_doc2, gt_outtab_doc2.
  MOVE  : tb-accnt             TO gs_outtab_doc2-hkont,
          gs_outtab_doc1-bukrs TO gs_outtab_doc2-bukrs,
          gs_outtab_doc1-b_tbl TO gs_outtab_doc2-b_tbl,
          level                TO gs_outtab_doc2-lev,
          tb-gjahr             TO gs_outtab_doc2-gjahr,
          fld                  TO gs_outtab_doc2-fld,
          amntb                TO gs_outtab_doc2-docamt,
          amntv                TO gs_outtab_doc2-tblamt,
          amntd                TO gs_outtab_doc2-difamt.
  APPEND  gs_outtab_doc2       TO gt_outtab_doc2.
**--------------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
ENDFORM.                    "write_f070_nb
* -------------------------------------------------------------------- *
* F070: Compare calc. Txn.Figs. to real Txn.Figs (Sub-ledger Sp.G/L Txn)
* -------------------------------------------------------------------- *
FORM shb_vgl TABLES tb STRUCTURE tvz
                     USING  pt001 LIKE t001
                            name LIKE string100
                            compare_from TYPE any
                            canrep TYPE c
                            canshb TYPE c.


  DATA: rpmax LIKE glt0-rpmax VALUE 16,
        colltab LIKE tvz OCCURS 10 WITH HEADER LINE.
  PERFORM get_rpmax USING pt001-periv
                    CHANGING rpmax.
  DATA: rpmax2 LIKE bkpf-monat.
  rpmax2 = rpmax.
  DATA: err_cnt TYPE i VALUE 0,
        firster TYPE i.
*        lastaccnt LIKE bseg-hkont.
**  NEW-LINE.
**  ULINE (115).
  DATA stringbuf(100) TYPE c.
  DATA lev TYPE c.
  IF canrep CA ' X'.
    lev = 'A'.
  ELSE.
    lev = canrep.
  ENDIF.

  CONCATENATE 'Vergleich'(551) compare_from '-' name 'Ebene'(550) lev
               INTO stringbuf SEPARATED BY space.
**-------------------------------------------------------------**
**  BEGIN OF CHANGES                                  C5053256
**-------------------------------------------------------------**
**  WRITE:/ sy-vline NO-GAP,
**          (113) stringbuf COLOR COL_TOTAL NO-GAP,
**          sy-vline NO-GAP.
  MOVE:   pt001-bukrs TO gs_outtab_doc1-bukrs,
          pt001-butxt TO gs_outtab_doc1-butxt,
          name        TO gs_outtab_doc1-b_tbl,
          lev         TO gs_outtab_doc1-lev,
          stringbuf   TO gs_outtab_doc1-ddtext.
**-------------------------------------------------------------**
**  END OF CHANGES                                    C5053256
**-------------------------------------------------------------**
  IF canshb = 'X'.
    SORT tb BY accnt gjahr shbkz.
    LOOP AT tb.
      CHECK tb-hslsd <> 0 OR tb-hslhd <> 0.
*     ***********************
      PERFORM rekursion_vorbereiten TABLES tb colltab
                                   USING canrep 'N'.

      ADD 1 TO err_cnt.
      IF firster = 0.
        firster = 1.
**        PERFORM write_header_shp USING compare_from name.
      ELSE.
**--------------------------------------------------------------**
** BEGIN OF CHANGES                                  C5053256
**--------------------------------------------------------------**
**        IF lastaccnt <> tb-accnt.
**          NEW-LINE.
**          ULINE (115).
**        ENDIF.
**--------------------------------------------------------------**
** END  OF CHANGES                                   C5053256
**--------------------------------------------------------------**
      ENDIF.
*      lastaccnt = tb-accnt.
      IF tb-hslsd <> 0.
**--------------------------------------------------------------**
** BEGIN OF CHANGES                                   C5053256
**--------------------------------------------------------------**
**        FORMAT INTENSIFIED ON.
        PERFORM write_f070_err_shb USING pt001 tb 'S' lev.
**--------------------------------------------------------------**
** END  OF CHANGES                                   C5053256
**--------------------------------------------------------------**
        IF canrep = 'X'.
          PERFORM differenzen_sammeln
          USING tb pt001-bukrs name 'S' tb-hslsd 16.
        ENDIF.
      ENDIF.
      IF tb-hslhd <> 0.
        FORMAT INTENSIFIED OFF.
        PERFORM write_f070_err_shb USING pt001 tb 'H' lev.
        FORMAT INTENSIFIED ON.
        IF canrep = 'X'.
          PERFORM differenzen_sammeln
          USING tb pt001-bukrs name 'H' tb-hslhd 16.
        ENDIF.
      ENDIF.
    ENDLOOP.
    IF err_cnt = 0.
**      WRITE: 95(20) 'No Differences found' COLOR COL_TOTAL NO-GAP.
      Move: 'Keine Differenzen gefunden'(552) TO gs_outtab_doc1-err_msg.
    ELSE.
      IF canrep = 'C'.
        EXIT.
      ENDIF.

      IF canrep = '' OR canrep = 'X'.
        PERFORM shb_vgl TABLES colltab
                        USING pt001 name
                              compare_from 'B' canshb.
      ELSEIF canrep = 'B'.
        PERFORM shb_vgl TABLES colltab
                        USING pt001 name
                              compare_from 'C' canshb.
      ENDIF.
    ENDIF.
  ELSE. " <-- p_pmonat
**-------------------------------------------------------------------**
**  BEGIN OF CHANGES                                         C5053256
**-------------------------------------------------------------------**
**    WRITE:/ sy-vline NO-GAP,
**         (55) 'Not checked - Check requires a period range from 01 to'
**                COLOR COL_NORMAL NO-GAP,
**         (3) rpmax2 COLOR COL_NORMAL NO-GAP LEFT-JUSTIFIED,
**         (55) '(all Periods)' COLOR COL_NORMAL NO-GAP,
**            sy-vline NO-GAP.
    CONCATENATE 'Nicht gepr¨¹ft - Pr¨¹fung ben#tigt einen Bereich von 01 bis'(553)
                rpmax2
                '(komplettes Jahr)'(554)
                INTO gs_outtab_doc1-err_msg SEPARATED BY space.
  ENDIF. " <-- p_pmonat
  APPEND gs_outtab_doc1  TO gt_outtab_doc1.
  CLEAR : gs_outtab_doc1-err_msg.
**-------------------------------------------------------------------**
**  END OF CHANGES                                            C5053256
**-------------------------------------------------------------------**
ENDFORM.                    "shb_vgl
* -------------------------------------------------------------------- *
*                     Write header for Sp.G/L tr.
* -------------------------------------------------------------------- *


* -------------------------------------------------------------------- *
*          Write the diffs F070/F190 ...vs GLT0
* -------------------------------------------------------------------- *
FORM write_f070_err_shb USING pit001 LIKE t001 tb TYPE ty_trans
                              sh TYPE any level TYPE c.     "#EC NEEDED
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                             C5053256
**--------------------------------------------------------------------**
  CLEAR : gs_outtab_doc2, gt_outtab_doc2.
  MOVE  : gs_outtab_doc1-bukrs  TO gs_outtab_doc2-bukrs,
          gs_outtab_doc1-b_tbl  TO gs_outtab_doc2-b_tbl,
          gs_outtab_doc1-lev    TO gs_outtab_doc2-lev.
  MOVE  : tb-accnt    TO gs_outtab_doc2-hkont,
          tb-gjahr    TO gs_outtab_doc2-gjahr,
          tb-shbkz    TO gs_outtab_doc2-shbkz,
          tb-hslsb    TO gs_outtab_doc2-docamt,
          pit001-waers TO gs_outtab_doc2-waers_doc,
          tb-hslsv    TO gs_outtab_doc2-tblamt,
          pit001-waers TO gs_outtab_doc2-waers_tbl,
          pit001-waers TO gs_outtab_doc2-waers_dif,
          tb-hslsd    TO gs_outtab_doc2-difamt.
  IF sh = 'S'.
**    FORMAT COLOR COL_KEY.
**    WRITE:/ sy-vline NO-GAP,
**            (17) tb-accnt NO-GAP, " sy-vline no-gap,
**            (6)  tb-gjahr NO-GAP, " sy-vline no-gap,
**            (12)  tb-shbkz NO-GAP, " sy-vline no-gap.
**            (9) 'SOLLL' NO-GAP, sy-vline NO-GAP.
**    IF level = 'A'.
**      FORMAT COLOR COL_NORMAL.
**    ELSE.
**      FORMAT COLOR COL_TOTAL.
**    ENDIF.
**  WRITE: (22) tb-hslsb CURRENCY pit001-waers NO-GAP, sy-vline NO-GAP,
**         (22) tb-hslsv CURRENCY pit001-waers NO-GAP, sy-vline NO-GAP,
**         (22) tb-hslsd CURRENCY pit001-waers NO-GAP, sy-vline NO-GAP.
    MOVE   'SOLLL'     TO gs_outtab_doc2-fld.
  ELSE.
**    FORMAT COLOR COL_KEY.
**    WRITE:/ sy-vline NO-GAP,
**            (17) tb-accnt NO-GAP, " sy-vline no-gap,
**            (6)  tb-gjahr NO-GAP, " sy-vline no-gap,
**            (12)  tb-shbkz NO-GAP, " sy-vline no-gap.
**            (9) 'HABNL' NO-GAP, sy-vline NO-GAP.

**    IF level = 'A'.
**      FORMAT COLOR COL_NORMAL.
**    ELSE.
**      FORMAT COLOR COL_TOTAL.
**    ENDIF.
**   WRITE: (22) tb-hslhb CURRENCY pit001-waers NO-GAP, sy-vline NO-GAP,
**          (22) tb-hslhv CURRENCY pit001-waers NO-GAP, sy-vline NO-GAP,
**          (22) tb-hslhd CURRENCY pit001-waers NO-GAP, sy-vline NO-GAP.
    MOVE   'HABNL'     TO gs_outtab_doc2-fld.
  ENDIF.
  APPEND gs_outtab_doc2  TO gt_outtab_doc2.
**  FORMAT COLOR OFF.
ENDFORM.                    "write_f070_err_shb
* -------------------------------------------------------------------- *
* Determine RPMAX for GLT0 for a given Period-version                  *
* -------------------------------------------------------------------- *
FORM get_rpmax USING pperiv LIKE t001-periv
               CHANGING rpmax LIKE glt0-rpmax.
  SELECT SINGLE * FROM t009 WHERE periv = pperiv.
  IF sy-subrc = 0.
    rpmax = t009-anzbp + t009-anzsp.
  ENDIF.
ENDFORM.                    "get_rpmax
* -------------------------------------------------------------------- *
*         Avoid initial entries in Txn. Figs.
* -------------------------------------------------------------------- *
FORM avoid_zero_amount USING name TYPE any.
  IF name = 'GLT0'.
    IF glt0-tslvt = 0 AND glt0-hslvt = 0 AND glt0-kslvt = 0
   AND glt0-tsl01 = 0 AND glt0-hsl01 = 0 AND glt0-ksl01 = 0
   AND glt0-tsl02 = 0 AND glt0-hsl02 = 0 AND glt0-ksl02 = 0
   AND glt0-tsl03 = 0 AND glt0-hsl03 = 0 AND glt0-ksl03 = 0
   AND glt0-tsl04 = 0 AND glt0-hsl04 = 0 AND glt0-ksl04 = 0
   AND glt0-tsl05 = 0 AND glt0-hsl05 = 0 AND glt0-ksl05 = 0
   AND glt0-tsl06 = 0 AND glt0-hsl06 = 0 AND glt0-ksl06 = 0
   AND glt0-tsl07 = 0 AND glt0-hsl07 = 0 AND glt0-ksl07 = 0
   AND glt0-tsl08 = 0 AND glt0-hsl08 = 0 AND glt0-ksl08 = 0
   AND glt0-tsl09 = 0 AND glt0-hsl09 = 0 AND glt0-ksl09 = 0
   AND glt0-tsl10 = 0 AND glt0-hsl10 = 0 AND glt0-ksl10 = 0
   AND glt0-tsl11 = 0 AND glt0-hsl11 = 0 AND glt0-ksl11 = 0
   AND glt0-tsl12 = 0 AND glt0-hsl12 = 0 AND glt0-ksl12 = 0
   AND glt0-tsl13 = 0 AND glt0-hsl13 = 0 AND glt0-ksl13 = 0
   AND glt0-tsl14 = 0 AND glt0-hsl14 = 0 AND glt0-ksl14 = 0
   AND glt0-tsl15 = 0 AND glt0-hsl15 = 0 AND glt0-ksl15 = 0
   AND glt0-tsl16 = 0 AND glt0-hsl16 = 0 AND glt0-ksl16 = 0.
      DATA: bw_glt0 LIKE glt0.
      MOVE-CORRESPONDING glt0 TO bw_glt0.                   "#EC ENHOK
      IF gd_glt0_update_allowed = 'X'.
        DELETE glt0.
        IF sy-subrc = 0.
          CALL FUNCTION 'FUNCTION_EXISTS'
            EXPORTING
              funcname           = 'OPEN_FI_PERFORM_00005012_P'
            EXCEPTIONS
              function_not_exist = 1
              OTHERS             = 2.
          IF sy-subrc = 0.

            CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
              EXPORTING
                i_chgtype         = 'D'
                i_origin          = 'RFINDEX AVOID_ZERO_AMOUNT'
                i_tabname         = 'GLT0'
                i_structure       = bw_glt0
*             TABLES
*               T_STRUCTURE       =
              EXCEPTIONS
                error             = 0
                OTHERS            = 0.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  IF name = 'KNC1'.
    IF knc1-umsav = 0
    AND knc1-um01h = 0 AND knc1-um01s = 0 AND knc1-um01u = 0
    AND knc1-um02h = 0 AND knc1-um02s = 0 AND knc1-um02u = 0
    AND knc1-um03h = 0 AND knc1-um03s = 0 AND knc1-um03u = 0
    AND knc1-um04h = 0 AND knc1-um04s = 0 AND knc1-um04u = 0
    AND knc1-um05h = 0 AND knc1-um05s = 0 AND knc1-um05u = 0
    AND knc1-um06h = 0 AND knc1-um06s = 0 AND knc1-um06u = 0
    AND knc1-um07h = 0 AND knc1-um07s = 0 AND knc1-um07u = 0
    AND knc1-um08h = 0 AND knc1-um08s = 0 AND knc1-um08u = 0
    AND knc1-um09h = 0 AND knc1-um09s = 0 AND knc1-um09u = 0
    AND knc1-um10h = 0 AND knc1-um10s = 0 AND knc1-um10u = 0
    AND knc1-um11h = 0 AND knc1-um11s = 0 AND knc1-um11u = 0
    AND knc1-um12h = 0 AND knc1-um12s = 0 AND knc1-um12u = 0
    AND knc1-um13h = 0 AND knc1-um13s = 0 AND knc1-um13u = 0
    AND knc1-um14h = 0 AND knc1-um14s = 0 AND knc1-um14u = 0
    AND knc1-um15h = 0 AND knc1-um15s = 0 AND knc1-um15u = 0
    AND knc1-um16h = 0 AND knc1-um16s = 0 AND knc1-um16u = 0
    AND knc1-babzg = 0
    AND knc1-uabzg = 0
    AND knc1-kzins = 0
    AND knc1-kumag = 0.
      DATA: bw_knc1 LIKE knc1.
      MOVE-CORRESPONDING knc1 TO bw_knc1.                   "#EC ENHOK
      DELETE knc1.
      IF sy-subrc = 0.
        CALL FUNCTION 'FUNCTION_EXISTS'
          EXPORTING
            funcname           = '0_PERFORM_00005012_P'
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.
        IF sy-subrc = 0.

          CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
            EXPORTING
              i_chgtype         = 'D'
              i_origin          = 'RFINDEX AVOID_ZERO_AMOUNT'
              i_tabname         = 'KNC1'
              i_structure       = bw_knc1
*            TABLES
*              T_STRUCTURE       =
            EXCEPTIONS
              error             = 0
              OTHERS            = 0.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  IF name = 'LFC1'.
    IF lfc1-umsav = 0
    AND lfc1-um01h = 0 AND lfc1-um01s = 0 AND lfc1-um01u = 0
    AND lfc1-um02h = 0 AND lfc1-um02s = 0 AND lfc1-um02u = 0
    AND lfc1-um03h = 0 AND lfc1-um03s = 0 AND lfc1-um03u = 0
    AND lfc1-um04h = 0 AND lfc1-um04s = 0 AND lfc1-um04u = 0
    AND lfc1-um05h = 0 AND lfc1-um05s = 0 AND lfc1-um05u = 0
    AND lfc1-um06h = 0 AND lfc1-um06s = 0 AND lfc1-um06u = 0
    AND lfc1-um07h = 0 AND lfc1-um07s = 0 AND lfc1-um07u = 0
    AND lfc1-um08h = 0 AND lfc1-um08s = 0 AND lfc1-um08u = 0
    AND lfc1-um09h = 0 AND lfc1-um09s = 0 AND lfc1-um09u = 0
    AND lfc1-um10h = 0 AND lfc1-um10s = 0 AND lfc1-um10u = 0
    AND lfc1-um11h = 0 AND lfc1-um11s = 0 AND lfc1-um11u = 0
    AND lfc1-um12h = 0 AND lfc1-um12s = 0 AND lfc1-um12u = 0
    AND lfc1-um13h = 0 AND lfc1-um13s = 0 AND lfc1-um13u = 0
    AND lfc1-um14h = 0 AND lfc1-um14s = 0 AND lfc1-um14u = 0
    AND lfc1-um15h = 0 AND lfc1-um15s = 0 AND lfc1-um15u = 0
    AND lfc1-um16h = 0 AND lfc1-um16s = 0 AND lfc1-um16u = 0.
      DATA: bw_lfc1 LIKE lfc1.
      MOVE-CORRESPONDING lfc1 TO bw_lfc1.                   "#EC ENHOK
      DELETE lfc1.
      IF sy-subrc = 0.

        CALL FUNCTION 'FUNCTION_EXISTS'
          EXPORTING
            funcname           = 'OPEN_FI_PERFORM_00005012_P'
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.
        IF sy-subrc = 0.

          CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
            EXPORTING
              i_chgtype         = 'D'
              i_origin          = 'RFINDEX AVOID_ZERO_AMOUNT'
              i_tabname         = 'LFC1'
              i_structure       = bw_lfc1
*          TABLES
*            T_STRUCTURE       =
            EXCEPTIONS
              error             = 0
              OTHERS            = 0.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  IF name = 'KNC3'.
    IF knc3-saldv = 0 AND knc3-solll = 0 AND knc3-habnl = 0.
      DATA: bw_knc3 LIKE knc3.
      MOVE-CORRESPONDING knc3 TO bw_knc3.                   "#EC ENHOK
      DELETE knc3.
      IF sy-subrc = 0.
        CALL FUNCTION 'FUNCTION_EXISTS'
          EXPORTING
            funcname           = 'OPEN_FI_PERFORM_00005012_P'
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.
        IF sy-subrc = 0.

          CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
             EXPORTING
                i_chgtype         = 'D'
                i_origin          = 'RFINDEX AVOID_ZERO_AMOUNT'
                i_tabname         = 'KNC3'
                i_structure       = bw_knc3
*            TABLES
*               T_STRUCTURE       =
             EXCEPTIONS
                error             = 0
                OTHERS            = 0.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  IF name = 'LFC3'.
    IF lfc3-saldv = 0 AND lfc3-solll = 0 AND lfc3-habnl = 0.
      DATA: bw_lfc3 LIKE lfc3.
      MOVE-CORRESPONDING lfc3 TO bw_lfc3.                   "#EC ENHOK
      DELETE lfc3.
      IF sy-subrc = 0.
        CALL FUNCTION 'FUNCTION_EXISTS'
          EXPORTING
            funcname           = 'OPEN_FI_PERFORM_00005012_P'
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.
        IF sy-subrc = 0.
          CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
            EXPORTING
              i_chgtype         = 'D'
              i_origin          = 'RFINDEX AVOID_ZERO_AMOUNT'
              i_tabname         = 'LFC3'
              i_structure       = bw_lfc3
*          TABLES
*            T_STRUCTURE       =
            EXCEPTIONS
              error             = 0
              OTHERS            = 0.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    "avoid_zero_amount
* -------------------------------------------------------------------- *
*                    F070: Collect Differences                         *
* -------------------------------------------------------------------- *
FORM differenzen_sammeln USING tb LIKE tvz
                             bkrs LIKE bseg-bukrs
                             name TYPE any
                             sh TYPE char1
                             delta LIKE huge_amount
                             prpmax LIKE glt0-rpmax.
  CLEAR tdelta.
  tdelta-name = name.
  tdelta-bukrs = bkrs.
  tdelta-accnt = tb-accnt.
  tdelta-rldnr = tb-rldnr.
  tdelta-shbkz = tb-shbkz.
  tdelta-gsber = tb-gsber.
  tdelta-gjahr = tb-gjahr.
  tdelta-monat = tb-monat.
  tdelta-shkzg = sh.
  tdelta-pswsl = tb-pswsl.
  tdelta-delta = delta.
  tdelta-rpmax = prpmax.
  APPEND tdelta.
ENDFORM.                    "differenzen_sammeln
* -------------------------------------------------------------------- *
*                    F070: Change Txn Figs.                            *
* -------------------------------------------------------------------- *
FORM vz_korrigieren.
  LOOP AT tdelta.
    CLEAR: glt0, knc1, lfc1, knc3, lfc3.
* <------------------------ GLT0 UPDATE ------------------------------
    IF tdelta-name CP '*SL'.
      SELECT SINGLE * FROM skb1 WHERE bukrs = tdelta-bukrs
                                  AND saknr = tdelta-accnt. "#EC CI_GENBUFF
      IF sy-subrc <> 0.
**------------------------------------------------------------------**
** BEFIN OF CHANGES                                          C5053256
**------------------------------------------------------------------**
** WRITE:/ 'No SKB1-Entry, could not change Transaction Figures for:'.
**   WRITE:/ tdelta-bukrs, tdelta-accnt.
        CLEAR : gt_foot_line.
        move 'Kein SKB1-Datensatz, Verkehrzahlen konnten nicht angepa#t werden f¨¹r:'(026)
           TO gt_foot_line-line_print.
        MOVE  gv_counter_outtab  TO gt_foot_line-list_no.
        APPEND gt_foot_line.
**------------------------------------------------------------------**
** END OF CHANGES                                              C5053256
**------------------------------------------------------------------**
        CONTINUE.
      ENDIF.
      IF gd_fagl_functions_present = 'X'.
        DATA lt_fagl_t_glt0 TYPE fagl_t_glt0.
        CLEAR lt_fagl_t_glt0.
        CALL FUNCTION 'FAGL_GET_GLT0'
          EXPORTING
            i_glt0_rldnr = tdelta-rldnr
            i_rrcty      = '0'
            i_rvers      = '001'
            i_bukrs      = tdelta-bukrs
            i_ryear      = tdelta-gjahr
            i_racct      = tdelta-accnt
            i_rbusa      = tdelta-gsber
            i_rtcur      = tdelta-pswsl
            i_drcrk      = tdelta-shkzg
            i_rpmax      = '016'
          IMPORTING
            et_glt0      = lt_fagl_t_glt0.
        READ TABLE lt_fagl_t_glt0 INTO glt0 INDEX 1.
      ELSE.
        SELECT SINGLE * FROM glt0 WHERE rldnr = tdelta-rldnr
                                    AND rrcty = '0'
                                    AND rvers = '001'
                                    AND bukrs = tdelta-bukrs
                                    AND ryear = tdelta-gjahr
                                    AND racct = tdelta-accnt
                                    AND rbusa = tdelta-gsber
                                    AND rtcur = tdelta-pswsl
                                    AND drcrk = tdelta-shkzg
                                    AND rpmax = '016'.

      ENDIF.
      IF sy-subrc <> 0.
        glt0-rldnr = tdelta-rldnr.
        glt0-rrcty = '0'.
        glt0-rvers = '001'.
        glt0-bukrs = tdelta-bukrs.
        glt0-ryear = tdelta-gjahr.
        glt0-racct = tdelta-accnt.
        glt0-rbusa = tdelta-gsber.
        glt0-rtcur = tdelta-pswsl.
        glt0-drcrk = tdelta-shkzg.
        glt0-rpmax = '016'.
      ENDIF.
      PERFORM hb_update USING tdelta.
      IF gd_glt0_update_allowed = 'X'.

        MODIFY glt0.
        IF sy-subrc = 0.
          CALL FUNCTION 'FUNCTION_EXISTS'
            EXPORTING
              funcname           = 'OPEN_FI_PERFORM_00005012_P'
            EXCEPTIONS
              function_not_exist = 1
              OTHERS             = 2.
          IF sy-subrc = 0.
            CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
              EXPORTING
                i_chgtype         = 'M'
                i_origin          = 'RFINDEX VZ_KORRIGIEREN'
                i_tabname         = 'GLT0'
                i_structure       = glt0
*       TABLES
*         T_STRUCTURE       =
              EXCEPTIONS
                error             = 0
                OTHERS            = 0.
          ENDIF.
        ENDIF.
        PERFORM avoid_zero_amount USING 'GLT0'.
      ENDIF.
    ENDIF.
* --------------------------------------------------------------------
* <------------------------ KNC1 UPDATE ------------------------------
    IF tdelta-name = 'KNC1'.
      SELECT SINGLE * FROM knb1 WHERE bukrs = tdelta-bukrs
                                  AND kunnr = tdelta-accnt.
      IF sy-subrc <> 0.
**------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**------------------------------------------------------------------**
** WRITE:/ 'No KNB1-Entry, could not change Transaction Figures for:'.
**        WRITE:/ tdelta-bukrs, tdelta-accnt.
        CLEAR : gt_foot_line.
        move 'Kein KNB1-Datensatz, Verkehrzahlen konnten nicht angepa#t werden f¨¹r:'(027)
           TO gt_foot_line-line_print.
        MOVE  gv_counter_outtab  TO gt_foot_line-list_no.
        APPEND gt_foot_line.
**------------------------------------------------------------------**
** END OF CHANGES                                             C5053256
**------------------------------------------------------------------**
        CONTINUE.
      ENDIF.

      SELECT SINGLE * FROM knc1 WHERE bukrs = tdelta-bukrs
                                  AND kunnr = tdelta-accnt
                                  AND gjahr = tdelta-gjahr.
      IF sy-subrc <> 0.
        knc1-bukrs = tdelta-bukrs.
        knc1-kunnr = tdelta-accnt.
        knc1-gjahr = tdelta-gjahr.
        knc1-erdat = sy-datum.
        knc1-usnam = sy-repid.
      ENDIF.
      PERFORM nb_update USING tdelta.
      MODIFY knc1.
      IF sy-subrc = 0.
        CALL FUNCTION 'FUNCTION_EXISTS'
          EXPORTING
            funcname           = 'OPEN_FI_PERFORM_00005012_P'
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.
        IF sy-subrc = 0.
          CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
            EXPORTING
              i_chgtype         = 'M'
              i_origin          = 'RFINDEX VZ_KORRIGIEREN'
              i_tabname         = 'KNC1'
              i_structure       = knc1
*     TABLES
*       T_STRUCTURE       =
            EXCEPTIONS
              error             = 0
              OTHERS            = 0.
        ENDIF.
      ENDIF.
      PERFORM avoid_zero_amount USING 'KNC1'.
    ENDIF.
* --------------------------------------------------------------------
* <----------------------- LFC1 UPDATE -------------------------------
    IF tdelta-name = 'LFC1'.
      SELECT SINGLE * FROM lfb1 WHERE bukrs = tdelta-bukrs
                                  AND lifnr = tdelta-accnt.
      IF sy-subrc <> 0.
        WRITE:/ 'Kein LFB1-Datensatz, Verkehrzahlen konnten nicht angepa#t werden f¨¹r:'(028).
        WRITE:/ tdelta-bukrs, tdelta-accnt.
        CONTINUE.
      ENDIF.

      SELECT SINGLE * FROM lfc1 WHERE bukrs = tdelta-bukrs
                                  AND lifnr = tdelta-accnt
                                  AND gjahr = tdelta-gjahr.
      IF sy-subrc <> 0.
        lfc1-bukrs = tdelta-bukrs.
        lfc1-lifnr = tdelta-accnt.
        lfc1-gjahr = tdelta-gjahr.
        lfc1-erdat = sy-datum.
        lfc1-usnam = sy-repid.
      ENDIF.
      PERFORM nb_update USING tdelta.
      MODIFY lfc1.
      IF sy-subrc = 0.
        CALL FUNCTION 'FUNCTION_EXISTS'
          EXPORTING
            funcname           = 'OPEN_FI_PERFORM_00005012_P'
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.
        IF sy-subrc = 0.
          CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
            EXPORTING
              i_chgtype         = 'M'
              i_origin          = 'RFINDEX VZ_KORRIGIEREN'
              i_tabname         = 'LFC1'
              i_structure       = lfc1
*     TABLES
*       T_STRUCTURE       =
            EXCEPTIONS
              error             = 0
              OTHERS            = 0.
        ENDIF.
      ENDIF.
      PERFORM avoid_zero_amount USING 'LFC1'.
    ENDIF.
* --------------------------------------------------------------------
* <--------------------- KNC3 UPDATE ---------------------------------
    IF tdelta-name = 'KNC3'.
      SELECT SINGLE * FROM knb1 WHERE bukrs = tdelta-bukrs
                                  AND kunnr = tdelta-accnt.
      IF sy-subrc <> 0.
**--------------------------------------------------------------------**
**  BEGIN OF CHANGES                                            C5053256
**--------------------------------------------------------------------**
**  WRITE:/ 'No KNB1-Entry, could not change Transaction Figures for:'.
**        WRITE:/ tdelta-bukrs, tdelta-accnt.
        CLEAR : gt_foot_line.
        Move 'Kein KNB1-Datensatz, Verkehrzahlen konnten nicht angepa#t werden f¨¹r:'(027)
           TO gt_foot_line-line_print.
        MOVE   gv_counter_outtab   TO gt_foot_line-list_no.
        APPEND gt_foot_line.
**--------------------------------------------------------------------**
**  END OF CHANGES                                              C5053256
**--------------------------------------------------------------------**
        CONTINUE.
      ENDIF.

      SELECT SINGLE * FROM knc3 WHERE bukrs = tdelta-bukrs
                                  AND kunnr = tdelta-accnt
                                  AND shbkz = tdelta-shbkz
                                  AND gjahr = tdelta-gjahr.
      IF sy-subrc <> 0.
        knc3-bukrs = tdelta-bukrs.
        knc3-kunnr = tdelta-accnt.
        knc3-gjahr = tdelta-gjahr.
        knc3-shbkz = tdelta-shbkz.
      ENDIF.
      PERFORM nb_update USING tdelta.
      MODIFY knc3.
      IF sy-subrc = 0.
        CALL FUNCTION 'FUNCTION_EXISTS'
          EXPORTING
            funcname           = 'OPEN_FI_PERFORM_00005012_P'
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.
        IF sy-subrc = 0.

          CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
            EXPORTING
              i_chgtype         = 'M'
              i_origin          = 'RFINDEX VZ_KORRIGIEREN'
              i_tabname         = 'KNC3'
              i_structure       = knc3
*     TABLES
*       T_STRUCTURE       =
            EXCEPTIONS
              error             = 0
              OTHERS            = 0.
        ENDIF.
      ENDIF.
      PERFORM avoid_zero_amount USING 'KNC3'.
    ENDIF.
* --------------------------------------------------------------------
* <--------------------- LFC3 UPDATE ---------------------------------
    IF tdelta-name = 'LFC3'.
      SELECT SINGLE * FROM lfb1 WHERE bukrs = tdelta-bukrs
                                  AND lifnr = tdelta-accnt.
      IF sy-subrc <> 0.
**--------------------------------------------------------------------**
**  BEGIN OF CHANGES                                            C5053256
**--------------------------------------------------------------------**
**  WRITE:/ 'No LFB1-Entry, could not change Transaction Figures for:'.
**     WRITE:/ tdelta-bukrs, tdelta-accnt.
        CLEAR : gt_foot_line.
        move 'Kein LFB1-Datensatz, Verkehrzahlen konnten nicht angepa#t werden f¨¹r:'(028)
           TO gt_foot_line-line_print.
        MOVE   gv_counter_outtab   TO gt_foot_line-list_no.
        APPEND gt_foot_line.
**--------------------------------------------------------------------**
**  END OF CHANGES                                              C5053256
**--------------------------------------------------------------------**

        CONTINUE.
      ENDIF.

      SELECT SINGLE * FROM lfc3 WHERE bukrs = tdelta-bukrs
                                  AND lifnr = tdelta-accnt
                                  AND shbkz = tdelta-shbkz
                                  AND gjahr = tdelta-gjahr.
      IF sy-subrc <> 0.
        lfc3-bukrs = tdelta-bukrs.
        lfc3-lifnr = tdelta-accnt.
        lfc3-gjahr = tdelta-gjahr.
        lfc3-shbkz = tdelta-shbkz.
      ENDIF.
      PERFORM nb_update USING tdelta.
      MODIFY lfc3.
      IF sy-subrc = 0.
        CALL FUNCTION 'FUNCTION_EXISTS'
          EXPORTING
            funcname           = 'OPEN_FI_PERFORM_00005012_P'
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.
        IF sy-subrc = 0.

          CALL FUNCTION 'OPEN_FI_PERFORM_00005012_P'
            EXPORTING
              i_chgtype         = 'M'
              i_origin          = 'RFINDEX VZ_KORRIGIEREN'
              i_tabname         = 'LFC3'
              i_structure       = lfc3
*     TABLES
*       T_STRUCTURE       =
            EXCEPTIONS
              error             = 0
              OTHERS            = 0.
        ENDIF.
      ENDIF.
      PERFORM avoid_zero_amount USING 'LFC3'.
    ENDIF.
  ENDLOOP.
  DESCRIBE TABLE tdelta LINES sy-tfill.
  IF sy-batch IS INITIAL.
    MESSAGE i000 WITH sy-tfill 'Datens#tze ge#ndert'(029).
  ENDIF.


  CLEAR tdelta.
  REFRESH tdelta.

ENDFORM.                    "vz_korrigieren


* -------------------------------------------------------------------- *
*                      F070: KNC1/LFC1 Change                          *
* -------------------------------------------------------------------- *
DEFINE vz_update.
  if tb-monat = &1.
    amount_delta = tb-delta.
    if tb-shkzg = 'S'.
      amount_before = &2-um&1s.
      &2-um&1s = &2-um&1s + tb-delta.
      amount_after = &2-um&1s.
    endif.
    if tb-shkzg = 'H'.
      amount_before = &2-um&1h.
      &2-um&1h = &2-um&1h + tb-delta.
      amount_after = &2-um&1h.
    endif.
    if tb-shkzg = 'U'.
      amount_before = &2-um&1u.
      &2-um&1u = &2-um&1u + tb-delta.
      amount_after = &2-um&1u.
    endif.
    write:/ tb-name,
            &2-bukrs,
            tb-accnt,
            &2-gjahr,
            tb-shkzg,
            tb-monat,
            'Vorher'(030),
            amount_before currency t001-waers,
            'Nachher'(031),
            amount_after currency t001-waers,
            'Delta'(032),
            amount_delta currency t001-waers.

  endif.
END-OF-DEFINITION.
* -------------------------------------------------------------------- *
*                      F070: GLT0 Change                               *
* -------------------------------------------------------------------- *
DEFINE vz_update_glt0.
  if tb-monat = &1.
    amount_delta = tb-delta.
    if tb-name = 'TSL'.
      amount_before = glt0-tsl&1.
      glt0-tsl&1 = glt0-tsl&1 + tb-delta.
      amount_after = glt0-tsl&1.
    endif.
    if tb-name = 'HSL'.
      amount_before = glt0-hsl&1.
      glt0-hsl&1 = glt0-hsl&1 + tb-delta.
      amount_after = glt0-hsl&1.
    endif.
    if tb-name = 'KSL'.
      amount_before = glt0-ksl&1.
      glt0-ksl&1 = glt0-ksl&1 + tb-delta.
      amount_after = glt0-ksl&1.
    endif.
    write:/ glt0-rldnr,
            glt0-bukrs,
            glt0-racct,
            glt0-ryear,
            glt0-rbusa,
            glt0-drcrk,
            glt0-rtcur,
            tb-name,
            tb-monat,
            'Vorher'(030),
            amount_before currency t001-waers,
            'Nachher'(031),
            amount_after currency t001-waers,
            'Delta'(032),
            amount_delta currency t001-waers.
  endif.
END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*                      F070: KNC3/LFC3 Change
* -------------------------------------------------------------------- *
DEFINE vz_update_shb.
  amount_delta = tb-delta.
  if tb-shkzg = 'S'.
    amount_before = &1-solll.
    &1-solll = &1-solll + tb-delta.
    amount_after = &1-solll.
  endif.
  if tb-shkzg = 'H'.
    amount_before = &1-habnl.
    &1-habnl = &1-habnl + tb-delta.
    amount_before = &1-habnl.
  endif.
  write:/ tb-name,
          &1-bukrs,
          tb-accnt,
          &1-gjahr,
          &1-shbkz,
          'Vorher'(030),
          amount_before currency t001-waers,
          'Nachher'(031),
          amount_after currency t001-waers,
          'Delta'(032),
          amount_delta currency t001-waers.

END-OF-DEFINITION.


* -------------------------------------------------------------------- *
*                     F070: Subledger Changes                          *
* -------------------------------------------------------------------- *
FORM nb_update USING tb LIKE tdelta.
  DATA: amount_before LIKE glt0-hsl01,
        amount_after LIKE glt0-hsl01,
        amount_delta LIKE glt0-hsl01.

  IF tb-name = 'KNC3'.
    vz_update_shb knc3.
  ENDIF.
  IF tb-name = 'LFC3'.
    vz_update_shb lfc3.
  ENDIF.

  IF tb-name = 'KNC1'.
    vz_update 01 knc1.
    vz_update 02 knc1.
    vz_update 03 knc1.
    vz_update 04 knc1.
    vz_update 05 knc1.
    vz_update 06 knc1.
    vz_update 07 knc1.
    vz_update 08 knc1.
    vz_update 09 knc1.
    vz_update 10 knc1.
    vz_update 11 knc1.
    vz_update 12 knc1.
    vz_update 13 knc1.
    vz_update 14 knc1.
    vz_update 15 knc1.
    vz_update 16 knc1.
  ENDIF.

  IF tb-name = 'LFC1'.
    vz_update 01 lfc1.
    vz_update 02 lfc1.
    vz_update 03 lfc1.
    vz_update 04 lfc1.
    vz_update 05 lfc1.
    vz_update 06 lfc1.
    vz_update 07 lfc1.
    vz_update 08 lfc1.
    vz_update 09 lfc1.
    vz_update 10 lfc1.
    vz_update 11 lfc1.
    vz_update 12 lfc1.
    vz_update 13 lfc1.
    vz_update 14 lfc1.
    vz_update 15 lfc1.
    vz_update 16 lfc1.
  ENDIF.



ENDFORM.                    "nb_update
* -------------------------------------------------------------------- *
*                      F070: G/L update                                *
* -------------------------------------------------------------------- *
FORM hb_update USING tb LIKE tdelta.
  DATA: amount_before LIKE glt0-hsl01,
        amount_after LIKE glt0-hsl01,
        amount_delta LIKE glt0-hsl01.
  vz_update_glt0 01.
  vz_update_glt0 02.
  vz_update_glt0 03.
  vz_update_glt0 04.
  vz_update_glt0 05.
  vz_update_glt0 06.
  vz_update_glt0 07.
  vz_update_glt0 08.
  vz_update_glt0 09.
  vz_update_glt0 10.
  vz_update_glt0 11.
  vz_update_glt0 12.
  vz_update_glt0 13.
  vz_update_glt0 14.
  vz_update_glt0 15.
  vz_update_glt0 16.
ENDFORM.                    "hb_update
************************************************************************
*                |---------------------------------|                   *
*                | E n d   o f  F 0 7 0    p a r t |                   *
*                |---------------------------------|                   *
************************************************************************
* -------------------------------------------------------------------- *
*            Debitoren selektieren und pr¨¹fen
*                     Index - Bseg
* -------------------------------------------------------------------- *
FORM debi_select TABLES iknb1 STRUCTURE no_knb1
                        iperiv STRUCTURE tmonat
                        ebseg STRUCTURE bseg
                 USING a_bukrs LIKE t001-bukrs
                 CHANGING p_error_log TYPE ty_error_log.
  PERFORM initialize_progress.
  LOOP AT iknb1.
    CLEAR account_written.
    odd = true.
    IF p_any = 'X' OR p_oi = 'X'.
      PERFORM bsid_bsad_pruefen TABLES iperiv
                                       ebseg
                                USING 'BSID'
                                      a_bukrs
                                      iknb1-kunnr
                             CHANGING p_error_log.
    ENDIF.
    CLEAR account_written.
    IF p_any = 'X' OR p_cl = 'X'.
      PERFORM bsid_bsad_pruefen TABLES iperiv
                                       ebseg
                                USING 'BSAD'
                                      a_bukrs
                                      iknb1-kunnr
                             CHANGING p_error_log.
    ENDIF.
  ENDLOOP.                                                  "knb1.
ENDFORM.                    "debi_select

* -------------------------------------------------------------------- *
*                Kreditoren selektieren und pr¨¹fen
*                         Index - Bseg
* -------------------------------------------------------------------- *
FORM kredi_select TABLES   ilfb1 STRUCTURE no_lfb1
                           iperiv STRUCTURE tmonat
                           ebseg STRUCTURE bseg
                  USING    a_bukrs LIKE t001-bukrs
                  CHANGING p_error_log TYPE ty_error_log.
  PERFORM initialize_progress.
  LOOP AT ilfb1.
    CLEAR account_written.
    odd = true.
    IF p_any = 'X' OR p_oi = 'X'.
      PERFORM bsik_bsak_pruefen TABLES iperiv
                                       ebseg
                                USING    'BSIK'
                                         a_bukrs
                                         ilfb1-lifnr
                                CHANGING p_error_log.
    ENDIF.
    CLEAR account_written.
    IF p_any = 'X' OR p_cl = 'X'.
      PERFORM bsik_bsak_pruefen TABLES iperiv
                                       ebseg
                                USING    'BSAK'
                                         a_bukrs
                                         ilfb1-lifnr
                                CHANGING p_error_log.
    ENDIF.
  ENDLOOP.                                                  "lfb1.
ENDFORM.                    "kredi_select

* -------------------------------------------------------------------- *
*                Bsim selektieren und pr¨¹fen
*                         Index - Bseg
* -------------------------------------------------------------------- *
FORM bsim_select TABLES   ilfb1 STRUCTURE no_lfb1
                           iperiv STRUCTURE tmonat
                           ebseg STRUCTURE bseg
                  USING    a_bukrs LIKE t001-bukrs
                  CHANGING p_error_log TYPE ty_error_log.   "#EC NEEDED
  PERFORM initialize_progress.

  DATA lt_matnr TYPE TABLE OF matnr.
  FIELD-SYMBOLS <ld_matnr> TYPE matnr.
  SELECT matnr FROM mara INTO TABLE lt_matnr WHERE matnr IN p_matnr.
  LOOP AT lt_matnr ASSIGNING <ld_matnr>.

    CLEAR account_written.
    odd = true.

    PERFORM bsim_pruefen TABLES iperiv
                                ebseg
                          USING 'BSIM'
                                a_bukrs
                                <ld_matnr>
                       CHANGING p_error_log.

  ENDLOOP.

ENDFORM.                    "bsim_select


* -------------------------------------------------------------------- *
*            Sachkonten selektieren und pr¨¹fen
*                    Index - Bseg
* -------------------------------------------------------------------- *
FORM sako_select TABLES iskb1 STRUCTURE no_skb1
                        iperiv STRUCTURE tmonat
                        ebseg STRUCTURE bseg
                 USING a_bukrs LIKE t001-bukrs
                 CHANGING p_error_log TYPE ty_error_log.

  DATA : konsist_oi TYPE i,
         masterstring1(80),
         masterstring2(75).
  PERFORM initialize_progress.
  LOOP AT iskb1.
    MOVE-CORRESPONDING iskb1 TO skb1.                       "#EC ENHOK
    skb1-bukrs = a_bukrs.
    CLEAR account_written.
    CHECK NOT iskb1-saknr IS INITIAL.
    konsist_oi = true.
    IF iskb1-mitkz IS INITIAL
      AND iskb1-xopvw = 'X' AND iskb1-xkres IS INITIAL.
*    Offenpostenflag ist gesetzt aber Einzelpostenflag nicht
*    Korrektur der SKB1 erforderlich, danach nochmals Report starten
      CONCATENATE 'Buchungskreis'(353) a_bukrs 'Konto'(306) iskb1-saknr
      INTO masterstring1 SEPARATED BY space.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                            C5053256
**--------------------------------------------------------------------**
      CLEAR  : gt_foot_line.
      MOVE gv_counter_outtab TO gt_foot_line-list_no.
      MOVE masterstring1     TO gt_foot_line-line_print.
      APPEND gt_foot_line.
**      SKIP.
**      WRITE:/ masterstring1 COLOR COL_TOTAL INTENSIFIED OFF.
**--------------------------------------------------------------------**
** END OF CHANGES                                               C5053256
**--------------------------------------------------------------------**
      CONCATENATE 'SKB1-XKRES = space'(033) 'and SKB1-XOPVW = "X"'(034)
      INTO masterstring2 SEPARATED BY space.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                            C5053256
**--------------------------------------------------------------------**
**      WRITE:/6 masterstring2 COLOR COL_HEADING INTENSIFIED OFF.
**      WRITE:/10(71) 'G/L master must be corrected, no check possible'
**                 COLOR COL_NORMAL INTENSIFIED OFF.
      CLEAR  : gt_foot_line.
      MOVE gv_counter_outtab TO gt_foot_line-list_no.
      MOVE masterstring2     TO gt_foot_line-line_print.
      APPEND gt_foot_line.
      CLEAR  : gt_foot_line.
      MOVE gv_counter_outtab TO gt_foot_line-list_no.
      move 'Stammsatz muss korrigiert werden, keine Pr¨¹fung m#glich'(035)
      TO gt_foot_line-line_print.
      APPEND gt_foot_line.
**--------------------------------------------------------------------**
** END OF CHANGES                                               C5053256
**--------------------------------------------------------------------**
      konsist_oi = false.
    ENDIF.
    IF konsist_oi = true.
      odd = true.
      IF p_any = 'X' OR p_oi = 'X'.
        PERFORM bsis_bsas_pruefen TABLES iperiv
                                         ebseg
                                  USING    'BSIS'
                                           a_bukrs
                                           iskb1-saknr
                                  CHANGING p_error_log.
      ENDIF.
      CLEAR account_written.
      IF p_any = 'X' OR p_cl = 'X'.
        PERFORM bsis_bsas_pruefen TABLES iperiv
                                         ebseg
                                  USING    'BSAS'
                                           a_bukrs
                                           iskb1-saknr
                                  CHANGING p_error_log.
      ENDIF.

    ENDIF.
  ENDLOOP.                                                  "skb1.

ENDFORM.                    "sako_select

* -------------------------------------------------------------------- *
*            Sachkontenindices selektieren und pr¨¹fen
* -------------------------------------------------------------------- *
FORM bsis_bsas_pruefen TABLES iperiv STRUCTURE tmonat
                              ebseg STRUCTURE bseg
                       USING name LIKE bseg-bukrs
                             p_bukrs LIKE bseg-bukrs
                             p_saknr LIKE bseg-saknr
                       CHANGING p_error_log TYPE ty_error_log.
  DATA: buffer LIKE bseg,
        buffer2 LIKE bkpf,
        p_cursor TYPE cursor.
  RANGES: raugbl FOR bseg-augbl,
          raugdt FOR bseg-augdt.
  IF name CA 'A'.
    raugbl[] = p_augbl[].
    raugdt[] = p_augdt[].
  ENDIF.

  OPEN CURSOR WITH HOLD p_cursor FOR SELECT * FROM (name)
      WHERE  bukrs  EQ p_bukrs
      AND    hkont  EQ p_saknr
      AND    augdt  IN raugdt
      AND    augbl  IN raugbl

      AND    gjahr  IN p_gjahr
      AND    belnr  IN p_belnr
      AND    monat  IN p_monat
      AND    budat  IN p_budat
      AND    gsber  IN p_gsber
      AND    pswsl  IN p_pswsl
      AND    xarch  EQ space.
  DO.
    FETCH NEXT CURSOR p_cursor INTO bsis.
    IF sy-subrc <> 0.
      CLOSE CURSOR p_cursor.
      EXIT.
    ENDIF.
    CHECK bsis-budat IN  p_budat.
    CHECK bsis-monat IN p_monat.
    CHECK bsis-gsber IN p_gsber.
    CHECK bsis-pswsl IN p_pswsl.
    CHECK bsis-xarch IS INITIAL.
    CHECK bsis-waers IN p_waers.
    CHECK NOT bsis-hkont IS INITIAL.         " <-- zur Sicherheit
    CHECK NOT bsis-bukrs IS INITIAL.         " <-- zur Sicherheit
    CLEAR buffer.
    MOVE-CORRESPONDING bsis TO buffer.                      "#EC ENHOK
    MOVE-CORRESPONDING bsis TO buffer2.                     "#EC ENHOK
    add_check.
    PERFORM check_index1 TABLES   iperiv
                                  ebseg
                         USING    buffer
                                  buffer2
                                  name
                                  ''
                         CHANGING p_error_log.
  ENDDO.
  IF repair = 'X' OR x_delhd = 'X' OR x_delind = 'X'.
    COMMIT WORK.
  ENDIF.
ENDFORM.                    "bsis_bsas_pruefen

* -------------------------------------------------------------------- *
*            Debitorenindices selektieren und pr¨¹fen
* -------------------------------------------------------------------- *
FORM bsid_bsad_pruefen TABLES iperiv STRUCTURE tmonat
                              ebseg STRUCTURE bseg
                       USING name LIKE bseg-bukrs
                             p_bukrs LIKE bseg-bukrs
                             p_kunnr LIKE bseg-kunnr
                       CHANGING p_error_log TYPE ty_error_log.
  DATA: buffer LIKE bseg,
        buffer2 LIKE bkpf,
        p_cursor TYPE cursor.
  RANGES: raugbl FOR bseg-augbl,
          raugdt FOR bseg-augdt.
  IF name CA 'A'.
    raugbl[] = p_augbl[].
    raugdt[] = p_augdt[].
  ENDIF.


  OPEN CURSOR WITH HOLD p_cursor FOR SELECT * FROM (name)
       WHERE  bukrs  EQ p_bukrs
       AND    kunnr  EQ p_kunnr
       AND    umsks  IN p_umsks
       AND    umskz  IN p_umskz
       AND    augdt  IN raugdt
       AND    augbl  IN raugbl

       AND    gjahr  IN p_gjahr
       AND    belnr  IN p_belnr
       AND    monat  IN p_monat
       AND    budat  IN p_budat
       AND    gsber  IN p_gsber
       AND    pswsl  IN p_pswsl

       AND    xarch  =  space.

  DO.
    FETCH NEXT CURSOR p_cursor INTO bsid.
    IF sy-subrc <> 0.
      CLOSE CURSOR p_cursor.
      EXIT.
    ENDIF.
    CHECK bsid-monat IN p_monat.
    CHECK bsid-budat IN  p_budat.
    CHECK bsid-gsber IN p_gsber.
    CHECK bsid-pswsl IN p_pswsl.
    CHECK bsid-waers IN p_waers.
    CHECK bsid-xarch IS INITIAL.
    CHECK NOT bsid-kunnr IS INITIAL.         " <-- zur Sicherheit
    CHECK NOT bsid-bukrs IS INITIAL.         " <-- zur Sicherheit
    CLEAR buffer.
    MOVE-CORRESPONDING bsid TO buffer.                      "#EC ENHOK
    MOVE-CORRESPONDING bsid TO buffer2.                     "#EC ENHOK
    add_check.
    PERFORM check_index1 TABLES iperiv
                                ebseg
                          USING buffer buffer2 name ''
                       CHANGING p_error_log.
  ENDDO.
  IF repair = 'X' OR x_delhd = 'X' OR x_delind = 'X'.
    COMMIT WORK.
  ENDIF.
ENDFORM.                    "bsid_bsad_pruefen

* -------------------------------------------------------------------- *
*            Kreditorenindices selektieren und pr¨¹fen
* -------------------------------------------------------------------- *
FORM bsik_bsak_pruefen TABLES iperiv STRUCTURE tmonat
                              ebseg STRUCTURE bseg
                       USING name LIKE bseg-bukrs
                             p_bukrs LIKE bseg-bukrs
                             p_lifnr LIKE bseg-lifnr
                       CHANGING p_error_log TYPE ty_error_log.
  DATA: buffer LIKE bseg,
        buffer2 LIKE bkpf,
        p_cursor TYPE cursor.
  RANGES: raugbl FOR bseg-augbl,
          raugdt FOR bseg-augdt.
  IF name CA 'A'.
    raugbl[] = p_augbl[].
    raugdt[] = p_augdt[].
  ENDIF.

  OPEN CURSOR WITH HOLD p_cursor FOR SELECT * FROM (name)
    WHERE  bukrs  EQ p_bukrs
    AND    lifnr  EQ p_lifnr
    AND    umsks  IN p_umsks
    AND    umskz  IN p_umskz
    AND    augdt  IN raugdt
    AND    augbl  IN raugbl
    AND    gjahr  IN p_gjahr
    AND    belnr  IN p_belnr
    AND    monat  IN p_monat
    AND    budat  IN p_budat
    AND    gsber  IN p_gsber
    AND    pswsl  IN p_pswsl
    AND    xarch  =  space.

  DO.
    FETCH NEXT CURSOR p_cursor INTO bsik.
    IF sy-subrc <> 0.
      CLOSE CURSOR p_cursor.
      EXIT.
    ENDIF.
    CHECK bsik-budat IN  p_budat.
    CHECK bsik-monat IN p_monat.
    CHECK bsik-gsber IN p_gsber.
    CHECK bsik-pswsl IN p_pswsl.
    CHECK bsik-waers IN p_waers.
    CHECK bsik-xarch IS INITIAL.
    CHECK NOT bsik-lifnr IS INITIAL.         " <-- zur Sicherheit
    CHECK NOT bsik-bukrs IS INITIAL.         " <-- zur Sicherheit
    CLEAR buffer.
    MOVE-CORRESPONDING bsik TO buffer.                      "#EC ENHOK
    MOVE-CORRESPONDING bsik TO buffer2.                     "#EC ENHOK
    add_check.
    PERFORM check_index1 TABLES iperiv
                                ebseg
                         USING buffer buffer2 name ''
                      CHANGING p_error_log.
  ENDDO.
  IF repair = 'X' OR x_delhd = 'X' OR x_delind = 'X'.
    COMMIT WORK.
  ENDIF.
ENDFORM.                    "bsik_bsak_pruefen

*&--------------------------------------------------------------------*
*&      Form  bsim_pruefen
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->IPERIV     text
*      -->EBSEG      text
*      -->NAME       text
*      -->P_BUKRS    text
*      -->P_MATNR    text
*      -->P_ERROR_LOGtext
*---------------------------------------------------------------------*
FORM bsim_pruefen TABLES iperiv STRUCTURE tmonat
                              ebseg STRUCTURE bseg
                       USING name LIKE bseg-bukrs
                             p_bukrs LIKE bseg-bukrs
                             p_matnr LIKE bseg-matnr
                       CHANGING p_error_log TYPE ty_error_log.
  DATA: buffer LIKE bseg,
        buffer2 LIKE bkpf,
        p_cursor TYPE cursor.

  DATA lt_t001k TYPE standard table of t001k.
  SELECT * FROM t001k INTO table lt_t001k WHERE bukrs = p_bukrs.

  describe table lt_t001k lines sy-tfill.
  CHECK sy-tfill gt 0.



  OPEN CURSOR WITH HOLD p_cursor FOR SELECT * FROM (name)
     for all entries in lt_t001k
     WHERE matnr = p_matnr
       AND bwkey = lt_t001k-bwkey.

  DO.
    FETCH NEXT CURSOR p_cursor INTO bsim.
    IF sy-subrc <> 0.
      CLOSE CURSOR p_cursor.
      EXIT.
    ENDIF.
    CHECK bsim-budat IN p_budat.
    CLEAR buffer.
    MOVE-CORRESPONDING bsim TO buffer.                      "#EC ENHOK
    MOVE-CORRESPONDING bsim TO buffer2.                     "#EC ENHOK
    buffer2-bukrs = p_bukrs.
    buffer-bukrs = p_bukrs.
    add_check.
    PERFORM check_index1 TABLES iperiv
                                ebseg
                         USING buffer buffer2 name p_bukrs
                      CHANGING p_error_log.
  ENDDO.
  IF repair = 'X' OR x_delhd = 'X' OR x_delind = 'X'.
    COMMIT WORK.
  ENDIF.
ENDFORM.                    "bsim_pruefen


* -------------------------------------------------------------------- *
*           Eine Index-zeile mit der Bseg vergleichen
*                       Index - Bseg
* ----------------------------------------------------------------------
FORM check_index1 TABLES   iperiv STRUCTURE tmonat
                           ebseg STRUCTURE bseg
                  USING    index LIKE bseg
                           kopf  LIKE bkpf
                           name LIKE bseg-bukrs
                           id_bukrs LIKE bkpf-bukrs " if not space: BSIM
                  CHANGING p_error_log TYPE ty_error_log.   "#EC NEEDED
  DATA: error,
        error_line LIKE string100,
        bkpf_kopf LIKE bkpf,
        errors_all TYPE i.
  STATICS: db_change TYPE i.
* -------------------------------------------------------------------- *
* Bseg vorhanden ?                                                     *
* konsistente Ausgleichsinformation in Bseg ?                          *
* -------------------------------------------------------------------- *
  PERFORM get_bseg_from_index
          USING index
          CHANGING error_line error p_error_log.
*    Returncodes:
*       Error = 'A' = Bseg fehlt zum Index
*       Error = 'C' = Inkonsistente Ausgleichsinformation in Bseg
* ------------- Pr¨¹fen / L#schen BKPF -------------------------------- *
  PERFORM check_bkpf TABLES   iperiv
                     USING    index
                              kopf
                              name
                     CHANGING error
                              error_line
                              bkpf_kopf
                              p_error_log.

* --------------- Allgemeine Checks ---------------------------------- *
* ¨¹berpr¨¹fen ob der Eintrag in die Tabelle geh#rt
  PERFORM index_in_correct_table
          USING name index
          CHANGING error error_line.
* -------------------------------------------------------------------- *
*     Error = 'X' = nur wenn Bseg vorhanden mit kons. Ausgl.inf.
*     und Index in falscher Tabelle oder mit inkon. Ausgl.inf.
*     ansonsten bleibt die Errorvariable unver#ndert
* -------------------------------------------------------------------- *

* -------------------------------------------------------------------- *
*                   Gibt's die Ausgleichsbelegnummer                   *
*   Standardm##ig auskommentiert, da bei Archivierung problematisch    *
* -------------------------------------------------------------------- *

  IF NOT error CA 'AC'.
*  Bseg vorhanden mit konsistenter Ausgleichsinformation
*  dann weitere Pr¨¹fungen ( auch wenn Error = 'X' )
    PERFORM check_any_index TABLES   iperiv
                            USING    name
                                     index
                                     kopf
                                     bkpf_kopf
                            CHANGING error
                                     error_line
                                     p_error_log.
  ENDIF.

* -------------------------------------------------------------------- *
* nach den Pr¨¹fungen ensprechend der 'error'-Variablen reagieren:
* Bem: repair = 'X' wird durch den Benutzer gesetzt
*       error = 'A' keine Bseg; Index wird nicht gel#scht obwohl
*                   scheinbar ¨¹berfl¨¹ssig.
*                   dient zur sicherheit, damit bei kaputten bsegs
*                   nicht f#lschlicherweise der index gel#scht wird.
*       error = 'C  Inkonsistente Ausgleichsinformation in Bseg
*                   aber konsistent zum index. status ausgeben, aber
*                   keine Reparatur des Index
*       error = ' ' es wird keine reparatur durchgef¨¹hrt Index ok.
*       error = 'X' der aufgetretene Fehler wird repariert.
* -------------------------------------------------------------------- *

  IF ( repair   = 'X' AND error = 'X' ) OR
     ( x_delind = 'X' AND error = 'A' ).
* Es soll (repair =   'X') und es kann (error = 'X') repariert werden
* Es soll (x_delind = 'X') und es kann (error = 'A') gel#scht werden

* ----- Zwischenspeichern der Kopfinformation und Index l#schen ------ *
    DATA save_bkpf LIKE bkpf.
    PERFORM store_delete_index USING    name
                                        bkpf_kopf
                                        kopf
                               CHANGING save_bkpf
                                        p_error_log
                                        error_line.
    IF error = 'X'.
* ------------------ Neuen Index erzeugen ---------------------------- *
      PERFORM modify_index USING    bseg
                                    save_bkpf
                                    name
                           CHANGING p_error_log
                                    error_line.
    ENDIF.
  ENDIF.
* ------------------ Fehlerausgabe ----------------------------------- *
  IF error <> space OR NOT error_line IS INITIAL.
    IF repair = 'X' OR x_delhd = 'X' OR x_delind = 'X'.
      ADD 1 TO db_change.
      IF db_change >= c_max.
        CALL FUNCTION 'DB_COMMIT'.
        db_change = 0.
      ENDIF.
    ENDIF.
    PERFORM write_index_err
            TABLES ebseg
            USING bseg index name error_line error
            CHANGING p_error_log.
  ENDIF.
  PERFORM fehler_summieren                      "  <--  Fehler summieren
                  USING p_error_log
               CHANGING errors_all.

  PERFORM execute_progress USING errors_all
                                 name.
ENDFORM.                    "check_index1
* -------------------------------------------------------------------- *
*             gibt's die Ausgleichsbelegnummer
* -------------------------------------------------------------------- *
*FORM ausgleichsbelegnummer USING    index LIKE bseg
*                           CHANGING error_line LIKE string100.
*  CHECK NOT index-augbl IS INITIAL.
*  DATA: len TYPE i.
*  len = STRLEN( index-augbl ).
*CHECK len > 3.                " R/2 Ausgleichsziffern nicht pr¨¹fen
*  STATICS dummy LIKE bkpf.
*  IF index-bukrs = dummy-bukrs AND
*     index-belnr = dummy-belnr AND
*     index-gjahr = dummy-gjahr.
*    EXIT.
*  ENDIF.
*  SELECT SINGLE bukrs belnr gjahr FROM bkpf
*                           INTO CORRESPONDING FIELDS OF dummy
*         WHERE  bukrs  = index-bukrs
*         AND    belnr  = index-augbl
*         AND    gjahr  = index-gjahr.
*
*  IF sy-subrc <> 0.
*    append_error 'NO_AUGBL'.
*  ENDIF.
*
*ENDFORM.                    "ausgleichsbelegnummer

* -------------------------------------------------------------------- *
*           Index in der richtigen Tabelle ?
* -------------------------------------------------------------------- *
FORM index_in_correct_table USING name  TYPE any
                                  p_index LIKE bseg
                         CHANGING p_state TYPE any
                                  error_line TYPE any.
  IF name = 'BSIM'.
    EXIT.
  ENDIF.


  IF ( name CP 'BSI*' AND
       ( ( NOT p_index-augdt IS INITIAL ) OR
        ( NOT p_index-augbl IS INITIAL ) ) )  OR
     ( name CP 'BSA*' AND
       ( ( p_index-augdt IS INITIAL ) OR
        ( p_index-augbl IS INITIAL ) ) ).
*    Index in falscher Tabelle !!
*    Konsistent falsch oder inkonsistente Ausgleichsinformation ?
    IF ( p_index-augdt IS INITIAL AND NOT p_index-augbl IS INITIAL ) OR
       ( NOT p_index-augdt IS INITIAL AND p_index-augbl IS INITIAL ).
*          Inkonsistente Ausgleichsinformation
      append_error 'Inkonsistenter Ausgleich'(036).
    ELSE.
*          Eintrag mit konsistenter Ausgleichsinf. in falscher Tabelle
      append_error 'Datensatz in falscher Tabelle'(037).
    ENDIF.
    IF p_state IS INITIAL.
*       Bseg vorh. und mit konsistenter Ausgleichsinformation
      p_state = 'X'.
    ENDIF.
  ENDIF.

ENDFORM.                    "index_in_correct_table

* -------------------------------------------------------------------- *
*      Gibt's zum Index einen Bseg Eintrag ?
* -------------------------------------------------------------------- *
FORM get_bseg_from_index USING p_index LIKE bseg
                      CHANGING error_line TYPE any
                               p_state TYPE any
                               p_error_log TYPE ty_error_log.

  SELECT SINGLE * FROM  bseg
         WHERE  bukrs  = p_index-bukrs
         AND    belnr  = p_index-belnr
         AND    gjahr  = p_index-gjahr
         AND    buzei  = p_index-buzei.
  IF sy-subrc <> 0.
*      Es gibt keine Bseg zum Index
    ADD 1 TO p_error_log-bseg-error.
    p_state = 'A'. " <-- Bseg fehlt
    append_error 'NO_BSEG'.
  ELSE.
*      Es gibt eine Bseg zum Index
    ADD 1 TO p_error_log-bseg-check.
*      Konsistente Ausgleichsinformation in Bseg ?
    IF ( bseg-augbl IS INITIAL AND  NOT bseg-augdt IS INITIAL ) OR
       ( NOT bseg-augbl IS INITIAL AND bseg-augdt IS INITIAL ).
      append_error 'Bseg_Incon_Clear'.
      p_state = 'C'. " <-- bei Inkonsistenter Ausgleichsinf.in Bseg
    ENDIF.
  ENDIF.
ENDFORM.                    "get_bseg_from_index

* -------------------------------------------------------------------- *
*    Belegkopf l#schen, wenn keine Bseg, aber Index ist vorhanden      *
*    Zus#tzlich auch noch RFBLG l#schen wenn vorhanden                 *
* -------------------------------------------------------------------- *
FORM check_bkpf TABLES p_periv STRUCTURE tmonat
                USING    p_index LIKE bseg
                         ikopf LIKE bkpf
                         p_name LIKE bseg-bukrs
                CHANGING p_state TYPE c
                         error_line LIKE string100
                         p_bkpf LIKE bkpf
                         p_error_log TYPE ty_error_log.     "#EC NEEDED

  STATICS: savebkpf LIKE bkpf.
  DATA: name LIKE bseg-bukrs.
  name = 'BKPF'.
  IF savebkpf-bukrs <> p_index-bukrs OR
     savebkpf-belnr <> p_index-belnr OR
     savebkpf-gjahr <> p_index-gjahr.
    SELECT SINGLE * FROM bkpf WHERE bukrs EQ p_index-bukrs
                                AND belnr EQ p_index-belnr
                                AND gjahr EQ p_index-gjahr.

    IF sy-subrc = 0.
      DATA: no_use TYPE c.
      add_check.

      PERFORM periode_pruefen_2 TABLES   p_periv
                                USING    bkpf-budat
                                         bkpf-monat
                                         bkpf-gjahr
                                         'BKPF'
                                CHANGING p_error_log
                                         error_line
                                         no_use.
      p_bkpf = bkpf.
      savebkpf = bkpf.                           " <-- merken
      IF p_state = 'A'.
*       Es gibt einen Kopf, die Bseg-zeile zum Index fehlt
*       Nachlesen, ob der Kopf keine Zeilen hat
        PERFORM delete_header USING    p_bkpf
                              CHANGING p_error_log
                                       error_line.
      ENDIF.                                     " <-- p_state = 'A'
    ELSE.                                          " <-- sy-subrc auf BKPF
      add_error.
      append_error 'NO_BKPF'.
    ENDIF.                                         " <-- sy-subrc auf BKPF
  ELSE.                                            " <-- If savebkpf...
*     Vorg#nger-Belegkopf = Aktueller Belegkopf
    p_bkpf = savebkpf.
    add_check.
    PERFORM periode_pruefen_2 TABLES   p_periv
                              USING    savebkpf-budat
                                       savebkpf-monat
                                       savebkpf-gjahr
                                       'BKPF'
                              CHANGING p_error_log
                                       error_line
                                       no_use.

    IF p_state = 'A'.
*       Es gibt einen Kopf, die Bseg-zeile zum Index fehlt
*       Nachlesen, ob der Kopf keine Zeilen hat
      PERFORM delete_header USING    savebkpf
                            CHANGING p_error_log
                                     error_line.
    ENDIF.                                     " <-- p_state = 'A'

  ENDIF.                                           " <-- If savebkpf...
ENDFORM.                    "check_bkpf
* -------------------------------------------------------------------- *
*             Kopf/RFBLG ohne BSEG l#schen (Index->Bseg)
* -------------------------------------------------------------------- *
FORM delete_header USING    p_bkpf LIKE bkpf
                   CHANGING p_error_log TYPE ty_error_log
                            error_line LIKE string100.
  DATA: string LIKE string100.
  string = 'Andere Belegzeile:'(038).
  SELECT * FROM  bseg
        WHERE    bukrs  = p_bkpf-bukrs
          AND    belnr  = p_bkpf-belnr
          AND    gjahr  = p_bkpf-gjahr.
    CONCATENATE string bseg-buzei INTO string SEPARATED BY space.
  ENDSELECT.
  IF sy-subrc <> 0.     " <-- es gibt keine keine einzige bseg-zeile
    IF x_delhd = 'X'.
*         Kopf ohne Bseg wird gel#scht -> auch Cluster l#schen
      PERFORM kopf_loeschen USING    p_bkpf
                            CHANGING p_error_log
                                     error_line.
    ELSE.
      append_error 'BKPF_FOUND'.
    ENDIF.
  ELSE.                                      " <-- sy-subrc auf BSEG
    append_error string.
  ENDIF.                                     " <-- sy-subrc auf BSEG


ENDFORM.                    "delete_header

* -------------------------------------------------------------------- *
*             Kopf/RFBLG ohne BSEG l#schen (Index->Bseg)
* -------------------------------------------------------------------- *
FORM kopf_loeschen USING    p_bkpf LIKE bkpf
                   CHANGING p_error_log TYPE ty_error_log
                            error_line LIKE string100.

  DELETE FROM rfblg WHERE bukrs EQ p_bkpf-bukrs
                      AND belnr EQ p_bkpf-belnr
                      AND gjahr EQ p_bkpf-gjahr.
  IF sy-subrc = 0.
    append_error 'RFBLG_DELETED'.
  ENDIF.
  DATA name LIKE bseg-bukrs.
  name = 'BKPF'.
  index_delete name p_bkpf.
ENDFORM.                    "kopf_loeschen
* -------------------------------------------------------------------- *
*              Indices neu erzeugen                                    *
* -------------------------------------------------------------------- *
FORM modify_index USING    p_bseg LIKE bseg
                           p_bkpf LIKE bkpf
                           name   LIKE bseg-bukrs
                  CHANGING p_error_log TYPE ty_error_log
                           error_line TYPE any.

* ------------- Materialkontenindex neu------------------------------- *
  IF name = 'BSIM'.
    PERFORM modify_bsim USING    p_bseg
                                 p_bkpf
                        CHANGING p_error_log
                                 error_line.
  ENDIF.


* ------------- Sachkontenindex neu ---------------------------------- *
  IF p_bseg-koart CA 'SM' AND p_bseg-xkres = 'X'.
    IF name = 'BSIS' OR name = 'BSAS'.
      PERFORM modify_sako USING    p_bseg
                                   p_bkpf
                          CHANGING p_error_log
                                   error_line.
    ENDIF.
  ENDIF.
* ------------- Abstimmkontenindex neu ------------------------------- *
  IF p_bseg-koart CA 'DKA' AND p_bseg-xhres = 'X'.
    IF name = 'BSIS' OR name = 'BSAS'.
      PERFORM modify_recon USING    p_bseg
                                    p_bkpf
                           CHANGING p_error_log
                                    error_line.
    ENDIF.
  ENDIF.
* ------------- Debitorenindex neu ----------------------------------- *
  IF p_bseg-koart = 'D'.
    IF name = 'BSID' OR name = 'BSAD'.
      PERFORM modify_debi USING    p_bseg
                                   p_bkpf
                          CHANGING p_error_log
                                   error_line.
    ENDIF.
  ENDIF.
* ------------- Kreditorenindex neu ---------------------------------- *
  IF p_bseg-koart = 'K'.
    IF name = 'BSIK' OR name = 'BSAK'.
      PERFORM modify_kredi USING    p_bseg
                                    p_bkpf
                           CHANGING p_error_log
                                    error_line.
    ENDIF.
  ENDIF.
ENDFORM.                    "modify_index

* -------------------------------------------------------------------- *
*    Neuen Sachkontenindex erzeugen                                    *
* -------------------------------------------------------------------- *
FORM modify_sako USING    p_bseg LIKE bseg
                          p_bkpf LIKE bkpf
                 CHANGING p_error_log TYPE ty_error_log
                          error_line TYPE any.

  DATA: name LIKE bseg-bukrs VALUE 'BSAS'.
  IF p_bseg-augbl IS INITIAL. name = 'BSIS'. ENDIF.
  MOVE-CORRESPONDING p_bkpf TO bsis.                        "#EC ENHOK
  MOVE-CORRESPONDING p_bseg TO bsis.                        "#EC ENHOK
  index_modify name bsis.
ENDFORM.                    "modify_sako

* -------------------------------------------------------------------- *
*    Neuen Materialkontenindex erzeugen                                *
* -------------------------------------------------------------------- *
FORM modify_bsim USING    p_bseg LIKE bseg
                          p_bkpf LIKE bkpf
                 CHANGING p_error_log TYPE ty_error_log
                          error_line TYPE any.

  DATA: name LIKE bseg-bukrs VALUE 'BSIM'.
  MOVE-CORRESPONDING p_bkpf TO bsim.                        "#EC ENHOK
  MOVE-CORRESPONDING p_bseg TO bsim.                        "#EC ENHOK
  index_modify name bsim.
ENDFORM.                    "modify_bsim


* -------------------------------------------------------------------- *
*    Neuen Abstimmkontenindex erzeugen                                 *
* -------------------------------------------------------------------- *
FORM modify_recon USING    p_bseg LIKE bseg
                           p_bkpf LIKE bkpf
                  CHANGING p_error_log TYPE ty_error_log
                           error_line TYPE any.

  DATA: name LIKE bseg-bukrs VALUE 'BSAS'.
  IF p_bseg-augbl IS INITIAL. name = 'BSIS'. ENDIF.
  MOVE-CORRESPONDING p_bkpf TO bsis.                        "#EC ENHOK
  MOVE-CORRESPONDING p_bseg TO bsis.                        "#EC ENHOK
  bsis-zuonr = p_bseg-hzuon.
  CLEAR bsis-xopvw.
  index_modify name bsis.



ENDFORM.                    "modify_recon

* -------------------------------------------------------------------- *
*    Neuen Debitorenindex erzeugen                                     *
* -------------------------------------------------------------------- *
FORM modify_debi USING    p_bseg LIKE bseg
                          p_bkpf LIKE bkpf
                 CHANGING p_error_log TYPE ty_error_log
                          error_line TYPE any.

  DATA: name LIKE bseg-bukrs VALUE 'BSAD'.
  IF p_bseg-augbl IS INITIAL. name = 'BSID'. ENDIF.
  MOVE-CORRESPONDING p_bkpf TO bsid.                        "#EC ENHOK
  MOVE-CORRESPONDING p_bseg TO bsid.                        "#EC ENHOK
  index_modify name bsid.
ENDFORM.                    "modify_debi

* -------------------------------------------------------------------- *
*    Neuen Kreditorenindex erzeugen                                    *
* -------------------------------------------------------------------- *
FORM modify_kredi USING    p_bseg LIKE bseg
                           p_bkpf LIKE bkpf
                  CHANGING p_error_log TYPE ty_error_log
                           error_line TYPE any.
  DATA: name LIKE bseg-bukrs VALUE 'BSAK'.
  IF p_bseg-augbl IS INITIAL. name = 'BSIK'. ENDIF.
  MOVE-CORRESPONDING p_bkpf TO bsik.                        "#EC ENHOK
  MOVE-CORRESPONDING p_bseg TO bsik.                        "#EC ENHOK
  index_modify name bsik.
ENDFORM.                    "modify_kredi

* -------------------------------------------------------------------- *
*    Speichern der Kopf-Information, l#schen Index                     *
* -------------------------------------------------------------------- *
FORM store_delete_index USING name LIKE bseg-bukrs
                              p_bkpf_kopf LIKE bkpf
                              p_index_kopf LIKE bkpf
                     CHANGING p_bkpf LIKE bkpf
                              p_error_log TYPE ty_error_log
                              error_line TYPE any.

  p_bkpf = p_index_kopf.
  IF NOT p_bkpf_kopf IS INITIAL.
*  Wenn einen Belegkopf in der BKPF gibt, dann ¨¹bernehmen
    p_bkpf = p_bkpf_kopf.
  ENDIF.
  CASE name.
    WHEN 'BSIM'.
      index_delete name bsim.
    WHEN 'BSIS' OR 'BSAS'.
      index_delete name bsis.
    WHEN 'BSID' OR 'BSAD'.
      index_delete name bsid.
    WHEN 'BSIK' OR 'BSAK'.
      index_delete name bsik.
  ENDCASE.
ENDFORM.                    "store_delete_index

* -------------------------------------------------------------------- *
*            Fehler bei Index gegen Bseg ausgeben                      *
* -------------------------------------------------------------------- *
FORM write_index_err TABLES ebseg STRUCTURE bseg
                      USING p_pbseg LIKE bseg
                            p_pindex LIKE bseg
                            name TYPE any
                            p_error_line TYPE any
                            p_error TYPE any
                   CHANGING p_error_log TYPE ty_error_log.
  DATA: p_index LIKE bseg,
        p_bseg LIKE bseg,
        p_act_typ(30) TYPE c.

  p_index = p_pindex.
  p_bseg = p_pbseg.
* p_bseg = gelesene bseg.
* p_index = aktueller index
* p_name = tabellen name
* p_act_typ = Kontoart Rec.accnt, G/L accnt, Customer oder Vendor.
* p_konto = Kontonummer des Index (Hkont, Kunnr oder Lifnr).
* p_error_line = Kommentarstring der Fehler
* Fehler counts erh#hen
  add_error.
*          Wenn protoc oder protox gesetzt ist dann ausgeben           *
  IF protoc = 'X' OR protox = 'X'.
    IF name = 'BSIM'.
      p_index-hkont = p_index-matnr.
      p_bseg-hkont = p_bseg-matnr.
      p_act_typ = 'Material Kto.'(039).
    ENDIF.
    IF name = 'BSIS' OR name = 'BSAS'.
      p_act_typ = 'Sachkonto'(040).
      IF NOT skb1-mitkz IS INITIAL.
        p_bseg-zuonr = p_bseg-hzuon.
        p_act_typ = 'Abstimmkonto'(041) .
        CONCATENATE p_act_typ '(' skb1-mitkz ')' INTO p_act_typ.
      ENDIF.
    ENDIF.
    IF name = 'BSID' OR name = 'BSAD'.
      p_index-hkont = p_index-kunnr.
      p_bseg-hkont = p_bseg-kunnr.
      p_act_typ = 'Kunde'(042).
    ENDIF.
    IF name = 'BSIK' OR name = 'BSAK'.
      p_index-hkont = p_index-lifnr.
      p_bseg-hkont = p_bseg-lifnr.
      p_act_typ = 'Lieferant'(043).
    ENDIF.
    IF account_written IS INITIAL.
      PERFORM konto_ueberschrift USING name p_index p_act_typ.
    ENDIF.
    PERFORM index_fehler_schreiben USING p_index p_error_line.
    IF protox = 'X'.
      ebseg = p_index.
      ebseg-sgtxt = p_act_typ.
      IF ebseg-shkzg = 'H'.
        ebseg-wrbtr = - ebseg-wrbtr.
        ebseg-dmbtr = - ebseg-dmbtr.
        ebseg-dmbe2 = - ebseg-dmbe2.
        ebseg-dmbe3 = - ebseg-dmbe3.
        ebseg-pswbt = - ebseg-pswbt.
      ENDIF.
      APPEND ebseg.
      IF p_error <> 'A'.
        PERFORM ausgabe_zeile_schreiben USING 'BSEG' name p_bseg 1 .
      ENDIF.
      PERFORM ausgabe_zeile_schreiben USING name name p_index 0.
    ENDIF.
  ENDIF. "                               <-- PROTOC = 'X' or Protox = 'X'.
ENDFORM.                    "write_index_err

* -------------------------------------------------------------------- *
*                  Fehlerhafte Indexzeile ausgeben                     *
* -------------------------------------------------------------------- *
FORM index_fehler_schreiben USING p_index LIKE bseg
                                  p_error_line TYPE any.
  DATA: d_err LIKE string100.
*        col2 TYPE i VALUE 4,
*        char TYPE c VALUE '|'.
  IF protox = 'X'.
*    col2 = 1.
    odd = 1.
*    char = ' '.
  ENDIF.
  d_err = p_error_line.
  SHIFT d_err LEFT.
* -------------------------------------------------------------------- *
** BEGIN OF CHANGES                                         C5053256
* -------------------------------------------------------------------- *
**  FORMAT COLOR = col2.
**  FORMAT INTENSIFIED = odd.
**  WRITE:/ sy-vline NO-GAP,
**          (11) p_index-belnr NO-GAP,
**          (5)  p_index-gjahr NO-GAP,
**               p_index-buzei NO-GAP,
**               char          NO-GAP,
**        (106)  d_err         NO-GAP,
**          sy-vline NO-GAP.
**  FORMAT INTENSIFIED ON.
**  FORMAT COLOR OFF.
  MOVE : p_index-belnr       TO    gs_outtab_list1-belnr,
         p_index-gjahr       TO    gs_outtab_list1-gjahr,
         p_index-buzei       TO    gs_outtab_list1-buzei,
         d_err               TO    gs_outtab_list1-err_msg.
  APPEND gs_outtab_list1     TO  gt_outtab_list1.
* -------------------------------------------------------------------- *
** END OF CHANGES                                             C5053256
* -------------------------------------------------------------------- *
  IF protoc = 'X'.
    IF odd = 0. odd = 1. ELSE. odd = 0. ENDIF.
  ENDIF.
ENDFORM.                    "index_fehler_schreiben

* -------------------------------------------------------------------- *
*                    Konto¨¹berschrift ausgeben
* -------------------------------------------------------------------- *
FORM konto_ueberschrift USING p_name LIKE bseg-bukrs
                              p_index LIKE bseg
                              p_act_typ TYPE any.
  DATA: recstring LIKE string100.
  CONCATENATE p_name 'vs BSEG'(044) INTO recstring SEPARATED BY space.
*----------------------------------------------------------------------*
** BEGIN of CHANGES                                            C5053256
*----------------------------------------------------------------------*
**  NEW-LINE.
**  ULINE (128).
**  FORMAT COLOR COL_TOTAL.
**  WRITE:/ sy-vline                           NO-GAP,
**          'Cpcd '                            NO-GAP,
**          'Account_Type '                    NO-GAP,
**       (10) 'Account_No'                     NO-GAP,
**       (98) 'Reconciliation' RIGHT-JUSTIFIED NO-GAP,
**          sy-vline                           NO-GAP.
**  FORMAT INTENSIFIED OFF.
**  WRITE:/ sy-vline NO-GAP,
**          (5) p_index-bukrs             NO-GAP,
**         (13) p_act_typ                 NO-GAP,
**         (10) p_index-hkont             NO-GAP,
**         (98) recstring RIGHT-JUSTIFIED NO-GAP,
**              sy-vline                  NO-GAP.
**  FORMAT COLOR COL_HEADING.
**  FORMAT INTENSIFIED ON.
**  WRITE:/ sy-vline NO-GAP,
**   (19)  'DOCUMENTNO YEAR POS'  NO-GAP,
**          ' ' NO-GAP,
**   (106) 'Errors / Statements' NO-GAP,
**          sy-vline NO-GAP.
**
**  IF protox = 'X'.
**    FORMAT COLOR COL_KEY.
**    IF p_name NE 'BSIM'.
**      WRITE:/ sy-vline NO-GAP,
**              (5) 'TABL'    NO-GAP,
**             (11) 'ACCOUNT' NO-GAP,
**              (6) 'UMSKS'   NO-GAP,
**              (6) 'UMSKZ'   NO-GAP,
**             (11) 'AUGDT'   NO-GAP,
**             (11) 'AUGBL'   NO-GAP,
**             (19) 'ZUONR'   NO-GAP,
**              (4) 'S/H'     NO-GAP,
**              (3) 'PK'      NO-GAP,
**             (16) 'DMBTR'   NO-GAP RIGHT-JUSTIFIED,
**                  ' '       NO-GAP,
**             (16) 'DMBE2'   NO-GAP RIGHT-JUSTIFIED,
**                  ' '       NO-GAP,
**             (16) 'DMBE3'   NO-GAP RIGHT-JUSTIFIED,
**                  sy-vline NO-GAP.
**    ELSE.
**      WRITE:/ sy-vline NO-GAP,
**              (5) 'TABL'    NO-GAP,
**             (11) 'ACCOUNT' NO-GAP,
**             (18) '         Quantity '   NO-GAP,
**              (9) 'UNIT'   NO-GAP,
**             (7) 'AUGDT'   NO-GAP,
**             (19) 'ZUONR'   NO-GAP,
**              (4) 'S/H'     NO-GAP,
**              (3) 'PK'      NO-GAP,
**             (16) 'DMBTR'   NO-GAP RIGHT-JUSTIFIED,
**                  ' '       NO-GAP,
**             (16) 'DMBE2'   NO-GAP RIGHT-JUSTIFIED,
**                  ' '       NO-GAP,
**             (16) 'DMBE3'   NO-GAP RIGHT-JUSTIFIED,
**                  sy-vline NO-GAP.
**
**
**    ENDIF.
**    NEW-LINE.
**    ULINE (128).
**  ENDIF.
  CLEAR : gs_outtab_list1, gs_outtab_list2.
  MOVE  : p_index-bukrs    TO gs_outtab_list1-bukrs,
          p_act_typ        TO gs_outtab_list1-gltype,
          p_index-hkont    TO gs_outtab_list1-hkont,
          recstring        TO gs_outtab_list1-recon.
*----------------------------------------------------------------------*
** END of CHANGES                                              C5053256
*----------------------------------------------------------------------*
  account_written = 'X'.
ENDFORM.                    "konto_ueberschrift

* -------------------------------------------------------------------- *
*               Internes Write statement                               *
* -------------------------------------------------------------------- *
FORM ausgabe_zeile_schreiben
               USING name LIKE bseg-bukrs
                     name1 LIKE bseg-bukrs
                     p_index LIKE bseg
                     int TYPE i.                            "#EC NEEDED
* -------------------------------------------------------------------- *
** BEGIN OF CHANGES                                            C5053256
* -------------------------------------------------------------------- *
**  FORMAT COLOR COL_KEY.
**  FORMAT INTENSIFIED = int.
  IF name1 = 'BSIM'.
**    WRITE:/   sy-vline NO-GAP,
**          (5) name          NO-GAP,
**         (11) p_index-hkont NO-GAP,
**         (18) p_index-menge NO-GAP,
**          (6) p_index-meins NO-GAP,
**         (9) ' ' NO-GAP,
**         (1) ' ' NO-GAP,
**         (19) ' ' NO-GAP,
**          (4) p_index-shkzg NO-GAP,
**          (3) ' ' NO-GAP,
**         (16) p_index-dmbtr NO-GAP,
**              ' '           NO-GAP,
**         (16) ' ' NO-GAP,
**              ' '           NO-GAP,
**              ' ' NO-GAP,
**      128 sy-vline NO-GAP.
    CLEAR : gs_outtab_list2.
    MOVE  : gs_outtab_list1-bukrs   TO  gs_outtab_list2-bukrs,
            gs_outtab_list1-belnr   TO  gs_outtab_list2-belnr,
            gs_outtab_list1-gjahr   TO  gs_outtab_list2-gjahr,
            gs_outtab_list1-buzei   TO  gs_outtab_list2-buzei,
            name                    TO  gs_outtab_list2-b_tbl,
            p_index-hkont           TO  gs_outtab_list2-hkont,
            p_index-menge           TO  gs_outtab_list2-menge,
            p_index-meins           TO  gs_outtab_list2-meins,
            p_index-shkzg           TO  gs_outtab_list2-shkzg,
            p_index-dmbtr           TO  gs_outtab_list2-wrbtr.
    APPEND  gs_outtab_list2  TO gt_outtab_list2.
  ELSE.
**    WRITE:/   sy-vline NO-GAP,
**          (5) name          NO-GAP,
**         (11) p_index-hkont NO-GAP,
**          (6) p_index-umsks NO-GAP,
**          (6) p_index-umskz NO-GAP,
**         (11) p_index-augdt NO-GAP,
**         (11) p_index-augbl NO-GAP,
**         (19) p_index-zuonr NO-GAP,
**          (4) p_index-shkzg NO-GAP,
**          (3) p_index-bschl NO-GAP,
**         (16) p_index-dmbtr NO-GAP,
**              ' '           NO-GAP,
**         (16) p_index-dmbe2 NO-GAP,
**              ' '           NO-GAP,
**              p_index-dmbe3 NO-GAP,
**      128 sy-vline NO-GAP.
    CLEAR : gs_outtab_list2.
    MOVE  : gs_outtab_list1-bukrs   TO  gs_outtab_list2-bukrs,
            gs_outtab_list1-belnr   TO  gs_outtab_list2-belnr,
            gs_outtab_list1-gjahr   TO  gs_outtab_list2-gjahr,
            gs_outtab_list1-buzei   TO  gs_outtab_list2-buzei,
            name                    TO  gs_outtab_list2-b_tbl,
            p_index-hkont           TO  gs_outtab_list2-hkont,
            p_index-umsks           TO  gs_outtab_list2-umsks,
            p_index-umskz           TO  gs_outtab_list2-umskz,
            p_index-augdt           TO  gs_outtab_list2-augdt,
            p_index-zuonr           TO  gs_outtab_list2-zuonr,
            p_index-augbl           TO  gs_outtab_list2-augbl,
            p_index-shkzg           TO  gs_outtab_list2-shkzg,
            p_index-bschl           TO  gs_outtab_list2-bschl,
            p_index-dmbtr           TO  gs_outtab_list2-wrbtr,
            p_index-dmbe2           TO  gs_outtab_list2-dmbtr,
            p_index-dmbe3           TO  gs_outtab_list2-dmbt2.
    APPEND  gs_outtab_list2  TO gt_outtab_list2.
  ENDIF.
**  FORMAT COLOR OFF.
**  FORMAT INTENSIFIED ON.
* -------------------------------------------------------------------- *
** END OF CHANGES                                              C5053256
* -------------------------------------------------------------------- *
ENDFORM.                    "ausgabe_zeile_schreiben

* -------------------------------------------------------------------- *
*          makro for special checks for customers and vendors
* -------------------------------------------------------------------- *
DEFINE check_sl_special.
  compare_single umsks.
  compare_single umskz.
  compare_single &1.
  compare_single zuonr.
  compare_single fipos.
  compare_single zlspr.
  compare_single zlsch.
  compare_single fistl.
  compare__single xnetb.
  compare__single monat.
* ****************************************************************
* Inkonsistenz zwischen Stammsatz und bseg (Debitor/Kreditor)
* Bseg sollte hier schon konsistent sein (da schon bei Abstimmung
* der Bseg gegen Stammsatz konsistent gemacht. Daher die Updates
* auf die Bseg nur zur Sicherheit.
* ****************************************************************
  if bseg-xkres <> 'X' or bseg-xopvw <> 'X'.
    if bseg-xkres <> 'X'.
      append_error 'XKRES'.
    endif.
    if bseg-xopvw <> 'X'.
      append_error 'XOPVW'.
    endif.
    if repair = 'X'.
      bseg-xkres = 'X'.
      bseg-xopvw = 'X'.
      update bseg.
    endif.
  endif. "bseg-xkres....
END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*                       checks der Indices                             *
* -------------------------------------------------------------------- *
FORM check_any_index TABLES   iperiv STRUCTURE tmonat
                     USING    name LIKE bseg-bukrs
                              p_index LIKE bseg
                              p_kopf  LIKE bkpf
                              b_kopf  LIKE bkpf

                     CHANGING state TYPE c
                              strin LIKE string100
                              p_error_log TYPE ty_error_log.

  IF name = 'BSIM'.
    PERFORM check_index_bsim
            TABLES    iperiv
             USING    p_index
                      p_kopf
                      b_kopf
                      name
          CHANGING    state
                      strin
                      p_error_log.

    EXIT.

  ENDIF.



* Kontoartunabh#ngige Pr¨¹fungen
  PERFORM check_index_all TABLES   iperiv
                          USING    p_index
                                   p_kopf
                                   b_kopf
                                   name
                          CHANGING state
                                   strin
                                   p_error_log.


* Kontoartabh#ngige Pr¨¹fungen
  CASE name.
    WHEN 'BSIS' OR 'BSAS'. " <-- Sachkonten
      IF skb1-mitkz IS INITIAL.
        PERFORM check_gl_special USING p_index CHANGING state strin.
      ELSE.
        PERFORM check_recon_special USING p_index CHANGING state strin.
      ENDIF.
    WHEN 'BSID' OR 'BSAD'. " <-- Debitoren
      PERFORM check_debi_special USING    p_index
                                          p_kopf
                                          b_kopf
                                 CHANGING state
                                          strin.
    WHEN 'BSIK' OR 'BSAK'.  " <-- Kreditoren
      PERFORM check_kredi_special USING    p_index
                                           p_kopf
                                           b_kopf
                                  CHANGING state
                                           strin.
  ENDCASE.
ENDFORM.                    "check_any_index

* -------------------------------------------------------------------- *
*                       checks for all accnts                          *
* -------------------------------------------------------------------- *
FORM check_index_all TABLES   iperiv STRUCTURE tmonat
                     USING    p_index LIKE bseg
                              p_kopf LIKE bkpf           "Kopf aus Index
                              b_kopf LIKE bkpf           "Kopf aus BKPF
                              name   LIKE bseg-bukrs
                     CHANGING p_state TYPE c
                              error_line LIKE string100
                              p_error_log TYPE ty_error_log. "#EC NEEDED


* Please enter account independent checks in this form rountine
  compare_single hkont.
  compare_single gsber.
  compare_single wrbtr.
  compare_single dmbtr.
  compare_single dmbe2.
  compare_single dmbe3.
  compare_single augbl.
  compare_single augdt.
  compare_single pswbt.
  compare_single pswsl.
  compare_single shkzg.
  compare_single bschl.
  compare_single xnegp.
  IF NOT b_kopf IS INITIAL.
    compare__single monat.
    compare__single budat.
    compare__single bldat.
    compare__single blart.
    compare__single xblnr.
    compare__single waers.
    compare__single bstat.
*      compare__single xstov.  " this comparsion caused too many errors
*                              " -> commented out because not important
  ENDIF.
  DATA: no_use TYPE ty_error_log.
  PERFORM periode_pruefen_2 TABLES iperiv
                            USING  p_kopf-budat
                                   p_kopf-monat
                                   p_kopf-gjahr
                                   name
                          CHANGING no_use
                                   error_line
                                   p_state.

  IF NOT p_index-augbl IS INITIAL AND NOT p_index-augdt IS INITIAL.
    IF p_kopf-budat > p_index-augdt.
      append_error 'BKPF-BUDAT_AUGBL'.
    ENDIF.
  ENDIF.
ENDFORM.                    "check_index_all

* -------------------------------------------------------------------- *
*                  Special checks for BSIM                             *
* -------------------------------------------------------------------- *
FORM check_index_bsim TABLES   iperiv STRUCTURE tmonat
                     USING    p_index LIKE bseg
                              p_kopf LIKE bkpf           "Kopf aus Index
                              b_kopf LIKE bkpf           "Kopf aus BKPF
                              name   LIKE bseg-bukrs
                     CHANGING p_state TYPE c
                              error_line LIKE string100
                              p_error_log TYPE ty_error_log. "#EC NEEDED

  compare_single buzid.
  compare_single shkzg.
  compare_single dmbtr.
  compare_single menge.
  compare_single meins.
  compare__single budat.
  compare__single bldat.
  compare__single blart.
ENDFORM.                    "check_index_bsim


* -------------------------------------------------------------------- *
*                  Special checks for G/L accnts                       *
* -------------------------------------------------------------------- *
FORM check_gl_special
     USING  p_index LIKE bseg
     CHANGING p_state  TYPE any error_line TYPE any.

* falsche Zuordnungsnummer (Sachkonto)
  compare_single zuonr.

* Inkonsistenz zwischen Stammsatz und bseg (Sachkonto), anpassen der
* Kontosteuerung in der bseg an die Werte, die im Stammsatz stehen
* (1)
  IF skb1-xkres <> bseg-xkres OR skb1-xopvw <> bseg-xopvw.
    compare_double skb1-xkres bseg-xkres.
* ausgeg. Posten sollen nicht auf EP korrigiert
    IF bseg-augbl NE space AND skb1-xopvw = space.
      IF repair = 'X'.
        append_error 'SKB1-XOPVW=Space&BSEG-AUGBL<>Space, kein update'(045).
      ELSE.
        append_error 'SKB1-XOPVW=Space&BSEG-AUGBL<>Space'(046).
      ENDIF.
    ELSE.
      compare_double skb1-xopvw bseg-xopvw.
    ENDIF.
    p_state = 'X'.
    IF repair = 'X'.
      bseg-xkres = skb1-xkres.
      DATA save_xopvw LIKE bseg-xopvw.
      save_xopvw = bseg-xopvw.

      bseg-xopvw = skb1-xopvw.
      IF bseg-xopvw IS INITIAL.
        IF save_xopvw = 'X' AND bseg-augbl NE space.
*     verhindern, da# ausgeg. u. xopvw = space
          bseg-xopvw = save_xopvw.
        ENDIF.
      ENDIF.

      IF bseg-koart = 'M'.
*      verhindern von OP und Koart M. -> Stammsatz eines Materialkontos
*      OP-verwaltet
        IF bseg-xopvw = 'X'.
          append_error 'XOPVW = X f¨¹r Mat.konto; kein Bseg update'(047).
          CLEAR bseg-xopvw.
        ENDIF.
      ENDIF.
      UPDATE bseg.
    ENDIF.
  ENDIF. "skb1-xkres....
  IF skb1-xkres IS INITIAL AND skb1-xopvw IS INITIAL.
*    G/L Account master is not OI or LI managed, this index is not
*    required anymore -> will be deleted.
*    **********************  Important *******************************
*    if this index is already cleared the corresponding clearing info.
*    in bseg is not changed (stays cleared though the accounts master
*    now says 'No OI, No LI'). This means that there's a small
*    inconsistency between Bseg-clearing info and Account master. The
*    advantage is: LI- OI-Management can be build up again without the
*    loss of clearing information.
*    *****************************************************************
    append_error 'SKB1-XKRES initial, kann gel#scht werden'(048).
    p_state = 'X'.
    IF repair = 'X'.
      CLEAR: bseg-xkres,
             bseg-xopvw.
      UPDATE bseg.
    ENDIF.
  ENDIF.

* XOPVW inkonsistent
  compare_single xopvw.

* Bei Materialkonten: Ist SKB1-OPVW oder BSEG-XOPVW gesetzt:
*   nur protokollieren weder Stammsatz noch Bseg werden angepa#t
*   -> Fehlermeldung ausgeben, da# Stammsatz ge#ndert werden mu#

*   Wird nach der Stammsatz#nderung nochmals das Programm startet, dann
*   tritt eine Inkonsistenz unter (1) auf und p_state wird auf 'X' geset
*   Bseg dem Stammsatz angepa#t und der Index sp#ter nachgezogen

* Materialkontenstammsatz nicht OPVW = 'X' aber nicht Stammsatz reparier
* aber keine inkonsistenz Stammsatz und Bseg
* -> Inkonsistenz in der Bseg selbst

  IF bseg-koart = 'M' AND skb1-xopvw = 'X'.
    append_error 'SKB1-XOPVW = X f¨¹r Koart M, bitte zuerst Stammsatz korrigieren'(049).
  ENDIF.
  IF bseg-koart = 'M' AND bseg-xopvw = 'X'.
    append_error 'BSEG-XOPVW = X f¨¹r Koart M, bitte zuerst Stammsatz korrigieren'(050).
  ENDIF.

ENDFORM.                    "check_gl_special

* -------------------------------------------------------------------- *
*              Special checks for Reconciliation accounts              *
* -------------------------------------------------------------------- *
FORM check_recon_special
     USING p_index LIKE bseg
     CHANGING p_state  TYPE any error_line TYPE any.
* falsche Zuordnungsnummer (Abstimmkonto oder Anlage)
  compare_double bseg-hzuon p_index-zuonr.
* Inkonsistenz zwischen Stammsatz und bseg (Abstimmkonto)
  IF skb1-xkres <> bseg-xhres.
    compare_double skb1-xkres bseg-xhres.
    p_state = 'X'.
    IF repair = 'X'.
      bseg-xhres = skb1-xkres.
      UPDATE bseg.
    ENDIF.
  ENDIF.
  IF skb1-xkres IS INITIAL.
*    Recon. Account master is not LI managed, this index is not
*    required anymore -> will be deleted.
*    **********************  Important *******************************
*    if this index is already cleared the corresponding clearing info.
*    in bseg is not changed (stays cleared though the accounts master
*    now says 'No OI, No LI'). This means that there's a small
*    inconsistency between Bseg-clearing info and Account master. The
*    advantage is: LI- OI-Management can be build up again without the
*    loss of clearing information.
*    *****************************************************************
    append_error 'SKB1-XKRES initial, kann gel#scht werden'(048).
    p_state = 'X'.
    IF repair = 'X'.
      CLEAR bseg-xhres.
      UPDATE bseg.
    ENDIF.
  ENDIF.

ENDFORM.                    "check_recon_special

* -------------------------------------------------------------------- *
*                  Special checks for customers                        *
* -------------------------------------------------------------------- *
FORM check_debi_special
                  USING    p_index LIKE bseg
                           p_kopf  LIKE bkpf
                           b_kopf  LIKE bkpf
                  CHANGING p_state TYPE any
                           error_line TYPE any.
  check_sl_special kunnr.
ENDFORM.                    "check_debi_special

* -------------------------------------------------------------------- *
*                  Special checks for vendors                          *
* -------------------------------------------------------------------- *
FORM check_kredi_special
                   USING    p_index LIKE bseg
                            p_kopf  LIKE bkpf
                            b_kopf  LIKE bkpf

                   CHANGING p_state TYPE any error_line TYPE any.
  check_sl_special lifnr.
ENDFORM.                    "check_kredi_special

************************************************************************
************************************************************************
************************************************************************
* -------------------------------------------------------------------- *
*                  Indices selektieren/pr¨¹fen
* -------------------------------------------------------------------- *
FORM indices_pruefen TABLES   bsegerror STRUCTURE no_ty_bsegerror
                              iperiv STRUCTURE tmonat
                     CHANGING p_error_log TYPE ty_error_log.


  IF x_matnr = 'X'.
* ******************************************************
* BSIM wenn Matnr ne space und koart = 'M'.
* bseg ist zu diesem Zeitpunkt konsistent zum Stammsatz
* ******************************************************
    CASE bseg-koart.
      WHEN 'M'.
*       Als Materialkonto ¨¹berpr¨¹fen
        IF bseg-matnr <> space AND bseg-matnr IN p_matnr.
          PERFORM makoindex TABLES bsegerror iperiv
                          CHANGING p_error_log.
        ENDIF.
    ENDCASE.

  ENDIF.


  IF x_sako = 'X'.
* ******************************************************
* BSIS/BSAS wenn Einzelposten oder OP in bseg
* bseg ist zu diesem Zeitpunkt konsistent zum Stammsatz
* ******************************************************

    CASE bseg-koart.
      WHEN 'S' OR 'M'.
        IF bseg-xkres = 'X' AND bseg-hkont IN p_hkont.
*         Als Sachkonto ¨¹berpr¨¹fen
          PERFORM sakoindex TABLES bsegerror iperiv
                          CHANGING p_error_log.
        ENDIF.
      WHEN 'D' OR 'K' OR 'A'.
        IF bseg-xhres = 'X' AND bseg-hkont IN p_hkont.
*          Als Abstimmkonto ¨¹berpr¨¹fen.
          PERFORM rekoindex TABLES bsegerror iperiv
                          CHANGING p_error_log.
        ENDIF.
    ENDCASE.

  ENDIF.
* *****************************************************
* BSID/BSAD Debitoren sind immer OP -> immer pr¨¹fen
* BSIK/BSAK Kreditoren sind immer OP -> immer pr¨¹fen
* *****************************************************
  IF x_debi = 'X' AND bseg-koart = 'D' AND bseg-kunnr IN p_kunnr.
    PERFORM debiindex TABLES bsegerror iperiv
                    CHANGING p_error_log.
  ENDIF.
  IF x_kredi = 'X' AND bseg-koart = 'K' AND bseg-lifnr IN p_lifnr.
    PERFORM krediindex TABLES bsegerror iperiv
                     CHANGING p_error_log.
  ENDIF.
ENDFORM.                    "indices_pruefen


* -------------------------------------------------------------------- *
*                    Abstimmkonten pr¨¹fen                              *
*                 Abstimmung Bseg gegen Index                          *
* -------------------------------------------------------------------- *
FORM rekoindex TABLES   bsegerror STRUCTURE no_ty_bsegerror
                        iperiv STRUCTURE tmonat
               CHANGING p_error_log TYPE ty_error_log.

  DATA: name1(4) VALUE 'BSIS',
        name2(4) VALUE 'BSAS',
        name(4),
        wa_index LIKE bsis,
        error_line LIKE string100,
        p_state,
        p_index LIKE bseg,
        p_kopf  LIKE bkpf,
        returncode TYPE i.

  IF NOT bseg-augbl IS INITIAL. name = name2. ELSE. name = name1. ENDIF.
  IF name CA 'A'.
    CHECK p_oi IS INITIAL.
  ELSE.
    CHECK p_cl IS INITIAL.
  ENDIF.

  PERFORM reko_index_selektieren
                            USING name
                         CHANGING wa_index
                                  returncode
                                  p_error_log
                                  error_line.
  CASE returncode.
    WHEN e_index_noindex OR e_index_zuonr.
      IF returncode = e_index_zuonr.
        add_check.
*      WA_INDEX-ZUONR = BSEG-HZUON.
        CLEAR wa_index-xopvw.
        MOVE-CORRESPONDING wa_index TO p_index.             "#EC ENHOK
      ENDIF.
      p_state = 'X'.
      IF repair = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        wa_index-zuonr = bseg-hzuon.
        CLEAR wa_index-xopvw.
        index_insert name wa_index.
      ENDIF.
    WHEN e_index_ok.
      add_check.

      MOVE-CORRESPONDING wa_index TO p_index.               "#EC ENHOK
      MOVE-CORRESPONDING wa_index TO p_kopf.                "#EC ENHOK
      IF NOT wa_index-xopvw IS INITIAL.
        append_error 'XOPVW=X'.
        p_state = 'X'.
      ENDIF.
      IF wa_index-xarch NE space.
        append_error 'xarch=X_&_Bseg_present'.
        p_state = 'X'.
      ENDIF.


      PERFORM check_index_all
              TABLES iperiv
              USING p_index
                    p_kopf
                    bkpf
                    name
          CHANGING  p_state
                    error_line
                    p_error_log.

      IF repair = 'X' AND p_state = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        wa_index-zuonr = bseg-hzuon.
        CLEAR wa_index-xopvw.
        index_update name wa_index.
      ENDIF.
  ENDCASE.

  IF p_state <> space.
    add_error.
    IF protoc = 'X' OR protox = 'X'.
      DATA d_bseg LIKE bseg.
      d_bseg = bseg.
      d_bseg-bukrs = 'BSEG'.
      IF returncode <> e_index_noindex.
        p_index-bukrs = name.
      ENDIF.
      d_bseg-kunnr = d_bseg-hkont.
      d_bseg-lifnr = d_bseg-hkont.
      d_bseg-zuonr = d_bseg-hzuon.
      PERFORM append_bseg_error TABLES bsegerror
               USING d_bseg p_index 'BSEG-RECO' error_line.
    ENDIF.
  ENDIF.
ENDFORM.                    " REKOINDEX
* -------------------------------------------------------------------- *
*                     Sachkonten pr¨¹fen                                *
*                 Abstimmung Bseg gegen Index                          *
* -------------------------------------------------------------------- *
FORM sakoindex TABLES   bsegerror STRUCTURE no_ty_bsegerror
                        iperiv STRUCTURE tmonat
               CHANGING p_error_log TYPE ty_error_log.

  DATA: name1(4) VALUE 'BSIS',
        name2(4) VALUE 'BSAS',
        name(4),
        wa_index LIKE bsis,
        error_line LIKE string100,
        p_state,
        p_index LIKE bseg,
        p_kopf  LIKE bkpf,
        returncode TYPE i.

  IF NOT bseg-augbl IS INITIAL. name = name2. ELSE. name = name1. ENDIF.
  IF name CA 'A'.
    CHECK p_oi IS INITIAL.
  ELSE.
    CHECK p_cl IS INITIAL.
  ENDIF.

  PERFORM sako_index_selektieren
                            USING name
                         CHANGING wa_index
                                  returncode
                                  p_error_log
                                  error_line.
  CASE returncode.
    WHEN e_index_noindex OR e_index_zuonr.
      IF returncode = e_index_zuonr.
        add_check.
        MOVE-CORRESPONDING wa_index TO p_index.             "#EC ENHOK
      ENDIF.
      p_state = 'X'.
      IF repair = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        index_insert name wa_index.
      ENDIF.
    WHEN e_index_ok.
      add_check.
      MOVE-CORRESPONDING wa_index TO p_index.               "#EC ENHOK
      MOVE-CORRESPONDING wa_index TO p_kopf.                "#EC ENHOK
      PERFORM check_index_all
              TABLES    iperiv
              USING     p_index
                        p_kopf
                        bkpf
                        name
              CHANGING  p_state
                        error_line
                        p_error_log.
      compare_single xopvw.

      IF wa_index-xarch NE space.
        append_error 'xarch=X_&_Bseg_present'.
        p_state = 'X'.
      ENDIF.

      IF repair = 'X' AND p_state = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        index_update name wa_index.
      ENDIF.
  ENDCASE.

  IF p_state <> space.
    add_error.
    IF protoc = 'X' OR protox = 'X'.
      DATA d_bseg LIKE bseg.
      d_bseg = bseg.
      d_bseg-bukrs = 'BSEG'.
      IF returncode <> e_index_noindex.
        p_index-bukrs = name.
      ENDIF.
      PERFORM append_bseg_error TABLES bsegerror
               USING d_bseg p_index 'BSEG-SAKO' error_line.
    ENDIF.
  ENDIF.
ENDFORM.                    " SAKOINDEX

* -------------------------------------------------------------------- *
*                     Materialien pr¨¹fen
*
*                 Abstimmung Bseg gegen Index(BSIM                     *
* -------------------------------------------------------------------- *
FORM makoindex TABLES   bsegerror STRUCTURE no_ty_bsegerror
                        iperiv STRUCTURE tmonat
               CHANGING p_error_log TYPE ty_error_log.

* BSIM is written only if MATNR is given and KOART = 'M'.

  CHECK bseg-koart = 'M'.
  CHECK bseg-matnr NE space.

  DATA: name(4) VALUE 'BSIM',
        wa_index LIKE bsim,
        error_line LIKE string100,
        p_state,
        p_index LIKE bseg,
        p_kopf  LIKE bkpf,
        returncode TYPE i.

* Do not check if 'only cleared positions' is flagged
  CHECK p_cl IS INITIAL.

  PERFORM mako_index_selektieren
                            USING name
                         CHANGING wa_index
                                  returncode
                                  p_error_log
                                  error_line.
  CASE returncode.
    WHEN e_index_noindex OR e_index_zuonr.
      IF returncode = e_index_zuonr.
        add_check.
        MOVE-CORRESPONDING wa_index TO p_index.             "#EC ENHOK
      ENDIF.
      p_state = 'X'.
      IF repair = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        index_insert name wa_index.
      ENDIF.
    WHEN e_index_ok.
      add_check.
      MOVE-CORRESPONDING wa_index TO p_index.               "#EC ENHOK
      MOVE-CORRESPONDING wa_index TO p_kopf.                "#EC ENHOK
      PERFORM check_index_bsim
              TABLES    iperiv
              USING     p_index
                        p_kopf
                        bkpf
                        name
              CHANGING  p_state
                        error_line
                        p_error_log.


      IF repair = 'X' AND p_state = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        index_update name wa_index.
      ENDIF.
  ENDCASE.

  IF p_state <> space.
    add_error.
    IF protoc = 'X' OR protox = 'X'.
      DATA d_bseg LIKE bseg.
      d_bseg = bseg.
      d_bseg-bukrs = 'BSEG'.
      IF returncode <> e_index_noindex.
        p_index-bukrs = name.
      ENDIF.
      PERFORM append_bseg_error TABLES bsegerror
               USING d_bseg p_index 'BSEG-MAKO' error_line.
    ENDIF.
  ENDIF.
ENDFORM.                    " MAKOINDEX


* -------------------------------------------------------------------- *
*                     Debitoren pr¨¹fen                                 *
*                 Abstimmung Bseg gegen Index                          *
* -------------------------------------------------------------------- *
FORM debiindex TABLES   bsegerror STRUCTURE no_ty_bsegerror
                        iperiv STRUCTURE tmonat
               CHANGING p_error_log TYPE ty_error_log.

  DATA: name1(4) VALUE 'BSID',
        name2(4) VALUE 'BSAD',
        name(4),
        wa_index LIKE bsid,
        error_line LIKE string100,
        p_state,
        p_index LIKE bseg,
        p_kopf  LIKE bkpf,
        returncode TYPE i.

  IF NOT bseg-augbl IS INITIAL. name = name2. ELSE. name = name1. ENDIF.
  IF name CA 'A'.
    CHECK p_oi IS INITIAL.
  ELSE.
    CHECK p_cl IS INITIAL.
  ENDIF.

  PERFORM nb_index_selektieren
                            USING name
                         CHANGING wa_index
                                  returncode
                                  p_error_log
                                  error_line.
  CASE returncode.
    WHEN e_index_noindex OR e_index_zuonr.
      IF returncode = e_index_zuonr.
        add_check.
        MOVE-CORRESPONDING wa_index TO p_index.             "#EC ENHOK
      ENDIF.
      p_state = 'X'.
      IF repair = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        index_insert name wa_index.
      ENDIF.
    WHEN e_index_ok.
      add_check.
      MOVE-CORRESPONDING wa_index TO p_index.               "#EC ENHOK
      MOVE-CORRESPONDING wa_index TO p_kopf.                "#EC ENHOK

      IF wa_index-xarch NE space.
        append_error 'xarch=X_&_Bseg_present'.
        p_state = 'X'.
      ENDIF.


      PERFORM check_index_all
              TABLES    iperiv
              USING     p_index
                        p_kopf
                        bkpf
                        name
              CHANGING  p_state
                        error_line
                        p_error_log.

      PERFORM check_debi_special USING    p_index
                                          p_kopf
                                          bkpf
                                 CHANGING p_state error_line.

      IF repair = 'X' AND p_state = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        index_update name wa_index.
      ENDIF.
  ENDCASE.

  IF p_state <> space.
    add_error.
    IF protoc = 'X' OR protox = 'X'.
      DATA d_bseg LIKE bseg.
      d_bseg = bseg.
      d_bseg-bukrs = 'BSEG'.
      IF returncode <> e_index_noindex.
        p_index-bukrs = name.
      ENDIF.
      PERFORM append_bseg_error TABLES bsegerror
               USING d_bseg p_index 'BSEG-DEBI' error_line.
    ENDIF.
  ENDIF.

ENDFORM.                    " DEBIINDEX

* -------------------------------------------------------------------- *
*                     Kreditoren pr¨¹fen                                *
*                     Abstimmung Bseg gegen Index                      *
* -------------------------------------------------------------------- *
FORM krediindex TABLES   bsegerror STRUCTURE no_ty_bsegerror
                         iperiv STRUCTURE tmonat
                CHANGING p_error_log TYPE ty_error_log.

  DATA: name1(4) VALUE 'BSIK',
        name2(4) VALUE 'BSAK',
        name(4),
        wa_index LIKE bsik,
        error_line LIKE string100,
        p_state,
        p_index LIKE bseg,
        p_kopf  LIKE bkpf,
        returncode TYPE i.

  IF NOT bseg-augbl IS INITIAL. name = name2. ELSE. name = name1. ENDIF.
  IF name CA 'A'.
    CHECK p_oi IS INITIAL.
  ELSE.
    CHECK p_cl IS INITIAL.
  ENDIF.

  PERFORM nb_index_selektieren
                            USING name
                         CHANGING wa_index
                                  returncode
                                  p_error_log
                                  error_line.
  CASE returncode.
    WHEN e_index_noindex OR e_index_zuonr.
      IF returncode = e_index_zuonr.
        add_check.
        MOVE-CORRESPONDING wa_index TO p_index.             "#EC ENHOK
      ENDIF.
      p_state = 'X'.
      IF repair = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        index_insert name wa_index.
      ENDIF.
    WHEN e_index_ok.
      add_check.
      MOVE-CORRESPONDING wa_index TO p_index.               "#EC ENHOK
      MOVE-CORRESPONDING wa_index TO p_kopf.                "#EC ENHOK

      IF wa_index-xarch NE space.
        append_error 'xarch=X_&_Bseg_present'.
        p_state = 'X'.
      ENDIF.

      PERFORM check_index_all
              TABLES    iperiv
              USING     p_index
                        p_kopf
                        bkpf
                        name
              CHANGING  p_state
                        error_line
                        p_error_log.

      PERFORM check_kredi_special USING    p_index
                                           p_kopf
                                           bkpf
                                  CHANGING p_state error_line.

      IF repair = 'X' AND p_state = 'X'.
        MOVE-CORRESPONDING bkpf TO wa_index.                "#EC ENHOK
        MOVE-CORRESPONDING bseg TO wa_index.                "#EC ENHOK
        index_update name wa_index.
      ENDIF.
  ENDCASE.

  IF p_state <> space.
    add_error.
    IF protoc = 'X' OR protox = 'X'.
      DATA d_bseg LIKE bseg.
      d_bseg = bseg.
      d_bseg-bukrs = 'BSEG'.
      IF returncode <> e_index_noindex.
        p_index-bukrs = name.
      ENDIF.
      PERFORM append_bseg_error TABLES bsegerror
               USING d_bseg p_index 'BSEG-KRED' error_line.
    ENDIF.
  ENDIF.

ENDFORM.                    " KREDIINDEX

* -------------------------------------------------------------------- *
*          Makro f¨¹r Debi/Kredi-select
* -------------------------------------------------------------------- *
DEFINE nebenbuch_select.
  select * from  (name) into wa_index
  where  bukrs = bseg-bukrs
  and    &1 = bseg-&1
  and    umsks = bseg-umsks
  and    umskz = bseg-umskz
  and    augdt = bseg-augdt
  and    augbl = bseg-augbl
  and    gjahr = bseg-gjahr
  and    belnr = bseg-belnr
  and    buzei = bseg-buzei.


  END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*          Makro f¨¹r Debi/Kredi-select
* -------------------------------------------------------------------- *
  DEFINE nebenbuch_select_single.
    select single * from  (name) into wa_index
    where  bukrs = bseg-bukrs
    and    &1 = bseg-&1
    and    umsks = bseg-umsks
    and    umskz = bseg-umskz
    and    augdt = bseg-augdt
    and    augbl = bseg-augbl
    and    zuonr = bseg-zuonr
    and    gjahr = bseg-gjahr
    and    belnr = bseg-belnr
    and    buzei = bseg-buzei.


  END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*                  Abstimmkontenindex selektieren
* -------------------------------------------------------------------- *
FORM reko_index_selektieren
                       USING name LIKE bseg-bukrs
                    CHANGING wa_index LIKE bsis
                             returncode TYPE i
                             p_error_log TYPE ty_error_log
                             error_line LIKE string100.
  CLEAR wa_index.
  DATA: error_str LIKE string100.
  SELECT SINGLE * FROM  (name) INTO wa_index
      WHERE  bukrs = bseg-bukrs
      AND    hkont = bseg-hkont
      AND    augdt = bseg-augdt
      AND    augbl = bseg-augbl
      AND    zuonr = bseg-hzuon
      AND    gjahr = bseg-gjahr
      AND    belnr = bseg-belnr
      AND    buzei = bseg-buzei.
  IF sy-subrc = 0.
    returncode = e_index_ok.
    EXIT.
  ELSE.
    SELECT * FROM  (name) INTO wa_index
    WHERE  bukrs = bseg-bukrs
      AND    hkont = bseg-hkont
      AND    augdt = bseg-augdt
      AND    augbl = bseg-augbl
      AND    gjahr = bseg-gjahr
      AND    belnr = bseg-belnr
      AND    buzei = bseg-buzei.
      IF repair = 'X'.
        index_delete name wa_index.
      ELSE.
        append_error 'HZUON'.
      ENDIF.
    ENDSELECT.
    IF sy-subrc = 0.
      returncode = e_index_zuonr.
      EXIT.
    ENDIF.
  ENDIF.
  returncode = e_index_noindex.
  CONCATENATE 'NO_' name INTO error_str.
  append_error error_str.
ENDFORM.                    "reko_index_selektieren

* -------------------------------------------------------------------- *
*                  Sachkontenindex selektieren
* -------------------------------------------------------------------- *
FORM sako_index_selektieren
                       USING name LIKE bseg-bukrs
                    CHANGING wa_index LIKE bsis
                             returncode TYPE i
                             p_error_log TYPE ty_error_log
                             error_line LIKE string100.
  CLEAR wa_index.
  DATA: error_str LIKE string100.
*  select with full key
  SELECT SINGLE * FROM  (name) INTO wa_index
      WHERE  bukrs = bseg-bukrs
      AND    hkont = bseg-hkont
      AND    augdt = bseg-augdt
      AND    augbl = bseg-augbl
      AND    zuonr = bseg-zuonr
      AND    gjahr = bseg-gjahr
      AND    belnr = bseg-belnr
      AND    buzei = bseg-buzei.
  IF sy-subrc = 0.
    returncode = e_index_ok.
    EXIT.
  ELSE.
*  index not found -> select without ZUONR
    SELECT * FROM  (name) INTO wa_index
    WHERE  bukrs = bseg-bukrs
      AND    hkont = bseg-hkont
      AND    augdt = bseg-augdt
      AND    augbl = bseg-augbl
      AND    gjahr = bseg-gjahr
      AND    belnr = bseg-belnr
      AND    buzei = bseg-buzei.
      IF repair = 'X'.
        index_delete name wa_index.
      ELSE.
        append_error 'ZUONR'.
      ENDIF.
    ENDSELECT.
    IF sy-subrc = 0.
      returncode = e_index_zuonr.
      EXIT.
    ENDIF.
  ENDIF.
  returncode = e_index_noindex.
  CONCATENATE 'NO_' name INTO error_str.
  append_error error_str.
ENDFORM.                    "sako_index_selektieren

* -------------------------------------------------------------------- *
*                  BSIM selektieren
* -------------------------------------------------------------------- *
FORM mako_index_selektieren
                       USING name LIKE bseg-bukrs
                    CHANGING wa_index LIKE bsim
                             returncode TYPE i
                             p_error_log TYPE ty_error_log
                             error_line LIKE string100.     "#EC NEEDED

*MATNR
*BWKEY
*BWTAR
*BELNR
*GJAHR
*BUZEI

  CLEAR wa_index.
  DATA: error_str LIKE string100.
*  select with full key


  SELECT SINGLE * FROM  (name) INTO wa_index
      WHERE  matnr = bseg-matnr
      AND    bwkey = bseg-bwkey
      AND    bwtar = bseg-bwtar
      AND    belnr = bseg-belnr
      AND    gjahr = bseg-gjahr
      AND    buzei = bseg-buzei.
  IF sy-subrc = 0.
    returncode = e_index_ok.
    EXIT.
  ENDIF.
  returncode = e_index_noindex.
  CONCATENATE 'NO_' name INTO error_str.
  append_error error_str.
ENDFORM.                    "mako_index_selektieren

* -------------------------------------------------------------------- *
*             Nebenbuch selektieren
* -------------------------------------------------------------------- *
DEFINE _select.
  nebenbuch_select_single &1.
  if sy-subrc = 0.
    returncode = e_index_ok.
    exit.
  endif.
  nebenbuch_select &1.
  if repair = 'X'.
    delete (name) from wa_index.
    append_error 'INDEX_DELETE'.
    add_delete.
  else.
    append_error 'ZUONR'.
  endif.
endselect.
END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*                  Nebenbuchindex selektieren                          *
* -------------------------------------------------------------------- *
FORM nb_index_selektieren
                       USING name LIKE bseg-bukrs
                    CHANGING wa_index TYPE any
                             returncode TYPE i
                             p_error_log TYPE ty_error_log
                             error_line LIKE string100.
  CLEAR wa_index.
  DATA: error_str LIKE string100.
  CASE name.
    WHEN 'BSIK' OR 'BSAK'.
      _select lifnr.
    WHEN 'BSID' OR 'BSAD'.
      _select kunnr.
  ENDCASE.
  IF sy-subrc = 0.
    returncode = e_index_zuonr.
    EXIT.
  ENDIF.
  returncode = e_index_noindex.
  CONCATENATE 'NO_' name INTO error_str.
  append_error error_str.
ENDFORM.                    "nb_index_selektieren

* -------------------------------------------------------------------- *
*     F¨¹llen der Error_tab f¨¹r Bseg-fehler
* -------------------------------------------------------------------- *
FORM append_bseg_error TABLES error_tab STRUCTURE no_ty_bsegerror
                        USING p_bseg    LIKE bseg
                              p_index   LIKE bseg
                              errortype LIKE bseg-zuonr
                              ssss       TYPE any.
  DATA sss(100).
  sss = ssss.
  CASE p_bseg-koart.
    WHEN 'S' OR 'M' OR 'A'.
      error_tab-konto = p_bseg-hkont.
    WHEN 'D'.
      error_tab-konto = p_bseg-kunnr.
    WHEN 'K'.
      error_tab-konto = p_bseg-lifnr.
    WHEN OTHERS.
      CLEAR error_tab-konto.
  ENDCASE.
  LOOP AT error_tab WHERE buzei = bseg-buzei
                      AND recon = errortype.
    CONDENSE  sss.
    CONCATENATE error_tab-estng sss
         INTO error_tab-estng SEPARATED BY space.
    MODIFY error_tab.
  ENDLOOP.
  IF sy-subrc <> 0.
    error_tab-recon = errortype.
    error_tab-zbseg = p_bseg.
    error_tab-ybseg = p_index.
    CONDENSE  sss.
    error_tab-estng = sss.
    MOVE-CORRESPONDING p_bseg TO error_tab.                 "#EC ENHOK
    APPEND error_tab.
  ENDIF.
ENDFORM.                    "append_bseg_error


* -------------------------------------------------------------------- *
*     Korrekte Konto art ?
* -------------------------------------------------------------------- *
FORM koart_pruefen TABLES bsegerror STRUCTURE no_ty_bsegerror
                CHANGING return_code TYPE any
                         p_error_log TYPE ty_error_log.
  IF bseg-koart CA 'SMDKA'.
*   Kontoart stimmt
    READ TABLE itbsl WITH KEY bschl = bseg-bschl BINARY SEARCH.
    IF sy-subrc = 0.
      IF itbsl-koart = bseg-koart.
        return_code = true.
      ELSE.
        ADD 1 TO p_error_log-bseg-error.
        DATA: d_bseg LIKE bseg.
        d_bseg = bseg.
        DATA: stringbuf2(113).
        CONCATENATE 'TBSL_KOART:' itbsl-koart
                    'BSEG_KOART:' bseg-koart
                               INTO stringbuf2 SEPARATED BY space.
        PERFORM append_bseg_error TABLES bsegerror
                   USING d_bseg d_bseg 'KOART_CHK' stringbuf2.

        return_code = false.
      ENDIF.
    ELSE.
      d_bseg = bseg.
      ADD 1 TO p_error_log-bseg-error.
      CONCATENATE 'BSEG_BSCHL:' bseg-bschl
                  'NO_TBSL_ENTRY'
                             INTO stringbuf2 SEPARATED BY space.
      PERFORM append_bseg_error TABLES bsegerror
                 USING d_bseg d_bseg 'KOART_CHK' stringbuf2.

      return_code = false.

    ENDIF.
  ELSE.
*   falsche Kontoart in BSEG
    ADD 1 TO p_error_log-bseg-error.
*    data: d_bseg like bseg.
    d_bseg = bseg.
    READ TABLE itbsl WITH KEY bschl = bseg-bschl BINARY SEARCH.
    IF sy-subrc = 0.
      d_bseg-koart = itbsl-koart.
      ADD 1 TO p_error_log-bseg-error.
      DATA: stringbuf(113).
      CONCATENATE
          'KOART_AUS_BSCHL:'(051)
           itbsl-koart
          'Keine weiteren Pr¨¹fungen'(052)
           INTO stringbuf SEPARATED BY space.
    ELSE.
      stringbuf = 'Falsche_KOART_und_BSCHL, Keine weiteren Pr¨¹fungen'(053).
    ENDIF.
    PERFORM append_bseg_error TABLES bsegerror
            USING d_bseg d_bseg 'KOART_CHK' stringbuf.
    return_code = false.
  ENDIF. " <--- Bseg-Koart ca 'SMDKA'.
ENDFORM.                    "koart_pruefen

* -------------------------------------------------------------------- *
*  F¨¹llen der internen tabelle Stammsatz-Tabellen pro Buchungskreis
* ----------------------------------------------------------------------
FORM stammsaetze_lesen TABLES i_skb1 STRUCTURE no_skb1
                              i_knb1 STRUCTURE no_knb1
                              i_lfb1 STRUCTURE no_lfb1
                        USING pit001 LIKE t001.

* Fill internal tables of master
  REFRESH i_skb1.
  CLEAR i_skb1.
  REFRESH i_knb1.
  CLEAR i_knb1.
  REFRESH i_lfb1.
  CLEAR i_lfb1.
  IF x_sako = 'X'.
    SELECT skb1~saknr skb1~xopvw skb1~xkres skb1~mitkz ska1~xbilk
           ska1~gvtyp skb1~zuawa skb1~xsalh skb1~wmeth
    INTO TABLE i_skb1 FROM skb1 INNER JOIN ska1
                     ON skb1~saknr = ska1~saknr
                     WHERE skb1~bukrs = pit001-bukrs
                       AND skb1~saknr IN p_hkont
                       AND ska1~ktopl = pit001-ktopl.  "#EC CI_BUFFJOIN
    SORT i_skb1 BY saknr.
  ENDIF.
  IF x_debi = 'X'.
    SELECT knb1~kunnr FROM knb1
                      INNER JOIN kna1 ON kna1~kunnr EQ knb1~kunnr
           INTO TABLE I_KNB1
           WHERE knb1~kunnr IN p_kunnr
             AND knb1~bukrs = pit001-bukrs.            "#EC CI_BUFFJOIN
    SORT i_knb1 BY kunnr.
  ENDIF.
  IF x_kredi = 'X'.
    SELECT lfb1~lifnr FROM lfb1
                     INNER JOIN lfa1 ON lfa1~lifnr EQ lfb1~lifnr
           INTO TABLE I_LFB1
           WHERE lfb1~lifnr IN p_lifnr
             AND lfb1~bukrs = pit001-bukrs.            "#EC CI_BUFFJOIN
    SORT i_lfb1 BY lifnr.
  ENDIF.
ENDFORM.                    "stammsaetze_lesen
* -------------------------------------------------------------------- *
*  F¨¹llen der internen tabelle Stammsatz-Tabellen pro Buchungskreis
*  for Open items at Date Abstimmkonten von D und K
* ----------------------------------------------------------------------
FORM stammsaetze_lesen_oi TABLES i_skb1 STRUCTURE no_skb1
                                 i_knb1 STRUCTURE no_knb1
                                 i_lfb1 STRUCTURE no_lfb1
                                  USING pit001 LIKE t001.


* Fill internal tables of master
  REFRESH i_skb1.
  CLEAR i_skb1.
  REFRESH i_knb1.
  CLEAR i_knb1.
  REFRESH i_lfb1.
  CLEAR i_lfb1.
  IF ( x_debi = 'X' AND p_kunnr[] IS INITIAL ) OR
     ( x_kredi = 'X' AND p_lifnr[] IS INITIAL ).
* Read all accounts because rec. accnt. are checked. So the accounts
* in the range of p_hkont my be not sufficient -> read all G/L accounts
* Rec. accnts will be checked in case of initial p_kunnr range or
* initial p_lifnr range !!!
    SELECT skb1~saknr skb1~xopvw skb1~xkres skb1~mitkz ska1~xbilk
                 ska1~gvtyp skb1~zuawa skb1~xsalh skb1~wmeth
    INTO TABLE i_skb1 FROM skb1 INNER JOIN ska1
                       ON skb1~saknr = ska1~saknr
                           WHERE skb1~bukrs = pit001-bukrs
*                           and skb1~saknr in p_hkont
                             AND ska1~ktopl = pit001-ktopl. "#EC CI_BUFFJOIN
  ELSE.
    SELECT skb1~saknr skb1~xopvw skb1~xkres skb1~mitkz ska1~xbilk
                 ska1~gvtyp skb1~zuawa skb1~xsalh skb1~wmeth
    INTO TABLE i_skb1 FROM skb1 INNER JOIN ska1
                       ON skb1~saknr = ska1~saknr
                           WHERE skb1~bukrs = pit001-bukrs
                             AND skb1~saknr IN p_hkont
                             AND ska1~ktopl = pit001-ktopl. "#EC CI_BUFFJOIN


  ENDIF.

  SORT i_skb1 BY saknr.

  IF x_debi = 'X'.
    SELECT knb1~kunnr FROM knb1
                      INNER JOIN kna1 ON kna1~kunnr EQ knb1~kunnr
           INTO TABLE I_KNB1
           WHERE knb1~kunnr IN p_kunnr
             AND knb1~bukrs = pit001-bukrs.
    SORT i_knb1 BY kunnr.                              "#EC CI_BUFFJOIN
  ENDIF.
  IF x_kredi = 'X'.
    SELECT lfb1~lifnr FROM lfb1
                     INNER JOIN lfa1 ON lfa1~lifnr EQ lfb1~lifnr
           INTO TABLE I_LFB1
           WHERE lfb1~lifnr IN p_lifnr
             AND lfb1~bukrs = pit001-bukrs.
    SORT i_lfb1 BY lifnr.                              "#EC CI_BUFFJOIN
  ENDIF.


ENDFORM.                    "stammsaetze_lesen_oi

* -------------------------------------------------------------------- *
* Stammsatz f¨¹r Hkont ¨¹berpr¨¹fen und gegebenenfalls anpassen           *
* -------------------------------------------------------------------- *
FORM bseg_gegen_stammsatz_pruefen
                  TABLES i_skb1 STRUCTURE no_skb1
                         i_knb1 STRUCTURE no_knb1
                         i_lfb1 STRUCTURE no_lfb1
                         bsegerror STRUCTURE no_ty_bsegerror
                CHANGING p_error_log TYPE ty_error_log.
  DATA: error_flag TYPE i.
*  DATA: bseg_error TYPE i.
  DATA: bseg_change TYPE i.
* Nur pr¨¹fen, wenn X_Bseg (Checkbox in Eingabemaske) = 'X' .
  CHECK x_bseg = 'X'.
* Debitoren und Kreditoren pr¨¹fen
  IF ( bseg-koart = 'D' AND bseg-kunnr IN p_kunnr  AND x_debi = 'X' )
  OR ( bseg-koart = 'K' AND bseg-lifnr IN p_lifnr AND x_kredi = 'X' ).

    IF bseg-koart = 'D'.
      READ TABLE i_knb1 WITH KEY kunnr = bseg-kunnr BINARY SEARCH.
      IF sy-subrc <> 0.
        PERFORM append_bseg_error TABLES bsegerror
           USING bseg bseg 'BSEG-KNB1' 'NO_KNB1_ENTRY'.
*        bseg_error = true.
      ENDIF.
    ENDIF.
    IF bseg-koart = 'K'.
      READ TABLE i_lfb1 WITH KEY lifnr = bseg-lifnr BINARY SEARCH.
      IF sy-subrc <> 0.
        PERFORM append_bseg_error TABLES bsegerror
           USING bseg bseg 'BSEG-LFB1' 'NO_LFB1_ENTRY'.
*        bseg_error = true.
      ENDIF.
    ENDIF.

* Konten die im Range sind: pr¨¹fen
* Kontoart D und K sind immer op-verwaltet
    DATA dummy LIKE bseg-zuonr VALUE 'KOART'.
    CONCATENATE dummy bseg-koart INTO dummy SEPARATED BY ' '.
    IF bseg-xopvw <> 'X'.
      bseg-xopvw = 'X'.
*      bseg_error = true.
      error_flag = 1.
      PERFORM append_bseg_error TABLES bsegerror
            USING bseg bseg dummy 'XOPVW_INITIAL'.
      IF repair = 'X'.
        bseg_change = true.
        UPDATE bseg.
      ENDIF.
    ENDIF.
    IF bseg-xkres <> 'X'.
      bseg-xkres = 'X'.
*      bseg_error = true.
      error_flag = 1.
      PERFORM append_bseg_error TABLES bsegerror
          USING bseg bseg dummy 'XKRES_INITIAL'.
      IF repair = 'X'.
        bseg_change = true.
        UPDATE bseg.
      ENDIF.
    ENDIF.
  ENDIF. " <-- Bseg-koart = D oder K
* >>>>>>>> Debitoren und Kreditoren pr¨¹fen ist hier zu Ende <<<<<<<<<< *

* >>>>>>>> Mit Sachkontenstammsatz ¨¹berpr¨¹fen <<<<<<<<<<<<<<<<<<<<<<<< *
* >>>>>>>> Abstimmkonten f. Koart D,K oder A werden hier auch gepr¨¹ft
  CHECK bseg-hkont IN p_hkont AND x_sako = 'X' .

  READ TABLE i_skb1 WITH KEY saknr = bseg-hkont BINARY SEARCH.
  IF sy-subrc = 0.
    CASE bseg-koart.
* >>>>>>             Sach- oder Materialkonten                 <<<<<<  *
      WHEN 'S' OR 'M'.

        IF i_skb1-gvtyp <> bseg-gvtyp.
          DATA stringbuf(100) TYPE c.
          error_flag = 1.
*          bseg_error = true.

* >>>>>>  GVTYP in Bseg inkon. zu SKB1.
          CONCATENATE stringbuf 'BSEG-GVTYP=' bseg-gvtyp INTO stringbuf.
          IF bseg-gvtyp IS INITIAL AND i_skb1-xbilk IS INITIAL.
* >>>>>>     rep. nur wenn stammsatz sagt: ist kein bilanz-kto
* >>>>>>     und in Bseg ist GVTYP initial.
            bseg-gvtyp = i_skb1-gvtyp.
            PERFORM append_bseg_error TABLES bsegerror
                      USING bseg bseg 'BSEG-SKB1' stringbuf.
            IF repair = 'X'.
              UPDATE bseg.
            ENDIF.
          ENDIF.
        ENDIF.

        IF i_skb1-xbilk <> bseg-xbilk.
          error_flag = 1.
*          bseg_error = true.
* >>>>>>  XBILK in Bseg inkon. zu SKB1.
          CONCATENATE stringbuf 'BSEG-XBILK=' bseg-xbilk INTO stringbuf.
          IF ( ( bseg-gvtyp IS INITIAL AND i_skb1-xbilk = 'X' ) OR
              ( bseg-gvtyp NE space AND i_skb1-xbilk IS INITIAL ) ).
            bseg-xbilk = i_skb1-xbilk.
* >>>>>>    nur reparieren, wenn die Stammsatzinformation konsistent
* >>>>>>    ist.
            PERFORM append_bseg_error TABLES bsegerror
                      USING bseg bseg 'BSEG-SKB1' stringbuf.
            IF repair = 'X'.
              UPDATE bseg.
            ENDIF.


          ENDIF.
        ENDIF.


*      if i_skb1-xkres <> bseg-xkres or i_skb1-xopvw <> bseg-xopvw
*      or not i_skb1-mitkz is initial.

        IF i_skb1-xkres <> bseg-xkres OR i_skb1-xopvw <> bseg-xopvw
        OR ( i_skb1-mitkz NE space AND i_skb1-mitkz NE 'V' ) .


          IF i_skb1-xkres <> bseg-xkres.
            error_flag = 1.
*            bseg_error = true.
* >>>>>>  EP-Flag in Bseg inkon. zu SKB1.
            CONCATENATE stringbuf 'BSEG-XKRES=' bseg-xkres INTO stringbuf.
          ENDIF.
          IF i_skb1-xopvw <> bseg-xopvw.
            error_flag = 1.
*            bseg_error = true.
* >>>>>>  OP-Flag in Bseg inkon. zu SKB1.
            CONCATENATE stringbuf 'BSEG-XOPVW=' bseg-xopvw INTO stringbuf.
          ENDIF.
*       Vertragskontokorrent: skb1-mitkz = 'V' und BSEG-koart = 'S' !!!
*       if not i_skb1-mitkz is initial.
          IF NOT i_skb1-mitkz IS INITIAL AND i_skb1-mitkz NE 'V'.
* >>>>>>  Mit Koart S oder M auf Abstimmkonto gebucht
* >>>>>>  Mit Koart S oder M auf Abstimmkonto gebucht
            error_flag = 1.
*            bseg_error = true.
            CONCATENATE stringbuf 'MITKZ=' i_skb1-mitkz INTO stringbuf.
          ENDIF.
          bseg-xopvw = i_skb1-xopvw.
* >>>>> Materialkonten d¨¹rfen nicht OPVW sein, tritt auf, wenn der
* >>>>> Stammsatz auf OP ge#ndert aber Bseg noch nicht angepa#t wurde
* >>>>> daher hier OP in der Bseg verhindern
          IF bseg-koart = 'M' AND bseg-xopvw = 'X'.
*            bseg_error = true.
            CLEAR bseg-xopvw.
            CLEAR stringbuf.
            stringbuf = 'Mat.kto. Stammsatz OP-verwaltet, BSEG-XOPVW wird nicht gesetzt'(054).
          ENDIF.
          bseg-xkres = i_skb1-xkres.
          PERFORM append_bseg_error TABLES bsegerror
                         USING bseg bseg 'BSEG-SKB1' stringbuf.
          IF bseg-zuonr IS INITIAL AND i_skb1-xkres = 'X'.
* >>>>>>   Zuorndungsnummer, wenn noch nicht gesetzt, setzen (wenn
*          EP oder OP-Verwaltung des Stammsatzes).
            PERFORM zuordnung_aufbauen(rszun000)
                     USING i_skb1-zuawa bseg-zuonr.
          ENDIF.
          IF repair = 'X'.
            bseg_change = true.
            UPDATE bseg.
          ENDIF.
        ENDIF.
* >>>>>>             Abstimmkonten f. D, K, A                   <<<<<< *
      WHEN 'D' OR 'K' OR 'A'.  "<< Debitoren-, Kreditoren, Anlagen

        IF bseg-gvtyp NE space.
          error_flag = 1.
*          bseg_error = true.
* >>>>>>    GVTYP in Bseg f. Rec. acc mu# immer space sein.
          CLEAR bseg-gvtyp.
          CONCATENATE stringbuf 'BSEG-GVTYP=' bseg-gvtyp INTO stringbuf.
          PERFORM append_bseg_error TABLES bsegerror
                         USING bseg bseg 'BSEG-SKB1' stringbuf.

          IF repair = 'X'.
            UPDATE bseg.
          ENDIF.

        ENDIF.

        IF i_skb1-xbilk <> 'X'.
          error_flag = 1.
*          bseg_error = true.
* >>>>>>    XBILK in Bseg inkon. zu SKB1.
          bseg-xbilk = 'X'.
          CONCATENATE stringbuf 'BSEG-XBILK=' bseg-xbilk INTO stringbuf.
          PERFORM append_bseg_error TABLES bsegerror
                         USING bseg bseg 'BSEG-SKB1' stringbuf.
          IF repair = 'X'.
            UPDATE bseg.
          ENDIF.

        ENDIF.


        IF i_skb1-xkres <> bseg-xhres OR bseg-koart <> i_skb1-mitkz.
          error_flag = 1.
*          bseg_error = true.
          IF i_skb1-xkres <> bseg-xhres.
* >>>>>>       Stammsatz Abstimmkonto-EP <> BSEG-XHRES
            CONCATENATE stringbuf 'BSEG-XHRES=' bseg-xhres
                      INTO stringbuf.
          ENDIF.
          IF bseg-koart <> i_skb1-mitkz.
* >>>>>>       SKB1-MITKZ ist <> BSEG-KOART. Ein Abtimmkonto darf nur
* >>>>>>       mit Kontoart = Stammsatz-Mitbuchkennzeichen beb.werden.
* >>>>>>       wenn diese Bed. nicht erf¨¹llt -> Fehler
            CONCATENATE stringbuf 'MITKZ=' i_skb1-mitkz
                                                 INTO stringbuf.
*            bseg_error = true.
          ENDIF.
          PERFORM append_bseg_error TABLES bsegerror
                         USING bseg bseg 'BSEG-SKB1' stringbuf.
          bseg-xhres = i_skb1-xkres.
          IF bseg-hzuon IS INITIAL AND i_skb1-xkres = 'X'.
* >>>>>>      Zuordnungsnummer, wenn noch nicht gesetzt, setzen (wenn
*             EP-Verwaltung des Abstimmkontos).
*            bseg_error = true.
            PERFORM zuordnung_aufbauen(rszun000)
                    USING i_skb1-zuawa bseg-hzuon.
          ENDIF.

          IF repair = 'X'.
            bseg_change = true.
            UPDATE bseg.
          ENDIF.
        ENDIF.
    ENDCASE.
  ELSE. "<< sy-subrc auf read table
* >>>>>> Sachkontenstammsatz existiert nicht
    error_flag = 1.
*    bseg_error = true.
    PERFORM append_bseg_error TABLES bsegerror
         USING bseg bseg 'BSEG-SKB1' 'NO_SKB1_ENTRY'.
  ENDIF.  "<< sy-subrc auf read table
  IF error_flag = 1.
    ADD 1 TO p_error_log-bseg-error.
  ENDIF.
  IF bseg_change = true.
    ADD 1 TO p_error_log-bseg-update.
  ENDIF.

ENDFORM.                    "bseg_gegen_stammsatz_pruefen

* ---------------------------------------------------------------------*
*       Form  SET_EXPERT
* ---------------------------------------------------------------------*
FORM set_expert CHANGING p_expert TYPE any.
  DATA: l_expert_on LIKE sy-ucomm VALUE 'XXPM'.

  IF x_bseg = 'X' AND x_index = 'X' AND x_heade = 'X'
    AND x_rfblg = 'X' AND x_clear = 'X' AND x_f070 = 'X'
    AND x_f190 = 'X' AND x_opdate = 'X' AND x_duplic = 'X'
    AND x_bila = 'X' . " and x_count = 'X'.

*    call 'SYST_LOGOFF'.
  ENDIF.
*  if sy-ucomm eq l_expert_on.
*     p_expert = true.
*     exit.
*  endif.
  CASE sy-ucomm.
    WHEN l_expert_on.
      p_expert = true.
*    WHEN 'BKPF'.
*      tab_name_input = sy-ucomm.
*      COLLECT tab_name_input.
*      CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
*        EXPORTING
*          titel     = 'Table to count entries'
*          textline1 = sy-ucomm.
*
*    WHEN 'RFBL' OR 'RFBLG'.
*      tab_name_input = 'RFBLG'.
*      COLLECT tab_name_input.
*      CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
*        EXPORTING
*          titel     = 'Table to count entries'
*          textline1 = 'RFBLG'.
*
*    WHEN 'BSIS'.
*      tab_name_input = sy-ucomm.
*      COLLECT tab_name_input.
*      CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
*        EXPORTING
*          titel     = 'Table to count entries'
*          textline1 = sy-ucomm.
*
*    WHEN 'BSAS'.
*      tab_name_input = sy-ucomm.
*      COLLECT tab_name_input.
*      CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
*        EXPORTING
*          titel     = 'Table to count entries'
*          textline1 = sy-ucomm.
*
*    WHEN 'BSID'.
*      tab_name_input = sy-ucomm.
*      COLLECT tab_name_input.
*      CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
*        EXPORTING
*          titel     = 'Table to count entries'
*          textline1 = sy-ucomm.
*
*    WHEN 'BSAD'.
*      tab_name_input = sy-ucomm.
*      COLLECT tab_name_input.
*      CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
*        EXPORTING
*          titel     = 'Table to count entries'
*          textline1 = sy-ucomm.
*
*    WHEN 'BSIK'.
*      tab_name_input = sy-ucomm.
*      COLLECT tab_name_input.
*      CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
*        EXPORTING
*          titel     = 'Table to count entries'
*          textline1 = sy-ucomm.
*
*    WHEN 'BSAK'.
*      tab_name_input = sy-ucomm.
*      COLLECT tab_name_input.
*      CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
*        EXPORTING
*          titel     = 'Table to count entries'
*          textline1 = sy-ucomm.

*    when others.
*      call function 'POPUP_TO_DISPLAY_TEXT'
*         exporting
*           titel        = 'Unknown user command'
*           textline1    = Sy-ucomm.
  ENDCASE.
ENDFORM.                    " SET_EXPERT

* ----------------------------------------------------------------------
*                     Abfrage Reparaturmodus
* ----------------------------------------------------------------------
FORM want_repair CHANGING return_value TYPE i.
*select single * from trdir where NAME = sy-REPID.
*if sy-subrc = 0.
*  if trdir-FIXPT = 'X'.
*     write:/ 'Fixpoint arithmetic in program attributes must be off.',
*             'Program stopped'.
*     return_value = false.
*     exit.
*  endif.
*else.
*  write:/ 'could not find TRDIR-Entry'.
* endif.
  DATA: rr.
  IF sy-batch = 'X'.
    return_value = true.
    EXIT.
  ENDIF.
*  DATA CHECKED TYPE C.
  IF x_bseg IS INITIAL AND x_index IS INITIAL AND x_heade IS INITIAL
  AND x_rfblg IS INITIAL AND x_clear IS INITIAL AND x_f070 IS INITIAL
  AND x_f190 IS INITIAL AND x_opdate IS INITIAL AND x_duplic IS INITIAL
  AND x_bila IS INITIAL. "  and x_count is initial.

    CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
      EXPORTING
        titel     = 'Sie haben keine Abstimmungsart angegeben'(376)
        textline1 = 'Bitte geben Sie mindestens eine Abstimmungsart an'(377)
        textline2 = ''.
    EXIT.
  ELSEIF ( x_rfblg IS INITIAL AND x_heade IS INITIAL ) AND
      (  x_sako IS INITIAL AND x_debi IS INITIAL AND x_kredi IS INITIAL
         AND x_matnr IS INITIAL ).

* if x_count is initial.
    CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
      EXPORTING
        titel     = 'Sie haben keine Kontoart ausgew#hlt'(378)
        textline1 = 'W#hlen Sie mindestens eine Kontoart aus'(379)
        textline2 = ''.
    EXIT.
* endif.
  ENDIF.


  IF NOT repair IS INITIAL
  OR NOT x_delhd IS INITIAL
  OR NOT x_delind IS INITIAL
  OR NOT x_repvz IS INITIAL.
*  IF CHECKED = 'X'.
    DATA rrr(40).
    rrr ='Echtlauf. M#chten Sie wirklich weitermachen?'(380).
*    data rr.
    CALL FUNCTION 'POPUP_TO_CONFIRM_STEP'                   "#EC *
      EXPORTING
        defaultoption  = 'N'
        textline1      = rrr
        titel          = 'Best#tigen'(373)
        cancel_display = ''
      IMPORTING
        answer         = rr.

    IF rr <> 'J'.
      return_value = false.
      EXIT.
    ELSE.
      return_value = true.
      EXIT.
    ENDIF.
  ELSE.
    return_value = true.
  ENDIF.

ENDFORM.                    "want_repair
* ----------------------------------------------------------------------
*     Abfrage Reparaturmodus f¨¹r Verkehrszhalen
* ----------------------------------------------------------------------
FORM confirm_to_rep_vz CHANGING return_value TYPE i.

  DATA rrr(40).
  rrr ='M#chten Sie die Verkehrszahlen jetzt #ndern?'(009).
  DATA rr.
  CALL FUNCTION 'POPUP_TO_CONFIRM_STEP'                     "#EC *
    EXPORTING
      defaultoption  = 'N'
      textline1      = rrr
      titel          = 'Best#tigen'(373)
      cancel_display = ''
    IMPORTING
      answer         = rr.

  IF rr <> 'J'.
    return_value = false.
    EXIT.
  ELSE.
    return_value = true.
    EXIT.
  ENDIF.

ENDFORM.                    "confirm_to_rep_vz

* ----------------------------------------------------------------------
*              Kopf ohne Bseg l#schen und ausgeben
*                 bei Abstimmung Bseg -> Index
* ----------------------------------------------------------------------
FORM delete_header_without_bseg
                   TABLES bkpferror STRUCTURE no_ty_bsegerror
                   CHANGING p_error_log TYPE ty_error_log.
  DATA save_subrc LIKE sy-subrc.
  DATA d_bseg LIKE bseg.
  DATA del_string(60) TYPE c.
*  DATA hd_string(60) TYPE c.
  IF x_delhd = 'X'.
    del_string = 'NO_BSEG_Header_deleted,'.
  ELSE.
    del_string = 'NO_BSEG,'.
  ENDIF.
* Schauen ob's zum Kopf noch einen RFBLG-Eintrag gibt.
  SELECT SINGLE * FROM rfblg WHERE bukrs = bkpf-bukrs
                                AND belnr = bkpf-belnr
                                AND gjahr = bkpf-gjahr
                                AND pageno = '0'.
  save_subrc = sy-subrc.

  MOVE-CORRESPONDING bkpf TO d_bseg.                        "#EC ENHOK
  DATA: error_str(100).
*  CONCATENATE bkpf-bukrs bkpf-belnr bkpf-gjahr INTO hd_string
*                                               SEPARATED BY space.
  IF save_subrc = 0.
    IF rfblg-pagelg <> 10.
      CONCATENATE del_string 'RFBLG_OK'
               INTO error_str SEPARATED BY space.
    ELSE.
      CONCATENATE del_string 'RFBLG_INITIAL'
               INTO error_str SEPARATED BY space.
    ENDIF.
    PERFORM append_bseg_error TABLES bkpferror
             USING d_bseg d_bseg 'BKPF-RFBLG' error_str.

    IF x_delhd = 'X'.
*       Kopf ohne Bseg wird gel#scht -> auch Cluster l#schen
      DELETE FROM rfblg WHERE bukrs = bkpf-bukrs
                          AND belnr = bkpf-belnr
                          AND gjahr = bkpf-gjahr.
*           add sy-dbcnt to
    ENDIF.
  ELSE.
    error_str = 'NO_BSEG, RFBLG_MISSING'.
    PERFORM append_bseg_error TABLES bkpferror
          USING d_bseg d_bseg 'BKPF-RFBLG' error_str.
  ENDIF.
  IF x_delhd = 'X'.
    DELETE bkpf.
    ADD 1 TO p_error_log-bkpf-delete.
  ENDIF.
ENDFORM.                    "delete_header_without_bseg

* -------------------------------------------------------------------- *
*             W#hrungsbetr#ge summieren
*                   Bseg -> Index
* -------------------------------------------------------------------- *
FORM waehrungsbetraege_summieren
     USING p_bseg LIKE bseg
     CHANGING p_currency TYPE ty_currency.

  IF p_bseg-shkzg = 'S'.
    ADD p_bseg-dmbtr TO p_currency-dmbtr.
    ADD p_bseg-dmbe2 TO p_currency-dmbe2.
    ADD p_bseg-dmbe3 TO p_currency-dmbe3.
    ADD p_bseg-wrbtr TO p_currency-wrbtr.
  ELSE.
    SUBTRACT p_bseg-dmbtr FROM p_currency-dmbtr.
    SUBTRACT p_bseg-dmbe2 FROM p_currency-dmbe2.
    SUBTRACT p_bseg-dmbe3 FROM p_currency-dmbe3.
    SUBTRACT p_bseg-wrbtr FROM p_currency-wrbtr.
  ENDIF.
ENDFORM.                    "waehrungsbetraege_summieren

* -------------------------------------------------------------------- *
* Kleines Makro f¨¹r Saldo 0 Pr¨¹fung
* -------------------------------------------------------------------- *
DEFINE check_zero.
  if p_currency-&1 <> 0.
    error_flg = true.
    concatenate error_str '&1' into error_str separated by ' '.
  endif.
END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*                 Saldo NULL Pr¨¹fung
*                   Bseg -> Index
* -------------------------------------------------------------------- *
FORM zero_balance_check
     TABLES bkpferror STRUCTURE no_ty_bsegerror
     USING p_bkpf LIKE bkpf
           p_currency TYPE ty_currency
     CHANGING p_error_log TYPE ty_error_log.

  DATA: error_str(100) TYPE c VALUE 'UNBALANCED:'.
  DATA: error_flg TYPE i VALUE 0.
  DATA: d_bseg LIKE bseg.
  check_zero dmbtr.
  check_zero dmbe2.
  check_zero dmbe3.
  check_zero wrbtr.
  IF error_flg = true.
    ADD 1 TO p_error_log-bseg-error.
    MOVE-CORRESPONDING p_bkpf TO d_bseg.                    "#EC ENHOK
    MOVE-CORRESPONDING p_currency TO d_bseg.                "#EC ENHOK
    PERFORM append_bseg_error TABLES bkpferror
               USING d_bseg d_bseg 'Saldo'(341) error_str.
  ENDIF.
ENDFORM.                    "zero_balance_check

* -------------------------------------------------------------------- *
*             Bseg zum Kopf selektieren
*                   Bseg -> Index
* -------------------------------------------------------------------- *
FORM bseg_pruefen TABLES   i_skb1 STRUCTURE no_skb1
                           i_knb1 STRUCTURE no_knb1
                           i_lfb1 STRUCTURE no_lfb1
                           iperiv STRUCTURE tmonat
                           bsegerror STRUCTURE no_ty_bsegerror
                           bkpferror STRUCTURE no_ty_bsegerror
                  CHANGING p_error_log TYPE ty_error_log.
  DATA:  d_currency TYPE ty_currency,
         ret_code TYPE i,
         ibseg LIKE bseg OCCURS 10 WITH HEADER LINE.
*  STATICS: db_change TYPE i."#EC NEEDED
  SELECT  * FROM  bseg INTO TABLE ibseg
                       WHERE  bukrs  = bkpf-bukrs
                       AND    belnr  = bkpf-belnr
                       AND    gjahr  = bkpf-gjahr.

  LOOP AT ibseg.
    bseg = ibseg.
    DATA: save_bseg_error_count TYPE i.
    DATA: save_bseg_update_count TYPE i.
    save_bseg_error_count = p_error_log-bseg-error.
    save_bseg_update_count = p_error_log-bseg-update.
    ADD 1 TO p_error_log-bseg-check.

    PERFORM waehrungsbetraege_summieren     " <-- Betr#ge summieren
                         USING    bseg
                         CHANGING d_currency.

    PERFORM koart_pruefen                   " <--schadhafte bseg-Koart
              TABLES   bsegerror
              CHANGING ret_code
                       p_error_log.
    CHECK ret_code = true.

    PERFORM bseg_gegen_t001
              TABLES   bsegerror
              CHANGING ret_code
                       p_error_log.

    PERFORM ausgleich_datum_pruefen         " <--Pr¨¹fen Ausgleichsinfo
              TABLES   bsegerror
              CHANGING ret_code
                       p_error_log.

*    Materialien werden nicht gegen MARA verprobt,
*    das wir vielleicht noch ge#ndert
    PERFORM bseg_gegen_stammsatz_pruefen " <--Pr¨¹fen zu Stammsatz
                    TABLES i_skb1
                           i_knb1
                           i_lfb1
                           bsegerror
                  CHANGING p_error_log.
*      bseg ist ab hier ausreichend konsistent
    IF x_bseg = 'X'.
      PERFORM indices_pruefen                 " <--Pr¨¹fen der INDICES
                         TABLES bsegerror
                                iperiv
                       CHANGING p_error_log.
    ENDIF.                                            " <-- X_BSEG = 'X'

    IF p_error_log-bseg-error > save_bseg_error_count.
      p_error_log-bseg-error = save_bseg_error_count + 1.
    ENDIF.
    IF p_error_log-bseg-update > save_bseg_update_count.
      p_error_log-bseg-update = save_bseg_update_count + 1.
    ENDIF.

  ENDLOOP.                                             " <-- bseg-select
  IF sy-subrc <> 0.
    ADD 1 TO p_error_log-bseg-error.
    PERFORM delete_header_without_bseg TABLES bkpferror
                                     CHANGING p_error_log.
  ELSE.
* Saldo 0 Pr¨¹fung
    PERFORM zero_balance_check
        TABLES bkpferror
         USING bkpf
               d_currency
      CHANGING p_error_log.
  ENDIF.


ENDFORM.                    "bseg_pruefen
* -------------------------------------------------------------------- *
*            ALLE FEHLER SUMMIEREN
* -------------------------------------------------------------------- *
FORM fehler_summieren USING error_log TYPE ty_error_log
                   CHANGING errors_all TYPE i.
  errors_all = error_log-bseg-error
             + error_log-bsis-error
             + error_log-bsas-error
             + error_log-bsid-error
             + error_log-bsad-error
             + error_log-bsik-error
             + error_log-bsak-error
             + error_log-bkpf-error
             + error_log-bsim-error.
ENDFORM.                    "fehler_summieren
* -------------------------------------------------------------------- *
*           Pr¨¹fen der Ausgleichsinformation der Bseg                  *
* -------------------------------------------------------------------- *
FORM ausgleich_datum_pruefen
          TABLES   bsegerror
          CHANGING ret_code TYPE i
                   p_error_log TYPE ty_error_log.
  ret_code = true.
  IF ( NOT bseg-augbl IS INITIAL AND     bseg-augdt IS INITIAL )
  OR (     bseg-augbl IS INITIAL AND NOT bseg-augdt IS INITIAL ).
    PERFORM append_bseg_error TABLES bsegerror
            USING bseg bseg
                 'BSEG_CLEAR'
                 'INCON_CLEARING, keine weiteren Pr¨¹fungen'(055).
    ret_code = false.
    EXIT.
  ENDIF.

  CHECK NOT bseg-augbl IS INITIAL.
  CHECK bkpf-budat > bseg-augdt.
  ret_code = false.
  ADD 1 TO p_error_log-bseg-error.
  PERFORM append_bseg_error TABLES bsegerror
              USING bseg bseg 'BKPF-BSEG' 'BUDAT>AUGDT'.
ENDFORM.                    "ausgleich_datum_pruefen
* -------------------------------------------------------------------- *
*                        Ausgabe der Summary                           *
* -------------------------------------------------------------------- *
*DEFINE write_prot_line.
*  write:/10 &1 color 2 intensified off,
*         21(67) 'in Table &2' color 2 intensified off.
*END-OF-DEFINITION.
*DEFINE write_prot_line_2.
*  write: &1 color 2 intensified off no-gap.
*  write: sy-vline no-gap.
*END-OF-DEFINITION.
*
*DEFINE write_prot_block.
*  write_prot_line error_log-bsis-&1 bsis.
*  write_prot_line error_log-bsas-&1 bsas.
*  write_prot_line error_log-bsid-&1 bsid.
*  write_prot_line error_log-bsad-&1 bsad.
*  write_prot_line error_log-bsik-&1 bsik.
*  write_prot_line error_log-bsak-&1 bsak.
*  write_prot_line error_log-bseg-&1 bseg.
*  write_prot_line error_log-bkpf-&1 bkpf.
*END-OF-DEFINITION.

DEFINE write_prot_block_2.
**--------------------------------------------------------------------**
** BEGIN of CHANGES                                             C5053256
**--------------------------------------------------------------------**
**  write:/   '|' no-gap.
**  write: (17) &2 color 2 intensified off no-gap.
**  write: sy-vline no-gap.
**  write_prot_line_2 error_log-bsas-&1.
**  write_prot_line_2 error_log-bsad-&1.
**  write_prot_line_2 error_log-bsak-&1.
**  write (67) '' color col_normal intensified off.
**  write 123 '|'.
  clear : gs_outtab_summ1,  gt_outtab_summ1.
  move : &2                 to gs_outtab_summ1-sumtype,
         error_log-bsas-&1  to gs_outtab_summ1-sum4,
         error_log-bsad-&1  to gs_outtab_summ1-sum6,
         error_log-bsak-&1  to gs_outtab_summ1-sum8.
  append gs_outtab_summ1    to gt_outtab_summ1.
**--------------------------------------------------------------------**
** END of CHANGES                                             C5053256
**--------------------------------------------------------------------**
END-OF-DEFINITION.
DEFINE write_prot_block_3.
**--------------------------------------------------------------------**
** BEGIN of CHANGES                                             C5053256
**--------------------------------------------------------------------**
**  write:/   '|' no-gap.
**  write: (17) &2 color 2 intensified off no-gap.
**  write: sy-vline no-gap.
**
**  write_prot_line_2 error_log-bsis-&1.
**  write_prot_line_2 error_log-bsas-&1.
**  write_prot_line_2 error_log-bsid-&1.
**  write_prot_line_2 error_log-bsad-&1.
**  write_prot_line_2 error_log-bsik-&1.
**  write_prot_line_2 error_log-bsak-&1.
**  write_prot_line_2 error_log-bseg-&1.
**  write_prot_line_2 error_log-bkpf-&1.
**  write (12) '' color col_normal intensified off.
**  write 128 '|'.
  clear : gs_outtab_summ1, gt_outtab_summ1.
  move : &2                 to gs_outtab_summ1-sumtype,
         error_log-bsis-&1  to gs_outtab_summ1-sum3,
         error_log-bsas-&1  to gs_outtab_summ1-sum4,
         error_log-bsid-&1  to gs_outtab_summ1-sum5,
         error_log-bsad-&1  to gs_outtab_summ1-sum6,
         error_log-bsik-&1  to gs_outtab_summ1-sum7,
         error_log-bsak-&1  to gs_outtab_summ1-sum8,
         error_log-bseg-&1  to gs_outtab_summ1-sum2,
         error_log-bkpf-&1  to gs_outtab_summ1-sum1.
  append  gs_outtab_summ1  to gt_outtab_summ1.
**--------------------------------------------------------------------**
** END of CHANGES                                               C5053256
**--------------------------------------------------------------------**
END-OF-DEFINITION.

DEFINE write_prot_block_4.
**--------------------------------------------------------------------**
** BEGIN of CHANGES                                             C5053256
**--------------------------------------------------------------------**
**  write:/   '|' no-gap.
**  write: (17) &2 color 2 intensified off no-gap.
**  write: sy-vline no-gap.
**  write_prot_line_2 error_log-bkpf-&1.
**  write_prot_line_2 error_log-bseg-&1.
**  write_prot_line_2 error_log-bsis-&1.
**  write_prot_line_2 error_log-bsas-&1.
**  write_prot_line_2 error_log-bsid-&1.
**  write_prot_line_2 error_log-bsad-&1.
**  write_prot_line_2 error_log-bsik-&1.
**  write_prot_line_2 error_log-bsak-&1.
**  write_prot_line_2 error_log-bsim-&1.
**  write (1) '' color col_normal intensified off.
**  write 128 '|'.
  clear : gs_outtab_summ1, gt_outtab_summ1.
  move : &2                 to gs_outtab_summ1-sumtype,
         error_log-bkpf-&1  to gs_outtab_summ1-sum1,
         error_log-bseg-&1  to gs_outtab_summ1-sum2,
         error_log-bsis-&1  to gs_outtab_summ1-sum3,
         error_log-bsas-&1  to gs_outtab_summ1-sum4,
         error_log-bsid-&1  to gs_outtab_summ1-sum5,
         error_log-bsad-&1  to gs_outtab_summ1-sum6,
         error_log-bsik-&1  to gs_outtab_summ1-sum7,
         error_log-bsak-&1  to gs_outtab_summ1-sum8,
         error_log-bsim-&1  to gs_outtab_summ1-sum9.
  append  gs_outtab_summ1    to gt_outtab_summ1.
**--------------------------------------------------------------------**
** END of CHANGES                                               C5053256
**--------------------------------------------------------------------**
END-OF-DEFINITION.

* ----------------------------------------------------------------------
*                        Abstimmung Bseg -> Index
*                               (Haupt Form)
* ----------------------------------------------------------------------
FORM bseg_vs_index.
  DATA:
      i_skb1 TYPE ty_skb1 OCCURS 10 WITH HEADER LINE,
      i_knb1 TYPE ty_knb1 OCCURS 10 WITH HEADER LINE,
      i_lfb1 TYPE ty_lfb1 OCCURS 10 WITH HEADER LINE,
      error_log TYPE ty_error_log,
      iperiv TYPE ty_monat OCCURS 16 WITH HEADER LINE,
      bsegerror TYPE ty_bsegerror OCCURS 5 WITH HEADER LINE,
      bkpferror TYPE ty_bsegerror OCCURS 5 WITH HEADER LINE,
      errors_all TYPE i,
      save_all TYPE i,
      head LIKE string100,
      p_cursor TYPE cursor.

  STATICS: db_change TYPE i.
* -------------------------------------------------------------------- *
** BEGIN of CHANGES                                          C5053256
* -------------------------------------------------------------------- *
**  PERFORM ueberschrift1.
* -------------------------------------------------------------------- *
** END OF CHANGES                                            C5053256
* -------------------------------------------------------------------- *

  LOOP AT it001.
*   Stammsatz Puffer f¨¹llen
    PERFORM stammsaetze_lesen TABLES i_skb1
                                     i_knb1
                                     i_lfb1
                               USING it001.
*   Vergleichstabelle Monat/budat f¨¹llen pro Buchungskreis f¨¹llen.
    PERFORM fill_iperiv TABLES iperiv USING it001-periv it001-bukrs.
    PERFORM initialize_progress.
    PERFORM get_cursor USING it001-bukrs CHANGING p_cursor.
    DO.
      FETCH NEXT CURSOR p_cursor INTO bkpf.
      IF sy-subrc <> 0.
        CLOSE CURSOR p_cursor.
        EXIT.
      ENDIF.
      CHECK bkpf-belnr IN p_belnr.
      CHECK bkpf-gjahr IN p_gjahr.
      CHECK bkpf-monat IN p_monat.
      CHECK bkpf-budat IN p_budat.
      CHECK bkpf-waers IN p_waers.
      CHECK bkpf-cpudt IN p_cpudt.
      CHECK bkpf-xblnr IN p_xblnr.
      CHECK bkpf-blart IN p_blart.
      CHECK bkpf-bstat = space.
      ADD 1 TO error_log-bkpf-check.
      CLEAR:   bsegerror, bkpferror.
      REFRESH: bsegerror, bkpferror.

      PERFORM fehler_summieren USING error_log
                            CHANGING errors_all.

      PERFORM execute_progress USING errors_all 'BKPF'.

      PERFORM periode_pruefen TABLES bkpferror iperiv
                            CHANGING error_log.

      PERFORM bseg_pruefen TABLES i_skb1 i_knb1 i_lfb1
                                  iperiv bsegerror bkpferror
                         CHANGING error_log.

      PERFORM write_errors TABLES bkpferror bsegerror USING bkpf.

      IF repair = 'X' OR x_delhd = 'X' OR x_delind = 'X'.
        PERFORM fehler_summieren USING error_log
                              CHANGING save_all.
        IF errors_all < save_all.
          save_all = save_all - errors_all.
          ADD save_all TO db_change.
          IF db_change >= c_max.
            CALL FUNCTION 'DB_COMMIT'.
            db_change = 0.
          ENDIF.
        ENDIF.
      ENDIF.

    ENDDO. " <-- bkpf.
  ENDLOOP.                                                  " <-- t001.

*  perform fehler_summieren using error_log
*                  changing errors_all.
  IF repair = 'X'.
    head = 'Zusammenfassung Abstimmung BSEG vs INDEX (Echtlauf)'(417).
  ELSE.
    head = 'Zusammenfassung Abstimmung BSEG vs INDEX (Testlauf)'(418).
  ENDIF.
**---------------------------------------------------------------**
** BEGIN OF CHANGES                                       C5053256
**---------------------------------------------------------------**
  MOVE head TO gv_head_line1.
**  NEW-LINE.
**  ULINE (128).
**
**  WRITE:/ '|' NO-GAP,
**         (126) head COLOR COL_TOTAL NO-GAP,
**      128 '|' NO-GAP.
**  NEW-LINE.
**  ULINE (128).
**  WRITE:/ '|' NO-GAP,
**         (17) 'Table' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BKPF' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSEG' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSIS' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSAS' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSID' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSAD' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSIK' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSAK' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (12) 'BSIM' COLOR COL_NORMAL NO-GAP,
***         sy-vline no-gap,
***         (13) '' color col_normal no-gap,
**      128 '|' NO-GAP.
**  NEW-LINE.
**  ULINE (128).
**---------------------------------------------------------------**
**  END OF CHANGES                                        C5053256
**---------------------------------------------------------------**
  write_prot_block_4 error 'Fehler'(424).
  write_prot_block_4 check 'Eintr#ge gepr¨¹ft'(425).
  PERFORM schedman_summary1 USING error_log 'BSEG_vs_INDEX'.




  IF repair = 'X' OR x_delhd = 'X' OR x_delind = 'X'.
    write_prot_block_4 delete 'Gel#scht'(056).
    write_prot_block_4 create 'Angelegt'(057).
    write_prot_block_4 update 'Aktualisiert'(058).
  ENDIF.
**---------------------------------------------------------------**
**  BEGIN OF CHANGES                                     C5053256
**---------------------------------------------------------------**
**  NEW-LINE.
**  ULINE (128).
**  SKIP 2.
**---------------------------------------------------------------**
**  END OF CHANGES                                       C5053256
**---------------------------------------------------------------**
ENDFORM.                    "bseg_vs_index
* -------------------------------------------------------------------- *
*   Write header line bseg_Index
* -------------------------------------------------------------------- *
* -------------------------------------------------------------------- *
** BEGIN of CHANGES                                             C5053256
* -------------------------------------------------------------------- *
**FORM ueberschrift1.
**  FORMAT COLOR COL_TOTAL.
**  NEW-LINE. ULINE (128).
**  WRITE:/ sy-vline NO-GAP,
**          (126) 'Reconciliation BKPF/BSEG vs Indexes' NO-GAP,
**          128 sy-vline NO-GAP.
**  NEW-LINE. ULINE (128).
**  FORMAT COLOR COL_KEY.
**  WRITE:/ sy-vline NO-GAP,
** (126) 'BKRS BELNR      YEAR POS Comparison Account   Message' NO-GAP,
**          128 sy-vline NO-GAP.
**
**  IF protox = 'X'.
**
**    WRITE:/ sy-vline NO-GAP.
**    FORMAT COLOR COL_NORMAL.
**    WRITE: 5(5)  'Tabl' NO-GAP,
**        (12) 'Umsks Umskz' NO-GAP,
**        (11) 'Augdt' NO-GAP LEFT-JUSTIFIED,
**        (11) 'Augbl' NO-GAP,
**        (16) 'Zuonr' NO-GAP,
**        (2)     ' S' NO-GAP RIGHT-JUSTIFIED,
**        (3)     ' ' NO-GAP,
**        (3)  'PK' NO-GAP,
**        (16) 'Wrbtr' NO-GAP RIGHT-JUSTIFIED,
**        (17) 'Dmbtr' NO-GAP RIGHT-JUSTIFIED,
**        (17) 'Pswbt' NO-GAP RIGHT-JUSTIFIED,
**             ' ' NO-GAP,
**        (3)  'XK' NO-GAP,
**        (3)  'XO' NO-GAP,
**        (3)  'XH' NO-GAP,
**
**
**      128 sy-vline NO-GAP.
**
**  ENDIF.
**  NEW-LINE. ULINE (128).
**  FORMAT COLOR OFF.
**
* -------------------------------------------------------------------- *
** END of CHANGES                                               C5053256
* -------------------------------------------------------------------- *
**ENDFORM.                    "ueberschrift1
* -------------------------------------------------------------------- *
*   Cursor f¨¹r BKPF select besorgen
* -------------------------------------------------------------------- *
FORM get_cursor USING    bkrs LIKE bkpf-bukrs
                CHANGING p_cursor TYPE cursor.
  IF NOT p_belnr IS INITIAL.
    OPEN CURSOR WITH HOLD p_cursor FOR SELECT * FROM bkpf
      WHERE  bukrs  EQ bkrs
      AND    belnr  IN p_belnr
      AND    gjahr  IN p_gjahr
      AND    budat  IN p_budat
      AND    monat  IN p_monat
      AND    cpudt  IN p_cpudt
      AND    blart  IN p_blart
*      AND    BSTAT  EQ  SPACE
      AND    xblnr  IN p_xblnr.
    EXIT.
  ENDIF.
  IF NOT p_blart IS INITIAL.
    OPEN CURSOR WITH HOLD p_cursor FOR SELECT * FROM bkpf
      WHERE  bukrs EQ bkrs
        AND  bstat EQ space
        AND  blart IN p_blart
        AND  xblnr IN p_xblnr
        AND  belnr IN p_belnr
        AND  gjahr IN p_gjahr.

    EXIT.
  ENDIF.
  IF NOT p_xblnr IS INITIAL.
    OPEN CURSOR WITH HOLD p_cursor FOR SELECT * FROM bkpf
      WHERE  bukrs EQ bkrs
        AND  bstat EQ space
        AND  xblnr IN p_xblnr
        AND  blart IN p_blart.
    EXIT.
  ELSE.
    IF p_budat IS INITIAL.
      IF p_cpudt IS INITIAL.
        OPEN CURSOR WITH HOLD p_cursor FOR SELECT * FROM bkpf
          WHERE  bukrs  EQ bkrs
          AND    belnr  IN p_belnr
          AND    gjahr  IN p_gjahr
          AND    budat  IN p_budat
          AND    monat  IN p_monat
          AND    bstat  EQ  space
          AND    waers  IN p_waers
          AND    blart  IN p_blart.
        EXIT.
      ELSE.
        OPEN CURSOR WITH HOLD p_cursor FOR SELECT * FROM bkpf
          WHERE  bukrs EQ bkrs
            AND  cpudt IN p_cpudt
            AND  bstat = space "Keine Muster-/Dauerbu'belege
            AND  blart IN p_blart.


      ENDIF.
    ELSE.
      OPEN CURSOR WITH HOLD p_cursor
           FOR SELECT * FROM bkpf
        WHERE  bukrs  = it001-bukrs
          AND  bstat = space "Keine Muster-/Dauerbu'belege
          AND  budat IN p_budat
          AND  monat IN p_monat
          AND  waers IN p_waers
          AND  blart IN p_blart.
    ENDIF.
  ENDIF.

ENDFORM.                    "get_cursor

* -------------------------------------------------------------------- *
*   Ausgabe des Fehlerprotokolls (Bseg-Index)
* -------------------------------------------------------------------- *
FORM write_errors TABLES bkpferror STRUCTURE no_ty_bsegerror
                         bsegerror STRUCTURE no_ty_bsegerror
                   USING p_bkpf LIKE bkpf.
  DATA: dc1 TYPE i,
        dc2 TYPE i,
        odd TYPE i VALUE 1,
*        col TYPE i VALUE 4,
        errors LIKE string100.

  IF protox = 'X'.
*    col = 4.
  ENDIF.

  DESCRIBE TABLE bkpferror LINES dc1.
  DESCRIBE TABLE bsegerror LINES dc2.
  IF dc1 > 0 OR dc2 > 0.
    LOOP AT bkpferror.
      CONCATENATE errors bkpferror-estng INTO errors
      SEPARATED BY space.
    ENDLOOP.
    CONDENSE errors.
    IF dc1 > 0.
* -------------------------------------------------------------------- *
** BEGIN of CHANGES                                           C5053256
* -------------------------------------------------------------------- *
**      FORMAT COLOR COL_KEY.
**      WRITE:/ sy-vline NO-GAP,
**           (5) p_bkpf-bukrs NO-GAP,
**           (11) p_bkpf-belnr NO-GAP,
**            (5) p_bkpf-gjahr NO-GAP,
**            (4) '*** ' NO-GAP,
**            (22) 'Document' NO-GAP,
**           (79) errors COLOR = col NO-GAP,
**        128 sy-vline NO-GAP.
      CLEAR : gs_outtab_list1, gs_outtab_list2.
      MOVE : p_bkpf-bukrs TO gs_outtab_list1-bukrs,
             p_bkpf-belnr TO gs_outtab_list1-belnr,
             p_bkpf-gjahr TO gs_outtab_list1-gjahr,
             0         TO gs_outtab_list1-buzei,
             'Dokument'(059)   TO gs_outtab_list1-recon,
             errors       TO gs_outtab_list1-err_msg.
      APPEND gs_outtab_list1 TO gt_outtab_list1.
* -------------------------------------------------------------------- *
** END  of CHANGES                                            C5053256
* -------------------------------------------------------------------- *
      MOVE-CORRESPONDING p_bkpf TO h_beln2.                 "#EC ENHOK
      HIDE h_beln2.

      FORMAT COLOR OFF.
      IF protox IS INITIAL.
        IF odd = 0. odd = 1. ELSE. odd = 0. ENDIF.
      ENDIF.

    ENDIF.

    LOOP AT bsegerror.
* -------------------------------------------------------------------- *
** BEGIN of CHANGES                                           C5053256
* -------------------------------------------------------------------- *
**      FORMAT INTENSIFIED = odd.
**      FORMAT COLOR COL_KEY.
**      WRITE:/ sy-vline NO-GAP.
**      IF odd = 1 AND sy-tabix = 1 OR protox = 'X'.
**        WRITE:(5) p_bkpf-bukrs NO-GAP,
**           (11) p_bkpf-belnr NO-GAP,
**           (5) p_bkpf-gjahr NO-GAP.
**      ENDIF.
**
**      WRITE:23(4) bsegerror-buzei NO-GAP,
**         (11) bsegerror-recon NO-GAP,
**         (10) bsegerror-konto NO-GAP,
**              ' ' NO-GAP,
**        (79) bsegerror-estng COLOR = col NO-GAP,
**         128  sy-vline NO-GAP.
**      MOVE-CORRESPONDING p_bkpf TO h_beln2.
**      HIDE h_beln2.
**
**      FORMAT INTENSIFIED ON.
**      FORMAT COLOR OFF.
      CLEAR : gs_outtab_list1, gs_outtab_list2.
      MOVE : p_bkpf-bukrs TO gs_outtab_list1-bukrs,
             p_bkpf-bukrs TO gs_outtab_list2-bukrs,
             p_bkpf-belnr TO gs_outtab_list1-belnr,
             p_bkpf-belnr TO gs_outtab_list2-belnr,
             p_bkpf-gjahr TO gs_outtab_list1-gjahr,
             p_bkpf-gjahr TO gs_outtab_list2-gjahr,
             bsegerror-buzei TO gs_outtab_list1-buzei,
             bsegerror-buzei TO gs_outtab_list2-buzei,
             bsegerror-recon TO gs_outtab_list1-recon,
             bsegerror-konto TO gs_outtab_list1-konto,
             bsegerror-estng TO gs_outtab_list1-err_msg.
      APPEND gs_outtab_list1 TO gt_outtab_list1.
* -------------------------------------------------------------------- *
** END of CHANGES                                           C5053256
* -------------------------------------------------------------------- *
      IF protox IS INITIAL.
*         if odd = 0. odd = 1. else. odd = 0. endif.
        IF odd = 1. odd = 0. ENDIF.
      ELSE.
        PERFORM write_protox USING bsegerror.
      ENDIF.
    ENDLOOP.
  ENDIF.


ENDFORM.                    "write_errors

* -------------------------------------------------------------------- *
*           Ausgabe des erweiterten Protokolls (BSEG-INDEX)
* -------------------------------------------------------------------- *
FORM write_protox USING bsegerror LIKE no_ty_bsegerror.
  CASE bsegerror-recon.
    WHEN 'BSEG-RECO' OR 'BSEG-KRED' OR 'BSEG-DEBI' OR 'BSEG-SAKO'.
      IF bsegerror-recon = 'BSEG-RECO'.
        CLEAR: bsegerror-zbseg-umsks,
               bsegerror-zbseg-umskz.
      ENDIF.
      PERFORM write_protox_2 USING bsegerror-zbseg.
      IF NOT bsegerror-ybseg-bukrs IS INITIAL.
        PERFORM write_protox_2 USING bsegerror-ybseg.
      ENDIF.
  ENDCASE.
ENDFORM.                    "write_protox

* -------------------------------------------------------------------- *
*           Ausgabe des erweiterten Protokolls (BSEG-INDEX)
* -------------------------------------------------------------------- *
FORM write_protox_2 USING zbseg LIKE bseg.
* -------------------------------------------------------------------- *
** BEGIN of CHANGES                                           C5053256
* -------------------------------------------------------------------- *
**  WRITE:/ sy-vline NO-GAP,
**  5(5) zbseg-bukrs COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**  (6) zbseg-umsks COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**  (6) zbseg-umskz COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
** (11) zbseg-augdt COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
** (11) zbseg-augbl COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
** (17) zbseg-zuonr COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**  (4) zbseg-shkzg COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**  (3) zbseg-bschl COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**      zbseg-wrbtr COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**      ' ' COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**      zbseg-dmbtr COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**      ' ' COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**      zbseg-pswbt COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**      ' ' COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
**
** (3) zbseg-xkres COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
** (3) zbseg-xopvw COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
** (3) zbseg-xhres COLOR COL_NORMAL NO-GAP INTENSIFIED OFF,
** 128  sy-vline NO-GAP.
  MOVE : zbseg-bukrs    TO   gs_outtab_list2-b_tbl,
         zbseg-umsks    TO   gs_outtab_list2-umsks,
         zbseg-umskz    TO   gs_outtab_list2-umskz,
         zbseg-augdt    TO   gs_outtab_list2-augdt,
         zbseg-augbl    TO   gs_outtab_list2-augbl,
         zbseg-zuonr    TO   gs_outtab_list2-zuonr,
         zbseg-shkzg    TO   gs_outtab_list2-shkzg,
         zbseg-bschl    TO   gs_outtab_list2-bschl,
         zbseg-wrbtr    TO   gs_outtab_list2-wrbtr,
         zbseg-dmbtr    TO   gs_outtab_list2-dmbtr,
         zbseg-pswbt    TO   gs_outtab_list2-pswbt,
         zbseg-xkres    TO   gs_outtab_list2-xkres,
         zbseg-xopvw    TO   gs_outtab_list2-xopvw,
         zbseg-xhres    TO   gs_outtab_list2-xhres.
  APPEND gs_outtab_list2  TO gt_outtab_list2.
  CLEAR : gs_outtab_list2-b_tbl,
          gs_outtab_list2-umsks,
          gs_outtab_list2-umskz,
          gs_outtab_list2-augdt,
          gs_outtab_list2-augbl,
          gs_outtab_list2-zuonr,
          gs_outtab_list2-shkzg,
          gs_outtab_list2-bschl,
          gs_outtab_list2-wrbtr,
          gs_outtab_list2-dmbtr,
          gs_outtab_list2-pswbt,
          gs_outtab_list2-xkres,
          gs_outtab_list2-xopvw,
          gs_outtab_list2-xhres.
* -------------------------------------------------------------------- *
** END of CHANGES                                              C5053256
* -------------------------------------------------------------------- *
ENDFORM.                    "write_protox_2

* ----------------------------------------------------------------------
*                        Abstimmung Index -> Bseg
*                               (Haupt Form)
* ----------------------------------------------------------------------
FORM index_vs_bseg.
*----------------------------------------------------------------------*
** BEGIN of CHANGES                                            C5053256
*----------------------------------------------------------------------*
**  IF x_bseg = 'X' OR x_heade = 'X'.
**    SKIP 1.
**  ENDIF.
*----------------------------------------------------------------------*
** END of CHANGES                                              C5053256
*----------------------------------------------------------------------*
  DATA : error_log TYPE ty_error_log,
         iskb1 TYPE ty_skb1 OCCURS 10 WITH HEADER LINE,
         iknb1 TYPE ty_knb1 OCCURS 10 WITH HEADER LINE,
         ilfb1 TYPE ty_lfb1 OCCURS 10 WITH HEADER LINE,
         iperiv TYPE ty_monat OCCURS 16 WITH HEADER LINE,
         ebseg LIKE bseg OCCURS 10 WITH HEADER LINE.
*----------------------------------------------------------------------*
** BEGIN of CHANGES                                            C5053256
*----------------------------------------------------------------------*
  CLEAR   : gt_outtab_list1, gt_outtab_list2, gt_outtab_summ1,
            gs_outtab_list1, gs_outtab_list2, gs_outtab_summ1.
  REFRESH : gt_outtab_list1, gt_outtab_list2, gt_outtab_summ1.
*----------------------------------------------------------------------*
** END of CHANGES                                              C5053256
*----------------------------------------------------------------------*
  LOOP AT it001.
    t001 = it001.
    PERFORM stammsaetze_lesen TABLES iskb1
                                     iknb1
                                     ilfb1
                               USING it001.

    PERFORM fill_iperiv TABLES iperiv USING it001-periv it001-bukrs.


    CHECK NOT t001-bukrs IS INITIAL.
*   Sachkonten / Abstimmkonten ¨¹berpr¨¹fen
    IF x_sako = 'X'.
      PERFORM sako_select TABLES iskb1
                                 iperiv
                                 ebseg
                          USING  it001-bukrs CHANGING error_log.
    ENDIF. "x_sako = 'X'
*   Debitoren ¨¹berpr¨¹fen
    IF x_debi = 'X'.
      PERFORM debi_select TABLES iknb1
                                 iperiv
                                 ebseg
                          USING  it001-bukrs CHANGING error_log.
    ENDIF. "x_debi = 'X'
*   Kreditoren ¨¹berpr¨¹fen
    IF x_kredi = 'X'.
      PERFORM kredi_select TABLES ilfb1
                                  iperiv
                                  ebseg
                           USING  it001-bukrs CHANGING error_log.
    ENDIF. "x_kredi = 'X'
    IF x_matnr = 'X'.
      PERFORM bsim_select TABLES ilfb1
                                  iperiv
                                  ebseg
                           USING  it001-bukrs CHANGING error_log.
    ENDIF.


  ENDLOOP.                                                  "t001.
**  NEW-LINE. ULINE (128).
  SORT ebseg BY bukrs  gjahr belnr buzei.
  DATA lastbuzei LIKE bseg-buzei.
  DATA: savejahr LIKE bseg-gjahr.
  DESCRIBE TABLE ebseg LINES sy-tfill.
**-----------------------------------------------------------------**
**  BEGIN OF CHANGES                                       C5053256
**-----------------------------------------------------------------**
**  IF sy-tfill > 0.
**    FORMAT COLOR COL_TOTAL.
**    WRITE:/ sy-vline NO-GAP,
**          'Errors Reconciliation Indexes vs BSEG in Document Order',
**          128 sy-vline NO-GAP.
**    FORMAT COLOR OFF.
**  ENDIF.
**-----------------------------------------------------------------**
**  END OF CHANGES                                         C5053256
**-----------------------------------------------------------------**
  LOOP AT ebseg.
    savejahr = ebseg-gjahr.
    AT NEW belnr.
      CLEAR lastbuzei.
**-----------------------------------------------------------------**
**  BEGIN OF CHANGES                                       C5053256
**-----------------------------------------------------------------**
**      NEW-LINE. ULINE (128).
**      FORMAT COLOR COL_HEADING.
**      WRITE:/ sy-vline NO-GAP,
**          (5) ebseg-bukrs NO-GAP,
**          (11) ebseg-belnr NO-GAP,
**          (4) savejahr NO-GAP,
**         128    sy-vline NO-GAP.
**      FORMAT COLOR OFF.
      CLEAR : gs_outtab_list3, gs_outtab_list4.
      MOVE  : ebseg-bukrs       TO gs_outtab_list3-bukrs,
              ebseg-belnr       TO gs_outtab_list3-belnr,
              savejahr          TO gs_outtab_list3-gjahr,
              ebseg-buzei       TO gs_outtab_list3-buzei.
      APPEND  gs_outtab_list3   TO gt_outtab_list3.
    ENDAT.
**    FORMAT COLOR COL_NORMAL.
**    FORMAT INTENSIFIED OFF.
**    WRITE:/ sy-vline NO-GAP,
**             (4) ebseg-buzei NO-GAP,
**            (13) ebseg-sgtxt NO-GAP,
**            (11) ebseg-hkont NO-GAP,
**            (3) ebseg-umsks NO-GAP,
**            (2) ebseg-umskz NO-GAP,
**            (11) ebseg-augdt NO-GAP,
**            (11) ebseg-augbl NO-GAP,
**            (17) ebseg-zuonr NO-GAP,
**            (3) ebseg-bschl NO-GAP,
**            (17) ebseg-wrbtr NO-GAP,
**            (17) ebseg-dmbtr NO-GAP,
**            (17) ebseg-pswbt NO-GAP,
**         128    sy-vline NO-GAP.
**    FORMAT COLOR OFF.
**    FORMAT INTENSIFIED ON.
    MOVE  : ebseg-bukrs       TO gs_outtab_list4-bukrs,
            ebseg-belnr       TO gs_outtab_list4-belnr,
            savejahr          TO gs_outtab_list4-gjahr,
            ebseg-buzei       TO gs_outtab_list4-buzei,
            ebseg-sgtxt       TO gs_outtab_list4-sgtxt,
            ebseg-hkont       TO gs_outtab_list4-hkont,
            ebseg-umsks       TO gs_outtab_list4-umsks,
            ebseg-umskz       TO gs_outtab_list4-umskz,
            ebseg-augdt       TO gs_outtab_list4-augdt,
            ebseg-augbl       TO gs_outtab_list4-augbl,
            ebseg-zuonr       TO gs_outtab_list4-zuonr,
            ebseg-bschl       TO gs_outtab_list4-bschl,
            ebseg-wrbtr       TO gs_outtab_list4-wrbtr,
            ebseg-dmbtr       TO gs_outtab_list4-dmbtr,
            ebseg-pswbt       TO gs_outtab_list4-pswbt.
    APPEND   gs_outtab_list4   TO gt_outtab_list4.
**-----------------------------------------------------------------**
** END OF CHANGES                                         C5053256
**-----------------------------------------------------------------**
    IF lastbuzei = ebseg-buzei.
      CLEAR: ebseg-dmbtr, ebseg-dmbe2, ebseg-dmbe3, ebseg-wrbtr,
             ebseg-pswbt.
      MODIFY ebseg.
    ELSE.
      lastbuzei = ebseg-buzei.
    ENDIF.
**-----------------------------------------------------------------**
** BEGIN OF CHANGES                                         C5053256
**-----------------------------------------------------------------**
**    AT END OF belnr.
**      SUM.
**      FORMAT COLOR COL_NORMAL.
**      WRITE:/ sy-vline NO-GAP,
**                (4) ebseg-buzei NO-GAP,
**             77(17) ebseg-wrbtr NO-GAP,
**               (17) ebseg-dmbtr NO-GAP,
**               (17) ebseg-pswbt NO-GAP,
**       128 sy-vline NO-GAP.
**      FORMAT COLOR OFF.
**    ENDAT.
**-----------------------------------------------------------------**
** END OF CHANGES                                         C5053256
**-----------------------------------------------------------------**
  ENDLOOP.
**  NEW-LINE.
**  ULINE (128).

  DATA: head(120) TYPE c.

  IF repair = 'X'.
    head = 'Zusammenfassung Abstimmung Index vs Bseg (Echtlauf)'(419).
  ELSE.
    head = 'Zusammenfassung Abstimmung Index vs Bseg (Testlauf)'(420).
  ENDIF.
**-----------------------------------------------------------------**
** BEGIN OF CHANGES                                        C5053256
**-----------------------------------------------------------------**
  MOVE head  TO gv_head.
**  WRITE:/ '|' NO-GAP,
**         (126) head COLOR COL_TOTAL NO-GAP,
**      128 '|' NO-GAP.
**  NEW-LINE.
**  ULINE (128).
**  WRITE:/ '|' NO-GAP,
**         (17) 'Table' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSIS' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSAS' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSID' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSAD' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSIK' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSAK' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSEG' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BKPF' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (12) '' COLOR COL_NORMAL NO-GAP,
**      128 '|' NO-GAP.
**  NEW-LINE.
**  ULINE (128).
**-----------------------------------------------------------------**
** END  OF CHANGES                                        C5053256
**-----------------------------------------------------------------**
  write_prot_block_3 error 'Fehler'(424).
  write_prot_block_3 check 'Eintr#ge gepr¨¹ft'(425).
  PERFORM schedman_summary1 USING error_log 'INDEX_vs_BSEG'.
  IF repair = 'X' OR x_delhd = 'X' OR x_delind = 'X'.
    write_prot_block_3 delete 'Gel#scht'(056).
    write_prot_block_3 create 'Angelegt'(057).
    write_prot_block_3 update 'Aktualisiert'(058).
    write_prot_block_3 modify 'Modifiziert'(060).
  ENDIF.
**-----------------------------------------------------------------**
** BEGIN OF CHANGES                                        C5053256
**-----------------------------------------------------------------**
**  NEW-LINE.
**  ULINE (128).
**  SKIP 2.
**-----------------------------------------------------------------**
** END OF CHANGES                                          C5053256
**-----------------------------------------------------------------**
ENDFORM.                    "index_vs_bseg
*&---------------------------------------------------------------------*
*&      Form  RFBLG_VS_BKPF
*&---------------------------------------------------------------------*
FORM rfblg_vs_bkpf.
*  perform write_the_legend3.
  DATA: d_rfblg LIKE rfblg,
        d_stat,
        d_error_count TYPE i,
        d_stmnt LIKE string100,
        odd TYPE i VALUE 1.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                         C5053256
**--------------------------------------------------------------------**
  CLEAR   : gs_outtab_list1, gt_outtab_list1, gv_head, gv_head_1.
  REFRESH : gt_outtab_list1.
**--------------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
* Anfang der Schleife
  PERFORM initialize_progress.
  LOOP AT it001.
    SELECT bukrs belnr gjahr pagelg FROM rfblg
    INTO CORRESPONDING FIELDS OF d_rfblg
    WHERE bukrs EQ it001-bukrs
      AND belnr IN p_belnr
      AND gjahr IN p_gjahr
      AND pageno = 0.
      PERFORM execute_progress USING d_error_count 'RFBLG'.
      bseg_written = false.
      CLEAR d_stmnt.
      d_stat = 'Y'.
      PERFORM find_header_from_rfblg USING d_rfblg
                                  CHANGING d_stat d_stmnt.

      PERFORM check_rfblg USING d_rfblg d_stat
                                 CHANGING d_stmnt.
      IF bseg_written = true.
*      Fehlerhafter Beleg.
        IF d_error_count = 0.
*        Listen¨¹berschrift hier ausgeben
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                         C5053256
**--------------------------------------------------------------------**
**          SKIP.
**          NEW-LINE.
**          ULINE (100).
**          WRITE:/ '|' NO-GAP,
**                  (98) 'Find missing Header' COLOR COL_TOTAL,
**                  100 '|'.
          move : 'Fehlende Belegk#pfe suchen'(421) TO gv_head_line1.
**          NEW-LINE.
**          ULINE (100).
**
**          WRITE:/ '|' NO-GAP,
**            (20) 'Cpcd DocumentNo Year'  COLOR COL_HEADING NO-GAP,
**                  '|' NO-GAP,
**                  (77) 'Statements/Errors'  COLOR COL_HEADING NO-GAP,
**                  100 '|'.
**          NEW-LINE.
**          ULINE (100).
**--------------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
        ENDIF. " d_error_count.
*        DATA d_head(100).
*
*        CONCATENATE d_rfblg-bukrs d_rfblg-belnr d_rfblg-gjahr
*                                        INTO d_head SEPARATED BY space.
        SHIFT d_stmnt LEFT BY 2 PLACES.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                         C5053256
**--------------------------------------------------------------------**
**        WRITE:/ '|' NO-GAP,
**               (20) d_head COLOR COL_KEY NO-GAP INTENSIFIED = odd,
**                '|' NO-GAP,
**               (77) d_stmnt COLOR COL_NORMAL NO-GAP INTENSIFIED = odd,
**               100 '|'.
        CLEAR : gs_outtab_list1, gt_outtab_list1.
        MOVE  : d_rfblg-bukrs       TO gs_outtab_list1-bukrs,
                d_rfblg-belnr       TO gs_outtab_list1-belnr,
                d_rfblg-gjahr       TO gs_outtab_list1-gjahr,
                d_stmnt             TO gs_outtab_list1-err_msg.
        APPEND  gs_outtab_list1     TO gt_outtab_list1.
**--------------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
        IF odd = 0.
          odd = 1.
        ELSE.
          odd = 0.
        ENDIF.


        ADD 1 TO  d_error_count.
      ENDIF.
    ENDSELECT.  " <-- RFBLG
  ENDLOOP.                                                  " <-- IT001
* Ende der Schleife
  IF d_error_count = 0.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**    NEW-LINE.
**    ULINE (100).
**    WRITE:/ '|',
**            'No errors in reconciliation Find missing Header',
**            100 '|'.
    CLEAR : gt_foot_line.
    move 'In der Abstimmung Fehlende Belegk#pfe suchen sind keine Fehler aufgetreten'(422)
          TO gt_foot_line-line_print.
    MOVE gv_counter_outtab  TO gt_foot_line-list_no.
    APPEND gt_foot_line.
**--------------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
  ENDIF.

**  NEW-LINE.
**  ULINE (100).
  DATA: d_check_count TYPE i.
  PERFORM query_progress CHANGING d_check_count.
  DATA: summ(98) TYPE c.
  DATA: buf1(16) TYPE c.
  DATA: buf2(16) TYPE c.
  buf1 = d_error_count.
  buf2 = d_check_count.
  CONCATENATE 'Zusammenfassung:'(423) buf1 'Fehler'(424) buf2 'Eintr#ge gepr¨¹ft'(425) INTO
              summ SEPARATED BY space.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
**  WRITE:/ '|' NO-GAP,
**           summ COLOR COL_TOTAL NO-GAP,
**      100 '|' NO-GAP.
**
**  NEW-LINE.
**  ULINE (100).
  CLEAR : gt_foot_line.
  MOVE summ              TO gt_foot_line-line_print.
  MOVE gv_counter_outtab TO gt_foot_line-list_no.
  APPEND gt_foot_line.
**--------------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**--------------------------------------------------------------------**
ENDFORM. " <-- RFBLG_VS_BKPF
* -------------------------------------------------------------------- *
*          Find missing bkpf_fast
* -------------------------------------------------------------------- *
FORM rfblg_vs_bkpf_fast.
  DATA: d_rfblg LIKE rfblg,
        d_stat,
        d_error_count TYPE i,
        d_error_count2 TYPE i,
        d_stmnt LIKE string100,
        odd TYPE i VALUE 1.
* -------------------------------------------------------------------- *
** BEGIN of CHANGES                                            C5053256
* -------------------------------------------------------------------- *
**  FORMAT COLOR COL_HEADING.
**  NEW-LINE. ULINE (36).
**  WRITE:/ sy-vline, (32) 'Reconciliation Find missing BKPF', sy-vline.
**  WRITE:/ sy-vline, 'BKRS BELNR      YEAR Message    ', sy-vline.
**  NEW-LINE. ULINE (36).
**  FORMAT COLOR COL_NORMAL.
  move 'Fehlende Belegk#pfe suchen'(421) TO gv_head_line1.
* -------------------------------------------------------------------- *
** END of CHANGES                                              C5053256
* -------------------------------------------------------------------- *

  PERFORM initialize_progress.
* Anfang der Schleife
  SELECT bkpf~bukrs
         rfblg~bukrs rfblg~gjahr  rfblg~belnr  rfblg~pagelg
  INTO (bkpf-bukrs,
        rfblg-bukrs, rfblg-gjahr, rfblg-belnr, rfblg-pagelg)
                   FROM rfblg " client specified
                   LEFT OUTER JOIN bkpf ON
                                  rfblg~bukrs EQ bkpf~bukrs AND
                                  rfblg~belnr EQ bkpf~belnr AND
                                  rfblg~gjahr EQ bkpf~gjahr
                                WHERE
                                      rfblg~bukrs IN p_bukrs
                                  AND rfblg~belnr IN p_belnr
                                  AND rfblg~gjahr IN p_gjahr
                                  AND rfblg~pageno EQ 0.

    FORMAT INTENSIFIED = odd.
    IF rfblg-pagelg = 10.
      ADD 1 TO d_error_count2.
**-------------------------------------------------------------------**
** BEGIN of CHANGES                                          C5053256
**-------------------------------------------------------------------**
**      WRITE:/ sy-vline,
**        rfblg-bukrs, rfblg-belnr, rfblg-gjahr, (11) 'RFBLG_INIT',
**              sy-vline.
      CLEAR : gs_outtab_list1.
      MOVE  : rfblg-bukrs   TO gs_outtab_list1-bukrs,
              rfblg-belnr   TO gs_outtab_list1-belnr,
              rfblg-gjahr   TO gs_outtab_list1-gjahr,
              'RFBLG_INIT'  TO gs_outtab_list1-err_msg.
      APPEND  gs_outtab_list1  TO gt_outtab_list1.
**-------------------------------------------------------------------**
** END of CHANGES                                            C5053256
**-------------------------------------------------------------------**
      IF odd = 0.
        odd = 1.
      ELSE.
        odd = 0.
      ENDIF.
    ENDIF.
    IF bkpf-bukrs IS INITIAL.
**-------------------------------------------------------------------**
** BEGIN of CHANGES                                          C5053256
**-------------------------------------------------------------------**
**      ADD 1 TO d_error_count.
**      WRITE:/ sy-vline,
**              rfblg-bukrs, rfblg-belnr, rfblg-gjahr, (11) 'NO_BKPF',
**                                                     sy-vline.
      CLEAR : gs_outtab_list1.
      MOVE  : rfblg-bukrs   TO gs_outtab_list1-bukrs,
              rfblg-belnr   TO gs_outtab_list1-belnr,
              rfblg-gjahr   TO gs_outtab_list1-gjahr,
              'RFBLG_INIT'  TO gs_outtab_list1-err_msg.
      APPEND  gs_outtab_list1  TO gt_outtab_list1.
**-------------------------------------------------------------------**
** END of CHANGES                                            C5053256
**-------------------------------------------------------------------**
      IF odd = 0.
        odd = 1.
      ELSE.
        odd = 0.
      ENDIF.
    ENDIF.
    IF sy-batch IS INITIAL.
      PERFORM execute_progress USING d_error_count 'RFBLG'.
    ENDIF.
  ENDSELECT.
**-------------------------------------------------------------------**
** BEGIN of CHANGES                                          C5053256
**-------------------------------------------------------------------**
**  FORMAT INTENSIFIED ON.
  IF d_error_count2 = 0 AND d_error_count = 0.
**    WRITE:/ sy-vline, (32) 'No Errors', sy-vline.
    CLEAR gt_foot_line.
    MOVE gv_counter_outtab  TO gt_foot_line-list_no.
    MOVE 'Keine Fehler'(061)        TO gt_foot_line-line_print.
    APPEND  gt_foot_line.
  ENDIF.
**  FORMAT COLOR COL_TOTAL.

**  NEW-LINE. ULINE (36).
**WRITE:/ sy-vline, 'RFBLGs checked:', sy-dbcnt, (4) ' ', sy-vline.
**WRITE:/ sy-vline, 'RFBLGs initial:', d_error_count2,(4) ' ', sy-line.
**WRITE:/ sy-vline, 'BKPFs missing: ', d_error_count, (4) ' ', sy-vline.
  WRITE sy-dbcnt        TO gv_char_cnt1.
  WRITE d_error_count2  TO gv_char_cnt2.
  WRITE d_error_count   TO gv_char_cnt3.
  CLEAR gt_foot_line.
  CONCATENATE 'RFBLGs gepr¨¹ft:'(062) gv_char_cnt1 '   '
              'RFBLGs initial:'(063) gv_char_cnt2  '   '
              'BKPFs  fehlend:'(064) gv_char_cnt3
  INTO gt_foot_line-line_print SEPARATED BY space.
  MOVE gv_counter_outtab  TO gt_foot_line-list_no.
  APPEND gt_foot_line.
**  NEW-LINE. ULINE (36).
**  FORMAT COLOR OFF.
**-------------------------------------------------------------------**
** END of CHANGES                                            C5053256
**-------------------------------------------------------------------**
  EXIT.



  LOOP AT it001.
    SELECT bukrs belnr gjahr pagelg FROM rfblg
    INTO CORRESPONDING FIELDS OF d_rfblg
    WHERE bukrs EQ it001-bukrs
      AND belnr IN p_belnr
      AND gjahr IN p_gjahr
      AND pageno = 0.
      bseg_written = false.
      CLEAR d_stmnt.
      d_stat = 'Y'.
      PERFORM find_header_from_rfblg USING d_rfblg
                                  CHANGING d_stat d_stmnt.

      PERFORM check_rfblg USING d_rfblg d_stat
                                 CHANGING d_stmnt.
      IF bseg_written = true.
*      Fehlerhafter Beleg.
        IF d_error_count = 0.
*        Listen¨¹berschrift hier ausgeben
          SKIP.
          NEW-LINE.
**          ULINE (100).
          WRITE:/ '|' NO-GAP,
                  (98) 'Fehlende Belegk#pfe suchen'(421) COLOR COL_TOTAL,
                  100 '|'.
          NEW-LINE.
**          ULINE (100).

          WRITE:/ '|' NO-GAP,
                  (20) 'Bkrs Belgnummer GJahr'(065)  COLOR COL_HEADING NO-GAP,
                  '|' NO-GAP,
                  (77) 'Statements/Fehler'(066)  COLOR COL_HEADING NO-GAP,
                  100 '|'.
          NEW-LINE.
**          ULINE (100).
        ENDIF. " d_error_count.
        DATA d_head(100).

        CONCATENATE d_rfblg-bukrs d_rfblg-belnr d_rfblg-gjahr
                                        INTO d_head SEPARATED BY space.
        SHIFT d_stmnt LEFT BY 2 PLACES.
        WRITE:/ '|' NO-GAP,
               (20) d_head COLOR COL_KEY NO-GAP INTENSIFIED = odd,
                '|' NO-GAP,
               (77) d_stmnt COLOR COL_NORMAL NO-GAP INTENSIFIED = odd,
               100 '|'.
        IF odd = 0.
          odd = 1.
        ELSE.
          odd = 0.
        ENDIF.


        ADD 1 TO  d_error_count.
      ENDIF.
    ENDSELECT.  " <-- RFBLG
  ENDLOOP.                                                  " <-- IT001
* Ende der Schleife
  IF d_error_count = 0.
    NEW-LINE.
**    ULINE (100).
    WRITE:/ '|',
            (30) 'Keine Fehler in der Abstimmung'(067),
            (69) 'Fehlende Belegk#pfe suchen'(421),
            100 '|'.
  ENDIF.

  NEW-LINE.
**  ULINE (100).
  DATA: d_check_count TYPE i.
  PERFORM query_progress CHANGING d_check_count.
  DATA: summ(98) TYPE c.
  DATA: buf1(16) TYPE c.
  DATA: buf2(16) TYPE c.
  buf1 = d_error_count.
  buf2 = d_check_count.
  CONCATENATE 'Zusammenfassung:'(423) buf1 'Fehler'(424) buf2 'Eintr#ge gepr¨¹ft'(425) INTO
              summ SEPARATED BY space.
  WRITE:/ '|' NO-GAP,
           summ COLOR COL_TOTAL NO-GAP,
      100 '|' NO-GAP.

  NEW-LINE.
**  ULINE (100).
ENDFORM. " <-- RFBLG_VS_BKPF

*&---------------------------------------------------------------------*
*&                Find Header from RFBLG
*&                Reconciliation RFBLG -> BKPF
*&---------------------------------------------------------------------*
FORM find_header_from_rfblg
     USING    p_rfblg LIKE rfblg
     CHANGING p_stat  LIKE bkpf-bstat
              p_stmnt LIKE string100.

  SELECT SINGLE bstat INTO p_stat FROM bkpf
  WHERE bukrs = p_rfblg-bukrs
    AND belnr = p_rfblg-belnr
    AND gjahr = p_rfblg-gjahr.
  IF sy-subrc <> 0.
*     Es gibt keinen Kopf zur RFBLG
    PERFORM write_error_heade USING 'No_BKPF' CHANGING p_stmnt.
  ENDIF.

ENDFORM. " <-- find_header_from_RFBLG
*&---------------------------------------------------------------------*
*&              Check  RFBLG-PAGELG ...
*&            Reconciliation RFBLG -> BKPF
*&---------------------------------------------------------------------*

FORM check_rfblg USING p_rfblg LIKE rfblg p_bstat LIKE bkpf-bstat
                 CHANGING p_stmnt LIKE string100.           "#EC NEEDED

  CHECK p_rfblg-pagelg = 10.
* initialer Cluster gefunden
  PERFORM write_error_heade USING 'RFBLG_Initial' CHANGING p_stmnt.

ENDFORM.                    "check_rfblg

*&---------------------------------------------------------------------*
*&              Check  BSEG ...
*&            Reconciliation RFBLG -> BKPF
*&---------------------------------------------------------------------*
*FORM check_bseg_from_rfblg
*     USING p_rfblg LIKE rfblg p_bstat LIKE bkpf-bstat
*     CHANGING p_stmnt LIKE string100.
*
*  DATA: d_currency TYPE ty_currency.
*  DATA: d_bkpf LIKE bkpf.
*  CHECK p_rfblg-pagelg > 10.
** p_bstat = space normaler Beleg und Kopf vorhanden, dann kann auch
** Saldo NULL gepr¨¹ft werden.
*  IF p_bstat IS INITIAL OR p_bstat = 'Y'.
*    SELECT * FROM  bseg WHERE bukrs = p_rfblg-bukrs
*                          AND belnr = p_rfblg-belnr
*                          AND gjahr = p_rfblg-gjahr.
*      PERFORM waehrungsbetraege_summieren
*                           USING bseg CHANGING d_currency.
*    ENDSELECT.
*    IF sy-subrc = 0.
*      MOVE-CORRESPONDING p_rfblg TO d_bkpf.
*      d_bkpf-bstat = p_bstat.
**        perform zero_balance_check using d_bkpf d_currency 'RFBLG'
**                                   changing p_stmnt.
*    ENDIF.
*  ELSE.
**     p_bstat ist nicht space: entweder kein Kopf (p_bstat = 'Y') oder
**     nicht 'Y' und nicht space.
**     Nur Select Single, da keine Saldo 0 Pr¨¹fung, ist schneller
*    SELECT SINGLE * FROM  bseg
*             WHERE  bukrs  = p_rfblg-bukrs
*             AND    belnr  = p_rfblg-belnr
*             AND    gjahr  = p_rfblg-gjahr.
*  ENDIF.
*  IF sy-subrc <> 0.
**   Es wurde keine BSEG im vorhandenen Cluster gefunden
*    PERFORM write_error_heade USING 'No_BSEG' CHANGING p_stmnt.
*  ENDIF.
*ENDFORM.                    "check_bseg_from_rfblg

* -------------------------------------------------------------------- *
*        Hauptform zum #berpr¨¹fen von Ausgleichsvorg#ngen
* -------------------------------------------------------------------- *
FORM clearing_check.
  DATA: error_log TYPE ty_error_log,
        error_f190 TYPE ty_err_f190 OCCURS 0 WITH HEADER LINE.
  PERFORM initialize_progress.

  LOOP AT it001.
    t001 = it001.
    CLEAR error_f190.
    REFRESH error_f190.
    IF x_sako = 'X'.
      PERFORM clearing_check_sako TABLES error_f190
                                  USING t001 CHANGING error_log.
    ENDIF.
    IF x_debi = 'X'.
      PERFORM clearing_check_debi USING t001-bukrs CHANGING error_log.
    ENDIF.
    IF x_kredi = 'X'.
      PERFORM clearing_check_kredi USING t001-bukrs CHANGING error_log.
    ENDIF.
    PERFORM konto_fehler_ausgeben TABLES error_f190.
  ENDLOOP.

  IF NOT error_log IS INITIAL.
**------------------------------------------------------------------**
** BEGIN OF CHANGES                                         C5053256
**------------------------------------------------------------------**
**    NEW-LINE.
**    ULINE (123).
**    WRITE:/ '|' NO-GAP,
**         (121) 'Summary of Clearing Check' COLOR COL_TOTAL NO-GAP,
**         123 '|' NO-GAP.
**    NEW-LINE.
**    ULINE (123).
**    WRITE:/ '|' NO-GAP,
**         (17) 'Table' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSAS' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSAD' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (11) 'BSAK' COLOR COL_NORMAL NO-GAP,
**         sy-vline NO-GAP,
**         (67) '' COLOR COL_NORMAL NO-GAP,
**      123 '|' NO-GAP.
**    NEW-LINE.
**    ULINE (123).
    write_prot_block_2 error 'Fehler gefunden'(068).
    write_prot_block_2 clear 'Ausgleiche gepr¨¹ft'(069).
    write_prot_block_2 check 'Indices gelesen'(070).
**    NEW-LINE.
**    ULINE (123).
**------------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**------------------------------------------------------------------**
  ENDIF.
ENDFORM.                    "clearing_check

* -------------------------------------------------------------------- *
*                        Nachlesen der Bseg
* -------------------------------------------------------------------- *
FORM get_psw CHANGING p_wa TYPE ty_clear2.
  SELECT SINGLE * FROM bseg WHERE bukrs = p_wa-bukrs
  AND belnr = p_wa-belnr
  AND gjahr = p_wa-gjahr
  AND buzei = p_wa-buzei.

  IF sy-subrc  = 0.
    p_wa-pswsl = bseg-pswsl.
    p_wa-pswbt = bseg-pswbt.
  ENDIF.
ENDFORM.                    "get_psw

* -------------------------------------------------------------------- *
*                        Cursor auf BSAS
* -------------------------------------------------------------------- *
FORM get_cursor_sako CHANGING p_cursor TYPE cursor.
  OPEN CURSOR p_cursor FOR SELECT *
       FROM bsas
       WHERE bukrs = skb1-bukrs
       AND hkont = skb1-saknr
     AND augdt IN p_augdt
     AND augbl IN p_augbl.
ENDFORM.                    "get_cursor_sako

* -------------------------------------------------------------------- *
*                        Cursor auf BSAD
* -------------------------------------------------------------------- *
FORM get_cursor_debi CHANGING p_cursor TYPE cursor.
  OPEN CURSOR p_cursor FOR SELECT *
       FROM bsad
       WHERE bukrs = knb1-bukrs
       AND kunnr = knb1-kunnr
     AND umsks IN p_umsks
     AND umskz IN p_umskz
     AND augdt IN p_augdt
     AND augbl IN p_augbl.
ENDFORM.                    "get_cursor_debi

* -------------------------------------------------------------------- *
*                        Cursor auf BSAK
* -------------------------------------------------------------------- *
FORM get_cursor_kredi CHANGING p_cursor TYPE cursor.
  OPEN CURSOR p_cursor FOR SELECT *
       FROM bsak
       WHERE bukrs = lfb1-bukrs
       AND lifnr = lfb1-lifnr
     AND augdt IN p_augdt
     AND augbl IN p_augbl.
ENDFORM.                    "get_cursor_kredi


*&---------------------------------------------------------------------*
*&      Form  move_corresponding
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->IS_FROM    text
*      -->CS_TO      text
*----------------------------------------------------------------------*
form move_corresponding using is_from type any changing cs_to type any.
  move-corresponding is_from to cs_to.                      "#EC ENHOK
endform.                    "move_corresponding


*&---------------------------------------------------------------------*
*&      Form  open_cursor_master
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->ID_TABNAME text
*      -->ID_BUK     text
*      -->CD_CURSOR  text
*----------------------------------------------------------------------*
form open_cursor_master using id_tabname type tabname id_buk type bukrs changing cd_cursor type cursor.
*  select * from &3 where bukrs = p_buk and &4 in p_&2."#EC CI_SGLSELECT
  case id_tabname.
    when 'SKB1'.
     open cursor with hold cd_cursor for select * from (id_tabname) where bukrs = id_buk and saknr in p_hkont. "#EC CI_SGLSELECT
    when 'KNB1'.
     open cursor with hold cd_cursor for select * from (id_tabname) where bukrs = id_buk and kunnr in p_kunnr. "#EC CI_SGLSELECT
    when 'LFB1'.
     open cursor with hold cd_cursor for select * from (id_tabname) where bukrs = id_buk and lifnr in p_lifnr. "#EC CI_SGLSELECT

  endcase.
endform.                    "open_cursor_master

* -------------------------------------------------------------------- *
*           Makro zum selektieren der Ausgleichsvorg#nge
*            f.  #berpr¨¹fen von Ausgleichsvorg#ngen
* -------------------------------------------------------------------- *

DEFINE index_loop.
* &1 = BSAS BSAD BSAK
* &2 = HKONT KUNNR LIFNR
* &3 = SKB1 KNB1 LFB1.
* &4 = SAKNR KUNNR LIFNR
* &5 = P_SAKO P_DEBI P_KREDI
* &6 = String 'G/L Account' 'Kunde'(042) 'Lieferant'(043)
* &7 = UMSKS oder gsber
* &8 = UMSKZ oder gsber
  data: d_wa type ty_clear2,
        account_type like bseg-zuonr,
        d_cursor type cursor,
        ld_account_cursor type cursor.

* #ber Stammsatz gehen und dar¨¹ber loopen
  clear skb1.
  account_type = &5.

  perform open_cursor_master using '&3' p_buk changing ld_account_cursor.


  do.
    fetch next cursor ld_account_cursor into &3.
    if sy-subrc ne 0.
      close cursor ld_account_cursor.
      exit.
    endif.

    if '&3' = 'SKB1'.
*    nur op-verwaltete Sachkonten pr¨¹fen
      if not skb1 is initial.
        case skb1-mitkz.
          when ' '.
            check skb1-xopvw = 'X'.
            account_type = 'Sachkonto'(040).
          when others.
            check skb1-xkres = 'X'.
            concatenate 'Abstimmkonto'(041) '(' skb1-mitkz ')' into account_type.
*          when 'D'.
*            check skb1-xkres = 'X'.
*            account_type = 'Rec.Acct(D)'.
*          when 'K'.
*            check skb1-xkres = 'X'.
*            account_type = 'Rec.Acct(K)'.
        endcase.
      endif.
    endif.
    refresh t_clear.
    clear t_clear.
    refresh t_clear2.
    clear t_clear2.

    if '&3' = 'SKB1'.
      perform get_cursor_sako changing d_cursor.
    elseif '&3' = 'KNB1'.
      perform get_cursor_debi changing d_cursor.
    else.
      perform get_cursor_kredi changing d_cursor.
    endif.
    clear d_wa.
    do.
      fetch next cursor d_cursor into &1.
      if sy-subrc <> 0.
        close cursor d_cursor.
        exit.
      endif.
      move-corresponding &1 to d_wa. "#EC ENHOK                 "1151217
*     perform move_corresponding using &1 changing d_wa.       "1151217
      d_wa-ebseg = 0.
      d_wa-bukrs = &3-bukrs.
      d_wa-&2 = &3-&4.
      d_wa-konto = &3-&4.
      if &1-augbl = 'ALE-extern'(080).
*           write :/ 'Clearing of ALE-Sender'.
        continue.
      endif.
      check d_wa-bstat is initial.
      clear d_wa-arcnt.
      if d_wa-xarch = 'X'.
        d_wa-arcnt = 1.
        clear d_wa-xarch.
      endif.
      d_wa-koart = '&1'.
      if d_wa-pswsl is initial or d_wa-pswbt is initial.
        perform get_psw changing d_wa.
      endif. " <-- nachlesen Bseg
      if d_wa-shkzg = 'H'.
        d_wa-dmbtr = - d_wa-dmbtr.
        d_wa-dmbe2 = - d_wa-dmbe2.
        d_wa-dmbe3 = - d_wa-dmbe3.
        d_wa-pswbt = - d_wa-pswbt.
      endif.

*        check not d_wa-pswsl is initial.
      add 1 to p_error_log-&1-check.
      check d_wa-pswsl in p_pswsl.
      check d_wa-gsber in p_gsber.
      if c_bseg = 'X'.
        index_bseg_vergleich &1.
      endif.

      move-corresponding d_wa to t_clear. "#EC ENHOK            "1151217
*     perform move_corresponding using d_wa changing t_clear.  "1151217
      collect t_clear.
*        collect_t_clear d_wa &2.
      perform execute_progress using p_error_log-&1-error '&1'.
    enddo. " <-- Indextabellen
    perform t_clear_loop
            tables t_clear
                   t_clear2
            using account_type
            changing p_error_log-&1-error  p_error_log-&1-clear.
*  endselect. " <-- Stammsatztabellen
  enddo.


END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*      Hilfsmakro zum selektieren der Bseg beim Ausgleichspr¨¹fen       *
* -------------------------------------------------------------------- *
DEFINE index_bseg_vergleich.
* &1: BSAS BSAD BSAK
  if &1-xarch is initial.
    select single * from  bseg
         where  bukrs  = &1-bukrs
         and    belnr  = &1-belnr
         and    gjahr  = &1-gjahr
         and    buzei  = &1-buzei.
    if sy-subrc = 0.
      if bseg-augbl <> &1-augbl or bseg-augdt <> &1-augdt.
        move-corresponding d_wa to t_clear2-ikey. "#EC ENHOK    "1151217
        move-corresponding &1 to t_clear2-index. "#EC ENHOK     "1151217
        move-corresponding bseg to t_clear2-ibseg. "#EC ENHOK   "1151217
*       perform move_corresponding using d_wa changing t_clear2-ikey.
*       perform move_corresponding using '&1' changing t_clear2-index.
*       perform move_corresponding using bseg changing t_clear2-ibseg.

        append t_clear2.
        d_wa-ebseg = 1.
      endif.
    endif.
  endif.
END-OF-DEFINITION.
* -------------------------------------------------------------------- *
*      1. Unterform zum #berpr¨¹fen von SAKO Ausgleichsvorg#ngen
* -------------------------------------------------------------------- *
FORM clearing_check_sako TABLES error_f190 STRUCTURE no_err_f190
     USING pt001 LIKE t001
     CHANGING p_error_log TYPE ty_error_log.                "#EC NEEDED

  DATA: t_clear TYPE ty_clear OCCURS 0 WITH HEADER LINE,
        t_clear2 TYPE ty_clear3 OCCURS 0 WITH HEADER LINE,
        p_buk LIKE bseg-bukrs.
  p_buk = pt001-bukrs.
  index_loop bsas hkont skb1 saknr 'Sachkonto'(040).
ENDFORM.                    "clearing_check_sako

* -------------------------------------------------------------------- *
*      1. Unterform zum #berpr¨¹fen von DEBI Ausgleichsvorg#ngen
* -------------------------------------------------------------------- *
FORM clearing_check_debi
     USING p_buk LIKE bseg-bukrs
     CHANGING p_error_log TYPE ty_error_log.
  DATA: t_clear TYPE ty_clear OCCURS 0 WITH HEADER LINE,
        t_clear2 TYPE ty_clear3 OCCURS 0 WITH HEADER LINE.
  index_loop bsad kunnr knb1 kunnr 'Kunde'(042).

ENDFORM.                    "clearing_check_debi

* -------------------------------------------------------------------- *
*      1. Unterform zum #berpr¨¹fen von KREDI Ausgleichsvorg#ngen
* -------------------------------------------------------------------- *
FORM clearing_check_kredi
     USING p_buk LIKE bseg-bukrs
     CHANGING p_error_log TYPE ty_error_log.
  DATA: t_clear TYPE ty_clear OCCURS 0 WITH HEADER LINE,
        t_clear2 TYPE ty_clear3 OCCURS 0 WITH HEADER LINE.
  index_loop bsak lifnr lfb1 lifnr 'Lieferant'(043).

ENDFORM.                    "clearing_check_kredi

* -------------------------------------------------------------------- *
*             Auswerten/Ausgeben der T_Clear-Tabelle
* -------------------------------------------------------------------- *
FORM t_clear_loop
        TABLES p_clear STRUCTURE no_ty_clear
               p_clear2 STRUCTURE no_ty_clear3
        USING p_account_type LIKE bseg-zuonr
        CHANGING p_error TYPE i p_ok TYPE i.                "#EC NEEDED
  DATA:



        odd TYPE i,
*        col TYPE i VALUE 5,
        tabl LIKE bseg-bukrs VALUE 'BSAS'.
* Wird am Ende eines Kontos aufgerufen
  DATA error TYPE i.
  DATA account_written TYPE i.

  IF p_account_type = 'Lieferant'(043).
*    col = 6.
    tabl = 'BSAK'.
  ELSEIF p_account_type = 'Kunde'(042).
*    col = 7.
    tabl = 'BSAD'.
  ELSE.
*    col = 4.
  ENDIF.
*  sort p_clear by augdt augbl gsber pswsl.
**--------------------------------------------------------------------**
** BEGIN of CHANGES                                           C5053256
**--------------------------------------------------------------------**
  CLEAR : gt_outtab_list1, gt_outtab_list2, gt_outtab_summ1,
          gs_outtab_list1, gs_outtab_list2, gs_outtab_summ1.
**  REFRESH : GT_OUTTAB_LIST1, GT_OUTTAB_LIST2, GT_OUTTAB_SUMM1.
**--------------------------------------------------------------------**
** END of CHANGES                                             C5053256
**--------------------------------------------------------------------**
  LOOP AT p_clear.

    IF p_clear-dmbtr <> 0
    OR p_clear-dmbe2 <> 0
    OR p_clear-dmbe3 <> 0
    OR p_clear-pswbt <> 0
    OR p_clear-ebseg >  0.
      ADD 1 TO p_error.
      IF account_written = false.
**--------------------------------------------------------------------**
** BEGIN of CHANGES                                           C5053256
**--------------------------------------------------------------------**
**        NEW-LINE.
**        ULINE AT (w123).
**        WRITE:/ sy-vline NO-GAP,
**               (12) p_account_type COLOR COL_HEADING NO-GAP,
**               (11) p_clear-konto COLOR COL_HEADING NO-GAP,
**               (13) 'Company code' COLOR COL_HEADING NO-GAP,
**               (5) p_clear-bukrs COLOR COL_HEADING NO-GAP,
**           AT (w80) 'Check Clearings' COLOR COL_HEADING NO-GAP
**                                               RIGHT-JUSTIFIED,
**             sy-vline NO-GAP.
**        NEW-LINE.
        CLEAR : gs_outtab_list1, gs_outtab_list2.
        MOVE  : p_account_type    TO   gs_outtab_list1-gltype,
                p_clear-konto     TO   gs_outtab_list1-konto,
                p_clear-bukrs     TO   gs_outtab_list1-bukrs.
        APPEND  gs_outtab_list1 TO gt_outtab_list1.
**        WRITE:  sy-vline NO-GAP.
**        WRITE: (10) 'HKONT' COLOR COL_HEADING NO-GAP,
**                ' ' COLOR COL_HEADING NO-GAP.
**        WRITE: (4) 'GSBE' COLOR COL_HEADING NO-GAP.
**        WRITE: ' ' COLOR COL_HEADING NO-GAP,
**               (1) 'S' COLOR COL_HEADING NO-GAP,
**                 ' ' COLOR COL_HEADING NO-GAP,
**                 (1)  'Z' COLOR COL_HEADING NO-GAP.
**        WRITE:  ' ' COLOR COL_HEADING NO-GAP,
**                 (10) 'AUGDT' COLOR COL_HEADING NO-GAP,
**                 ' ' COLOR COL_HEADING NO-GAP,
**                 (10) 'AUGBL' COLOR COL_HEADING NO-GAP,
**                 ' ' COLOR COL_HEADING NO-GAP,
**                 (5)  'PSWSL' COLOR COL_HEADING NO-GAP,
**                 sy-vline NO-GAP,
**                 (16) 'DMBTR' COLOR COL_HEADING
**                          RIGHT-JUSTIFIED NO-GAP,
**                 ' ' COLOR COL_HEADING NO-GAP,
**                 (16) 'DMBE2' COLOR COL_HEADING
**                          RIGHT-JUSTIFIED NO-GAP,
**                 ' ' COLOR COL_HEADING NO-GAP,
**                 (16) 'DMBE3' COLOR COL_HEADING
**                          RIGHT-JUSTIFIED NO-GAP,
**                 ' ' COLOR COL_HEADING NO-GAP,
**                 (16) 'PSWBT' COLOR COL_HEADING
**                          RIGHT-JUSTIFIED NO-GAP,
**                 ' ' COLOR COL_HEADING NO-GAP,
**                 (5) 'XARCH' COLOR COL_HEADING
**                          RIGHT-JUSTIFIED NO-GAP,
**                 sy-vline NO-GAP.
**--------------------------------------------------------------------**
** END of CHANGES                                             C5053256
**--------------------------------------------------------------------**
        account_written = true.
      ENDIF.
      IF protoc = 'X' OR protox = 'X'.
        NEW-LINE.
        IF odd = 0.
          odd = 1.
        ELSE.
          odd = 0.
        ENDIF.
**--------------------------------------------------------------------**
** BEGIN of CHANGES                                             C5053256
**--------------------------------------------------------------------**
**        NEW-LINE.
**        WRITE: sy-vline NO-GAP.
**        WRITE: 2 p_clear-hkont COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**              ' ' COLOR COL_KEY INTENSIFIED = odd NO-GAP.
**        WRITE: p_clear-gsber COLOR COL_KEY INTENSIFIED = odd NO-GAP.
**        WRITE:   ' ' COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**                 p_clear-umsks COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**                 ' ' COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**                 p_clear-umskz COLOR COL_KEY INTENSIFIED = odd NO-GAP.
**        WRITE:   ' ' COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**                 p_clear-augdt COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**                 ' ' COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**                 p_clear-augbl COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**                 ' ' COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**                 p_clear-pswsl COLOR COL_KEY INTENSIFIED = odd NO-GAP,
**                 sy-vline NO-GAP,
**    (16) p_clear-dmbtr COLOR COL_NORMAL INTENSIFIED = odd NO-GAP,
**                 ' ' COLOR COL_NORMAL INTENSIFIED = odd NO-GAP,
**   (16) p_clear-dmbe2 COLOR COL_NORMAL INTENSIFIED = odd NO-GAP,
**                 ' ' COLOR COL_NORMAL INTENSIFIED = odd NO-GAP,
**   (16) p_clear-dmbe3 COLOR COL_NORMAL INTENSIFIED = odd NO-GAP,
**                 ' ' COLOR COL_NORMAL INTENSIFIED = odd NO-GAP,
**   (16) p_clear-pswbt COLOR COL_NORMAL INTENSIFIED = odd NO-GAP,
**                 ' ' COLOR COL_NORMAL INTENSIFIED = odd NO-GAP,
**    (5)  p_clear-arcnt COLOR COL_NORMAL INTENSIFIED = odd NO-GAP.
**       WRITE: '|'.
        CLEAR : gs_outtab_list2.
        MOVE : p_clear-bukrs     TO  gs_outtab_list2-bukrs,
               p_clear-konto     TO  gs_outtab_list2-konto,
               p_clear-hkont     TO  gs_outtab_list2-hkont,
               p_clear-gsber     TO  gs_outtab_list2-gsber,
               p_clear-umsks     TO  gs_outtab_list2-umsks,
               p_clear-umskz     TO  gs_outtab_list2-umskz,
               p_clear-augdt     TO  gs_outtab_list2-augdt,
               p_clear-augbl     TO  gs_outtab_list2-augbl,
               p_clear-pswsl     TO  gs_outtab_list2-pswsl,
               p_clear-dmbtr     TO  gs_outtab_list2-wrbtr,
               p_clear-dmbe2     TO  gs_outtab_list2-dmbtr,
               p_clear-dmbe3     TO  gs_outtab_list2-dmbt2,
               p_clear-pswbt     TO  gs_outtab_list2-pswbt,
               p_clear-arcnt     TO  gs_outtab_list2-arcnt.
        MOVE   p_clear-koart     TO  gs_outtab_list2-b_tbl.
        APPEND gs_outtab_list2  TO  gt_outtab_list2.
**--------------------------------------------------------------------**
** END of CHANGES                                             C5053256
**--------------------------------------------------------------------**
        IF NOT sy-batch = 'X'.
          MOVE p_clear TO h_clear.                          "#EC ENHOK
          HIDE h_clear.
        ENDIF. "<-- sy-batch
        IF c_bseg = 'X' AND p_clear-ebseg > 0.
          LOOP AT p_clear2 WHERE       ikey-hkont = p_clear-hkont
                             AND       ikey-umsks = p_clear-umsks
                             AND       ikey-umskz = p_clear-umskz
                             AND       ikey-augdt = p_clear-augdt
                             AND       ikey-augbl = p_clear-augbl
                             AND       ikey-gsber = p_clear-gsber
                             AND       ikey-pswsl = p_clear-pswsl.

**--------------------------------------------------------------------**
** BEGIN of CHANGES                                           C5053256
**--------------------------------------------------------------------**
**            FORMAT COLOR COL_NORMAL ON.
**            FORMAT INTENSIFIED ON.
**            WRITE:/ sy-vline NO-GAP,
**           (11)   p_clear2-index-belnr NO-GAP,
**           (5)    p_clear2-index-gjahr NO-GAP,
**           (4)    p_clear2-index-buzei NO-GAP.
**            WRITE 49 sy-vline NO-GAP.
**            WRITE: (73)  ' ' NO-GAP,
**                  sy-vline NO-GAP.
**            FORMAT INTENSIFIED OFF.
**            WRITE:/ sy-vline NO-GAP.
**            WRITE:   (10) ' '.
**            WRITE:  p_clear2-index-gsber.
**            WRITE: p_clear2-index-umsks,
**                   p_clear2-index-umskz.
**            WRITE: p_clear2-index-augdt,
**                   p_clear2-index-augbl,
**              (5)  p_clear2-index-pswsl NO-GAP,
**                   sy-vline NO-GAP,
**              (16) p_clear2-index-dmbtr,
**              (16) p_clear2-index-dmbe2,
**              (16) p_clear2-index-dmbe3,
**              (16) p_clear2-index-pswbt,
**              (4)  tabl,
**                   sy-vline.
            CLEAR : gs_outtab_list2.
            MOVE  : p_clear-bukrs        TO gs_outtab_list2-bukrs,
                    p_clear-konto        TO gs_outtab_list2-konto.
            MOVE  : p_clear2-index-bukrs TO gs_outtab_list2-bukrs,
                    p_clear2-index-hkont TO gs_outtab_list2-hkont.
            MOVE  : p_clear2-index-belnr TO gs_outtab_list2-belnr,
                    p_clear2-index-gjahr TO gs_outtab_list2-gjahr,
                    p_clear2-index-buzei TO gs_outtab_list2-buzei,
                    p_clear2-index-gsber TO gs_outtab_list2-gsber,
                    p_clear2-index-umsks TO gs_outtab_list2-umsks,
                    p_clear2-index-umskz TO gs_outtab_list2-umskz,
                    p_clear2-index-augdt TO gs_outtab_list2-augdt,
                    p_clear2-index-augbl TO gs_outtab_list2-augbl,
                    p_clear2-index-pswsl TO gs_outtab_list2-pswsl,
                    p_clear2-index-dmbtr TO gs_outtab_list2-wrbtr,
                    p_clear2-index-dmbe2 TO gs_outtab_list2-dmbtr,
                    p_clear2-index-dmbe3 TO gs_outtab_list2-dmbt2,
                    p_clear2-index-pswbt TO gs_outtab_list2-pswbt,
                    tabl                 TO gs_outtab_list2-b_tbl.
            APPEND  gs_outtab_list2  TO   gt_outtab_list2.
**            WRITE:/ sy-vline NO-GAP.
**            WRITE: (10) ' '.
**            WRITE: p_clear2-ibseg-gsber.
**            WRITE:  p_clear2-ibseg-umsks,
**                    p_clear2-ibseg-umskz.
**            WRITE:  p_clear2-ibseg-augdt,
**                    p_clear2-ibseg-augbl,
**               (5)  p_clear2-ibseg-pswsl NO-GAP,
**                    sy-vline NO-GAP,
**               (16) p_clear2-ibseg-dmbtr,
**               (16) p_clear2-ibseg-dmbe2,
**               (16) p_clear2-ibseg-dmbe3,
**               (16) p_clear2-ibseg-pswbt,
**               (4) 'BSEG',
**                    sy-vline.
            CLEAR : gs_outtab_list2.
            MOVE  : p_clear2-ibseg-bukrs TO gs_outtab_list2-bukrs,
                    p_clear-konto        TO gs_outtab_list2-konto,
                    p_clear2-ibseg-hkont TO gs_outtab_list2-hkont,
                    p_clear2-ibseg-gsber TO gs_outtab_list2-gsber,
                    p_clear2-ibseg-umsks TO gs_outtab_list2-umsks,
                    p_clear2-ibseg-umskz TO gs_outtab_list2-umskz,
                    p_clear2-ibseg-augdt TO gs_outtab_list2-augdt,
                    p_clear2-ibseg-augbl TO gs_outtab_list2-augbl,
                    p_clear2-ibseg-pswsl TO gs_outtab_list2-pswsl,
                    p_clear2-ibseg-dmbtr TO gs_outtab_list2-wrbtr,
                    p_clear2-ibseg-dmbe2 TO gs_outtab_list2-dmbtr,
                    p_clear2-ibseg-dmbe3 TO gs_outtab_list2-dmbt2,
                    p_clear2-ibseg-pswbt TO gs_outtab_list2-pswbt,
                    'BSEG'               TO gs_outtab_list2-b_tbl.
            APPEND  gs_outtab_list2  TO  gt_outtab_list2.
**            FORMAT INTENSIFIED OFF.
**            FORMAT COLOR OFF.
**--------------------------------------------------------------------**
** END of CHANGES                                             C5053256
**--------------------------------------------------------------------**
            IF repair = 'X' AND p_clear-dmbtr = 0.
              UPDATE bseg SET augbl = p_clear-augbl
                              augdt = p_clear-augdt
                              augcp = p_clear-augdt
                 WHERE bukrs = p_clear2-ibseg-bukrs
                   AND belnr = p_clear2-ibseg-belnr
                   AND gjahr = p_clear2-ibseg-gjahr
                   AND buzei = p_clear2-ibseg-buzei
                   AND augbl = space
                   AND augdt = '00000000'
                   AND augcp = '00000000'.
              IF sy-subrc <> 0.
                WRITE:/ sy-vline,
                   'Update fehlerhaft'(081),
                123 sy-vline.
              ELSE.
                WRITE:/ sy-vline,
                   'Update erfolgreich'(082),
                123 sy-vline.

              ENDIF.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF. " <-- protoc = ...
      error = true.

    ELSE.
      ADD 1 TO p_ok.
    ENDIF.

    IF error = true.
**--------------------------------------------------------------------**
** BEGIN of CHANGES                                           C5053256
**--------------------------------------------------------------------**
**      AT END OF konto.
**        SUM.
**
**        WRITE:/ '|' NO-GAP.
**        DATA buf(30) TYPE c.
**        CONCATENATE 'Sum' p_account_type p_clear-konto
**                                     INTO buf SEPARATED BY space.
**
**        WRITE: AT (w47)
**                buf COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**                sy-vline NO-GAP,
**           (16) p_clear-dmbtr COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**                ' ' COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**           (16) p_clear-dmbe2 COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**                ' ' COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**           (16) p_clear-dmbe3 COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**                ' ' COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**           (16) p_clear-pswbt COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**                ' ' COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**           (5)  p_clear-arcnt COLOR COL_TOTAL INTENSIFIED OFF NO-GAP,
**                sy-vline NO-GAP.
**      ENDAT. " <-- at end of Konto
**--------------------------------------------------------------------**
** END of CHANGES                                             C5053256
**--------------------------------------------------------------------**
    ENDIF. " <-- Error = true,
  ENDLOOP.
  REFRESH p_clear.
  CLEAR   p_clear.
  REFRESH p_clear2.
  CLEAR   p_clear2.

ENDFORM.                    "t_clear_loop

* -------------------------------------------------------------------- *
*         Hilfsmakro f¨¹r Doppelclicks bei Ausgleichspr¨¹fung            *
* -------------------------------------------------------------------- *
DEFINE index_at_selection.
* Hidebereichstabelle f¨¹r Belgkeys l#schen
  if not sy-batch = 'X'.
    clear h_beln.
  endif.
  select * from &1 where bukrs = p_clear-bukrs
                       and &2 = p_clear-konto
                       and &3 = p_clear-&3
                       and &4 = p_clear-&4
                       and augdt = p_clear-augdt
                       and augbl = p_clear-augbl.
    check &1-gsber = p_clear-gsber.
    check &1-bstat is initial.
    if &1-pswsl is initial or &1-pswsl is initial.
      move-corresponding &1 to d_wa. "#EC ENHOK                 "1151217
*     perform move_corresponding using &1 changing d_wa.       "1151217
      perform get_psw changing d_wa.                        "#EC ENHOK
      &1-pswsl = d_wa-pswsl.
      &1-pswbt = d_wa-pswbt.
    endif.

    check &1-pswsl = p_clear-pswsl.
    move-corresponding &1 to wa_clear. "#EC ENHOK               "1151217
*   perform move_corresponding using &1 changing wa_clear.     "1151217
    add 1 to index_count.
    if &1-shkzg = 'H'.
      wa_clear-dmbtr = - wa_clear-dmbtr.
      wa_clear-dmbe2 = - wa_clear-dmbe2.
      wa_clear-dmbe3 = - wa_clear-dmbe3.
      wa_clear-pswbt = - wa_clear-pswbt.
    endif.

*   Intensified 'off' oder 'on'.
    if odd = 0.
      odd = 1.
    else.
      odd = 0.
    endif.
    write:/1 '|'.
    write:4  &1-bukrs color col_normal,
             &1-belnr color col_normal,
             &1-gjahr color col_normal,
             &1-buzei color col_normal,
             &1-shkzg color col_normal intensified = odd,
        (16) wa_clear-dmbtr color col_normal intensified = odd currency t001-waers,
        (16) wa_clear-dmbe2 color col_normal intensified = odd currency t001-waers,
        (16) wa_clear-dmbe3 color col_normal intensified = odd currency t001-waers,
        (16) wa_clear-pswbt color col_normal intensified = odd currency wa_clear-pswsl.
    write:100 '|'.
    if not sy-batch = 'X'.
*     Hidebereichstabelle f¨¹r Belegkeys f¨¹llen
      move-corresponding &1 to h_beln. "#EC ENHOK               "1151217
*     perform move_corresponding using &1 changing h_beln.     "1151217
*      append h_beln.
      hide h_beln.
    endif.
  endselect.
  clear h_beln.
  new-line.
  uline (100).
  write:/1 '|'.
  write: 4(26) 'Saldo'(341) color col_total right-justified,
         (16) p_clear-dmbtr color col_total intensified off currency t001-waers,
         (16) p_clear-dmbe2 color col_total intensified off currency t001-waers,
         (16) p_clear-dmbe3 color col_total intensified off currency t001-waers,
         (16) p_clear-pswbt color col_total intensified off currency wa_clear-pswsl,
           100 '|'.
  write:/1 '|'.
  write: 4(17) index_count color col_total no-gap,
         (77) 'Indices gefunden'(083) color col_total no-gap, 100 '|'.
END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*                     Klicks auf die Liste                             *
* -------------------------------------------------------------------- *
FORM get_at_selection
     USING p_clear TYPE ty_clear.
  DATA: wa_clear TYPE ty_clear,
        d_wa TYPE ty_clear2,
        odd TYPE i,
        index_count TYPE i.
  IF p_clear-koart = 'BSAS'.
    index_at_selection bsas hkont augdt augdt.
  ENDIF.
  IF p_clear-koart = 'BSAD'.
    index_at_selection bsad kunnr umsks umskz.
  ENDIF.
  IF p_clear-koart = 'BSAK'.
    index_at_selection bsak lifnr umsks umskz.
  ENDIF.
ENDFORM.                    "get_at_selection

* -------------------------------------------------------------------- *
*                #berschrift 1. Verzweigungsliste
* -------------------------------------------------------------------- *
FORM write_headerline_selection_1
     USING h_clear TYPE ty_clear.

  NEW-LINE.
  ULINE (100).
  WRITE:/1 '|',
         4(14) 'SELECT * FROM' COLOR COL_HEADING NO-GAP,
         (81)  h_clear-koart COLOR COL_HEADING NO-GAP,
         100 '|'.
  IF h_clear-koart = 'BSAS'.
    WRITE:/1 '|',
           4 'WHERE HKONT =' COLOR COL_HEADING NO-GAP,
           (1) ' ' COLOR COL_HEADING NO-GAP,
           (81) h_clear-konto COLOR COL_HEADING NO-GAP,
           100 '|'.
  ENDIF.
  IF h_clear-koart = 'BSAD'.
    WRITE:/1 '|',
           4 'WHERE KUNNR =' COLOR COL_HEADING NO-GAP,
          (1) ' ' COLOR COL_HEADING NO-GAP,
          (81) h_clear-konto COLOR COL_HEADING NO-GAP,
           100 '|'.
  ENDIF.
  IF h_clear-koart = 'BSAK'.
    WRITE:/1 '|',
           4 'WHERE LIFNR =' COLOR COL_HEADING NO-GAP,
           (1) ' ' COLOR COL_HEADING NO-GAP,
           (81) h_clear-konto COLOR COL_HEADING NO-GAP,
           100 '|'.
  ENDIF.
  IF NOT h_clear-koart = 'BSAS'.
    WRITE:/1 '|',
         4(13) 'AND UMSKS =' COLOR COL_HEADING NO-GAP RIGHT-JUSTIFIED,
         (1) ' ' COLOR COL_HEADING NO-GAP,
         (81) h_clear-umsks COLOR COL_HEADING NO-GAP,
           100 '|'.
    WRITE:/1 '|',
         4(13) 'AND UMSKZ =' COLOR COL_HEADING NO-GAP RIGHT-JUSTIFIED,
         (1) ' ' COLOR COL_HEADING NO-GAP,
         (81) h_clear-umskz COLOR COL_HEADING NO-GAP,
           100 '|'.

  ENDIF.
  WRITE:/1 '|',
       4(13) 'AND AUGDT =' COLOR COL_HEADING NO-GAP RIGHT-JUSTIFIED,
       (1) ' ' COLOR COL_HEADING NO-GAP,
       (81) h_clear-augdt COLOR COL_HEADING NO-GAP,
         100 '|'.
  WRITE:/1 '|',
       4(13) 'AND AUGBL =' COLOR COL_HEADING NO-GAP RIGHT-JUSTIFIED,
       (1) ' ' COLOR COL_HEADING NO-GAP,
       (81) h_clear-augbl COLOR COL_HEADING NO-GAP,
         100 '|'.
  WRITE:/1 '|',
       4(13) 'AND GSBER =' COLOR COL_HEADING NO-GAP RIGHT-JUSTIFIED,
       (1) ' ' COLOR COL_HEADING NO-GAP,
       (81) h_clear-gsber COLOR COL_HEADING NO-GAP,
         100 '|'.
  WRITE:/1 '|',
       4(13) 'AND PSWSL =' COLOR COL_HEADING NO-GAP RIGHT-JUSTIFIED,
       (1) ' ' COLOR COL_HEADING NO-GAP,
       (81) h_clear-pswsl COLOR COL_HEADING NO-GAP,
         100 '|'.
  NEW-LINE.
  ULINE (100).

  NEW-LINE.
  ULINE (100).
  NEW-LINE.
  WRITE:/1 '|',
           4(29) 'Anz. Eintr#ge in Idx-Tabelle'(084)
                       COLOR COL_HEADING,
           33(65) h_clear-koart COLOR COL_HEADING NO-GAP,
           100 '|'.
  WRITE:/1 '|'.

  WRITE:4(5)   'BUKR' COLOR COL_HEADING INTENSIFIED OFF NO-GAP,
           (11) 'BELNR' COLOR COL_HEADING INTENSIFIED OFF NO-GAP,
           (5)  'JAHR' COLOR COL_HEADING INTENSIFIED OFF NO-GAP,
           (4)  'BUZ' COLOR COL_HEADING INTENSIFIED OFF NO-GAP,
           (2)  'H' COLOR COL_HEADING INTENSIFIED OFF NO-GAP,
           (16) 'DMBTR' COLOR COL_HEADING
                    INTENSIFIED OFF RIGHT-JUSTIFIED NO-GAP,
           (17) 'DMBE2' COLOR COL_HEADING
                    INTENSIFIED OFF RIGHT-JUSTIFIED NO-GAP,
           (17) 'DMBE3' COLOR COL_HEADING
                    INTENSIFIED OFF RIGHT-JUSTIFIED NO-GAP,
           (17) 'PSWBT' COLOR COL_HEADING
                    INTENSIFIED OFF RIGHT-JUSTIFIED NO-GAP.
  WRITE:100 '|'.
  NEW-LINE.
  ULINE (100).

ENDFORM.                    "write_headerline_selection_1

* -------------------------------------------------------------------- *
*                   Auf die Hauptliste geklickt
* -------------------------------------------------------------------- *
FORM line_selection_1.
  IF NOT excute_tr IS INITIAL AND sy-cucol > 2 AND sy-cucol < 6.
    DATA: ret TYPE i.
    IF x_repvz IS INITIAL.
      MESSAGE i000 WITH 'Kein Echtlauf'(426).
      EXIT.
    ENDIF.
    PERFORM confirm_to_rep_vz CHANGING ret.
    IF ret = true.
      PERFORM vz_korrigieren.
    ENDIF.
    EXIT.
  ENDIF.
  IF NOT h_beln2 IS INITIAL.
    SET PARAMETER ID 'BUK' FIELD h_beln2-bukrs.
    SET PARAMETER ID 'BLN' FIELD h_beln2-belnr.
    SET PARAMETER ID 'GJR' FIELD h_beln2-gjahr.
    CALL TRANSACTION 'FB03' AND SKIP FIRST SCREEN.       "#EC CI_CALLTA
    EXIT.
  ENDIF.
  IF NOT h_clear IS INITIAL.

    CALL SCREEN 3000.
**-------------------------------------------------------------------**
**   BEGIN OF CHANGES                                          C5053256
**-------------------------------------------------------------------**
**    PERFORM write_headerline_selection_1
**            USING h_clear.
**
**    PERFORM get_at_selection
**            USING h_clear.
**
**    NEW-LINE.
**    ULINE (100).
**    NEW-LINE.
**-------------------------------------------------------------------**
**   END OF CHANGES                                            C5053256
**-------------------------------------------------------------------**
  ENDIF.
ENDFORM.                    "line_selection_1

* -------------------------------------------------------------------- *
*                Auf die 1. Verzweigungsliste geklickt
* -------------------------------------------------------------------- *
FORM line_selection_2.
*  DATA strbuf(30).
  CLEAR h_beln.
  READ CURRENT LINE. " sy-LILLI index sy-LISTI.

  IF NOT h_beln IS INITIAL.
    SET PARAMETER ID 'BUK' FIELD h_beln-bukrs.
    SET PARAMETER ID 'BLN' FIELD h_beln-belnr.
    SET PARAMETER ID 'GJR' FIELD h_beln-gjahr.
    CALL TRANSACTION 'FB03' AND SKIP FIRST SCREEN.       "#EC CI_CALLTA

  ENDIF.
ENDFORM.                    "line_selection_2

* -------------------------------------------------------------------- *
*                  Fortschrittsbalken initialisieren                   *
* -------------------------------------------------------------------- *
FORM initialize_progress.
  DATA: no_use TYPE i,
        no_name.

  PERFORM do_progress USING 'X'
                      CHANGING no_use no_name.
ENDFORM.                    "initialize_progress

*&--------------------------------------------------------------------*
*&      Form  execute_progress
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->P_ERROR_COUtext
*      -->NAME       text
*---------------------------------------------------------------------*
FORM execute_progress USING p_error_count TYPE i name TYPE any.
  PERFORM do_progress USING ' '
                      CHANGING p_error_count name.
ENDFORM.                    "execute_progress

* -------------------------------------------------------------------- *
*              Abfrage des aktuellen Fehlercounts                      *
* -------------------------------------------------------------------- *
FORM query_progress CHANGING p_count TYPE i.
  DATA: no_name.
  PERFORM do_progress USING 'A'
                      CHANGING p_count no_name.
ENDFORM.                    "query_progress

* -------------------------------------------------------------------- *
*            Formroutine zum Hochz#hlen und ausgeben                   *
* -------------------------------------------------------------------- *
FORM do_progress USING init_flag TYPE any
                 CHANGING p_error_count TYPE i name TYPE any.

  STATICS hit100 TYPE i.
  STATICS hit1000 TYPE i.
  STATICS hitall TYPE i.
  DATA hitstring_count(7) TYPE c.
  DATA string_error(6) TYPE c.
  DATA status_sting(40) TYPE c.
  DATA per_cent TYPE i.
  IF init_flag = 'A'.
    p_error_count = hitall.
    EXIT.
  ENDIF.
  IF init_flag = 'X'.
    hit100 = 0.
    hit1000 = 0.
    hitall = 0.
    EXIT.
  ENDIF.

  ADD 1 TO hit100.
  ADD 1 TO hit1000.
  ADD 1 TO hitall.
  IF hit100 = c_progress_small.
    hitstring_count = hitall.
    per_cent = hit1000 / 10.
    string_error = p_error_count.
    DATA name2(30).
    concatenate name 'Datens#tze'(085) into name2 separated by space.
    CONCATENATE name2 ',' string_error INTO name2.
    CONCATENATE hitstring_count
                name2
               'Fehler'(424)
                INTO status_sting
                           SEPARATED BY space.
    PERFORM progress USING status_sting per_cent.
    CLEAR hit100.
  ENDIF.
  IF hit1000 = c_progress_large.
    CLEAR hit1000.
  ENDIF.

ENDFORM.                    "do_progress

* -------------------------------------------------------------------- *
*                     Fortschrittsanzeige
* -------------------------------------------------------------------- *
FORM progress USING text TYPE any outperc TYPE any.
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      text       = text
      percentage = outperc.
ENDFORM.                    "progress

* -------------------------------------------------------------------- *
*  Check Buchungsperiode-budat (BSEG->INDEX).
* -------------------------------------------------------------------- *
FORM periode_pruefen TABLES   errorbkpf STRUCTURE no_ty_bsegerror
                              p_periv STRUCTURE tmonat
                     CHANGING p_error_log TYPE ty_error_log.
* P_periv mu# pro buchungskreis gef¨¹llt werden !! ¨¹ber IT001.
  DATA p_bseg LIKE bseg.
  READ TABLE p_periv WITH KEY gjahr = bkpf-gjahr
                              monat = bkpf-monat BINARY SEARCH.
  IF sy-subrc = 0.
    IF bkpf-budat < p_periv-fiday OR bkpf-budat > p_periv-laday.

      ADD 1 TO p_error_log-bkpf-error.
      MOVE-CORRESPONDING bkpf TO p_bseg.                    "#EC ENHOK
      PERFORM append_bseg_error TABLES errorbkpf
                   USING p_bseg p_bseg 'BKPF' 'MONAT_BUDAT'.
    ENDIF.
  ENDIF.

  IF bkpf-glvor = 'RFBV'.
    ADD 1 TO p_error_log-bkpf-error.
    MOVE-CORRESPONDING bkpf TO p_bseg.                      "#EC ENHOK
    PERFORM append_bseg_error TABLES errorbkpf
                 USING p_bseg p_bseg 'BKPF' 'GLVOR = RFBV'.

  ENDIF.


ENDFORM.                    "periode_pruefen

* -------------------------------------------------------------------- *
*  Check Buchungsperiode-budat (INDEX->BSEG).
* -------------------------------------------------------------------- *
FORM periode_pruefen_2 TABLES p_periv STRUCTURE tmonat
                        USING p_budat LIKE bkpf-budat
                              p_monat LIKE bkpf-monat
                              p_gjahr LIKE bkpf-gjahr
                              name    LIKE bseg-bukrs
                     CHANGING p_error_log TYPE ty_error_log
                              error_line LIKE string100
                              p_state TYPE any.
* P_periv mu# pro buchungskreis gef¨¹llt werden !! ¨¹ber IT001.

  READ TABLE p_periv WITH KEY gjahr = p_gjahr
                              monat = p_monat BINARY SEARCH.
  IF sy-subrc = 0.
    DATA: string LIKE string100.
    IF p_budat < p_periv-fiday OR p_budat > p_periv-laday.
      CONCATENATE  name '_BUDAT_MONAT' INTO string.
      append_error string.
      IF name <> 'BKPF'.
        IF p_state IS INITIAL. p_state = 'X'. ENDIF.
      ENDIF.
      add_error.
    ENDIF.
  ENDIF.
ENDFORM.                    "periode_pruefen_2

* -------------------------------------------------------------------- *
* F¨¹llen der internen Tabelle zum ¨¹berpr¨¹fen Budat / Monat /pro BUKRS
* -------------------------------------------------------------------- *
FORM fill_iperiv TABLES iperiv STRUCTURE tmonat
                  USING p_periv LIKE t001-periv
                        p_bukrs LIKE t001-bukrs.
  REFRESH iperiv.
  CLEAR iperiv.
  DATA: per LIKE bkpf-monat,
        yea LIKE bkpf-gjahr,
        yea_start LIKE bkpf-gjahr,
        yea_end LIKE bkpf-gjahr,
        mon_cnt LIKE t009-anzbp.

  IF p_gjahr-low IS INITIAL.
    CALL FUNCTION 'GET_CURRENT_YEAR'
      EXPORTING
        bukrs = p_bukrs
        date  = sy-datum
      IMPORTING
        curry = yea_end
        prevy = yea_start.
    IF yea_end IS INITIAL OR yea_start IS INITIAL.
      EXIT.
    ENDIF.
  ELSE.
    yea_start = p_gjahr-low.
    yea_end   = p_gjahr-low.
    IF NOT p_gjahr-high IS INITIAL.
*     es ist noch ein Bis-Jahr angegeben worden
      yea_end = p_gjahr-high.
    ENDIF.
  ENDIF.
*   Ist die Periodenversion schon schon in der internen Tabelle ?
*   Wenn ja dann raus ansonsten weiter
  SELECT SINGLE anzbp anzsp FROM t009
               INTO CORRESPONDING FIELDS OF t009
                            WHERE periv = p_periv.
  IF sy-subrc = 0.
    yea = yea_start.
    WHILE yea <= yea_end.
*      solange der Yea-z#hler kleiner oder gleich dem Letzten zu
*      f¨¹llenden Jahr ist: ausf¨¹hren, ansonsten raus
      per = 1.
      mon_cnt = t009-anzbp + t009-anzsp.
      WHILE per <= mon_cnt.
*        solange der per-z#hler kleiner oder gleich dem Letzten zu
*        f¨¹llenden Periode ist: ausf¨¹hren, ansonsten raus
        iperiv-monat = per.
        iperiv-gjahr = yea.
*         IPERIV-PERIV = t009-periv.
        IF per IN p_monat.
          APPEND iperiv.
        ENDIF.
        ADD 1 TO per.
      ENDWHILE.
      ADD 1 TO yea.
    ENDWHILE.
  ENDIF.
* endselect.
* Anfangs- und End-tag der Perioden f¨¹llen
  LOOP AT iperiv.
    CALL FUNCTION 'PERIOD_DAY_DETERMINE'
      EXPORTING
        i_gjahr              = iperiv-gjahr
        i_monat              = iperiv-monat
        i_periv              = p_periv
      IMPORTING
        e_fday               = iperiv-fiday
        e_lday               = iperiv-laday
      EXCEPTIONS
        error_period         = 1
        error_period_version = 2
        firstday_not_defined = 3
        period_not_defined   = 4
        year_invalid         = 5
        OTHERS               = 6.
    IF sy-subrc = 0.
*    Wenn's klappt, dann ¨¹bernehmen
      MODIFY iperiv.
    ELSE.
*    anderenfalls l#schen
      DELETE iperiv.
    ENDIF.
  ENDLOOP.

  SORT iperiv BY gjahr monat.
ENDFORM.                    "fill_iperiv

* -------------------------------------------------------------------- *
*                       F¨¹llen der IT001
* -------------------------------------------------------------------- *
FORM fill_it001.
* Get Company code information
  CLEAR it001.
  REFRESH it001.
  SELECT * FROM  t001 INTO TABLE it001 WHERE bukrs IN p_bukrs.
* Get posting key information
  CLEAR itbsl.
  REFRESH itbsl.
  SELECT * FROM tbsl INTO TABLE itbsl ORDER BY PRIMARY KEY.
ENDFORM.                                                    "fill_it001
* -------------------------------------------------------------------- *
*                Check Authority for CC in use
* -------------------------------------------------------------------- *
*FORM check_authority_it001 CHANGING ret TYPE i.
*  DATA: return TYPE i.
*  DATA: err TYPE i.
*  LOOP AT it001.
*    PERFORM bukrs_authority USING it001 CHANGING return.
*    CASE return.
*      WHEN '0'.
*        IF err = 0.
*          err = 1.
*          NEW-LINE. ULINE (62).
*          WRITE:/ sy-vline NO-GAP,
*  'No Authority to display data of the following Company Codes ' NO-
* GAP,
*          62 sy-vline NO-GAP.
*          NEW-LINE. ULINE (62).
*        ENDIF.
*        WRITE:/ sy-vline NO-GAP,
*                  it001-bukrs NO-GAP,
*                 62 sy-vline NO-GAP.
*        DELETE it001.
*      WHEN '3'. " Nur Anzeige
*
*    IF repair = 'X' OR x_delind = 'X' OR x_delhd = 'X' OR x_repvz =
* 'X'.
*          IF err = 0.
*            err = 1.
*            NEW-LINE. ULINE (62).
*            WRITE:/ sy-vline NO-GAP,
*   'No Authority to change data of the following Company Codes ' NO-
* GAP,
*            62 sy-vline NO-GAP.
*            NEW-LINE. ULINE (62).
*          ENDIF.
*
*          WRITE:/ sy-vline NO-GAP,
*                   it001-bukrs NO-GAP,
*                  62 sy-vline NO-GAP.
*          DELETE it001.
*        ENDIF.
*    ENDCASE.
*  ENDLOOP.
*  IF err = 1.
*    NEW-LINE. ULINE (62).
*  ENDIF.
*  DESCRIBE TABLE it001 LINES sy-tfill.
*  IF sy-tfill = 0.
*    ret = false.
*  ELSE.
*    ret = true.
*  ENDIF.
*ENDFORM.                    "check_authority_it001

* -------------------------------------------------------------------- *
*  f¨¹r F070: bestimmen des Datums 1. und letzter Tag des selektierten
*  Bereichs.
* -------------------------------------------------------------------- *
FORM get_min_max_day USING    pt001 LIKE t001
                     CHANGING minday LIKE bkpf-budat
                              maxday LIKE bkpf-budat.

  DATA: min LIKE bkpf-monat VALUE '01',
        max LIKE bkpf-monat VALUE '16',
        miny LIKE bkpf-gjahr VALUE '1900',
        maxy LIKE bkpf-gjahr VALUE '3000',
        maxlast LIKE bkpf-monat VALUE '16'.

  SELECT SINGLE * FROM t009 WHERE periv = pt001-periv.
  IF sy-subrc <> 0.
    FORMAT COLOR COL_POSITIVE.
    NEW-LINE. ULINE (115).
    WRITE:/ sy-vline NO-GAP,
            'Buchungskreis'(388) NO-GAP,
            ' ' NO-GAP,
             pt001-bukrs NO-GAP,
            ' ' NO-GAP,
          (95) pt001-butxt NO-GAP,
           115 sy-vline NO-GAP.
    FORMAT COLOR COL_NEGATIVE.
    WRITE:/ sy-vline NO-GAP,
             'Gesch#ftsjahresvariante'(427) NO-GAP,
            ' "' NO-GAP,
             pt001-periv NO-GAP,
            '" ' NO-GAP,
           (88) 'nicht gefunden. Buchungskreis wurde nicht gepr¨¹ft'(428) NO-GAP,
           115 sy-vline NO-GAP.

    NEW-LINE. ULINE (115).
    FORMAT COLOR OFF.
    CLEAR: minday,maxday.
    EXIT.
  ELSE.
    maxlast = t009-anzbp + t009-anzsp.
  ENDIF.
  max = maxlast.
  IF NOT p_monat[] IS INITIAL.

    min = maxlast.
    max = '01'.
    LOOP AT p_monat.
      IF p_monat-low < min AND NOT p_monat-low IS INITIAL.
        min = p_monat-low.
      ENDIF.
      IF p_monat-high < min AND NOT p_monat-high IS INITIAL.
        min = p_monat-high.
      ENDIF.
      IF p_monat-low > max AND NOT p_monat-low IS INITIAL.
        max = p_monat-low.
      ENDIF.
      IF p_monat-high > max AND NOT p_monat-high IS INITIAL.
        max = p_monat-high.
      ENDIF.
    ENDLOOP.
  ENDIF.
  IF NOT p_gjahr[] IS INITIAL.
    miny = '9999'.
    maxy = '0001'.
    LOOP AT p_gjahr.
      IF p_gjahr-low < miny AND NOT p_gjahr-low IS INITIAL.
        miny = p_gjahr-low.
      ENDIF.
      IF p_gjahr-high < miny AND NOT p_gjahr-high IS INITIAL.
        miny = p_gjahr-high.
      ENDIF.
      IF p_gjahr-low > maxy AND NOT p_gjahr-low IS INITIAL.
        maxy = p_gjahr-low.
      ENDIF.
      IF p_gjahr-high > maxy AND NOT p_gjahr-high IS INITIAL.
        maxy = p_gjahr-high.
      ENDIF.
    ENDLOOP.
  ENDIF.
  CALL FUNCTION 'PERIOD_DAY_DETERMINE'
     EXPORTING
          i_gjahr              = miny
          i_monat              = min
          i_periv              = pt001-periv
     IMPORTING
          e_fday               = minday
*          E_LDAY               = mayday
    EXCEPTIONS
         error_period         = 1
         error_period_version = 2
         firstday_not_defined = 3
         period_not_defined   = 4
         year_invalid         = 5
         OTHERS               = 6.
  IF sy-subrc <> 0.
    FORMAT COLOR COL_POSITIVE.
    NEW-LINE. ULINE (115).
    WRITE:/ sy-vline NO-GAP,
            (12) 'Buchungskreis'(353) NO-GAP,
            ' ' NO-GAP,
             pt001-bukrs NO-GAP,
            ' ' NO-GAP,
          (95) pt001-butxt NO-GAP,
           115 sy-vline NO-GAP.
    FORMAT COLOR COL_NEGATIVE.
    WRITE:/ sy-vline NO-GAP,
           (15) 'GJahr-Variante'(086) NO-GAP,
            (3)  pt001-periv NO-GAP,
            (5) 'Jahr'(304) NO-GAP,
            (5)  miny NO-GAP,
           (20) '1. Tag d. Zeitraums'(087) NO-GAP,
            (3)  min NO-GAP,
           (62) 'konnte nicht bestimmt werden'(088) NO-GAP,
           115 sy-vline NO-GAP.
    NEW-LINE. ULINE (115).
    FORMAT COLOR OFF.
    CLEAR: minday,maxday.
    EXIT.
  ENDIF.
  CALL FUNCTION 'PERIOD_DAY_DETERMINE'
     EXPORTING
          i_gjahr              = maxy
          i_monat              = max
          i_periv              = pt001-periv
     IMPORTING
*          E_FDAY               = minday
          e_lday               = maxday
    EXCEPTIONS
         error_period         = 1
         error_period_version = 2
         firstday_not_defined = 3
         period_not_defined   = 4
         year_invalid         = 5
         OTHERS               = 6.
  IF sy-subrc <> 0.
    FORMAT COLOR COL_POSITIVE.
    NEW-LINE. ULINE (115).
    WRITE:/ sy-vline NO-GAP,
            (12) 'Buchungskreis'(353) NO-GAP,
            ' ' NO-GAP,
             pt001-bukrs NO-GAP,
            ' ' NO-GAP,
          (95) pt001-butxt NO-GAP,
           115 sy-vline NO-GAP.
    FORMAT COLOR COL_NEGATIVE.
    WRITE:/ sy-vline NO-GAP,
           (15) 'GJahr-Variante'(086) NO-GAP,
            (3)  pt001-periv NO-GAP,
            (5) 'Jahr'(304) NO-GAP,
            (5)  maxy NO-GAP,
           (19) 'Letzer Tag d.Zeitr.'(089) NO-GAP,
            (3)  max NO-GAP,
           (63) 'konnte nicht bestimmt werden'(088) NO-GAP,
           115 sy-vline NO-GAP.

    NEW-LINE. ULINE (115).
    FORMAT COLOR OFF.
    CLEAR: minday,maxday.
    EXIT.

  ENDIF.



ENDFORM.                    "get_min_max_day
************************************************************************
* -------------------------------------------------------------------- *
*                   Mainform: OPs at date
* -------------------------------------------------------------------- *
************************************************************************
FORM offene_posten.
  IF NOT sy-batch = 'X' AND p_gjahr IS INITIAL.

    CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT'
      EXPORTING
        titel     = 'Sie haben keine Gesch#ftjahr angegeben!'(381)
        textline1 = 'Bitte geben Sie ein Gesch#ftjahr an'(382).
  ENDIF.

  PERFORM initialize_progress.
  CHECK x_sako = 'X' OR x_debi = 'X' OR x_kredi = 'X'.
  CHECK NOT p_gjahr IS INITIAL.
**-----------------------------------------------------------------**
** BEGIN OF CHANGES                                       C5053256
**-----------------------------------------------------------------**
**  SKIP.
**  NEW-LINE. ULINE (115).
**  FORMAT COLOR COL_HEADING.
**  WRITE:/ sy-vline,
**          'Sum of Open Items to Account Balance',
  move 'Summe offener Posten zum Kontosaldo'(429) TO gv_head_line1.
**    115 sy-vline.
**  NEW-LINE. ULINE (115).
**  FORMAT COLOR OFF.
**
  IF NOT p_lifnr IS INITIAL AND x_kredi = 'X'.
**    NEW-LINE. ULINE (115).
**    WRITE:/ sy-vline,
**            '"Sum of Vendors Open Items to Balance',
**            'of Rec. Account" can only be checked for all Vendors',
**         115 sy-vline.
    CONCATENATE 'Summe offener Posten zum Kontosaldo'(429)
            'von Abstimmkonten kann nur f¨¹r alle Lieferanten durchgef¨¹hrt werden'(431)
    INTO gv_head_line3 SEPARATED BY space.
**    NEW-LINE. ULINE (115).
  ENDIF.
  IF NOT p_kunnr IS INITIAL AND x_debi = 'X'.
**    IF p_lifnr IS INITIAL OR x_kredi IS INITIAL.
**      NEW-LINE. ULINE (115).
**    ENDIF.
**    WRITE:/ sy-vline,
**            '"Sum of Customers Open Items to Balance',
**            'of Rec. Account" can only be checked for all Customers',
    CONCATENATE 'Summe offener Posten zum Kontosaldo'(429)
            'von Abstimmkonten kann nur f¨¹r alle Kunden durchgef¨¹hrt werden'(430)
    INTO gv_head_line3 SEPARATED BY space.
**         115 sy-vline.
**    NEW-LINE. ULINE (115).
  ENDIF.
**-----------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**-----------------------------------------------------------------**

  LOOP AT it001.
    PERFORM offene_posten_bukrs USING it001.
  ENDLOOP.
  IF sy-subrc <> 0.
**----------------------------------------------------**
**  BEGIN OF CHANGES                            C5053256
**----------------------------------------------------**
**    NEW-LINE. ULINE (115).
**    WRITE:/ sy-vline,
**            'Reconciliation Open Items to Balance:',
**            'No Company Codes checked',
**        115  sy-vline.
**    NEW-LINE. ULINE (115).
    CLEAR : gt_foot_line.
    CONCATENATE 'Summe offener Posten zum Kontosaldo'(429)
                'Keine Buchungskreise gepr¨¹ft'(433)
    INTO gt_foot_line-line_print SEPARATED BY space.
    MOVE gv_counter_outtab TO gt_foot_line-list_no.
    APPEND gt_foot_line.
**----------------------------------------------------**
**  END OF CHANGES                             C5053256
**----------------------------------------------------**
    EXIT.
  ENDIF.
ENDFORM.                    "offene_posten
* -------------------------------------------------------------------- *
*         Sum of Open items for a specific CC
* -------------------------------------------------------------------- *
FORM offene_posten_bukrs USING pit001 LIKE t001.
  DATA: minday LIKE bkpf-budat,
        maxday LIKE bkpf-budat,
        curtab TYPE ty_curtab OCCURS 2 WITH HEADER LINE,
        iskb1 TYPE ty_skb1 OCCURS 10 WITH HEADER LINE,
        iknb1 TYPE ty_knb1 OCCURS 10 WITH HEADER LINE,
        ilfb1 TYPE ty_lfb1 OCCURS 10 WITH HEADER LINE,

        eskb1 LIKE skb1 OCCURS 0 WITH HEADER LINE,
        messagestring(60) TYPE c.

  PERFORM get_min_max_day USING pit001 CHANGING minday maxday.
  IF minday IS INITIAL.
    EXIT.
  ENDIF.
* **************************************
* Read account master data
* **************************************
  PERFORM stammsaetze_lesen_oi TABLES iskb1
                                   iknb1
                                   ilfb1
                             USING pit001.

* **************************************
* Get the required ledgers
* **************************************
  PERFORM ledger_lesen TABLES curtab USING pit001.
* **************************************
*  skip.
** BEGIN OF CHANGES                                         C5053256
**  NEW-LINE. ULINE (115).
**  FORMAT COLOR COL_HEADING.
**  WRITE:/ sy-vline NO-GAP,
**          'Company Code ' NO-GAP,
**          pit001-bukrs NO-GAP,
**          ' Sum of Open Items before date ' NO-GAP,
**      (52) minday NO-GAP,
**    115 sy-vline NO-GAP.
  CLEAR   : gt_outtab_led.
  REFRESH : gt_outtab_led.
  CLEAR   : gt_outtab_list11, gs_outtab_list11.
  MOVE    : pit001-bukrs   TO gs_outtab_list11-bukrs.
  CONCATENATE 'Buchungskreis'(388) pit001-bukrs
              'Summe offener Posten vor'(090) minday
  INTO gs_outtab_list11-err_msg SEPARATED BY space.
  APPEND  gs_outtab_list11 TO gt_outtab_list11.
** END OF CHANGES                                           C5053256
  PERFORM list_ledgers TABLES curtab.
**  NEW-LINE. ULINE (115).
**  FORMAT COLOR OFF.
* **************************************
* Perform the comparisons
* **************************************
  IF x_sako = 'X'.
*   ************************************
*   Compare G/L items to balance G/L
*   ************************************
    PERFORM op_at_date_sako TABLES curtab iskb1 eskb1
                             USING pit001 minday.
  ENDIF.
  IF x_debi = 'X'.
*   ****************************************************
*   Compare Customers items to Customer and rec. balance
*   ****************************************************
    PERFORM op_at_date_debi
                       TABLES curtab iskb1 iknb1 ilfb1 eskb1
                        USING pit001 minday.
  ENDIF.
  IF x_kredi = 'X'.
*   ****************************************************
*   Compare Vendors items to Vendor and rec. balance
*   ****************************************************
    PERFORM op_at_date_kredi
                        TABLES curtab iskb1 ilfb1 iknb1 eskb1
                         USING pit001 minday.
  ENDIF.
* *****************************************
* Write not exsiting account Master data. *
* *****************************************
  DESCRIBE TABLE eskb1 LINES sy-tfill.
  IF sy-tfill > 0.
    SORT eskb1 BY mitkz saknr xkres.
**------------------------------------------------------------**
** BEGIN OF CHANGES                                  C5053256
**------------------------------------------------------------**
**    FORMAT COLOR COL_NEGATIVE.
**    NEW-LINE. ULINE (102).
**    WRITE :/ sy-vline NO-GAP,
**             'Critical Accounts in Company Code ' NO-GAP,
**             pit001-bukrs NO-GAP,
**         102  sy-vline NO-GAP.
**    NEW-LINE. ULINE (102).
**    FORMAT COLOR COL_NORMAL.
**------------------------------------------------------------**
** END OF CHANGES                                    C5053256
**------------------------------------------------------------**
    LOOP AT eskb1.
      IF eskb1-mitkz = 'S'.
*  G/L accounts
        IF eskb1-xkres = 'X'.
          messagestring = 'BSID-/BSAD-HKONT ohne Stamm'(092).
        ELSEIF eskb1-xkres = 'Y'.
          messagestring = 'BSIK-/BSAK-HKONT ohne Stamm'(093).
        ELSEIF eskb1-xkres = 'Z'.
          messagestring = 'BSIS-/BSAS-HKONT ohne Stamm'(094).
        ELSEIF eskb1-xkres = 'A'.
          messagestring = 'BSIS-/BSAS-Eintr#ge ohne SKB1-XKRES'(095).
        ELSEIF eskb1-xkres = 'L'.
          messagestring = 'BSIS-/BSAS-Eintr#ge mit ALE-Extern'(071).
        ELSEIF eskb1-xkres = 'M'.
          messagestring = 'Kontof¨¹hrung extern, SKB1-WMETH = X'(072).
        ELSE.
          messagestring = 'GLT0-Datensatz ohne Stammsatz'(073).
        ENDIF.
      ENDIF.
      IF eskb1-mitkz = 'K'.
*  Vendors
        IF eskb1-xkres = 'X'.
          messagestring = 'BSIK-/BSAK-LIFNR ohne Stamm'(074).
        ELSEIF eskb1-xkres = 'L'.
          messagestring = 'BSIK-/BSAK-Eintr#ge mit ALE-Extern'(075).
        ELSEIF eskb1-xkres IS INITIAL.
          messagestring = 'LFC* ohne Stamm'(076).
        ENDIF.
      ENDIF.
      IF eskb1-mitkz = 'D'.
*  Cusromers
        IF eskb1-xkres = 'X'.
          messagestring = 'BSID-/BSAD-KUNNR ohne Stamm'(077).
        ELSEIF eskb1-xkres = 'L'.
          messagestring = 'BSID-/BSAD-Eintr#ge mit ALE-Extern'(078).
        ELSEIF eskb1-xkres IS INITIAL.
          messagestring = 'KNC* ohne Stamm'(079).
        ENDIF.
      ENDIF.
**----------------------------------------------------------------**
** BEGIN OF CHANGES                                         C5053256
**----------------------------------------------------------------**
**      WRITE:/ sy-vline NO-GAP,
**              eskb1-mitkz NO-GAP,
***           sy-vline no-gap,
***           eskb1-bukrs no-gap,
**              sy-vline NO-GAP,
**              eskb1-saknr NO-GAP,
**              sy-vline NO-GAP,
**              messagestring,
**          102 sy-vline NO-GAP.
      CLEAR : gs_outtab_list29.
      MOVE  : eskb1-mitkz    TO gs_outtab_list29-koart,
              eskb1-bukrs    TO gs_outtab_list29-bukrs,
              eskb1-saknr    TO gs_outtab_list29-hkont,
              messagestring  TO gs_outtab_list29-err_msg.
      APPEND  gs_outtab_list29  TO gt_outtab_list29.
      AT END OF saknr.
**        NEW-LINE. ULINE (102).
**----------------------------------------------------------------**
** END OF CHANGES                                           C5053256
**----------------------------------------------------------------**
      ENDAT.
    ENDLOOP.
*  new-line. uline (102).
**    FORMAT COLOR OFF.
    REFRESH eskb1.
  ENDIF.

ENDFORM.                    "offene_posten_bukrs


* -------------------------------------------------------------------- *
*   Ops at date sako
* -------------------------------------------------------------------- *
FORM op_at_date_sako TABLES curtab STRUCTURE no_curtab
                            iskb1  STRUCTURE no_skb1
                            eskb1  STRUCTURE skb1

                      USING pit001 LIKE t001 minday LIKE bkpf-budat.

  DATA: sb1  TYPE ty_trans OCCURS 100 WITH HEADER LINE. " GLT0 for rec.
  PERFORM salden_berechnen_hb TABLES sb1 eskb1 curtab iskb1
                              USING pit001 ''.

  DATA: errors TYPE i,
        wa_bsis TYPE ty_bsxx,
        save_subrc LIKE sy-subrc,
        augbl LIKE bseg-augbl.
  SELECT hkont gsber shkzg pswsl augbl
         SUM( pswbt ) SUM( dmbtr ) SUM( dmbe2 ) SUM( dmbe3 )
  INTO (wa_bsis-accnt, wa_bsis-gsber, wa_bsis-shkzg,
        wa_bsis-pswsl, augbl, wa_bsis-pswbt, wa_bsis-dmbtr,
        wa_bsis-dmbe2, wa_bsis-dmbe3)
  FROM bsis WHERE bukrs = pit001-bukrs
              AND hkont IN p_hkont
              AND budat < minday
              AND bstat = space
   GROUP BY hkont gsber pswsl shkzg augbl.
    IF sy-batch IS INITIAL.
      PERFORM execute_progress USING errors 'BSIS'.
    ENDIF.
    CLEAR wa_bsis-iiale.
    IF augbl = 'ALE-extern'(080).
      wa_bsis-iiale = 1.
    ENDIF.
    PERFORM sako_oi TABLES sb1 curtab USING wa_bsis.
  ENDSELECT.
  save_subrc = sy-subrc.
  SELECT hkont gsber shkzg pswsl augbl
         SUM( pswbt ) SUM( dmbtr ) SUM( dmbe2 ) SUM( dmbe3 )
  INTO (wa_bsis-accnt, wa_bsis-gsber, wa_bsis-shkzg,
        wa_bsis-pswsl, augbl, wa_bsis-pswbt, wa_bsis-dmbtr,
        wa_bsis-dmbe2, wa_bsis-dmbe3)
  FROM bsas WHERE bukrs = pit001-bukrs
              AND hkont IN p_hkont
              AND augdt >= minday
              AND budat < minday
              AND bstat = space
   GROUP BY hkont gsber pswsl shkzg augbl.
    IF sy-batch IS INITIAL.
      PERFORM execute_progress USING errors 'BSAS'.
    ENDIF.
    CLEAR wa_bsis-iiale.
    IF augbl = 'ALE-extern'(080).
      wa_bsis-iiale = 1.
    ENDIF.
    PERFORM sako_oi TABLES sb1 curtab USING wa_bsis.
  ENDSELECT.
* ******************************************
* Was something read at all ? if not exit
* ******************************************
  IF sy-subrc <> 0 AND save_subrc <> 0.
**---------------------------------------------------------**
** BEGIN OF CHANGES                                 C5053256
**---------------------------------------------------------**
**    NEW-LINE. ULINE (115).
**    WRITE:/ sy-vline,
**            'No entries for Company Code',
**             pit001-bukrs,
**             'in tables BSIS or BSAS for specified key',
**        115  sy-vline.
    CONCATENATE 'Keine Datens#tze zum Buchungskreis'(096)
                pit001-bukrs
               'in Tabellen BSIS or BSAS zum angeg. Schl¨¹ssel'(097)
    INTO gt_foot_line-line_print SEPARATED BY space.
    MOVE gc_32nd_list  TO gt_foot_line-list_no.
    APPEND gt_foot_line.
**    NEW-LINE. ULINE (115).
**---------------------------------------------------------**
** END OF CHANGES                                   C5053256
**---------------------------------------------------------**
*    exit.
  ENDIF.

  SORT sb1 BY accnt gsber pswsl.

  LOOP AT sb1.
    AT NEW accnt.
*       read the master
      CLEAR iskb1.
      READ TABLE iskb1 WITH KEY saknr = sb1-accnt BINARY SEARCH.
    ENDAT.
    IF iskb1 IS INITIAL.
*          Master data's missing
      eskb1-bukrs = pit001-bukrs.
      eskb1-saknr = sb1-accnt.
      eskb1-mitkz = 'S'.
      eskb1-xkres = 'Z'.
      COLLECT eskb1.
      DELETE sb1 WHERE accnt = sb1-accnt.
      CONTINUE.
    ENDIF.
    IF iskb1-xkres <> 'X'.
*          index entry for an account without line item display
      eskb1-bukrs = pit001-bukrs.
      eskb1-saknr = sb1-accnt.
      eskb1-mitkz = 'S'.
      eskb1-xkres = 'A'.
      COLLECT eskb1.
    ENDIF.
    IF iskb1-wmeth = 'X'.
      eskb1-bukrs = pit001-bukrs.
      eskb1-saknr = sb1-accnt.
      eskb1-mitkz = 'S'.
      eskb1-xkres = 'M'.
      COLLECT eskb1.
      DELETE sb1 WHERE accnt = sb1-accnt.
      CONTINUE.
    ENDIF.
    IF sb1-iiale > 0.
      eskb1-bukrs = pit001-bukrs.
      eskb1-saknr = sb1-accnt.
      eskb1-mitkz = 'S'.
      eskb1-xkres = 'L'.
      COLLECT eskb1.
      DELETE sb1 WHERE accnt = sb1-accnt.
      CONTINUE.
    ENDIF.
    IF p_oi = 'X'.
*       if p_oi = 'X' the user wants only accounts with OI-management
*       to be checked.
      IF iskb1-mitkz IS INITIAL AND iskb1-xopvw IS INITIAL.
*          condition for normal accnts
        DELETE sb1.
        CONTINUE.
      ENDIF.
      IF iskb1-mitkz NE space AND iskb1-xkres IS INITIAL.
*          condition for rec. accnts.
        DELETE sb1.
        CONTINUE.
      ENDIF.
    ENDIF.
  ENDLOOP.

***********************************************************************
* Compare BSIS/BSAS OI to Balance of G/L accnts with line item display.
***********************************************************************
  DATA: level TYPE i VALUE 1.
  PERFORM oi_to_balance TABLES sb1 iskb1 curtab
                         USING pit001
                              'Sachkonto'(040)
                              'Summe offener Posten / Kontosaldovortrag'(098)
                     CHANGING level.

ENDFORM.                    "op_at_date_sako

* -------------------------------------------------------------------- *
*           Helper Macro to select BSID/AD, BSIK/AK                    *
* -------------------------------------------------------------------- *
DEFINE select_oi_i.
* Select BSID,BSIK
* &1 = KUNNR, LIFNR
* &2 = BSID,BSIK
* &3 = P_DEBI, P_KREDI

  select &1 umskz gsber shkzg pswsl hkont augbl
         sum( pswbt ) sum( dmbtr ) sum( dmbe2 ) sum( dmbe3 )
  into (wa_bsis-accnt, wa_bsis-umskz, wa_bsis-gsber, wa_bsis-shkzg,
        wa_bsis-pswsl, hkont, augbl, wa_bsis-pswbt, wa_bsis-dmbtr,
        wa_bsis-dmbe2, wa_bsis-dmbe3)
  from &2 where bukrs = pit001-bukrs
              and &1 in p_&1
              and budat < minday
              and bstat = space
   group by &1 umskz pswsl gsber shkzg hkont augbl.
    if sy-batch is initial.
      perform execute_progress using errors '&2'.
    endif.

    clear: sb1, sb.
    sb-accnt = wa_bsis-accnt.
    sb-hkont = hkont.
    if ( ( not wa_bsis-umskz is initial ) and ( p_monat is initial ) )
    or wa_bsis-umskz is initial.
      sb-umskz = wa_bsis-umskz.
      if wa_bsis-shkzg = 'S'.
        sb-dmbtr = wa_bsis-dmbtr.
      else.
        sb-dmbtr = - wa_bsis-dmbtr.
      endif.
      if augbl = 'ALE-extern'(080).
        sb-iiale = 1.
      endif.

      collect sb.
    endif.
    if p_&1 is initial.
*   check sum of OI Vendor/Customers to OI of
*   rec. accnt can only be applied for all customers/Vendors
      wa_bsis-accnt = hkont.
      if augbl = 'ALE-extern'(080).
        wa_bsis-iiale = 1.
      endif.

      perform sako_oi tables sb1 curtab using wa_bsis.
    endif.
  endselect.
END-OF-DEFINITION.

DEFINE select_oi_a.
* Select BSAD,BSAK
* &1 = KUNNR, LIFNR
* &2 = BSAD,BSAK
* &3 = P_DEBI, P_KREDI

  select &1 umskz gsber shkzg pswsl hkont augbl
         sum( pswbt ) sum( dmbtr ) sum( dmbe2 ) sum( dmbe3 )
  into (wa_bsis-accnt, wa_bsis-umskz, wa_bsis-gsber, wa_bsis-shkzg,
        wa_bsis-pswsl, hkont, augbl, wa_bsis-pswbt, wa_bsis-dmbtr,
        wa_bsis-dmbe2, wa_bsis-dmbe3)
  from &2 where bukrs = pit001-bukrs
              and &1 in p_&1
              and augdt >= minday
              and budat < minday
              and bstat = space
   group by &1 umskz pswsl gsber shkzg hkont augbl.
    if sy-batch is initial.
      perform execute_progress using errors '&2'.
    endif.

    clear: sb1, sb.
    sb-accnt = wa_bsis-accnt.
    sb-hkont = hkont.
    if ( ( not wa_bsis-umskz is initial ) and ( p_monat is initial ) )
    or wa_bsis-umskz is initial.
      sb-umskz = wa_bsis-umskz.
      if wa_bsis-shkzg = 'S'.
        sb-dmbtr = wa_bsis-dmbtr.
      else.
        sb-dmbtr = - wa_bsis-dmbtr.
      endif.
      if augbl = 'ALE-extern'(080).
        sb-iiale = 1.
      endif.
      collect sb.
    endif.
    if p_&1[] is initial.
*   check sum of OI Vendor/Customers to OI of
*   rec. accnt can only be applied for all customers/Vendors
      if augbl = 'ALE-extern'(080).
        wa_bsis-iiale = 1.
      endif.

      wa_bsis-accnt = hkont.
      perform sako_oi tables sb1 curtab using wa_bsis.
    endif.
  endselect.
END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*   Ops at date debi
* -------------------------------------------------------------------- *

FORM op_at_date_debi TABLES curtab STRUCTURE no_curtab
                            iskb1  STRUCTURE no_skb1
                            iknb1  STRUCTURE no_knb1
                            ilfb1  STRUCTURE no_knb1
                            eskb1  STRUCTURE skb1
                      USING pit001 LIKE t001 minday LIKE bkpf-budat.

  DATA: sb   TYPE ty_ops OCCURS 100 WITH HEADER LINE,
        sb1  TYPE ty_trans OCCURS 100 WITH HEADER LINE, " GLT0 for rec.
        hkont LIKE bseg-hkont,
        save_subrc LIKE sy-subrc,
        errors TYPE i,
        wa_bsis TYPE ty_bsxx,
        augbl LIKE bseg-augbl.
* **************************************************
* Calculate the balances for the rec. accnts (GLT0).
* **************************************************
  PERFORM salden_berechnen_hb TABLES sb1 eskb1 curtab iskb1
                               USING pit001 'D'.
* *********************************************
* Do the selections on the BSIK and BSAK tables
* *********************************************
  select_oi_i kunnr bsid.
  save_subrc = sy-subrc.
  select_oi_a kunnr bsad.
* ******************************************
* Was something read at all ? if not exit
* ******************************************
  IF sy-subrc <> 0 AND save_subrc <> 0.
**--------------------------------------------------------------**
**  BEGIN OF CHANGES                                   C5053256
**--------------------------------------------------------------**
**    NEW-LINE. ULINE (115).
**    WRITE:/ sy-vline,
**            'Keine Datens#tze zum Buchungskreis'(096),
**             pit001-bukrs,
**             'in Tabellen BSID or BSAD zum angeg. Schl¨¹ssel'(099),
**        115  sy-vline.
    CONCATENATE 'Keine Datens#tze zum Buchungskreis'(096)
                pit001-bukrs
               'in Tabellen BSID or BSAD zum angeg. Schl¨¹ssel'(099)
    INTO gt_foot_line-line_print SEPARATED BY space.
    MOVE gc_34th_list  TO gt_foot_line-list_no.
    APPEND gt_foot_line.
**    NEW-LINE. ULINE (115).
**--------------------------------------------------------------**
**  END OF CHANGES                                     C5053256
**--------------------------------------------------------------**
*  exit.
  ENDIF.

* ******************************************
* Compare Sum of Vendor/Customer Items to
* Vendor/Customer balance
* ******************************************
  PERFORM oi_to_balance_nb TABLES sb eskb1 iknb1 ilfb1 USING 'D' pit001.
* ************************************************
* Vendor/Customer Items-Hkont without SKB1-Entry ?
* ************************************************
  PERFORM check_hkont_exsits TABLES sb1 eskb1 iskb1 USING 'X' pit001.
***************************************************
* Compare sum of Customer/Vendor OI
* to Balance of reconciliation Account.
***************************************************
  IF p_kunnr IS INITIAL.
*   ********************************************************
*   check sum of OI Vendor/Customers to OI of
*   rec. accnt can only be applied for all customers/Vendors
*   ********************************************************
    DATA level TYPE i VALUE 1.
    PERFORM oi_to_balance TABLES sb1 iskb1 curtab
                USING pit001 'Abstimmkonto'(041)
                'Summe debitorischer OPs / Saldo Abstimmkonto'(100)
                CHANGING level.
  ENDIF.
ENDFORM.                    "op_at_date_debi

* -------------------------------------------------------------------- *
*   Ops at date kredi
* -------------------------------------------------------------------- *
FORM op_at_date_kredi TABLES curtab STRUCTURE no_curtab
                             iskb1  STRUCTURE no_skb1
                             ilfb1  STRUCTURE no_lfb1
                             iknb1  STRUCTURE no_knb1
                             eskb1  STRUCTURE skb1
                       USING pit001 LIKE t001 minday LIKE bkpf-budat.

  DATA: sb   TYPE ty_ops OCCURS 100 WITH HEADER LINE,
        sb1  TYPE ty_trans OCCURS 100 WITH HEADER LINE, " GLT0 for rec.
        hkont LIKE bseg-hkont,
        save_subrc LIKE sy-subrc,
        errors TYPE i,
        wa_bsis TYPE ty_bsxx,
        augbl LIKE bseg-augbl.
* **************************************************
* Calculate the balances for the rec. accnts (GLT0).
* **************************************************
  PERFORM salden_berechnen_hb TABLES sb1 eskb1 curtab iskb1
                               USING pit001 'K'.
* *********************************************
* Do the selections on the BSIK and BSAK tables
* *********************************************
  select_oi_i lifnr bsik.
  save_subrc = sy-subrc.
  select_oi_a lifnr bsak.
* ******************************************
* Was something read at all ? if not exit
* ******************************************
  IF sy-subrc <> 0 AND save_subrc <> 0.
**-------------------------------------------------------------**
** BEGIN OF CHANGES                                    C5053256
**-------------------------------------------------------------**
**    NEW-LINE. ULINE (115).
**    WRITE:/ sy-vline,
**            'No entries for Company Code',
**             pit001-bukrs,
**             'in tables BSIK or BSAK for specified key',
**        115  sy-vline.
    CONCATENATE 'Keine Datens#tze zum Buchungskreis'(096)
                pit001-bukrs
               'in Tabellen BSIK or BSAK zum angeg. Schl¨¹ssel'(101)
    INTO gt_foot_line-line_print SEPARATED BY space.
    MOVE gc_36th_list  TO gt_foot_line-list_no.
    APPEND gt_foot_line.
**    NEW-LINE. ULINE (115).
**-------------------------------------------------------------**
** END  OF CHANGES                                     C5053256
**-------------------------------------------------------------**
*  exit.
  ENDIF.
* ******************************************
* Compare Sum of Vendor/Customer Items to
* Vendor/Customer balance
* ******************************************
  PERFORM oi_to_balance_nb TABLES sb eskb1 iknb1 ilfb1 USING 'K' pit001.
* ************************************************
* Vendor/Customer Items-Hkont without SKB1-Entry ?
* ************************************************
  PERFORM check_hkont_exsits TABLES sb1 eskb1 iskb1 USING 'Y' pit001.
***************************************************
* Compare BSIK/BSAK OI to Balance of re. Acc.
***************************************************
  IF p_lifnr IS INITIAL.
*   ********************************************************
*   check sum of OI Vendor/Customers to OI of
*   rec. accnt can only be applied for all customers/Vendors
*   ********************************************************
    DATA level TYPE i VALUE 1.
    PERFORM oi_to_balance TABLES sb1 iskb1 curtab USING pit001
                                                        'Abstimmkonto'(041)
                'Summe kreditorischer OPs / Saldo Abstimmkonto'(102)
                CHANGING level.
  ENDIF.

ENDFORM.                    "op_at_date_kredi
* -------------------------------------------------------------------- *
* Check if an KUNNR/LIFNR in sub ledger indexes exsists
* -------------------------------------------------------------------- *
FORM chk_kunnr_lifnr_exsits TABLES eskb1 STRUCTURE skb1
                                   iknb1 STRUCTURE no_knb1
                                   ilfb1 STRUCTURE no_lfb1
                             USING koart LIKE bseg-koart
                                   accnt LIKE bseg-hkont
                                   pit001 LIKE t001.
  IF koart = 'D'.
    READ TABLE iknb1 WITH KEY kunnr = accnt BINARY SEARCH.
    IF sy-subrc <> 0.
      CLEAR eskb1.
      eskb1-bukrs = pit001-bukrs.
      eskb1-saknr = accnt.
      eskb1-mitkz = 'D'.
      eskb1-xkres = 'X'.
      COLLECT eskb1.
    ENDIF.
  ELSEIF koart = 'K'.
    READ TABLE ilfb1 WITH KEY lifnr = accnt BINARY SEARCH.
    IF sy-subrc <> 0.
      CLEAR eskb1.
      eskb1-bukrs = pit001-bukrs.
      eskb1-saknr = accnt.
      eskb1-mitkz = 'K'.
      eskb1-xkres = 'X'.
      COLLECT eskb1.
    ENDIF.
  ENDIF.
ENDFORM.                    "chk_kunnr_lifnr_exsits
* -------------------------------------------------------------------- *
* Check if an rec. accnt found in sub ledger indexes exsists
* -------------------------------------------------------------------- *
FORM check_hkont_exsits TABLES sb1 STRUCTURE tvz
                                      eskb1 STRUCTURE skb1
                                      iskb1  STRUCTURE no_skb1
                                USING d_or_k TYPE c
                                      pit001 LIKE t001.
  SORT sb1 BY accnt gsber pswsl.
  LOOP AT sb1.
    AT NEW accnt.
      CLEAR iskb1.
      READ TABLE iskb1 WITH KEY saknr = sb1-accnt BINARY SEARCH.
    ENDAT.

    IF iskb1 IS INITIAL.
      eskb1-bukrs = pit001-bukrs.
      eskb1-saknr = sb1-accnt.
      eskb1-mitkz = 'S'.
      eskb1-xkres = d_or_k.
      COLLECT eskb1.
      DELETE sb1.
      CONTINUE.
    ENDIF.
  ENDLOOP.
ENDFORM.                    "check_hkont_exsits


* -------------------------------------------------------------------- *
* Compare Open items to subledger accnt balance
*--------------------------------------------------------------------- *

FORM oi_to_balance_nb TABLES sb STRUCTURE no_ty_ops
                             eskb1 STRUCTURE skb1
                             iknb1  STRUCTURE no_knb1
                             ilfb1  STRUCTURE no_lfb1
                       USING koart LIKE bseg-koart
                             pit001 LIKE t001.

  SORT sb BY accnt umskz hkont.
  DATA: saldo LIKE huge_amount,
        dsaldo LIKE huge_amount,
        sb3  TYPE ty_ops OCCURS 10 WITH HEADER LINE, " GLT0 for rec.
        f_accnt_header TYPE c,
        error_count TYPE i,
*        error_count_account TYPE i VALUE -1,
        acnt_type_name(16).

  acnt_type_name = 'Kunde'(042).

  DATA: balance TYPE ty_trans OCCURS 100 WITH HEADER LINE.
  IF koart = 'K'.
    acnt_type_name = 'Lieferant'(043).
  ENDIF.
  PERFORM salden_berechnen_nb TABLES balance USING koart pit001.
***********************************************
*  Check: is there an KNC1/3 or an LFC1/3 entry
*         without KNB1 or LFB1 entry.
***********************************************
  LOOP AT balance.
    CLEAR eskb1.
    IF koart = 'D'.
      READ TABLE iknb1 WITH KEY kunnr = balance-accnt BINARY SEARCH.
    ELSEIF koart = 'K'.
      READ TABLE ilfb1 WITH KEY lifnr = balance-accnt BINARY SEARCH.
    ENDIF.
    IF sy-subrc <> 0.
*    Transaction figures exist but no accnt master
      eskb1-bukrs = pit001-bukrs.
      eskb1-mitkz = koart.
      eskb1-saknr = balance-accnt.
      COLLECT eskb1.
    ELSE.
      READ TABLE sb WITH KEY accnt = balance-accnt umskz = balance-shbkz.
      IF sy-subrc NE 0.
*     for the accnt/umskz no OI was read but a transaction figure
*     entry does exsist -> add this entry to the SB table
        CLEAR sb.
        sb-accnt = balance-accnt.
        sb-umskz = balance-shbkz.
        APPEND sb.
      ENDIF.
    ENDIF.
  ENDLOOP.
  SORT sb BY accnt umskz hkont.

  LOOP AT sb.
*  Ereignis 'New Account' -> check if master exsists
    AT NEW accnt.
      CLEAR: f_accnt_header.
*             error_count_account.
      PERFORM chk_kunnr_lifnr_exsits TABLES eskb1 iknb1 ilfb1
                                      USING koart sb-accnt pit001.
    ENDAT.
*  to know all the different hkonts collect them into sb3 -helper table
    APPEND sb TO sb3.
    AT END OF umskz.
      SUM.
*    Ereignis 'End of UMSKZ' -> At this point after sum, DMBTR must be
*                               equal to the account balance (saldo)

*    this perform return the balance of an account. Depending on
*    koart and umskz KNC1, KNC3, LFC1 or LFC3 Balance will be returned:

      CLEAR saldo.
      READ TABLE balance WITH KEY shbkz = sb-umskz accnt = sb-accnt
                                  BINARY SEARCH.
      IF sy-subrc = 0.
        saldo = balance-hslsv.
      ENDIF.
      dsaldo = saldo - sb-dmbtr.
      IF sb-iiale > 0.
        CLEAR eskb1.
        eskb1-bukrs = pit001-bukrs.
        eskb1-mitkz = koart.
        eskb1-saknr = sb-accnt.
        eskb1-xkres = 'L'.
        COLLECT eskb1.
        DELETE sb WHERE accnt = sb-accnt.

      ENDIF.
*    A difference occured:
      IF dsaldo <> 0 AND sb-iiale = 0.
        ADD 1 TO error_count.
*        error_count_account = 1.
        IF f_accnt_header IS INITIAL.
          f_accnt_header = 'X'.
        ENDIF.
      ENDIF.   " dsaldo <> 0.
      CLEAR sb3.
      REFRESH sb3.
    ENDAT. "event at end of umskz
    AT END OF accnt.
      IF protox = 'X' AND f_accnt_header IS INITIAL.
**--------------------------------------------------------------------**
**  BEGIN OF CHANGES                                          C5053256
**--------------------------------------------------------------------**
**        FORMAT COLOR COL_NORMAL.
**        FORMAT INTENSIFIED OFF.
***       new-line. uline (102).
**
**        WRITE :/ sy-vline NO-GAP,
**                 'Cpcd ' NO-GAP,
**                 pit001-bukrs NO-GAP,
**                 ' ' NO-GAP,
**                 acnt_type_name NO-GAP,
**                 ' ' NO-GAP,
**                 sb-accnt NO-GAP,
**            (71) 'No_Difference' NO-GAP RIGHT-JUSTIFIED,
**                102 sy-vline NO-GAP.
**        FORMAT COLOR OFF.
**        FORMAT INTENSIFIED ON.
        CLEAR : gs_outtab_list25.
        MOVE  : pit001-bukrs     TO gs_outtab_list25-bukrs,
                acnt_type_name   TO gs_outtab_list25-gltype,
                sb-accnt         TO gs_outtab_list25-err_msg,
                'No_Difference'  TO gs_outtab_list25-recon.
        IF acnt_type_name = 'Kunde'(042).
          APPEND  gs_outtab_list25 TO gt_outtab_list25.
        ELSE.
          APPEND  gs_outtab_list25 TO gt_outtab_list26.
        ENDIF.
**--------------------------------------------------------------------**
**  END OF CHANGES                                            C5053256
**--------------------------------------------------------------------**
        DELETE sb WHERE accnt = sb-accnt.
*       write:/ sy-subrc.
      ENDIF.
    ENDAT.
  ENDLOOP.

  CLEAR f_accnt_header.
  error_count = 0.
*  error_count_account = 0.
  CLEAR sb3.
  REFRESH sb3.




  LOOP AT sb.
*  Ereignis 'New Account' -> check if master exsists
    AT NEW accnt.
      CLEAR: f_accnt_header.
*             error_count_account.
      PERFORM chk_kunnr_lifnr_exsits TABLES eskb1 iknb1 ilfb1
                                      USING koart sb-accnt pit001.
    ENDAT.
*  to know all the different hkonts collect them into sb3 -helper table
    APPEND sb TO sb3.
    AT END OF umskz.
      SUM.
*    Ereignis 'End of UMSKZ' -> At this point after sum, DMBTR must be
*                               equal to the account balance (saldo)

*    this perform return the balance of an account. Depending on
*    koart and umskz KNC1, KNC3, LFC1 or LFC3 Balance will be returned:

      CLEAR saldo.
      READ TABLE balance WITH KEY shbkz = sb-umskz accnt = sb-accnt
                                  BINARY SEARCH.
      IF sy-subrc = 0.
        saldo = balance-hslsv.
      ENDIF.
      dsaldo = saldo - sb-dmbtr.
      IF sb-iiale > 0.
        WRITE:/ 'Konto ist ALE-Sender'(103), sb-accnt.
      ENDIF.
*    A difference occured:
      IF dsaldo <> 0 AND sb-iiale = 0.
        ADD 1 TO error_count.
*        error_count_account = 1.
        IF f_accnt_header IS INITIAL.
          f_accnt_header = 'X'.
          PERFORM write_nb_header USING pit001-bukrs koart sb-accnt.
        ENDIF.
        FORMAT COLOR COL_NORMAL.
*     Read all hkonts that caused the balance and list them:
        LOOP AT sb3.
**------------------------------------------------------------------**
** begin of changes                                           c5053256
**------------------------------------------------------------------**
          CLEAR : gs_outtab_list24.
          MOVE  : gs_outtab_list23-bukrs TO gs_outtab_list24-bukrs,
                  gs_outtab_list23-konto TO gs_outtab_list24-konto.
          MOVE  : sb3-umskz           TO gs_outtab_list24-umskz,
                  sb3-hkont           TO gs_outtab_list24-hkont,
                  sb3-dmbtr           TO gs_outtab_list24-dmbtr.
          IF gs_outtab_list23-gltype = 'Kunde'(042).
            APPEND gs_outtab_list24 TO gt_outtab_list24.
          ELSE.
            APPEND gs_outtab_list24 TO gt_outtab_list28.
          ENDIF.
**          WRITE:/ sy-vline NO-GAP,
**              (5) sb3-umskz NO-GAP, sy-vline NO-GAP,
**             (15) sb3-hkont NO-GAP, sy-vline NO-GAP,
**             (21) sb3-dmbtr NO-GAP, sy-vline NO-GAP,
**             (21) ' ' NO-GAP,       sy-vline NO-GAP,
**             (21) ' ' NO-GAP,
**             102  sy-vline NO-GAP.
**------------------------------------------------------------------**
** END of changes                                             c5053256
**------------------------------------------------------------------**
        ENDLOOP.
        FORMAT COLOR COL_TOTAL.
*     Write the difference
**------------------------------------------------------------------**
** begin of changes                                           c5053256
**------------------------------------------------------------------**
        CLEAR : gs_outtab_list24.
        MOVE  : gs_outtab_list23-bukrs TO gs_outtab_list24-bukrs,
                gs_outtab_list23-konto TO gs_outtab_list24-konto.
        MOVE  : sb-umskz           TO gs_outtab_list24-umskz,
                sb-hkont           TO gs_outtab_list24-hkont,
                sb-dmbtr           TO gs_outtab_list24-dmbtr,
                saldo              TO gs_outtab_list24-dmbt2,
                dsaldo             TO gs_outtab_list24-pswbt.
        IF gs_outtab_list23-gltype = 'Kunde'(042).
          APPEND gs_outtab_list24 TO gt_outtab_list24.
        ELSE.
          APPEND gs_outtab_list24 TO gt_outtab_list28.
        ENDIF.
**        WRITE:/ sy-vline NO-GAP,
**            (5) sb-umskz NO-GAP, sy-vline NO-GAP,
**           (15) sb-hkont NO-GAP, sy-vline NO-GAP,
**           (21) sb-dmbtr NO-GAP, sy-vline NO-GAP,
**           (21) saldo NO-GAP,    sy-vline NO-GAP,
**           (21) dsaldo NO-GAP,
**           102  sy-vline NO-GAP.
**        FORMAT COLOR OFF.
**------------------------------------------------------------------**
** END of changes                                             c5053256
**------------------------------------------------------------------**
      ELSE.   " dsaldo <> 0.
        IF sb-iiale = 0.
*         write:/ sy-vline no-gap,
*             (11) sb-accnt no-gap, sy-vline no-gap,
*              (5) sb-umskz no-gap, sy-vline no-gap,
*             (21) sb-dmbtr no-gap, sy-vline no-gap,
*             (21) saldo no-gap,    sy-vline no-gap,
*             (21) dsaldo no-gap,
*             102  sy-vline no-gap.

        ENDIF.
      ENDIF.   " dsaldo <> 0.
      CLEAR sb3.
      REFRESH sb3.
    ENDAT. "event at end of umskz

    AT END OF accnt.
      IF protox = 'X' AND f_accnt_header IS INITIAL.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                            C5053256
**--------------------------------------------------------------------**
***       perform write_nb_header using pit001-bukrs koart sb-accnt.
**        FORMAT COLOR COL_NORMAL.
**        FORMAT INTENSIFIED OFF.
***       format color col_key.
**        NEW-LINE. ULINE (102).
**
**        WRITE :/ sy-vline NO-GAP,
**                 'Cpcd ' NO-GAP,
**                 pit001-bukrs NO-GAP,
**                 ' ' NO-GAP,
**                 acnt_type_name NO-GAP,
**                 ' ' NO-GAP,
**                 sb-accnt NO-GAP,
**            (71) 'No_Difference' NO-GAP RIGHT-JUSTIFIED,
**                102 sy-vline NO-GAP.
**        FORMAT COLOR OFF.
**        FORMAT INTENSIFIED ON.
        CLEAR : gs_outtab_list25.
        MOVE  : pit001-bukrs     TO gs_outtab_list25-bukrs,
                acnt_type_name   TO gs_outtab_list25-gltype,
                sb-accnt         TO gs_outtab_list25-err_msg,
                'No_Difference'  TO gs_outtab_list25-recon.
        IF acnt_type_name = 'Kunde'(042).
          APPEND  gs_outtab_list25 TO gt_outtab_list25.
        ELSE.
          APPEND  gs_outtab_list25 TO gt_outtab_list26.
        ENDIF.
**--------------------------------------------------------------------**
** END OF CHANGES                                              C5053256
**--------------------------------------------------------------------**
      ENDIF.
    ENDAT.
  ENDLOOP.



  IF error_count > 0.
**    NEW-LINE. ULINE (102).
  ENDIF.

  FORMAT COLOR OFF.
ENDFORM.                    "oi_to_balance_nb
* -------------------------------------------------------------------- *
*                 Calculate Subledger balances
* -------------------------------------------------------------------- *
FORM salden_berechnen_nb TABLES balance STRUCTURE tvz
                          USING koart LIKE bseg-koart
                                pit001 LIKE t001.
  DATA: saldo LIKE huge_amount.
  IF koart = 'D'.
    IF p_monat IS INITIAL.
      SELECT kunnr shbkz saldv INTO
          (balance-accnt, balance-shbkz, balance-hslsv)
          FROM knc3 WHERE bukrs = pit001-bukrs
                      AND kunnr IN p_kunnr
                      AND gjahr = p_gjahr-low.
        APPEND balance.
      ENDSELECT.
    ENDIF.
    SELECT * FROM knc1 WHERE bukrs = pit001-bukrs
                         AND gjahr = p_gjahr-low
                         AND kunnr IN p_kunnr.

      CLEAR balance.
      PERFORM saldo_berechnen_sub USING knc1 CHANGING saldo.
      balance-accnt = knc1-kunnr.
      balance-hslsv = saldo.
      APPEND balance.
    ENDSELECT.
  ELSEIF koart = 'K'.
    IF p_monat IS INITIAL.
      SELECT lifnr shbkz saldv INTO
            (balance-accnt, balance-shbkz, balance-hslsv)
            FROM lfc3 WHERE bukrs = pit001-bukrs
                        AND lifnr IN p_lifnr
                        AND gjahr = p_gjahr-low.
        APPEND balance.
      ENDSELECT.
    ENDIF.
    SELECT * FROM lfc1 WHERE bukrs = pit001-bukrs
                         AND gjahr = p_gjahr-low
                         AND lifnr IN p_lifnr.
      CLEAR balance.
      MOVE-CORRESPONDING lfc1 TO knc1.                      "#EC ENHOK
      knc1-kunnr = lfc1-lifnr.
      PERFORM saldo_berechnen_sub USING knc1 CHANGING saldo.
      balance-accnt = lfc1-lifnr.
      balance-hslsv = saldo.
      APPEND balance.

    ENDSELECT.

  ENDIF.
  SORT balance BY shbkz accnt.

ENDFORM.                    "salden_berechnen_nb
* -------------------------------------------------------------------- *
* Write NB-header
* -------------------------------------------------------------------- *
FORM write_nb_header USING bkrs LIKE bseg-bukrs
                           koart LIKE bseg-koart
                           accnt LIKE bseg-hkont.
  DATA vend_cust(10) TYPE c.
  IF koart = 'K'.
    vend_cust = 'Lieferant'(043).
  ELSE.
    vend_cust = 'Kunde'(042).
  ENDIF.

**----------------------------------------------------------**
** BEGIN OF CHANGES                                   C5053256
**----------------------------------------------------------**
  CLEAR : gs_outtab_list23.
  MOVE  : bkrs              TO  gs_outtab_list23-bukrs,
          vend_cust         TO  gs_outtab_list23-gltype,
          accnt             TO  gs_outtab_list23-konto.
  IF vend_cust = 'Kunde'(042).
    APPEND gs_outtab_list23 TO gt_outtab_list23.
  ELSE.
    APPEND gs_outtab_list23 TO gt_outtab_list27.
  ENDIF.
**  FORMAT COLOR COL_KEY.
**  NEW-LINE. ULINE (102).
**  WRITE :/ sy-vline NO-GAP,
**         (5) 'Cpcd' NO-GAP,
**         (5) bkrs NO-GAP,
**        (10) vend_cust NO-GAP,
**        (80) accnt NO-GAP,
**          sy-vline NO-GAP.
**  FORMAT COLOR COL_HEADING.
**  WRITE :/ sy-vline NO-GAP,
**         (6) 'UMSKZ' NO-GAP,
**        (16) 'HKONT' NO-GAP,
**        (22) 'Calc. Balance' NO-GAP,
**        (22) 'Txn. Balance' NO-GAP,
**        (22) 'Difference' NO-GAP,
**         102  sy-vline NO-GAP.
**  FORMAT COLOR OFF.
**----------------------------------------------------------**
** END OF CHANGES                                     C5053256
**----------------------------------------------------------**
ENDFORM.                    "write_nb_header
* -------------------------------------------------------------------- *
* Compare Open items to G/L accnt balance
*--------------------------------------------------------------------- *
FORM oi_to_balance TABLES sb1 STRUCTURE tvz
                          iskb1  STRUCTURE no_skb1
                          curtab STRUCTURE no_curtab
                    USING pit001 LIKE t001
                          compare_name TYPE any
                          compare_from TYPE any
                 CHANGING level TYPE i.

  DATA: account_written,                                    "#EC NEEDED
        error_count TYPE i,
        x_read_from_itab TYPE c,
        sb_gsber TYPE ty_trans OCCURS 100 WITH HEADER LINE,
        sb_pswsl TYPE ty_trans OCCURS 100 WITH HEADER LINE,
        sb_gsber_pswsl TYPE ty_trans OCCURS 100 WITH HEADER LINE.

  x_read_from_itab = 'X'.
  SORT sb1 BY accnt rldnr gsber pswsl.

  IF level = 1.
    PERFORM remove_clean_entries TABLES sb1 iskb1
                                  USING pit001 x_read_from_itab
                                        compare_from.
  ENDIF.

  LOOP AT sb1.
    AT NEW accnt.
      IF NOT sb_gsber IS INITIAL.
        PERFORM write_condensed_account TABLES
                                       sb_gsber sb_pswsl sb_gsber_pswsl
                                       curtab.
      ENDIF.


      CLEAR: sb_gsber, sb_pswsl, sb_gsber_pswsl.
      REFRESH: sb_gsber, sb_pswsl, sb_gsber_pswsl.
      PERFORM ueberschrift_sako_op USING pit001
                                         level
                                         sb1
                                         compare_name
                                         compare_from.
    ENDAT.
    ADD 1 TO error_count.
**---------------------------------------------------------------**
** BEGIN OF CHANGES                                       C5053256
**---------------------------------------------------------------**
**    FORMAT COLOR COL_NORMAL.
**    FORMAT INTENSIFIED OFF.
**---------------------------------------------------------------**
** END OF CHANGES                                         C5053256
**---------------------------------------------------------------**
    PERFORM write_oi_line TABLES curtab
                          USING sb1 'TSL' level.
    PERFORM write_oi_line TABLES curtab
                          USING sb1 'HSL' level.
    PERFORM write_oi_line TABLES curtab
                          USING sb1 'KSL' level.
**    FORMAT INTENSIFIED ON.
    sb_gsber = sb1.
    sb_pswsl = sb1.
    sb_gsber_pswsl = sb1.
    CLEAR: sb_gsber-gsber,
           sb_pswsl-pswsl,
           sb_gsber_pswsl-gsber,
           sb_gsber_pswsl-pswsl.
    COLLECT: sb_gsber, sb_pswsl, sb_gsber_pswsl.
  ENDLOOP.
  IF NOT sb_gsber IS INITIAL.
    PERFORM write_condensed_account TABLES
                        sb_gsber sb_pswsl sb_gsber_pswsl curtab.
  ENDIF.
**---------------------------------------------------------------**
** BEGIN OF CHANGES                                       C5053256
**---------------------------------------------------------------**
**  IF error_count > 0.
**    NEW-LINE. ULINE (102).
**  ENDIF.
**
**
**  FORMAT COLOR OFF.
**---------------------------------------------------------------**
** END OF CHANGES                                         C5053256
**---------------------------------------------------------------**
ENDFORM.                    "oi_to_balance
* -------------------------------------------------------------------- *
* Write the clears on pswsl or gsber or pswsl and gsber
* -------------------------------------------------------------------- *
FORM write_condensed_account TABLES sb_gsber STRUCTURE tvz
                                    sb_pswsl STRUCTURE tvz
                                    sb_gsber_pswsl STRUCTURE tvz
                                    curtab STRUCTURE no_curtab.

*  FORMAT COLOR COL_HEADING.

*write :/ sy-vline no-gap,
*         'Comparison without Business area' no-gap,
*         102  sy-vline no-gap.
*write :/ sy-vline no-gap,
*           (6)  'RLDNR' no-gap,
*           (6)  '*****' no-gap,
*           (6)  'PSWSL' no-gap,
*           (4)  'KEY' no-gap,
*           (22) 'Calc. Balance' no-gap,
*           (22) 'Txn. Balance' no-gap,
*           (22) 'Difference' no-gap,
*           102  sy-vline no-gap.
**-----------------------------------------------------------**
** BEGIN OF CHANGES                                  C5053256
**-----------------------------------------------------------**
**  NEW-LINE. ULINE (102).
**  FORMAT COLOR COL_TOTAL.
**  FORMAT INTENSIFIED OFF.
**-----------------------------------------------------------**
** END OF CHANGES                                    C5053256
**-----------------------------------------------------------**
  LOOP AT sb_gsber.
    PERFORM write_oi_line TABLES curtab USING sb_gsber 'TSL' 2.
    PERFORM write_oi_line TABLES curtab USING sb_gsber 'HSL' 2.
    PERFORM write_oi_line TABLES curtab USING sb_gsber 'KSL' 2.
*      new-line. uline (102).
  ENDLOOP.
**-----------------------------------------------------------**
** BEGIN OF CHANGES                                  C5053256
**-----------------------------------------------------------**
**  FORMAT INTENSIFIED ON.
**  FORMAT COLOR COL_HEADING.
**
**  NEW-LINE. ULINE (102).
**  FORMAT COLOR COL_TOTAL.
**  FORMAT INTENSIFIED OFF.
**-----------------------------------------------------------**
** END OF CHANGES                                    C5053256
**-----------------------------------------------------------**
  LOOP AT sb_pswsl.
    PERFORM write_oi_line TABLES curtab USING sb_pswsl 'HSL' 4.
    PERFORM write_oi_line TABLES curtab USING sb_pswsl 'KSL' 4.
*      new-line. uline (102).
  ENDLOOP.
**-----------------------------------------------------------**
** BEGIN OF CHANGES                                  C5053256
**-----------------------------------------------------------**
**  FORMAT INTENSIFIED ON.
**  FORMAT COLOR COL_HEADING.
**  NEW-LINE. ULINE (102).
**  FORMAT COLOR COL_TOTAL.
**-----------------------------------------------------------**
** END OF CHANGES                                    C5053256
**-----------------------------------------------------------**
  LOOP AT sb_gsber_pswsl.
    PERFORM write_oi_line TABLES curtab USING sb_gsber_pswsl 'HSL' 3.
    PERFORM write_oi_line TABLES curtab USING sb_gsber_pswsl 'KSL' 3.
*      new-line. uline (102).
  ENDLOOP.
**  FORMAT COLOR OFF.
ENDFORM.                    "write_condensed_account
* -------------------------------------------------------------------  *
* Remove not need and uncheckable entries from sb1
* -------------------------------------------------------------------  *
FORM remove_clean_entries TABLES sb1   STRUCTURE tvz
                                 iskb1 STRUCTURE no_skb1
                           USING pit001 LIKE t001
                                 x_read_from_itab TYPE c
                                 compare_from TYPE any.

  RANGES: exclude_acc FOR bseg-hkont.
* **************************************************************
* Fill exclude_acc with accounts that cannot be checked
* -> GuV carryforward accounts
* **************************************************************
  SELECT * FROM t030 WHERE ktopl = pit001-ktopl AND ktosl = 'BIL'. "#EC CI_GENBUFF
    exclude_acc-sign = 'I'.
    exclude_acc-option = 'EQ'.
    IF NOT t030-konts IS INITIAL.
      exclude_acc-low = t030-konts.
      COLLECT exclude_acc.
    ENDIF.
    IF NOT t030-konth IS INITIAL.
      exclude_acc-low = t030-konth.
      COLLECT exclude_acc.
    ENDIF.
  ENDSELECT.
* *************************************************************

  DATA: error_account LIKE bseg-hkont VALUE c_init_accnt_no,
        ok_account LIKE bseg-hkont VALUE c_init_accnt_no.
  DATA: sb2 LIKE tvz OCCURS 10 WITH HEADER LINE.
  DATA: sb3 LIKE tvz OCCURS 10 WITH HEADER LINE.            "#EC NEEDED
  DATA: is_bilk LIKE ska1-xbilk.
  FORMAT COLOR COL_NORMAL.
* ******** start of main loop ********************************
  LOOP AT sb1.
*    ****** A new account is read ********
    AT NEW accnt.
      IF error_account NE c_init_accnt_no.
*          *********************************************************** *
*          all entries for the previous accnt are currently in sb2
*          and an error occured on this previous accnt copy all entries
*          in sb2 to sb3.
        APPEND LINES OF sb2 TO sb3.
*          *********************************************************** *
      ELSEIF ok_account NE c_init_accnt_no.
        IF protox = 'X'.
**--------------------------------------------------------------------**
** BEGIN OF CHANGES                                            C5053256
**--------------------------------------------------------------------**
**          WRITE:/ sy-vline NO-GAP,
**             (5)  pit001-bukrs NO-GAP,
**             (11)     ok_account NO-GAP,
**             (70)    compare_from NO-GAP,
**             (14)    'No_Difference' RIGHT-JUSTIFIED NO-GAP,
**              102 sy-vline NO-GAP.
          CLEAR : gt_outtab_list12, gs_outtab_list12.
          MOVE  : pit001-bukrs     TO gs_outtab_list12-bukrs,
                  ok_account       TO gs_outtab_list12-konto,
                  compare_from     TO gs_outtab_list12-err_msg,
                  'No_Difference'  TO gs_outtab_list12-recon.
          APPEND gs_outtab_list12  TO gt_outtab_list12.
**--------------------------------------------------------------------**
** END OF CHANGES                                              C5053256
**--------------------------------------------------------------------**
        ENDIF.
      ENDIF.
      error_account = c_init_accnt_no.
      ok_account = c_init_accnt_no.
      CLEAR sb2. REFRESH sb2.
*      *************************************************************** *
*      is the current account a normal G/L account regarding 'XBILK' ? *
      CLEAR is_bilk.
      IF x_read_from_itab = 'X'.
        READ TABLE iskb1 WITH KEY saknr = sb1-accnt BINARY SEARCH.
        IF sy-subrc = 0.
          is_bilk = iskb1-xbilk.
        ENDIF.
      ELSE.
        SELECT SINGLE xbilk FROM ska1 INTO is_bilk
                                  WHERE ktopl = pit001-ktopl
                                    AND saknr = sb1-accnt. "#EC CI_GENBUFF
      ENDIF.
*      *************************************************************** *
    ENDAT.
*    ****** end of event 'new account' *******
    sb2 = sb1. APPEND sb2.
    ok_account = sb1-accnt.
    IF sb1-tslsd <> 0 OR sb1-hslsd <> 0 OR sb1-kslsd <> 0.
      IF NOT sb1-accnt IN exclude_acc. " no P/L carry forw. accnt
        IF sb1-iiale = 0 AND is_bilk = 'X'.
*             ******************************************************** *
*             under the following conditions the accnt will be checked:
*             1. no ALE accnt.
*             2. no P/L accnt
*             3. at least line item display
*             4. no P/L carry forward accnt
          error_account = sb1-accnt.
*             ******************************************************** *
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.
* ********************************************************
* *            the main loop ends here                   *
* ********************************************************

* **************************************************************
* if the last accnt has an error the 'at new accnt' is not triggered
* therefore it must be processed after the loop.
  IF error_account NE c_init_accnt_no.
    APPEND LINES OF sb2 TO sb3.
  ENDIF.
* **************************************************************

* ********************************************
* finally copy  a l l  the entries back to sb1
* ********************************************
  sb1[] = sb3[].
* ********************************************
  FORMAT COLOR OFF.
ENDFORM.                    "remove_clean_entries
* -------------------------------------------------------------------  *
* Write account header sum of open items to account balance
* -------------------------------------------------------------------  *
FORM ueberschrift_sako_op USING pit001 LIKE t001
                                level TYPE i
                                psb1 TYPE ty_trans
                                compare_name TYPE any
                                compare_from TYPE any.      "#EC NEEDED
**-------------------------------------------------------------------**
**  BEGIN OF CHANGES                                          C5053256
**-------------------------------------------------------------------**
  CLEAR  : gs_outtab_list21, gt_outtab_list21.
**  FORMAT COLOR COL_POSITIVE. "col_key.
**  NEW-LINE. ULINE (102).
**  WRITE :/ sy-vline NO-GAP,
**         (5)  'Cpcd' NO-GAP,
**         (5)  pit001-bukrs NO-GAP,
**         (10) compare_name NO-GAP,
**         (10) psb1-accnt NO-GAP,
**         (70) compare_from NO-GAP RIGHT-JUSTIFIED,
**           sy-vline NO-GAP.
**  FORMAT COLOR COL_HEADING.
**  IF level = 1.
**    WRITE :/ sy-vline NO-GAP,
**            'Comparison on HKONT, GSBER and PSWSL' NO-GAP,
**            102  sy-vline NO-GAP.
  move 'Vergleich auf Ebene HKONT, GSBER und PSWSL'(104)
        TO gs_outtab_list21-ddtext.
**  ENDIF.
**  WRITE :/ sy-vline NO-GAP,
**         (6)  'RLDNR' NO-GAP,
**         (6)  'GSBER' NO-GAP,
**         (6)  'PSWSL' NO-GAP,
**         (4)  'KEY' NO-GAP,
**         (22) 'Calc. Balance' NO-GAP,
**         (22) 'Txn. Balance' NO-GAP,
**         (22) 'Difference' NO-GAP,
**         102  sy-vline NO-GAP.
**
**  FORMAT COLOR OFF.
  MOVE   : pit001-bukrs      TO gs_outtab_list21-bukrs,
           compare_name      TO gs_outtab_list21-gltype,
           psb1-accnt        TO gs_outtab_list21-hkont,
           compare_from      TO gs_outtab_list21-err_msg.
  APPEND   gs_outtab_list21  TO gt_outtab_list21.
**-------------------------------------------------------------------**
**  END OF CHANGES                                            C5053256
**-------------------------------------------------------------------**
ENDFORM.                    "ueberschrift_sako_op
* ------------------------------------------------------------------- *
* Write statement OI to G/L Balance
* ------------------------------------------------------------------- *
FORM write_oi_line TABLES curtab STRUCTURE no_curtab
                   USING sb1 LIKE tvz curkey TYPE any level TYPE i.
  IF level = 3 AND curkey = 'TSL'.  EXIT. ENDIF.
  READ TABLE curtab WITH KEY rldnr = sb1-rldnr.
  IF curkey = 'HSL'.
    CHECK curtab-usehsl = 1.
  ENDIF.
  IF curkey = 'KSL'.
    CHECK curtab-useksl = 1.
  ENDIF.
  IF curkey = 'TSL'.
    CHECK curtab-useksl = 1 OR curtab-usehsl = 1.
  ENDIF.

  DATA: gsber LIKE bseg-gsber,
        pswsl LIKE bseg-pswsl.
  gsber = sb1-gsber.
  pswsl = sb1-pswsl.
  IF level = 2.
    gsber = '****'.
  ENDIF.
  IF level = 3.
    gsber = '****'.
    pswsl = '*****'.
  ENDIF.
  IF level = 4.
    pswsl = '*****'.
  ENDIF.
*  if level = 1.
  FORMAT COLOR COL_KEY.
*  endif.
**---------------------------------------------------------**
** BEGIN OF CHANGES                                C5053256
**---------------------------------------------------------**
**  WRITE:/ sy-vline NO-GAP.
**  IF ( level < 3 AND curkey = 'TSL' ) OR
**     ( level > 2 AND curkey = 'HSL' ) OR
**     ( level > 2 AND curkey = 'KSL' AND curtab-useksl = 1
**                                    AND curtab-usehsl NE 1 ) .
**    WRITE:(5) sb1-rldnr NO-GAP,
**               ' ' NO-GAP,
**              (5) gsber NO-GAP,
**               ' ' NO-GAP,
**                  pswsl NO-GAP.
  CLEAR : gs_outtab_list22.
  MOVE  : gs_outtab_list21-bukrs  TO gs_outtab_list22-bukrs.
  MOVE  : sb1-rldnr  TO gs_outtab_list22-rldnr,
          gsber      TO gs_outtab_list22-gsber,
          pswsl      TO gs_outtab_list22-pswsl,
          sb1-accnt  TO gs_outtab_list22-hkont,
          curkey     TO gs_outtab_list22-fld.
**  ELSE.
**    WRITE: (18) ' ' COLOR OFF.
**  ENDIF.
**  WRITE:
**         20 curkey NO-GAP,
**         sy-vline NO-GAP.
**  IF level = 1.
**    FORMAT COLOR COL_NORMAL.
**  ELSE.
**    FORMAT COLOR COL_TOTAL.
**  ENDIF.
*  DATA: curr1 LIKE bkpf-waers,
*        curr2 LIKE bkpf-waers.
*  curr1 = curtab-curr1. "bukrs_waers-hw1.
*  curr2 = curtab-curr2. "bukrs_waers-hw2.
  MOVE : 0 TO gs_outtab_list22-tblamt,
         0 TO gs_outtab_list22-docamt,
         0 TO gs_outtab_list22-difamt.
  IF curkey = 'TSL'.
**    WRITE: (21) sb1-tslsb CURRENCY sb1-pswsl NO-GAP,
**           sy-vline NO-GAP,
**           (21) sb1-tslsv CURRENCY sb1-pswsl  NO-GAP,
**           sy-vline NO-GAP,
**           (21) sb1-tslsd CURRENCY sb1-pswsl  NO-GAP.
    MOVE : sb1-tslsb    TO gs_outtab_list22-docamt,
           sb1-tslsv    TO gs_outtab_list22-tblamt,
           sb1-tslsd    TO gs_outtab_list22-difamt.
  ENDIF.
  IF curkey = 'HSL'.
**    WRITE: (21) sb1-hslsb CURRENCY curr1 NO-GAP,
**           sy-vline NO-GAP,
**           (21) sb1-hslsv CURRENCY curr1 NO-GAP,
**           sy-vline NO-GAP,
**           (21) sb1-hslsd CURRENCY curr1 NO-GAP.
    MOVE : sb1-hslsb    TO gs_outtab_list22-docamt,
           sb1-hslsv    TO gs_outtab_list22-tblamt,
           sb1-hslsd    TO gs_outtab_list22-difamt.
  ENDIF.
  IF curkey = 'KSL'.
**    WRITE: (21) sb1-kslsb CURRENCY curr2 NO-GAP,
**           sy-vline NO-GAP,
**           (21) sb1-kslsv CURRENCY curr2 NO-GAP,
**           sy-vline NO-GAP,
**           (21) sb1-kslsd CURRENCY curr2 NO-GAP.
    MOVE : sb1-kslsb    TO gs_outtab_list22-docamt,
           sb1-kslsv    TO gs_outtab_list22-tblamt,
           sb1-kslsd    TO gs_outtab_list22-difamt.
  ENDIF.
  APPEND gs_outtab_list22  TO gt_outtab_list22.
**  WRITE 102  sy-vline NO-GAP.
**---------------------------------------------------------**
** END OF CHANGES                                   C5053256
**---------------------------------------------------------**
ENDFORM.                    "write_oi_line

* -------------------------------------------------------------------- *
* Calculate Sum of OI for G/L account
* -------------------------------------------------------------------- *
DEFINE add_monat.
  if &1 < p_monat-low.
    vz-tslsv = glt0-tsl&1.
    vz-tslsd = glt0-tsl&1.
    if curtab-usehsl = 1.
      vz-hslsv = glt0-hsl&1.
      vz-hslsd = glt0-hsl&1.
    endif.
    if curtab-useksl = 1.
      vz-kslsv = glt0-ksl&1.
      vz-kslsd = glt0-ksl&1.
    endif.
    collect vz.
  endif.
END-OF-DEFINITION.

* -------------------------------------------------------------------- *
*       Open items at dat for G/L accounts.
* -------------------------------------------------------------------- *
FORM salden_berechnen_hb TABLES vz STRUCTURE tvz
                                eskb1 STRUCTURE skb1
                                curtab STRUCTURE no_curtab
                                iskb1 STRUCTURE no_skb1
                          USING pit001 LIKE t001
                                mitkz LIKE skb1-mitkz.
  IF NOT mitkz IS INITIAL.
    IF mitkz = 'D'.
      CHECK p_kunnr[] IS INITIAL.
    ELSEIF mitkz = 'K'.
      CHECK p_lifnr[] IS INITIAL.
    ENDIF.
  ENDIF.
  DATA: racct LIKE glt0-racct.
  LOOP AT curtab.
    IF curtab-usehsl IS INITIAL AND curtab-useksl IS INITIAL.
      CONTINUE.
    ENDIF.

    DATA lt_fagl_t_glt0 TYPE fagl_t_glt0.
    IF gd_fagl_functions_present = 'X'.
      CALL FUNCTION 'FAGL_GET_GLT0'
        EXPORTING
          i_glt0_rldnr = curtab-rldnr
          i_rrcty      = '0'
          i_rvers      = '001'
          i_bukrs      = pit001-bukrs
          i_ryear      = p_gjahr-low
          i_rpmax      = '016'
        IMPORTING
          et_glt0      = lt_fagl_t_glt0.
      SORT lt_fagl_t_glt0 BY racct.
    ELSE.
      SELECT * FROM glt0 INTO TABLE lt_fagl_t_glt0
                         WHERE rrcty = '0'
                           AND rvers = '001'
                           AND bukrs = pit001-bukrs
                           AND rldnr = curtab-rldnr
                           AND ryear = p_gjahr-low
                           AND rpmax = '016' ORDER BY racct.
    ENDIF.

    FIELD-SYMBOLS: <ls_fagl_t_glt0> TYPE glt0.
    LOOP AT lt_fagl_t_glt0 ASSIGNING <ls_fagl_t_glt0>.
      glt0 = <ls_fagl_t_glt0>.
      IF mitkz IS INITIAL.
*           used for BSIS/BSAS OI comparison to G/L balance
*           read only selected G/L account
        CHECK glt0-racct IN p_hkont.
      ENDIF.
      IF racct <> glt0-racct.
*          new racct -> check master
*           clear skb1.
        CLEAR iskb1.
        racct = glt0-racct.
        READ TABLE iskb1 WITH KEY saknr = glt0-racct BINARY SEARCH.
        IF sy-subrc <> 0.
*              no master found collect into eskb1
          CLEAR eskb1.
          eskb1-bukrs = pit001-bukrs.
          eskb1-mitkz = 'S'.
          eskb1-saknr = glt0-racct.
          COLLECT eskb1.
        ENDIF.
      ENDIF.
*        no skb1 entry fount -> skip.
      CHECK NOT iskb1 IS INITIAL.
      IF NOT mitkz IS INITIAL.
*           used for BSIDK/BSADK OI comparison to rec. balance
*           Read the rec. accnts balance for a specific. mitkz
*           read all rec. accnt of  a specific. mitkz
        CHECK iskb1-mitkz = mitkz.
      ELSE.
*           used for BSIS/BSAS OI comparison to G/L balance
*           read G/L account with line item display only.
        CHECK iskb1-xkres = 'X'.
      ENDIF.
      CLEAR vz.
      vz-accnt = glt0-racct.
      vz-gsber = glt0-rbusa.
      vz-pswsl = glt0-rtcur.
      vz-rldnr = glt0-rldnr.

      vz-tslsv = glt0-tslvt.
      vz-tslsd = glt0-tslvt.
      IF curtab-usehsl = 1.
        vz-hslsv = glt0-hslvt.
        vz-hslsd = glt0-hslvt.
      ENDIF.
      IF curtab-useksl = 1.
        vz-kslsv = glt0-kslvt.
        vz-kslsd = glt0-kslvt.
      ENDIF.
      COLLECT vz.
      add_monat 01.
      add_monat 02.
      add_monat 03.
      add_monat 04.
      add_monat 05.
      add_monat 06.
      add_monat 07.
      add_monat 08.
      add_monat 09.
      add_monat 10.
      add_monat 11.
      add_monat 12.
      add_monat 13.
      add_monat 14.
      add_monat 15.
      add_monat 16.

    ENDLOOP.                                                " loop GLT0

  ENDLOOP.
ENDFORM.                    "salden_berechnen_hb

* ------------------------------------------------------------------- *
* Calc. sum of OI for a customer
* ------------------------------------------------------------------- *
DEFINE get_saldo_.
  if &1 < p_monat-low.
    saldo = saldo + pknc1-um&1s.
    saldo = saldo - pknc1-um&1h.
  endif.
END-OF-DEFINITION.

*&--------------------------------------------------------------------*
*&      Form  saldo_berechnen_sub
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->PKNC1      text
*      -->SALDO      text
*---------------------------------------------------------------------*
FORM saldo_berechnen_sub USING pknc1 LIKE knc1
                         CHANGING saldo LIKE huge_amount.
  saldo = pknc1-umsav.
  IF p_monat IS INITIAL.
    EXIT.
  ELSE.
    get_saldo_ 01.
    get_saldo_ 02.
    get_saldo_ 03.
    get_saldo_ 04.
    get_saldo_ 05.
    get_saldo_ 06.
    get_saldo_ 07.
    get_saldo_ 08.
    get_saldo_ 09.
    get_saldo_ 10.
    get_saldo_ 11.
    get_saldo_ 12.
    get_saldo_ 13.
    get_saldo_ 14.
    get_saldo_ 15.
    get_saldo_ 16.
  ENDIF.
ENDFORM.                    "saldo_berechnen_sub



DEFINE set_amounts_oi.
* &1 = 1, 2 or 3.
  case curtab-map&1.
    when '2'.
      bel-hslsb = dmbe&1.
      bel-hslsd = - dmbe&1.
    when '3'.
      bel-kslsb = dmbe&1.
      bel-kslsd = - dmbe&1.
  endcase.
END-OF-DEFINITION.


*&--------------------------------------------------------------------*
*&      Form  sako_oi
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->BEL        text
*      -->CURTAB     text
*      -->IBSIS      text
*---------------------------------------------------------------------*
FORM sako_oi TABLES bel STRUCTURE tvz
                    curtab STRUCTURE no_curtab
             USING  ibsis TYPE ty_bsxx.

  CLEAR bel.
  bel-accnt = ibsis-accnt.
  bel-gsber = ibsis-gsber.
  bel-pswsl = ibsis-pswsl.

  DATA: pswbt LIKE huge_amount.
  DATA: dmbe1 LIKE huge_amount.
  DATA: dmbe2 LIKE huge_amount.
  DATA: dmbe3 LIKE huge_amount.
  IF ibsis-shkzg = 'S'.
    pswbt = ibsis-pswbt.
    dmbe1 = ibsis-dmbtr.
    dmbe2 = ibsis-dmbe2.
    dmbe3 = ibsis-dmbe3.
  ELSE.
    pswbt = - ibsis-pswbt.
    dmbe1 = - ibsis-dmbtr.
    dmbe2 = - ibsis-dmbe2.
    dmbe3 = - ibsis-dmbe3.
  ENDIF.
  LOOP AT curtab.
    CLEAR: bel-tslsb, bel-hslsb, bel-kslsb, bel-tslhb, bel-hslhb, bel-kslhb.
    CLEAR: bel-tslsd, bel-hslsd, bel-kslsd, bel-tslhd, bel-hslhd, bel-kslhd.
    CHECK curtab-map1 > 0 OR curtab-map2 > 0 OR curtab-map3 > 0.
    bel-rldnr = curtab-rldnr.
    bel-tslsb = pswbt.
    bel-tslsd = - pswbt.
    bel-iiale = ibsis-iiale.
    set_amounts_oi 1.
    set_amounts_oi 2.
    set_amounts_oi 3.
    COLLECT bel.
  ENDLOOP.
ENDFORM.                    "sako_oi



* -------------------------------------------------------------------- *
*                           Authority check
* -------------------------------------------------------------------- *


FORM bukrs_authority USING pt001 LIKE t001
                  CHANGING return TYPE i.                   "#EC CALLED
* Returncodes: 0 = keine Anzeigeberechgtigung.
*              2 = #nderungsberechtigung
*              3 = nur Anzeigeberechgtigung

  AUTHORITY-CHECK OBJECT 'F_BKPF_BUK'
                  ID 'BUKRS' FIELD pt001-bukrs
                  ID 'ACTVT' FIELD '02'.
  IF sy-subrc = 0.
    return = 2.
    EXIT.
  ENDIF.
  AUTHORITY-CHECK OBJECT 'F_BKPF_BUK'
                  ID 'BUKRS' FIELD pt001-bukrs
                  ID 'ACTVT' FIELD '03'.
  IF sy-subrc = 0.
    return = 3.
    EXIT.
  ENDIF.
  return = false.

ENDFORM.                               "BUKRS_INIT_AUTHORITY.

*&---------------------------------------------------------------------*
*&      Form  MAKE_YOUR_CHOICE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM make_your_choice.
*cb
* initialization:
  REFRESH choice_tab.
*
  DEFINE check_choice.
    if &1 eq 'X'.
      choice_tab-choice = '&1'.
      append choice_tab.
    endif.
  END-OF-DEFINITION.

  check_choice x_bseg.
  check_choice x_index.
  check_choice x_heade.
  check_choice x_clear.
  check_choice x_f070.
  check_choice x_f190.
  check_choice x_opdate.
  check_choice x_rfblg.
  check_choice x_duplic.
  check_choice x_bila.

* check_choice X_NEW_OPTION.     " replace this line when creating
  "a new option.
ENDFORM.                         " of MAKE_YOUR_CHOICE
*cb

*&---------------------------------------------------------------------*
*&      Form  DUPLICATE_INDEXES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
* cb

FORM duplicate_indexes.
  PERFORM initialize_progress.
  IF x_sako EQ 'X'.
    PERFORM duplicate_indexes_s.
  ENDIF.
  IF x_debi EQ 'X'.
    PERFORM duplicate_indexes_d.
  ENDIF.

  IF x_kredi EQ 'X'.
    PERFORM duplicate_indexes_k.
  ENDIF.
ENDFORM.                    " DUPLICATE_INDEXES

*&--------------------------------------------------------------------*
*&      Form  duplicate_indexes_s
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM duplicate_indexes_s.
  find_duplicate_index s hkont.
  PERFORM duplicate_indexes_s_2i.
  PERFORM duplicate_indexes_s_2a.
ENDFORM.                    "duplicate_indexes_s

*&--------------------------------------------------------------------*
*&      Form  duplicate_indexes_d
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM duplicate_indexes_d.
  find_duplicate_index d kunnr.
  PERFORM duplicate_indexes_d_2i.
  PERFORM duplicate_indexes_d_2a.

ENDFORM.                    "duplicate_indexes_d

*&--------------------------------------------------------------------*
*&      Form  duplicate_indexes_k
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM duplicate_indexes_k.
  find_duplicate_index k lifnr.
  PERFORM duplicate_indexes_k_2i.
  PERFORM duplicate_indexes_k_2a.

ENDFORM.                    "duplicate_indexes_k

*&--------------------------------------------------------------------*
*&      Form  write_dbl_index_header
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*      -->P_MSG      text
*---------------------------------------------------------------------*
FORM write_dbl_index_header USING p_msg LIKE string100.     "#EC CALLED
  DATA: msg(78) TYPE c.
  msg = 'Doppelte Indices'(434).
  CONCATENATE msg p_msg INTO msg SEPARATED BY space.
  CONDENSE msg.
**  NEW-LINE. ULINE (80).
  FORMAT COLOR COL_POSITIVE.
  WRITE:/   sy-vline NO-GAP,
       (78) msg NO-GAP,
        80  sy-vline NO-GAP.
  FORMAT COLOR OFF.
ENDFORM.                    "write_dbl_index_header

*&---------------------------------------------------------------------*
*&      Form  DUPLICATE_INDEXES_S_2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM duplicate_indexes_s_2i.
  find_duplicate_index_2 bsis hkont.
ENDFORM.                    " DUPLICATE_INDEXES_S_2
*&--------------------------------------------------------------------*
*&      Form  duplicate_indexes_s_2a
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM duplicate_indexes_s_2a.
  find_duplicate_index_2 bsas hkont.
ENDFORM.                    " DUPLICATE_INDEXES_S_2
*&--------------------------------------------------------------------*
*&      Form  duplicate_indexes_d_2i
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM duplicate_indexes_d_2i.
  find_duplicate_index_2 bsid kunnr.
ENDFORM.                    " DUPLICATE_INDEXES_S_2
*&--------------------------------------------------------------------*
*&      Form  duplicate_indexes_d_2a
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM duplicate_indexes_d_2a.
  find_duplicate_index_2 bsad kunnr.
ENDFORM.                    " DUPLICATE_INDEXES_S_2
*&--------------------------------------------------------------------*
*&      Form  duplicate_indexes_k_2i
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM duplicate_indexes_k_2i.
  find_duplicate_index_2 bsik lifnr.
ENDFORM.                    " DUPLICATE_INDEXES_S_2
*&--------------------------------------------------------------------*
*&      Form  duplicate_indexes_k_2a
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
FORM duplicate_indexes_k_2a.
  find_duplicate_index_2 bsak lifnr.
ENDFORM.                    " DUPLICATE_INDEXES_S_2
*&---------------------------------------------------------------------*
*&      Form  count_table_entries
*&---------------------------------------------------------------------*
*DEFINE select_count_index.
** &1 = hkont, kunnr or lifnr
** &2 = hkont, umsks
** &3 = hkont, umskz
*  select count(*) into cnt from
*           (tab_name_input) where bukrs in p_bukrs
*                              and &1 in p_&1
*                              and &2 in p_&2
*                              and &3 in p_&3
*                              and augdt in p_augdt
*                              and augbl in p_augbl
*                              and belnr in p_belnr
*                              and gjahr in p_gjahr
*                              and xblnr in p_xblnr
*                              and waers in p_waers
*                              and blart in p_blart
*                              and budat in p_budat.
*END-OF-DEFINITION.
*&--------------------------------------------------------------------*
*&      Form  count_table_entries
*&--------------------------------------------------------------------*
*       text
*---------------------------------------------------------------------*
*FORM count_table_entries.
*  DATA cnt TYPE i.
*  LOOP AT tab_name_input.
*    CASE tab_name_input.
*      WHEN 'BKPF'.
*        SELECT COUNT(*) INTO cnt FROM bkpf WHERE bukrs IN p_bukrs
*                                    AND belnr IN p_belnr
*                                    AND gjahr IN p_gjahr
*                                    AND monat IN p_monat
*                                    AND waers IN p_waers
*                                    AND xblnr IN p_xblnr
*                                    AND cpudt IN p_cpudt
*                                    AND budat IN p_budat
*                                    AND blart IN p_blart.
*
*        WRITE:/ 'Number of entries in', tab_name_input, cnt.
*      WHEN 'RFBLG'.
*        SELECT COUNT(*) INTO cnt FROM rfblg WHERE bukrs IN p_bukrs
*                                    AND belnr IN p_belnr
*                                    AND gjahr IN p_gjahr.
*
*        WRITE:/ 'Number of entries in', tab_name_input, cnt.
*      WHEN 'BSIS' OR 'BSAS'.
*        select_count_index hkont hkont hkont.
*        WRITE:/ 'Number of entries in', tab_name_input, cnt.
*      WHEN 'BSID' OR 'BSAD'.
*        select_count_index kunnr umsks umskz.
*        WRITE:/ 'Number of entries in', tab_name_input, cnt.
*      WHEN 'BSIK' OR 'BSAK'.
*        select_count_index lifnr umsks umskz.
*        WRITE:/ 'Number of entries in', tab_name_input, cnt.
*
*
*    ENDCASE.
*  ENDLOOP.
*ENDFORM.                    " count_table_entries
*&---------------------------------------------------------------------*
*&      Form  bseg_gegen_t001
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_BSEGERROR  text
*      <--P_RET_CODE  text
*      <--P_P_ERROR_LOG  text
*----------------------------------------------------------------------*
FORM bseg_gegen_t001 TABLES bsegerror STRUCTURE no_ty_bsegerror
                CHANGING return_code TYPE any
                         p_error_log TYPE ty_error_log.     "#EC NEEDED


  DATA dummy LIKE bseg-zuonr VALUE 'T001 XNEGP'.
  IF bseg-xnegp NE space AND it001-xnegp NE 'X'.
    CLEAR bseg-xnegp.
    ADD 1 TO p_error_log-bseg-error.
    PERFORM append_bseg_error TABLES bsegerror
          USING bseg bseg dummy 'XNEGP=X'.
    IF repair = 'X'.
      ADD 1 TO p_error_log-bseg-update.
      UPDATE bseg.
    ENDIF.
  ENDIF.

ENDFORM.                    " bseg_gegen_t001
*&---------------------------------------------------------------------*
*&      Form  check_flags
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM check_flags .
  IF repair = 'X' AND c_bseg = 'X' AND ( x_index = 'X' OR x_bseg = 'X' ) .
    MESSAGE e000 WITH 'Ung¨¹ltige Kombination von Selektionsparametern'(436).
  ENDIF.

ENDFORM.                    " check_flags
*&---------------------------------------------------------------------*
*&      Form  set_properties_fagl
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM set_properties_fagl .
  DATA ld_glflex_active TYPE char1.
  DATA ld_read_glt0_user TYPE char1.
  gd_glt0_update_allowed = 'X'.
  CLEAR gd_fagl_functions_present.
* check glflex activation

  DATA: ld_name(30) VALUE 'FAGL_CHECK_GLFLEX_ACTIVE'.

  CALL FUNCTION 'RH_FUNCTION_EXIST'
    EXPORTING
      name               = ld_name
    EXCEPTIONS
      function_not_found = 1
      OTHERS             = 2.

  CHECK sy-subrc = 0.

  CALL FUNCTION 'FAGL_CHECK_GLFLEX_ACTIVE'
    IMPORTING
      e_glflex_active = ld_glflex_active
    EXCEPTIONS
      error_in_setup  = 1
      OTHERS          = 2.

  IF sy-subrc <> 0.
    CLEAR gd_fagl_functions_present.
    RETURN.
  ENDIF.
  gd_fagl_functions_present = 'X'.

  IF ld_glflex_active = 'X'.
    CALL FUNCTION 'FAGL_GET_GLT0_SETTING'
      IMPORTING
        ed_read_glt0_user = ld_read_glt0_user.

    IF ld_read_glt0_user NE 'X'.
*       FlexGL ist aktiv aber nicht mehr die Fortschreibung der GLT0
*       updates d¨¹rfen nicht mehr gehen
      CLEAR gd_glt0_update_allowed.
    ENDIF.
  ENDIF.



ENDFORM.                    " set_properties_fagl

* SET EXTENDED CHECK ON.
*&---------------------------------------------------------------------*
*&      Form  schedman_summary1
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM schedman_summary1 USING error_log TYPE ty_error_log
                             id_abstimmung TYPE char255.
  FIELD-SYMBOLS <fs_obj> TYPE tt_error.

  DATA lt_checks TYPE TABLE OF tabname.
  FIELD-SYMBOLS <ls_check> TYPE tabname.

  APPEND 'BKPF' TO lt_checks.
  APPEND 'BSEG' TO lt_checks.
  APPEND 'BSIS' TO lt_checks.
  APPEND 'BSAS' TO lt_checks.
  APPEND 'BSID' TO lt_checks.
  APPEND 'BSAD' TO lt_checks.
  APPEND 'BSIK' TO lt_checks.
  APPEND 'BSAK' TO lt_checks.

  DATA ld_severity TYPE char1.

  LOOP AT lt_checks ASSIGNING <ls_check>.
    ASSIGN COMPONENT <ls_check> OF STRUCTURE error_log TO <fs_obj>.
    CHECK sy-subrc = 0.
    IF <fs_obj>-error > 0.
      ld_severity = 'E'.
    ELSE.
      ld_severity = 'S'.
    ENDIF.
    PERFORM log_almsg_var  USING 'FB' ld_severity '000'
            id_abstimmung
            <ls_check>
            <fs_obj>-check
            <fs_obj>-error.
  ENDLOOP.


ENDFORM.                    " schedman_summary1
*&---------------------------------------------------------------------*
** BEGIN of CHANGES                                             C5053256
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  display_alv_document_list
*&---------------------------------------------------------------------*
*       Display the First ALV List.
*----------------------------------------------------------------------*
FORM display_alv_document_list TABLES lt_alv_table1
                                      lt_alv_table2.
  DATA: lt_fcat_list TYPE slis_t_fieldcat_alv,
        ls_layo_list TYPE slis_layout_alv,
        lt_evts_list TYPE slis_t_event,
        ls_prnt_list TYPE slis_print_alv,
        lt_sort_list TYPE slis_t_sortinfo_alv,
        ls_keyinfo   TYPE slis_keyinfo_alv.

* Display Account wise detail list.
  PERFORM set_fieldcatalog CHANGING lt_fcat_list.  "Field Catalog
  PERFORM set_layout       CHANGING ls_layo_list.  "Layout
  PERFORM set_print        CHANGING ls_prnt_list.  "Print attribute
  PERFORM set_events       CHANGING lt_evts_list.  "Events
  PERFORM set_keyinfo_alv  CHANGING ls_keyinfo.
  PERFORM set_group_det    CHANGING lt_sort_list.  "Sort & Group Inf
* Set Group Information.
*
  CASE gv_counter_outtab.
    WHEN gc_eighth_list OR gc_eleventh_list OR gc_25th_list.
      MOVE gc_header_doc1 TO gv_header.
      MOVE gc_item_doc1   TO gv_item.
    WHEN gc_31st_list.
      MOVE gc_header11    TO gv_header.
      MOVE gc_item12      TO gv_item.
    WHEN gc_32nd_list.
      MOVE gc_header21    TO gv_header.
      MOVE gc_item22      TO gv_item.
    WHEN gc_34th_list.
      MOVE gc_header23    TO gv_header.
      MOVE gc_item24      TO gv_item.
    WHEN gc_36th_list.
      MOVE gc_header27    TO gv_header.
      MOVE gc_item28      TO gv_item.
    WHEN OTHERS.
      MOVE gc_header1  TO gv_header.
      MOVE gc_item1    TO gv_item.
  ENDCASE.
*
  PERFORM hirerchy_list_display TABLES lt_alv_table1
                                       lt_alv_table2
                                USING  ls_layo_list
                                       lt_fcat_list
                                       lt_sort_list
                                       lt_evts_list
                                       ls_keyinfo
                                       ls_prnt_list
                                       gv_header
                                       gv_item.
*
ENDFORM.                    " display_alv_document_list
*
*&---------------------------------------------------------------------*
*&      Form  set_fieldcatalog
*&---------------------------------------------------------------------*
*       Set the field catalog using structure.
*       Also set the individual characteristics of the columns.
*----------------------------------------------------------------------*
*      <--XT_FCAT   Field Catalog Internal Table.
*----------------------------------------------------------------------*
FORM set_fieldcatalog  CHANGING xt_fcat TYPE slis_t_fieldcat_alv. "#EC *

  DATA:  lt_fcat            TYPE slis_t_fieldcat_alv,       "#EC NEEDED
         ls_fcat            TYPE slis_fieldcat_alv.
  DATA:  lv_header_name     TYPE slis_tabname,
         lv_item_name       TYPE slis_tabname,
         lv_structure_name1 TYPE dd02l-tabname,
         lv_structure_name2 TYPE dd02l-tabname.
  CLEAR: xt_fcat, lv_header_name,     lv_item_name,
                  lv_structure_name1, lv_structure_name2.
  REFRESH xt_fcat.

  CASE gv_counter_outtab.
    WHEN gc_first_list OR gc_third_list OR
         gc_sixth_list OR gc_23rd_list.
*
      MOVE : gc_header1         TO lv_header_name,
             gc_item1           TO lv_item_name,
             gc_structure_list1 TO lv_structure_name1,
             gc_structure_list2 TO lv_structure_name2.
      PERFORM set_hir_fieldcat USING    lv_header_name
                                        lv_item_name
                                        lv_structure_name1
                                        lv_structure_name2
                               CHANGING xt_fcat.
*
    WHEN gc_eighth_list OR gc_eleventh_list OR gc_25th_list.
*
      MOVE : gc_header_doc1     TO lv_header_name,
             gc_item_doc1       TO lv_item_name,
             gc_structure_list3 TO lv_structure_name1,
             gc_structure_list4 TO lv_structure_name2.
      PERFORM set_hir_fieldcat USING    lv_header_name
                                        lv_item_name
                                        lv_structure_name1
                                        lv_structure_name2
                               CHANGING xt_fcat.
*
    WHEN gc_second_list OR gc_fifth_list OR gc_seventh_list.
*
      MOVE gc_structure_summ      TO       lv_structure_name1.
      PERFORM set_simple_fieldcat USING    lv_structure_name1
                                  CHANGING xt_fcat.
*
    WHEN gc_forth_list.
*
      MOVE gc_structure_list2     TO       lv_structure_name1.
      PERFORM set_simple_fieldcat USING    lv_structure_name1
                                  CHANGING xt_fcat.
*
    WHEN gc_ninenth_list OR gc_12th_list OR gc_26th_list
                         OR gc_37th_list.
*
      MOVE gc_structure_list5     TO       lv_structure_name1.
      PERFORM set_simple_fieldcat USING    lv_structure_name1
                                  CHANGING xt_fcat.
*
    WHEN gc_tenth_list OR gc_13th_list OR gc_27th_list.
*
      MOVE gc_structure_list6     TO       lv_structure_name1.
      PERFORM set_simple_fieldcat USING    lv_structure_name1
                                  CHANGING xt_fcat.
*
    WHEN gc_33rd_list OR
         gc_35th_list OR gc_17th_list.
*
      MOVE gc_structure_list1     TO       lv_structure_name1.
      PERFORM set_simple_fieldcat USING    lv_structure_name1
                                  CHANGING xt_fcat.
*
    WHEN gc_31st_list.
*
      MOVE : gc_header11        TO lv_header_name,
             gc_item12          TO lv_item_name,
             gc_structure_list1 TO lv_structure_name1,
             gc_structure_list1 TO lv_structure_name2.
      PERFORM set_hir_fieldcat USING    lv_header_name
                                        lv_item_name
                                        lv_structure_name1
                                        lv_structure_name2
                               CHANGING xt_fcat.
*
    WHEN gc_32nd_list.
*
      MOVE : gc_header21        TO lv_header_name,
             gc_item22          TO lv_item_name,
             gc_structure_list1 TO lv_structure_name1,
             gc_structure_list4 TO lv_structure_name2.
      PERFORM set_hir_fieldcat USING    lv_header_name
                                        lv_item_name
                                        lv_structure_name1
                                        lv_structure_name2
                               CHANGING xt_fcat.
*
    WHEN gc_34th_list.
*
      MOVE : gc_header23        TO lv_header_name,
             gc_item24          TO lv_item_name,
             gc_structure_list1 TO lv_structure_name1,
             gc_structure_list2 TO lv_structure_name2.
      PERFORM set_hir_fieldcat USING    lv_header_name
                                        lv_item_name
                                        lv_structure_name1
                                        lv_structure_name2
                               CHANGING xt_fcat.
*
    WHEN gc_36th_list.
*
      MOVE : gc_header27        TO lv_header_name,
             gc_item28          TO lv_item_name,
             gc_structure_list1 TO lv_structure_name1,
             gc_structure_list2 TO lv_structure_name2.
      PERFORM set_hir_fieldcat USING    lv_header_name
                                        lv_item_name
                                        lv_structure_name1
                                        lv_structure_name2
                               CHANGING xt_fcat.
*
  ENDCASE.

  CASE gv_counter_outtab.
    WHEN gc_first_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-tabname.
          WHEN gc_item1.
            CASE ls_fcat-fieldname.
*              WHEN 'BUKRS'.
*                ls_fcat-tech      = gc_checked.
*              WHEN 'BELNR'.
*                ls_fcat-tech     = gc_checked.
*              WHEN 'GJAHR'.
*                ls_fcat-tech     = gc_checked.
*              WHEN 'BUZEI'.
*                ls_fcat-tech     = gc_checked.
              WHEN 'B_TBL'.
                ls_fcat-seltext_l = text-308.
                ls_fcat-seltext_m = text-308.
                ls_fcat-seltext_s = text-308.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'UMSKS'.
                ls_fcat-seltext_l = text-309.
                ls_fcat-seltext_m = text-309.
                ls_fcat-seltext_s = text-309.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'UMSKZ'.
                ls_fcat-seltext_l = text-310.
                ls_fcat-seltext_m = text-310.
                ls_fcat-seltext_s = text-310.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'AUGDT'.
                ls_fcat-seltext_l = text-311.
                ls_fcat-seltext_m = text-311.
                ls_fcat-seltext_s = text-311.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'AUGBL'.
                ls_fcat-seltext_l = text-312.
                ls_fcat-seltext_m = text-312.
                ls_fcat-seltext_s = text-312.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'ZUONR'.
                ls_fcat-seltext_l = text-313.
                ls_fcat-seltext_m = text-313.
                ls_fcat-seltext_s = text-313.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'SHKZG'.
                ls_fcat-seltext_l = text-314.
                ls_fcat-seltext_m = text-314.
                ls_fcat-seltext_s = text-314.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'BSCHL'.
                ls_fcat-seltext_l = text-315.
                ls_fcat-seltext_m = text-315.
                ls_fcat-seltext_s = text-315.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'WRBTR'.
                ls_fcat-seltext_l = text-316.
                ls_fcat-seltext_m = text-316.
                ls_fcat-seltext_s = text-316.
                ls_fcat-outputlen = 15.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'DMBTR'.
                ls_fcat-seltext_l = text-317.
                ls_fcat-seltext_m = text-317.
                ls_fcat-seltext_s = text-317.
                ls_fcat-outputlen = 15.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'PSWBT'.
                ls_fcat-seltext_l = text-318.
                ls_fcat-seltext_m = text-318.
                ls_fcat-seltext_s = text-318.
                ls_fcat-outputlen = 15.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'XKRES'.
                ls_fcat-seltext_l = text-319.
                ls_fcat-seltext_m = text-319.
                ls_fcat-seltext_s = text-319.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'XOPVW'.
                ls_fcat-seltext_l = text-320.
                ls_fcat-seltext_m = text-320.
                ls_fcat-seltext_s = text-320.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'XHRES'.
                ls_fcat-seltext_l = text-321.
                ls_fcat-seltext_m = text-321.
                ls_fcat-seltext_s = text-321.
                ls_fcat-ddictxt   = gc_l.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
          WHEN gc_header1.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-seltext_l = text-302.
                ls_fcat-seltext_m = text-302.
                ls_fcat-seltext_s = text-302.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'BELNR'.
                ls_fcat-seltext_l = text-303.
                ls_fcat-seltext_m = text-303.
                ls_fcat-seltext_s = text-303.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'GJAHR'.
                ls_fcat-seltext_l = text-304.
                ls_fcat-seltext_m = text-304.
                ls_fcat-seltext_s = text-304.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'BUZEI'.
                ls_fcat-lzero    = gc_checked.
              WHEN 'RECON'.
                ls_fcat-seltext_l = text-305.
                ls_fcat-seltext_m = text-305.
                ls_fcat-seltext_s = text-305.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'KONTO'.
                ls_fcat-seltext_l = text-306.
                ls_fcat-seltext_m = text-306.
                ls_fcat-seltext_s = text-306.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'ERR_MSG'.
                ls_fcat-seltext_l = text-307.
                ls_fcat-seltext_m = text-307.
                ls_fcat-seltext_s = text-307.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 50.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname
            AND tabname   = ls_fcat-tabname.
      ENDLOOP.
**********
    WHEN gc_third_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-tabname.
          WHEN gc_item1.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-tech      = gc_checked.
              WHEN 'BELNR'.
                ls_fcat-tech     = gc_checked.
              WHEN 'GJAHR'.
                ls_fcat-tech     = gc_checked.
              WHEN 'BUZEI'.
                ls_fcat-tech     = gc_checked.
              WHEN 'B_TBL'.
                ls_fcat-seltext_l = text-308.
                ls_fcat-seltext_m = text-308.
                ls_fcat-seltext_s = text-308.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos   = 1.
              WHEN 'UMSKS'.
                ls_fcat-seltext_l = text-309.
                ls_fcat-seltext_m = text-309.
                ls_fcat-seltext_s = text-309.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'UMSKZ'.
                ls_fcat-seltext_l = text-310.
                ls_fcat-seltext_m = text-310.
                ls_fcat-seltext_s = text-310.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'AUGDT'.
                ls_fcat-seltext_l = text-311.
                ls_fcat-seltext_m = text-311.
                ls_fcat-seltext_s = text-311.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'AUGBL'.
                ls_fcat-seltext_l = text-312.
                ls_fcat-seltext_m = text-312.
                ls_fcat-seltext_s = text-312.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'ZUONR'.
                ls_fcat-seltext_l = text-313.
                ls_fcat-seltext_m = text-313.
                ls_fcat-seltext_s = text-313.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'SHKZG'.
                ls_fcat-seltext_l = text-314.
                ls_fcat-seltext_m = text-314.
                ls_fcat-seltext_s = text-314.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'BSCHL'.
                ls_fcat-seltext_l = text-315.
                ls_fcat-seltext_m = text-315.
                ls_fcat-seltext_s = text-315.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'WRBTR'.
                ls_fcat-seltext_l = text-345.
                ls_fcat-seltext_m = text-345.
                ls_fcat-seltext_s = text-345.
                ls_fcat-outputlen = 15.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'DMBTR'.
                ls_fcat-seltext_l = text-346.
                ls_fcat-seltext_m = text-346.
                ls_fcat-seltext_s = text-346.
                ls_fcat-outputlen = 15.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'DMBT2'.
                ls_fcat-seltext_l = text-347.
                ls_fcat-seltext_m = text-347.
                ls_fcat-seltext_s = text-347.
                ls_fcat-outputlen = 15.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'HKONT'.
                ls_fcat-seltext_l = text-306.
                ls_fcat-seltext_m = text-306.
                ls_fcat-seltext_s = text-306.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos   = 2.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
          WHEN gc_header1.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-seltext_l = text-302.
                ls_fcat-seltext_m = text-302.
                ls_fcat-seltext_s = text-302.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-row_pos   = 1.
                ls_fcat-col_pos   = 1.
              WHEN 'BELNR'.
                ls_fcat-seltext_l = text-303.
                ls_fcat-seltext_m = text-303.
                ls_fcat-seltext_s = text-303.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-row_pos   = 2.
                ls_fcat-col_pos   = 1.
              WHEN 'GJAHR'.
                ls_fcat-seltext_l = text-304.
                ls_fcat-seltext_m = text-304.
                ls_fcat-seltext_s = text-304.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-row_pos   = 2.
                ls_fcat-col_pos   = 2.
              WHEN 'BUZEI'.
                ls_fcat-lzero    = gc_checked.
                ls_fcat-row_pos   = 2.
                ls_fcat-col_pos   = 3.
              WHEN 'RECON'.
                ls_fcat-seltext_l = text-332.
                ls_fcat-seltext_m = text-332.
                ls_fcat-seltext_s = text-332.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-row_pos   = 1.
                ls_fcat-col_pos   = 4.
              WHEN 'HKONT'.
                ls_fcat-seltext_l = text-306.
                ls_fcat-seltext_m = text-306.
                ls_fcat-seltext_s = text-306.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-row_pos   = 1.
                ls_fcat-col_pos   = 3.
              WHEN 'ERR_MSG'.
                ls_fcat-seltext_l = text-331.
                ls_fcat-seltext_m = text-331.
                ls_fcat-seltext_s = text-331.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 50.
                ls_fcat-row_pos   = 2.
                ls_fcat-col_pos   = 4.
              WHEN 'GLTYPE'.
                ls_fcat-seltext_l = text-334.
                ls_fcat-seltext_m = text-334.
                ls_fcat-seltext_s = text-334.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-row_pos   = 1.
                ls_fcat-col_pos   = 2.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname
            AND tabname   = ls_fcat-tabname.
      ENDLOOP.
    WHEN gc_second_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-fieldname.
          WHEN 'SUMTYPE'.
            ls_fcat-outputlen = 20.
            ls_fcat-seltext_l = text-322.
            ls_fcat-seltext_m = text-322.
            ls_fcat-seltext_s = text-322.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 1.
          WHEN 'SUM1'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-323.
            ls_fcat-seltext_m = text-323.
            ls_fcat-seltext_s = text-323.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 2.
          WHEN 'SUM2'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-324.
            ls_fcat-seltext_m = text-324.
            ls_fcat-seltext_s = text-324.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 3.
          WHEN 'SUM3'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-325.
            ls_fcat-seltext_m = text-325.
            ls_fcat-seltext_s = text-325.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 4.
          WHEN 'SUM4'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-326.
            ls_fcat-seltext_m = text-326.
            ls_fcat-seltext_s = text-326.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 5.
          WHEN 'SUM5'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-327.
            ls_fcat-seltext_m = text-327.
            ls_fcat-seltext_s = text-327.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 6.
          WHEN 'SUM6'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-328.
            ls_fcat-seltext_m = text-328.
            ls_fcat-seltext_s = text-328.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 7.
          WHEN 'SUM7'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-329.
            ls_fcat-seltext_m = text-329.
            ls_fcat-seltext_s = text-329.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 8.
          WHEN 'SUM8'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-330.
            ls_fcat-seltext_m = text-330.
            ls_fcat-seltext_s = text-330.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 9.
          WHEN 'SUM9'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-359.
            ls_fcat-seltext_m = text-359.
            ls_fcat-seltext_s = text-359.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 10.
          WHEN OTHERS.
            ls_fcat-tech    = gc_checked.
        ENDCASE.
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            seltext_l seltext_m seltext_s
                            ddictxt
          WHERE fieldname = ls_fcat-fieldname.
      ENDLOOP.
**
    WHEN gc_fifth_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-fieldname.
          WHEN 'SUMTYPE'.
            ls_fcat-outputlen = 20.
            ls_fcat-seltext_l = text-322.
            ls_fcat-seltext_m = text-322.
            ls_fcat-seltext_s = text-322.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 1.
          WHEN 'SUM1'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-323.
            ls_fcat-seltext_m = text-323.
            ls_fcat-seltext_s = text-323.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 9.
          WHEN 'SUM2'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-324.
            ls_fcat-seltext_m = text-324.
            ls_fcat-seltext_s = text-324.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 8.
          WHEN 'SUM3'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-325.
            ls_fcat-seltext_m = text-325.
            ls_fcat-seltext_s = text-325.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 2.
          WHEN 'SUM4'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-326.
            ls_fcat-seltext_m = text-326.
            ls_fcat-seltext_s = text-326.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 3.
          WHEN 'SUM5'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-327.
            ls_fcat-seltext_m = text-327.
            ls_fcat-seltext_s = text-327.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 4.
          WHEN 'SUM6'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-328.
            ls_fcat-seltext_m = text-328.
            ls_fcat-seltext_s = text-328.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 5.
          WHEN 'SUM7'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-329.
            ls_fcat-seltext_m = text-329.
            ls_fcat-seltext_s = text-329.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 6.
          WHEN 'SUM8'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-330.
            ls_fcat-seltext_m = text-330.
            ls_fcat-seltext_s = text-330.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 7.
          WHEN OTHERS.
            ls_fcat-tech    = gc_checked.
        ENDCASE.
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            seltext_l seltext_m seltext_s
                            ddictxt
          WHERE fieldname = ls_fcat-fieldname.
      ENDLOOP.
**
    WHEN gc_seventh_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-fieldname.
          WHEN 'SUMTYPE'.
            ls_fcat-outputlen = 20.
            ls_fcat-seltext_l = text-322.
            ls_fcat-seltext_m = text-322.
            ls_fcat-seltext_s = text-322.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 1.
          WHEN 'SUM4'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-326.
            ls_fcat-seltext_m = text-326.
            ls_fcat-seltext_s = text-326.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 1.
          WHEN 'SUM6'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-328.
            ls_fcat-seltext_m = text-328.
            ls_fcat-seltext_s = text-328.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 2.
          WHEN 'SUM8'.
            ls_fcat-outputlen  = 10.
            ls_fcat-seltext_l = text-330.
            ls_fcat-seltext_m = text-330.
            ls_fcat-seltext_s = text-330.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-col_pos   = 3.
          WHEN OTHERS.
            ls_fcat-tech    = gc_checked.
        ENDCASE.
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            seltext_l seltext_m seltext_s
                            ddictxt
          WHERE fieldname = ls_fcat-fieldname.
      ENDLOOP.
**
    WHEN gc_forth_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-fieldname.
          WHEN 'BUKRS'.
            ls_fcat-col_pos  = 1.
          WHEN 'BELNR'.
            ls_fcat-col_pos  = 2.
          WHEN 'GJAHR'.
            ls_fcat-col_pos  = 3.
          WHEN 'BUZEI'.
            ls_fcat-lzero    = gc_checked.
            ls_fcat-col_pos  = 4.
          WHEN 'SGTXT'.
            ls_fcat-outputlen = 15.
            ls_fcat-col_pos   = 5.
          WHEN 'UMSKS'.
            ls_fcat-seltext_l = text-309.
            ls_fcat-seltext_m = text-309.
            ls_fcat-seltext_s = text-309.
            ls_fcat-ddictxt   = gc_l.
          WHEN 'UMSKZ'.
            ls_fcat-seltext_l = text-310.
            ls_fcat-seltext_m = text-310.
            ls_fcat-seltext_s = text-310.
            ls_fcat-ddictxt   = gc_l.
          WHEN 'AUGDT'.
            ls_fcat-seltext_l = text-311.
            ls_fcat-seltext_m = text-311.
            ls_fcat-seltext_s = text-311.
            ls_fcat-ddictxt   = gc_l.
          WHEN 'AUGBL'.
            ls_fcat-seltext_l = text-312.
            ls_fcat-seltext_m = text-312.
            ls_fcat-seltext_s = text-312.
            ls_fcat-ddictxt   = gc_l.
          WHEN 'ZUONR'.
            ls_fcat-seltext_l = text-313.
            ls_fcat-seltext_m = text-313.
            ls_fcat-seltext_s = text-313.
            ls_fcat-ddictxt   = gc_l.
          WHEN 'BSCHL'.
            ls_fcat-seltext_l = text-315.
            ls_fcat-seltext_m = text-315.
            ls_fcat-seltext_s = text-315.
            ls_fcat-ddictxt   = gc_l.
          WHEN 'WRBTR'.
            ls_fcat-seltext_l = text-316.
            ls_fcat-seltext_m = text-316.
            ls_fcat-seltext_s = text-316.
            ls_fcat-outputlen = 15.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-do_sum    = gc_checked.
          WHEN 'DMBTR'.
            ls_fcat-seltext_l = text-317.
            ls_fcat-seltext_m = text-317.
            ls_fcat-seltext_s = text-317.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-outputlen = 15.
            ls_fcat-do_sum    = gc_checked.
          WHEN 'PSWBT'.
            ls_fcat-seltext_l = text-318.
            ls_fcat-seltext_m = text-318.
            ls_fcat-seltext_s = text-318.
            ls_fcat-ddictxt   = gc_l.
            ls_fcat-outputlen = 15.
            ls_fcat-do_sum    = gc_checked.
          WHEN OTHERS.
            ls_fcat-tech      = gc_checked.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname.
      ENDLOOP.
    WHEN gc_sixth_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-tabname.
          WHEN gc_item1.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-tech      = gc_checked.
              WHEN 'BELNR'.
                ls_fcat-tech      = gc_checked.
              WHEN 'GJAHR'.
                ls_fcat-tech      = gc_checked.
              WHEN 'BUZEI'.
                ls_fcat-tech      = gc_checked.
              WHEN 'HKONT'.
                ls_fcat-seltext_l = text-348.
                ls_fcat-seltext_m = text-348.
                ls_fcat-seltext_s = text-348.
                ls_fcat-ddictxt   = gc_l.
*                ls_fcat-row_pos   = 2.
*              WHEN 'B_TBL'.
*                ls_fcat-seltext_l = text-308.
*                ls_fcat-seltext_m = text-308.
*                ls_fcat-seltext_s = text-308.
*                ls_fcat-ddictxt   = gc_l.
*                ls_fcat-row_pos   = 2.
              WHEN 'UMSKS'.
                ls_fcat-seltext_l = text-309.
                ls_fcat-seltext_m = text-309.
                ls_fcat-seltext_s = text-309.
                ls_fcat-ddictxt   = gc_l.
*                ls_fcat-row_pos   = 2.
              WHEN 'UMSKZ'.
                ls_fcat-seltext_l = text-310.
                ls_fcat-seltext_m = text-310.
                ls_fcat-seltext_s = text-310.
                ls_fcat-ddictxt   = gc_l.
*                ls_fcat-row_pos   = 2.
              WHEN 'AUGDT'.
                ls_fcat-seltext_l = text-311.
                ls_fcat-seltext_m = text-311.
                ls_fcat-seltext_s = text-311.
                ls_fcat-ddictxt   = gc_l.
*                ls_fcat-row_pos   = 2.
              WHEN 'AUGBL'.
                ls_fcat-seltext_l = text-312.
                ls_fcat-seltext_m = text-312.
                ls_fcat-seltext_s = text-312.
                ls_fcat-ddictxt   = gc_l.
*                ls_fcat-row_pos   = 2.
              WHEN 'WRBTR'.
                ls_fcat-seltext_l = text-345.
                ls_fcat-seltext_m = text-345.
                ls_fcat-seltext_s = text-345.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-do_sum    = gc_checked.
                ls_fcat-outputlen = 15.
*                ls_fcat-row_pos   = 2.
              WHEN 'DMBTR'.
                ls_fcat-seltext_l = text-346.
                ls_fcat-seltext_m = text-346.
                ls_fcat-seltext_s = text-346.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-do_sum    = gc_checked.
                ls_fcat-outputlen = 15.
*                ls_fcat-row_pos   = 2.
              WHEN 'DMBT2'.
                ls_fcat-seltext_l = text-347.
                ls_fcat-seltext_m = text-347.
                ls_fcat-seltext_s = text-347.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-do_sum    = gc_checked.
                ls_fcat-outputlen = 15.
*                ls_fcat-row_pos   = 2.
              WHEN 'PSWBT'.
                ls_fcat-seltext_l = text-350.
                ls_fcat-seltext_m = text-350.
                ls_fcat-seltext_s = text-350.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-do_sum    = gc_checked.
                ls_fcat-outputlen = 15.
*                ls_fcat-row_pos   = 2.
              WHEN 'PSWSL'.
                ls_fcat-seltext_l = text-351.
                ls_fcat-seltext_m = text-351.
                ls_fcat-seltext_s = text-351.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos   = 28.
*                ls_fcat-row_pos   = 2.
              WHEN 'ARCNT'.
                ls_fcat-seltext_l = text-352.
                ls_fcat-seltext_m = text-352.
                ls_fcat-seltext_s = text-352.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 5.
*                ls_fcat-row_pos   = 2.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
          WHEN gc_header1.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-seltext_l = text-353.
                ls_fcat-seltext_m = text-353.
                ls_fcat-seltext_s = text-353.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'KONTO'.
                ls_fcat-seltext_l = text-306.
                ls_fcat-seltext_m = text-306.
                ls_fcat-seltext_s = text-306.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos   = 3.
              WHEN 'GLTYPE'.
                ls_fcat-seltext_l = text-343.
                ls_fcat-seltext_m = text-343.
                ls_fcat-seltext_s = text-343.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos   = 2.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname
            AND tabname   = ls_fcat-tabname.
      ENDLOOP.
    WHEN gc_eighth_list OR gc_eleventh_list OR gc_25th_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-tabname.
          WHEN gc_item_doc1.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-tech     = gc_checked.
              WHEN 'BELNR'.
                ls_fcat-tech     = gc_checked.
              WHEN 'BUZEI'.
                ls_fcat-tech     = gc_checked.
              WHEN 'B_TBL'.
                ls_fcat-tech     = gc_checked.
              WHEN 'LEV'.
                ls_fcat-tech     = gc_checked.
              WHEN 'HKONT'.
                ls_fcat-seltext_l = text-306.
                ls_fcat-seltext_m = text-306.
                ls_fcat-seltext_s = text-306.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'DOCAMT'.
                ls_fcat-outputlen = 13.
                CASE gv_counter_outtab.
                  WHEN gc_eighth_list.
                    ls_fcat-seltext_l = text-336.
                    ls_fcat-seltext_m = text-336.
                    ls_fcat-seltext_s = text-336.
                    ls_fcat-ddictxt   = gc_l.
                  WHEN gc_eleventh_list.
                    ls_fcat-seltext_l = text-340.
                    ls_fcat-seltext_m = text-340.
                    ls_fcat-seltext_s = text-340.
                    ls_fcat-ddictxt   = gc_l.
                  WHEN gc_25th_list.
                    ls_fcat-seltext_l = text-342.
                    ls_fcat-seltext_m = text-342.
                    ls_fcat-seltext_s = text-342.
                    ls_fcat-ddictxt   = gc_l.
                ENDCASE.
              WHEN 'TBLAMT'.
                CASE gv_counter_outtab.
                  WHEN gc_eighth_list OR gc_eleventh_list.
                    ls_fcat-outputlen = 13.
                    ls_fcat-seltext_l = text-322.
                    ls_fcat-seltext_m = text-322.
                    ls_fcat-seltext_s = text-322.
                    ls_fcat-ddictxt   = gc_l.
                  WHEN gc_25th_list.
                    ls_fcat-outputlen = 13.
                    ls_fcat-seltext_l = text-343.
                    ls_fcat-seltext_m = text-343.
                    ls_fcat-seltext_s = text-343.
                    ls_fcat-ddictxt   = gc_l.
                ENDCASE.
              WHEN 'DIFAMT'.
                CASE gv_counter_outtab.
                  WHEN gc_eighth_list OR gc_eleventh_list.
                    ls_fcat-outputlen = 13.
                    ls_fcat-seltext_l = text-337.
                    ls_fcat-seltext_m = text-337.
                    ls_fcat-seltext_s = text-337.
                    ls_fcat-ddictxt   = gc_l.
                  WHEN gc_25th_list.
                    ls_fcat-outputlen = 13.
                    ls_fcat-seltext_l = text-341.
                    ls_fcat-seltext_m = text-341.
                    ls_fcat-seltext_s = text-341.
                    ls_fcat-ddictxt   = gc_l.
                ENDCASE.
              WHEN 'RLDNR'.
                ls_fcat-seltext_l = text-339.
                ls_fcat-seltext_m = text-339.
                ls_fcat-seltext_s = text-339.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'GJAHR'.
                ls_fcat-seltext_l = text-354.
                ls_fcat-seltext_m = text-354.
                ls_fcat-seltext_s = text-354.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'GSBER'.
                ls_fcat-seltext_l = text-355.
                ls_fcat-seltext_m = text-355.
                ls_fcat-seltext_s = text-355.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'PSWSL'.
                CASE gv_counter_outtab.
                  WHEN gc_eighth_list.
                    ls_fcat-seltext_l = text-351.
                    ls_fcat-seltext_m = text-351.
                    ls_fcat-seltext_s = text-351.
                  WHEN gc_25th_list.
                    ls_fcat-seltext_l = text-356.
                    ls_fcat-seltext_m = text-356.
                    ls_fcat-seltext_s = text-356.
                ENDCASE.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'FLD'.
                ls_fcat-seltext_l = text-349.
                ls_fcat-seltext_m = text-349.
                ls_fcat-seltext_s = text-349.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'SHBKZ'.
                CASE gv_counter_outtab.
                  WHEN gc_eighth_list.
                    ls_fcat-tech      = gc_checked.
                  WHEN gc_eleventh_list.
                    ls_fcat-tech      = gc_checked.
                  WHEN gc_25th_list.
                    ls_fcat-seltext_l = text-357.
                    ls_fcat-seltext_m = text-357.
                    ls_fcat-seltext_s = text-357.
                    ls_fcat-ddictxt   = gc_l.
                ENDCASE.
              WHEN 'BUTXT'.
*              WHEN OTHERS.
*                ls_fcat-tech      = gc_checked.
            ENDCASE.
          WHEN gc_header_doc1.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-seltext_l = text-302.
                ls_fcat-seltext_m = text-302.
                ls_fcat-seltext_s = text-302.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-row_pos   = 1.
                ls_fcat-col_pos   = 1.
              WHEN 'ERR_MSG'.
                ls_fcat-tech      = gc_checked.
              WHEN 'B_TBL'.
                ls_fcat-tech      = gc_checked.
              WHEN 'LEV'.
                ls_fcat-tech      = gc_checked.
              WHEN 'RLDNR'.
                ls_fcat-tech      = gc_checked.
              WHEN 'CURR1'.
                ls_fcat-tech      = gc_checked.
              WHEN 'CURTP'.
                ls_fcat-tech      = gc_checked.
              WHEN 'DDTEXT'.
                ls_fcat-seltext_l = ' '.
                ls_fcat-seltext_m = ' '.
                ls_fcat-seltext_s = ' '.
                ls_fcat-ddictxt   = gc_l.
              WHEN OTHERS.
*                ls_fcat-tech      = gc_checked.
            ENDCASE.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname
            AND tabname   = ls_fcat-tabname.
      ENDLOOP.
**
    WHEN gc_17th_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-fieldname.
          WHEN 'BUKRS'.
          WHEN 'BELNR'.
          WHEN 'GJAHR'.
          WHEN 'ERR_MSG'.
          WHEN OTHERS.
            ls_fcat-tech      = gc_checked.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname.
      ENDLOOP.
**
    WHEN gc_23rd_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-tabname.
          WHEN gc_item1.
            CASE ls_fcat-fieldname.
              WHEN 'BELNR'.
              WHEN 'GJAHR'.
              WHEN 'BUZEI'.
                ls_fcat-lzero     = gc_checked.
                ls_fcat-ddictxt   = gc_l.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
          WHEN gc_header1.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-col_pos = 1.
              WHEN 'GLTYPE'.
                ls_fcat-col_pos = 2.
                ls_fcat-outputlen = 25.
                ls_fcat-seltext_l = text-344.
                ls_fcat-seltext_s = text-344.
                ls_fcat-seltext_m = text-344.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'HKONT'.
                ls_fcat-col_pos = 3.
                ls_fcat-seltext_l = text-348.
                ls_fcat-seltext_s = text-348.
                ls_fcat-seltext_m = text-348.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'ERR_MSG'.
                ls_fcat-col_pos = 4.
                ls_fcat-outputlen = 40.
                ls_fcat-seltext_l = text-358.
                ls_fcat-seltext_s = text-358.
                ls_fcat-seltext_m = text-358.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'ERCNT'.
                ls_fcat-row_pos = 2.
                ls_fcat-col_pos = 1.
              WHEN 'RECON'.
                ls_fcat-row_pos = 2.
                ls_fcat-col_pos = 2.
              WHEN 'KONTO'.
                ls_fcat-row_pos = 2.
                ls_fcat-col_pos = 3.
              WHEN 'DDTEXT'.
                ls_fcat-row_pos = 2.
                ls_fcat-col_pos = 4.
                ls_fcat-outputlen = 40.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname
            AND tabname   = ls_fcat-tabname.
      ENDLOOP.
**
    WHEN gc_31st_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-tabname.
          WHEN gc_item12.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-col_pos = 1.
              WHEN 'KONTO'.
                ls_fcat-col_pos = 2.
              WHEN 'ERR_MSG'.
                ls_fcat-col_pos = 3.
                ls_fcat-outputlen = 80.
              WHEN 'RECON'.
                ls_fcat-col_pos = 4.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
          WHEN gc_header11.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
              WHEN 'ERR_MSG'.
                ls_fcat-outputlen = 80.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname
            AND tabname   = ls_fcat-tabname.
      ENDLOOP.

    WHEN gc_32nd_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-tabname.
          WHEN gc_item22.
            CASE ls_fcat-fieldname.
              WHEN 'RLDNR'.
                ls_fcat-col_pos = 1.
                ls_fcat-seltext_l = text-360.
                ls_fcat-seltext_m = text-360.
                ls_fcat-seltext_s = text-360.
                ls_fcat-ddictxt   = gc_l.
              WHEN 'GSBER'.
                ls_fcat-seltext_l = text-355.
                ls_fcat-seltext_m = text-355.
                ls_fcat-seltext_s = text-355.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos = 2.
              WHEN 'PSWSL'.
                ls_fcat-seltext_l = text-351.
                ls_fcat-seltext_m = text-351.
                ls_fcat-seltext_s = text-351.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos = 3.
              WHEN 'FLD'.
                ls_fcat-seltext_l = text-363.
                ls_fcat-seltext_m = text-363.
                ls_fcat-seltext_s = text-363.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos = 4.
              WHEN 'DOCAMT'.
                ls_fcat-seltext_l = text-361.
                ls_fcat-seltext_m = text-361.
                ls_fcat-seltext_s = text-361.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 17.
                ls_fcat-col_pos = 5.
              WHEN 'TBLAMT'.
                ls_fcat-seltext_l = text-362.
                ls_fcat-seltext_m = text-362.
                ls_fcat-seltext_s = text-362.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 17.
                ls_fcat-col_pos = 6.
              WHEN 'DIFAMT'.
                ls_fcat-seltext_l = text-337.
                ls_fcat-seltext_m = text-337.
                ls_fcat-seltext_s = text-337.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 17.
                ls_fcat-col_pos = 7.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
          WHEN gc_header21.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
              WHEN 'ERR_MSG'.
                ls_fcat-outputlen = 80.
              WHEN 'HKONT'.
              WHEN 'DDTEXT'.
                ls_fcat-row_pos   = 2.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname
            AND tabname   = ls_fcat-tabname.
      ENDLOOP.
    WHEN gc_33rd_list OR gc_35th_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-fieldname.
          WHEN 'BUKRS'.
            ls_fcat-col_pos   = 1.
          WHEN 'GLTYPE'.
            ls_fcat-col_pos   = 2.
          WHEN 'ERR_MSG'.
            ls_fcat-col_pos   = 3.
            ls_fcat-outputlen = 60.
          WHEN 'RECON'.
            ls_fcat-col_pos   = 4.
          WHEN OTHERS.
            ls_fcat-tech      = gc_checked.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname.
      ENDLOOP.

    WHEN gc_34th_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-tabname.
          WHEN gc_item24.
            CASE ls_fcat-fieldname.
              WHEN 'UMSKZ'.
                ls_fcat-seltext_l = text-310.
                ls_fcat-seltext_m = text-310.
                ls_fcat-seltext_s = text-310.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos = 1.
              WHEN 'HKONT'.
                ls_fcat-seltext_l = text-348.
                ls_fcat-seltext_m = text-348.
                ls_fcat-seltext_s = text-348.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos = 2.
              WHEN 'DMBTR'.
                ls_fcat-seltext_l = text-361.
                ls_fcat-seltext_m = text-361.
                ls_fcat-seltext_s = text-361.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 17.
                ls_fcat-col_pos = 3.
              WHEN 'DMBT2'.
                ls_fcat-seltext_l = text-362.
                ls_fcat-seltext_m = text-362.
                ls_fcat-seltext_s = text-362.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 17.
                ls_fcat-col_pos   = 4.
              WHEN 'PSWBT'.
                ls_fcat-seltext_l = text-337.
                ls_fcat-seltext_m = text-337.
                ls_fcat-seltext_s = text-337.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 17.
                ls_fcat-col_pos   = 5.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
          WHEN gc_header23.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-col_pos = 1.
              WHEN 'GLTYPE'.
                ls_fcat-seltext_l = text-344.
                ls_fcat-seltext_m = text-344.
                ls_fcat-seltext_s = text-344.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos = 2.
              WHEN 'KONTO'.
                ls_fcat-col_pos = 3.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname
            AND tabname   = ls_fcat-tabname.
      ENDLOOP.
*
    WHEN gc_36th_list.
      LOOP AT xt_fcat INTO ls_fcat.
        CASE ls_fcat-tabname.
          WHEN gc_item28.
            CASE ls_fcat-fieldname.
              WHEN 'UMSKZ'.
                ls_fcat-seltext_l = text-310.
                ls_fcat-seltext_m = text-310.
                ls_fcat-seltext_s = text-310.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos = 1.
              WHEN 'HKONT'.
                ls_fcat-seltext_l = text-348.
                ls_fcat-seltext_m = text-348.
                ls_fcat-seltext_s = text-348.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos = 2.
              WHEN 'DMBTR'.
                ls_fcat-seltext_l = text-361.
                ls_fcat-seltext_m = text-361.
                ls_fcat-seltext_s = text-361.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 17.
                ls_fcat-col_pos = 3.
              WHEN 'DMBT2'.
                ls_fcat-seltext_l = text-362.
                ls_fcat-seltext_m = text-362.
                ls_fcat-seltext_s = text-362.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 17.
                ls_fcat-col_pos   = 4.
              WHEN 'PSWBT'.
                ls_fcat-seltext_l = text-337.
                ls_fcat-seltext_m = text-337.
                ls_fcat-seltext_s = text-337.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-outputlen = 17.
                ls_fcat-col_pos   = 5.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
          WHEN gc_header27.
            CASE ls_fcat-fieldname.
              WHEN 'BUKRS'.
                ls_fcat-col_pos = 1.
              WHEN 'GLTYPE'.
                ls_fcat-seltext_l = text-344.
                ls_fcat-seltext_m = text-344.
                ls_fcat-seltext_s = text-344.
                ls_fcat-ddictxt   = gc_l.
                ls_fcat-col_pos = 2.
              WHEN 'KONTO'.
                ls_fcat-col_pos = 3.
              WHEN OTHERS.
                ls_fcat-tech      = gc_checked.
            ENDCASE.
        ENDCASE.
*
        MODIFY xt_fcat FROM ls_fcat TRANSPORTING
                            tech outputlen col_pos do_sum
                            row_pos offset seltext_s
                            seltext_m seltext_l ddictxt
                            lzero
          WHERE fieldname = ls_fcat-fieldname
            AND tabname   = ls_fcat-tabname.
      ENDLOOP.
*
  ENDCASE.
*
ENDFORM.                    " set_fieldcatalog
*&---------------------------------------------------------------------*
*&      Form  set_layout
*&---------------------------------------------------------------------*
*       Set the Layout of for List.
*----------------------------------------------------------------------*
*      <--XS_LAYO   Layout Structure.
*----------------------------------------------------------------------*
FORM set_layout  CHANGING xs_layo TYPE slis_layout_alv.     "#EC *
*
  IF gv_first_list <> gc_checked.
    xs_layo-list_append       = gc_yes.
    gv_first_list = gc_checked.
  ELSE.
    xs_layo-list_append       = gc_checked.
  ENDIF.
  xs_layo-min_linesize      = gc_len132.
*
  xs_layo-no_totalline      = gc_checked.
  xs_layo-no_uline_hs       = gc_checked.
  CASE gv_counter_outtab.
    WHEN gc_ninenth_list OR gc_12th_list OR gc_26th_list OR
         gc_37th_list OR gc_36th_list.
      xs_layo-no_colhead   = gc_checked.
    WHEN gc_tenth_list OR gc_13th_list OR gc_27th_list OR gc_31st_list
         OR gc_33rd_list OR gc_35th_list OR gc_23rd_list.
      xs_layo-no_colhead   = gc_checked.
  ENDCASE.
ENDFORM.                    " set_layout
*&---------------------------------------------------------------------*
*&      Form  set_print
*&---------------------------------------------------------------------*
*       Set Standard Print Attributes for the List
*----------------------------------------------------------------------*
*      <--XS_PRNT  Print Attribute Structure.
*----------------------------------------------------------------------*
FORM set_print  CHANGING xs_prnt TYPE slis_print_alv.       "#EC *
*
  xs_prnt-no_print_listinfos = gc_checked.
  xs_prnt-no_print_selinfos  = gc_checked.
*
ENDFORM.                    " set_print
*&---------------------------------------------------------------------*
*&      Form  set_events
*&---------------------------------------------------------------------*
*       Set Events for the List.
*----------------------------------------------------------------------*
*      <--XT_EVTS  Internal table to store List Events.
*----------------------------------------------------------------------*
FORM set_events  CHANGING xt_evts TYPE slis_t_event.        "#EC *
*
  DATA: ls_events TYPE slis_alv_event.
*
  ls_events-name = gc_end_of_list.
  ls_events-form = gc_handle_end_of_list.
  APPEND ls_events TO xt_evts.
*
  ls_events-name = gc_top_of_page.
  ls_events-form = gc_handle_top_of_page.
  APPEND ls_events TO xt_evts.
*
  IF gv_counter_outtab = gc_eighth_list OR
     gv_counter_outtab = gc_eleventh_list OR
     gv_counter_outtab = gc_25th_list OR
     gv_counter_outtab = gc_31st_list OR
     gv_counter_outtab = gc_32nd_list.
*
    ls_events-name = slis_ev_after_line_output.
    ls_events-form = gc_after_line_output.
    APPEND ls_events TO xt_evts.
*
    ls_events-name = slis_ev_before_line_output.
    ls_events-form = gc_before_line_output.
    APPEND ls_events TO xt_evts.
  ENDIF.
*
ENDFORM.                    " set_events
*&---------------------------------------------------------------------*
*&      Form  set_group_det
*&---------------------------------------------------------------------*
*       Procedure to Get the Sort and Group Details for List.
*----------------------------------------------------------------------*
*      <--XT_SORT_ACC  Sort and Group Attribute Internal Table.
*----------------------------------------------------------------------*
FORM set_group_det  CHANGING xt_sort_acc TYPE slis_t_sortinfo_alv.
*
  DATA: lv_spos  TYPE i VALUE 0,
        ls_sort_acc TYPE slis_sortinfo_alv.
*
  CASE gv_counter_outtab.
    WHEN gc_first_list.
      ADD 1 TO lv_spos.
      CLEAR ls_sort_acc.
*
    WHEN gc_second_list.
*
      ADD 1 TO lv_spos.
    WHEN gc_forth_list.

      ADD 1 TO lv_spos.
      CLEAR ls_sort_acc.
      ls_sort_acc-fieldname = 'BELNR'.
      ls_sort_acc-spos = lv_spos.
      ls_sort_acc-up = gc_checked.
      ls_sort_acc-subtot = gc_checked.
      ls_sort_acc-group  = 'UL'.
      APPEND ls_sort_acc TO xt_sort_acc.
*
    WHEN gc_sixth_list.
*
      ADD 1 TO lv_spos.
      CLEAR ls_sort_acc.
      ls_sort_acc-tabname   = gc_item1.
      ls_sort_acc-fieldname = 'BUKRS'.
      ls_sort_acc-spos = lv_spos.
      ls_sort_acc-up = gc_checked.
      ls_sort_acc-group  = 'UL'.
      APPEND ls_sort_acc TO xt_sort_acc.
*
      ADD 1 TO lv_spos.
      CLEAR ls_sort_acc.
      ls_sort_acc-tabname   = gc_item1.
      ls_sort_acc-fieldname = 'KONTO'.
      ls_sort_acc-spos = lv_spos.
      ls_sort_acc-up = gc_checked.
      ls_sort_acc-subtot = gc_checked.
      ls_sort_acc-group  = 'UL'.
      APPEND ls_sort_acc TO xt_sort_acc.
*
    WHEN gc_eighth_list OR gc_eleventh_list OR gc_25th_list.
*
      ADD 1 TO lv_spos.
      CLEAR ls_sort_acc.
      ls_sort_acc-tabname     = gc_header_doc1.
      ls_sort_acc-fieldname   = 'BUKRS'.
      ls_sort_acc-spos        = lv_spos.
      ls_sort_acc-up          = gc_checked.
      ls_sort_acc-group       = 'UL'.
      APPEND ls_sort_acc TO xt_sort_acc.
*
  ENDCASE.

ENDFORM.                    " set_group_det
*
*&---------------------------------------------------------------------*
*&      Form  handle_event_end_of_list
*&---------------------------------------------------------------------*
*       Procedure to Handle the End of List Event.
*----------------------------------------------------------------------*
FORM handle_event_end_of_list .                             "#EC CALLED
*
  CASE gv_counter_outtab.
    WHEN gc_first_list.   " Check For BSEG to Account.
      PERFORM write_footer_lines.
      gv_counter_outtab = gc_second_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_summ1.
** Next List
    WHEN gc_second_list.
      MOVE  gc_third_list   TO gv_counter_outtab.
      PERFORM flow_logic_for_alv.
    WHEN gc_third_list.   " Check for Account to BSEG.
      gv_counter_outtab = gc_forth_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_list4.
    WHEN gc_forth_list.
      gv_counter_outtab = gc_fifth_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_summ1.
** Next List
    WHEN gc_fifth_list.
      MOVE  gc_17th_list    TO gv_counter_outtab.
      PERFORM flow_logic_for_alv.
** Next List
    WHEN gc_17th_list.
      PERFORM write_footer_lines.
      MOVE    gc_sixth_list TO gv_counter_outtab.
      PERFORM flow_logic_for_alv.
    WHEN gc_sixth_list.
      gv_counter_outtab = gc_seventh_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_summ1.
** Next List
    WHEN gc_seventh_list.
      gv_counter_outtab = gc_eighth_list.
      PERFORM flow_logic_for_alv.
    WHEN gc_eighth_list.
      gv_counter_outtab = gc_ninenth_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_doc3.
****    WHEN gc_ninenth_list.
***      DESCRIBE TABLE gt_outtab_doc4 LINES gv_tab_lines.
***      IF gv_tab_lines = 0.
***        excute_tr = 1.
***        WRITE:/ sy-vline,
***                gv_head_1,
***                115 sy-vline.
***        ULINE (115).
***        HIDE excute_tr.
****        gv_counter_outtab = gc_eleventh_list.
****        PERFORM flow_logic_for_alv.
***      ELSE.
***        gv_counter_outtab = gc_tenth_list.
***        PERFORM display_alv_summary_list TABLES gt_outtab_doc4.
***      ENDIF.
****
***      IF gv_tenth_cnt = gc_checked.
***        excute_tr = 1.
***        move '@15@' to gv_execute.
***        WRITE:/ sy-vline,
***            gv_execute AS ICON HOTSPOT,
***            'Repair Transaction Figures now ? Company Codes',
***            'with critical documents will not be affected',
***            115 sy-vline.
***        ULINE (115).
***        HIDE excute_tr.
***      ELSE.
***        WRITE:/ sy-vline,
***               'No repairable Differences found',
***               115 sy-vline.
***        ULINE (115).
***      ENDIF.
      IF NOT gv_head_1 IS INITIAL.
        WRITE:/ sy-vline,
                gv_head_1,
                115 sy-vline.
        ULINE (115).
      ENDIF.
      DESCRIBE TABLE gt_outtab_doc4 LINES gv_tab_lines.
      gv_counter_outtab = gc_tenth_list.
      IF gv_counter_outtab > 0.
        PERFORM display_alv_summary_list TABLES gt_outtab_doc4.
      ENDIF.

      IF NOT sy-batch  = 'X'.
        DESCRIBE TABLE tdelta LINES sy-tfill.
        CLEAR excute_tr.
        IF sy-tfill > 0.
          excute_tr = 1.
          MOVE '@15@' TO gv_execute.
          WRITE:/ sy-vline,
                  gv_execute AS ICON HOTSPOT,
                  text-405,
                  115 sy-vline.
          HIDE excute_tr.
          NEW-LINE.
          ULINE (115).
        ELSE.
          WRITE:/ sy-vline,
                  text-404,
                  115 sy-vline.
          NEW-LINE. ULINE (115).
        ENDIF.
      ELSE.
        IF x_repvz = 'X'.
          PERFORM vz_korrigieren.
        ENDIF.
      ENDIF.
      PERFORM write_footer_lines.
      gv_counter_outtab = gc_eleventh_list.
      PERFORM flow_logic_for_alv.
**
    WHEN gc_eleventh_list.
      gv_counter_outtab = gc_12th_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_doc3.
    WHEN gc_12th_list.
      DESCRIBE TABLE gt_outtab_doc4 LINES gv_tab_lines.
      IF gv_tab_lines = 0.
        WRITE:/ sy-vline,
                gv_head_1,
                115 sy-vline.
        ULINE (115).
      ELSE.
        gv_counter_outtab = gc_13th_list.
        PERFORM display_alv_summary_list TABLES gt_outtab_doc4.
      ENDIF.
      IF gv_tenth_cnt = gc_checked.
        excute_tr = 1.
        MOVE '@15@' TO gv_execute.
        WRITE:/ sy-vline,
            gv_execute AS ICON HOTSPOT,
            text-405,
            115 sy-vline.
        ULINE (115).
        HIDE excute_tr.
      ELSE.
        WRITE:/ sy-vline,
               text-404,
            115 sy-vline.
        ULINE (115).
      ENDIF.
      PERFORM write_footer_lines.
    WHEN gc_13th_list.
      gv_counter_outtab = gc_31st_list.
      PERFORM flow_logic_for_alv.
*
**    WHEN gc_31st_list.
**      perform write_footer_lines.
**      gv_counter_outtab = gc_32nd_list.
**      PERFORM display_alv_document_list TABLES gt_outtab_list21
**                                               gt_outtab_list22.
**    WHEN gc_32nd_list.
**      perform write_footer_lines.
**      gv_counter_outtab = gc_33rd_list.
**      PERFORM display_alv_summary_list TABLES gt_outtab_list25.
**    WHEN gc_33rd_list.
**      perform write_footer_lines.
**      gv_counter_outtab = gc_34th_list.
**      PERFORM display_alv_document_list TABLES gt_outtab_list23
**                                               gt_outtab_list24.
**    WHEN gc_34th_list.
**      perform write_footer_lines.
**      gv_counter_outtab = gc_35th_list.
**      PERFORM display_alv_summary_list TABLES gt_outtab_list26.
**    WHEN gc_35th_list.
**      perform write_footer_lines.
**      gv_counter_outtab = gc_36th_list.
**      PERFORM display_alv_document_list TABLES gt_outtab_list27
**                                               gt_outtab_list28.
**    WHEN gc_36th_list.
**      perform write_footer_lines.
**      gv_counter_outtab = gc_37th_list.
**      PERFORM display_alv_summary_list TABLES gt_outtab_list29.
***
**    WHEN gc_37th_list.
**      perform write_footer_lines.
**      gv_counter_outtab = gc_23rd_list.
**      PERFORM flow_logic_for_alv.
    WHEN gc_31st_list.
      gv_print_stat = gc_checked.
      PERFORM write_footer_lines.
      CLEAR gv_table_cnt.
      DESCRIBE TABLE gt_outtab_list21 LINES gv_table_cnt.
      gv_counter_outtab = gc_32nd_list.
      IF gv_table_cnt > 0.
        PERFORM display_alv_document_list TABLES gt_outtab_list21
                                                 gt_outtab_list22.
      ENDIF.
      PERFORM write_footer_lines.
*
      gv_counter_outtab = gc_33rd_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_list25.
      PERFORM write_footer_lines.
*
      DESCRIBE TABLE gt_outtab_list23 LINES gv_table_cnt.
      gv_counter_outtab = gc_34th_list.
      IF gv_table_cnt > 0.
        PERFORM display_alv_document_list TABLES gt_outtab_list23
                                                 gt_outtab_list24.
      ENDIF.
      PERFORM write_footer_lines.
*
      gv_counter_outtab = gc_35th_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_list26.
      PERFORM write_footer_lines.
*
      DESCRIBE TABLE gt_outtab_list27 LINES gv_table_cnt.
      gv_counter_outtab = gc_36th_list.
      IF gv_table_cnt > 0.
        PERFORM display_alv_document_list TABLES gt_outtab_list27
                                                 gt_outtab_list28.
      ENDIF.
      PERFORM write_footer_lines.
*
      gv_counter_outtab = gc_37th_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_list29.
      PERFORM write_footer_lines.
      CLEAR : gv_print_stat.
*
      gv_counter_outtab = gc_23rd_list.
      PERFORM flow_logic_for_alv.

**    WHEN gc_32nd_list.
**      perform write_footer_lines.
**    WHEN gc_33rd_list.
**      perform write_footer_lines.
**    WHEN gc_34th_list.
**      perform write_footer_lines.
**    WHEN gc_35th_list.
**      perform write_footer_lines.
**    WHEN gc_36th_list.
**      perform write_footer_lines.
**    WHEN gc_37th_list.
**      perform write_footer_lines.
**
    WHEN gc_23rd_list.
      PERFORM write_footer_lines.
      gv_counter_outtab = gc_25th_list.
      PERFORM flow_logic_for_alv.

    WHEN gc_25th_list.
      PERFORM write_footer_lines.
      gv_counter_outtab = gc_26th_list.
      PERFORM display_alv_summary_list TABLES gt_outtab_doc3.
    WHEN gc_26th_list.
      DESCRIBE TABLE gt_outtab_doc4 LINES gv_tab_lines.
      IF gv_tab_lines = 0.
        WRITE:/ sy-vline,
                gv_head_1,
                115 sy-vline.
        ULINE (115).
      ELSE.
        gv_counter_outtab = gc_27th_list.
        PERFORM display_alv_summary_list TABLES gt_outtab_doc4.
      ENDIF.
      IF gv_tenth_cnt = gc_checked.
        MOVE '@15@' TO gv_execute.
        WRITE:/ sy-vline,
            gv_execute AS ICON HOTSPOT,
            text-405,
            115 sy-vline.
        ULINE (115).
        HIDE excute_tr.
      ELSE.
        WRITE:/ sy-vline,
               text-404,
           115 sy-vline.
        ULINE (115).
      ENDIF.
      PERFORM write_footer_lines.
  ENDCASE.
**
  IF NOT gv_print_stat = gc_checked.
    GET TIME.
    NEW-LINE.
    ULINE (35).
*   WRITE:/ sy-vline, (11) 'Started at', startdate, starttime, sy-vline.
    WRITE:/ sy-vline, (11) text-500, startdate, starttime, sy-vline.
*   WRITE:/ sy-vline, (11) 'Stopped at', sy-datum, sy-uzeit, sy-vline.
    WRITE:/ sy-vline, (11) text-501, sy-datum, sy-uzeit, sy-vline.
    starttime = sy-uzeit - starttime.
    startdate = sy-datum - startdate.
*   WRITE:/ sy-vline, (11) 'Runtime', startdate, starttime, sy-vline.
    WRITE:/ sy-vline, (11) text-502, startdate, starttime, sy-vline.
    NEW-LINE.
    ULINE (35).
    MOVE gc_checked TO gv_print_stat.
  ENDIF.
**
ENDFORM.                    " handle_event_end_of_list
*
*&---------------------------------------------------------------------*
*&      Form  display_alv_summary_list
*&---------------------------------------------------------------------*
*       Display Second ALV List. For summary Currency wise summary.
*----------------------------------------------------------------------*
*      <--IT_ALV_TABLE    OUTPUT TABLE FOR SINGLE LIST DISPLAY
*----------------------------------------------------------------------*
FORM display_alv_summary_list TABLES lt_alv_table.
  DATA: lt_fcat_list TYPE slis_t_fieldcat_alv,
        ls_layo_list TYPE slis_layout_alv,
        lt_evts_list TYPE slis_t_event,
        ls_prnt_list TYPE slis_print_alv,
        lt_sort_list TYPE slis_t_sortinfo_alv.
* Display Account wise detail list.
  PERFORM set_fieldcatalog CHANGING lt_fcat_list.  "Field Catalog
  PERFORM set_layout       CHANGING ls_layo_list.  "Layout
  PERFORM set_print        CHANGING ls_prnt_list.  "Print attribute
  PERFORM set_events       CHANGING lt_evts_list.  "Events
  PERFORM set_group_det    CHANGING lt_sort_list.  "Sort & Group Inf
*
  PERFORM display_single_list TABLES lt_alv_table
                              USING  lt_fcat_list
                                     lt_evts_list
                                     lt_sort_list
                                     ls_layo_list
                                     ls_prnt_list.
*
ENDFORM.                    " display_alv_summary_list
*
*&---------------------------------------------------------------------*
*&      Form  set_keyinfo_alv
*&---------------------------------------------------------------------*
*       Building the Key Information Table which is the Link between the
*       Header Output Table and the Item Output Table
*----------------------------------------------------------------------*
*      <--XS_KEYINFO  Key Information Table
*----------------------------------------------------------------------*
FORM set_keyinfo_alv  CHANGING xs_keyinfo TYPE slis_keyinfo_alv .
*
  CASE gv_counter_outtab.
    WHEN gc_first_list OR gc_third_list.
      xs_keyinfo-header01 = 'BUKRS'.
      xs_keyinfo-item01   = 'BUKRS'.
*
      xs_keyinfo-header02 = 'BELNR'.
      xs_keyinfo-item02   = 'BELNR'.
*
      xs_keyinfo-header03 = 'GJAHR'.
      xs_keyinfo-item03   = 'GJAHR'.
*
      xs_keyinfo-header04 = 'BUZEI'.
      xs_keyinfo-item04   = 'BUZEI'.
*
    WHEN gc_sixth_list.
      xs_keyinfo-header01 = 'BUKRS'.
      xs_keyinfo-item01   = 'BUKRS'.
*
      xs_keyinfo-header02 = 'KONTO'.
      xs_keyinfo-item02   = 'KONTO'.
*
    WHEN gc_23rd_list.
      xs_keyinfo-header01 = 'BUKRS'.
      xs_keyinfo-item01   = 'BUKRS'.
*
      xs_keyinfo-header02 = 'HKONT'.
      xs_keyinfo-item02   = 'HKONT'.

    WHEN gc_eighth_list OR gc_eleventh_list OR gc_25th_list.
      xs_keyinfo-header01 = 'BUKRS'.
      xs_keyinfo-item01   = 'BUKRS'.
*
      xs_keyinfo-header02 = 'B_TBL'.
      xs_keyinfo-item02   = 'B_TBL'.
*
      xs_keyinfo-header03 = 'LEV'.
      xs_keyinfo-item03   = 'LEV'.
*
    WHEN gc_31st_list.
      xs_keyinfo-header01 = 'BUKRS'.
      xs_keyinfo-item01   = 'BUKRS'.

    WHEN gc_32nd_list.
      xs_keyinfo-header01 = 'BUKRS'.
      xs_keyinfo-item01   = 'BUKRS'.
*
      xs_keyinfo-header02 = 'HKONT'.
      xs_keyinfo-item02   = 'HKONT'.
    WHEN gc_34th_list OR gc_36th_list.
      xs_keyinfo-header01 = 'BUKRS'.
      xs_keyinfo-item01   = 'BUKRS'.
*
      xs_keyinfo-header02 = 'KONTO'.
      xs_keyinfo-item02   = 'KONTO'.
  ENDCASE.
*
ENDFORM.                    " set_keyinfo_alv
*&---------------------------------------------------------------------*
*&      Form  handle_event_pf_status
*&---------------------------------------------------------------------*
*       Set PF Status for the List.
*----------------------------------------------------------------------*
FORM handle_event_pf_status USING rt_extab TYPE slis_t_extab. "#EC *
*
  SET PF-STATUS 'APPEND_RFINDEX_ALV'.
ENDFORM.                    " handle_event_pf_status
*&---------------------------------------------------------------------*
*&      Form  handle_event_top_of_page
*&---------------------------------------------------------------------*
*       Top of Page for the List.
*----------------------------------------------------------------------*
FORM handle_event_top_of_page.                              "#EC *
*
  CASE gv_counter_outtab.
    WHEN gc_first_list.
      WRITE text-301.
    WHEN gc_second_list.
      WRITE gv_head_line1.
    WHEN gc_forth_list.
      WRITE text-335.
    WHEN gc_fifth_list.
      WRITE gv_head.
    WHEN gc_sixth_list.
      WRITE text-402.
    WHEN gc_seventh_list.
      WRITE text-403.
    WHEN gc_eighth_list.
      WRITE text-336.
    WHEN gc_eleventh_list.
      WRITE text-340.
    WHEN gc_25th_list.
      WRITE text-341.
    WHEN gc_ninenth_list OR gc_12th_list OR gc_26th_list.
      WRITE text-338.
    WHEN gc_tenth_list OR gc_13th_list OR gc_27th_list.
      WRITE gv_head.
    WHEN gc_31st_list.
      IF NOT gv_head_line1 IS INITIAL.
        WRITE:/ gv_head_line1.
      ENDIF.
      IF NOT gv_head_line2 IS INITIAL.
        WRITE:/ gv_head_line2.
      ENDIF.
      IF NOT gv_head_line3 IS INITIAL.
        WRITE:/ gv_head_line3.
      ENDIF.
    WHEN gc_37th_list.
      WRITE text-401.
    WHEN gc_17th_list.
      WRITE gv_head_line1.
  ENDCASE.
*
ENDFORM.                    " handle_event_top_of_page
*&---------------------------------------------------------------------*
*&      Form  DISPLAY_SINGLE_LIST
*&---------------------------------------------------------------------*
*       Procedure to display a Simple ALV List.
*----------------------------------------------------------------------*
*      -->IT_TABLE      Internal Table
*      -->IT_FCAT_LIST  Field Catalog
*      -->IT_EVTS_LIST  Events Table
*      -->IT_SORT_LIST  Group and Sort Table
*      -->IS_LAYO_LIST  Layout Structure
*      -->IS_PRNT_LIST  Print Structure
*----------------------------------------------------------------------*
FORM display_single_list
     TABLES   it_table
     USING    it_fcat_list TYPE slis_t_fieldcat_alv
              it_evts_list TYPE slis_t_event
              it_sort_list TYPE slis_t_sortinfo_alv
              is_layo_list TYPE slis_layout_alv
              is_prnt_list TYPE slis_print_alv.
*
  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      i_callback_program       = gv_repid
      i_callback_pf_status_set = gc_pf_status
      i_callback_user_command  = gc_user_command
      i_default                = gc_checked
      is_layout                = is_layo_list
      it_fieldcat              = it_fcat_list
      it_events                = it_evts_list
      it_sort                  = it_sort_list
      is_print                 = is_prnt_list
    TABLES
      t_outtab                 = it_table
    EXCEPTIONS
      program_error            = 1
      OTHERS                   = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
*
ENDFORM.                    " DISPLAY_SINGLE_LIST
*&---------------------------------------------------------------------*
*&      Form  hirerchy_list_display
*&---------------------------------------------------------------------*
*       Procedure to display the Hir-Chy List.
*----------------------------------------------------------------------*
*      -->IT_ALV_TABLE1  Header Table
*      -->IT_ALV_TABLE2  Item Table
*      -->IS_LAYO_LIST   Layout Structure
*      -->IT_FCAT_LIST   Field Catalog
*      -->IT_SORT_LIST   Sort/Group Table
*      -->IT_EVTS_LIST   Events List
*      -->IS_KEYINFO     Key Information
*      -->IS_PRNT_LIST   Print Layout Structure
*      -->IV_HEADER      Header table Name
*      -->IV_ITEM        Item table Name
*----------------------------------------------------------------------*
FORM hirerchy_list_display  TABLES   it_alv_table1 TYPE STANDARD TABLE
                                     it_alv_table2 TYPE STANDARD TABLE
                            USING    is_layo_list TYPE any
                                     it_fcat_list TYPE any
                                     it_sort_list TYPE any
                                     it_evts_list TYPE any
                                     is_keyinfo TYPE any
                                     is_prnt_list TYPE any
                                     iv_header TYPE any
                                     iv_item TYPE any.
*
  CALL FUNCTION 'REUSE_ALV_HIERSEQ_LIST_DISPLAY'
      EXPORTING
*   I_INTERFACE_CHECK              = ' '
       i_callback_program             = gv_repid
       i_callback_pf_status_set       = gc_pf_status
       i_callback_user_command        = gc_user_command
       is_layout                      = is_layo_list
       it_fieldcat                    = it_fcat_list
*   IT_EXCLUDING                   =
*   IT_SPECIAL_GROUPS              =
       it_sort                        = it_sort_list
       it_events                      = it_evts_list
*   IT_EVENT_EXIT                  =
       i_tabname_header               = iv_header
       i_tabname_item                 = iv_item
*   I_STRUCTURE_NAME_HEADER        =
*   I_STRUCTURE_NAME_ITEM          =
       is_keyinfo                     = is_keyinfo
       is_print                       = is_prnt_list
     TABLES
       t_outtab_header                = it_alv_table1
       t_outtab_item                  = it_alv_table2
     EXCEPTIONS
       program_error                  = 1
       OTHERS                         = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

ENDFORM.                    " hirerchy_list_display
*
*&---------------------------------------------------------------------*
*&      Form  Handle_group_level_change.
*&---------------------------------------------------------------------*
*       Procedure to Handle event Group level Change.
*----------------------------------------------------------------------*
*      -->IS_LINEINFO      LINE INFORMATION
*      -->IS_GROUPS        GROUP LEVEL INFORMATION.
*----------------------------------------------------------------------*
FORM handle_group_level_change
                  USING  is_lineinfo   TYPE  slis_lineinfo
                         is_groups     TYPE  kkblo_grouplevels. "#EC *
*
  READ TABLE gt_outtab_doc1 INTO gs_outtab_doc1
       INDEX is_groups-index_to.
  IF sy-subrc = 0.
    IF NOT gs_outtab_doc1-err_msg IS INITIAL.
      WRITE :/ sy-vline,
               gs_outtab_doc1-err_msg.
      WRITE :/(80) sy-uline.
    ENDIF.
  ENDIF.
ENDFORM.                    "handle_group_level_change
*&---------------------------------------------------------------------*
*&      Form  Handle_after_line_output.
*&---------------------------------------------------------------------*
*       Procedure to Handle event after line output.
*----------------------------------------------------------------------*
*      -->IS_LINEINFO      LINE INFORMATION
*----------------------------------------------------------------------*
FORM handle_after_line_output
                  USING  is_lineinfo   TYPE  slis_lineinfo. "#EC CALLED
*
  CASE is_lineinfo-tabname.
    WHEN 'GT_OUTTAB_LIST11'.
      READ TABLE gt_outtab_list11 INTO gs_outtab_list11
      INDEX is_lineinfo-tabindex.
      IF sy-subrc = 0.
        LOOP AT gt_outtab_led
        WHERE led_bukrs = gs_outtab_list11-bukrs.
          WRITE :/ sy-vline,
                 2 gt_outtab_led-led_desc.
          WRITE AT is_lineinfo-linsz sy-vline.
        ENDLOOP.
      ENDIF.
      WRITE :/ sy-uline(is_lineinfo-linsz).
    WHEN 'GT_OUTTAB_DOC1'.
      READ TABLE gt_outtab_doc1 INTO gs_outtab_doc1
      INDEX is_lineinfo-tabindex.
      IF sy-subrc = 0.
        LOOP AT gt_outtab_led
        WHERE led_bukrs = gs_outtab_doc1-bukrs.
          WRITE :/ sy-vline,
                 2 gt_outtab_led-led_desc.
          WRITE AT is_lineinfo-linsz sy-vline.
*              write :/ sy-uline(is_lineinfo-linsz).
        ENDLOOP.
        IF NOT gs_outtab_doc1-err_msg IS INITIAL.
          WRITE :/ sy-vline,
                 7 gs_outtab_doc1-err_msg.
          WRITE AT is_lineinfo-linsz sy-vline.
        ENDIF.
      ENDIF.
      IF NOT gv_line_print = gc_checked.
        WRITE :/ sy-uline(is_lineinfo-linsz).
      ENDIF.
      CLEAR gv_line_print.
  ENDCASE.
*
ENDFORM.                    "handle_group_level_change
*&---------------------------------------------------------------------*
*&      Form  Handle_before_line_output.
*&---------------------------------------------------------------------*
*       Procedure to Handle event before line output.
*----------------------------------------------------------------------*
*      -->IS_LINEINFO      LINE INFORMATION
*----------------------------------------------------------------------*
FORM handle_before_line_output
                  USING  is_lineinfo   TYPE  slis_lineinfo. "#EC CALLED
*
  CASE is_lineinfo-tabname.
    WHEN 'GT_OUTTAB_DOC2'.
      READ TABLE gt_outtab_doc2 INTO gs_outtab_doc2
      INDEX is_lineinfo-tabindex.
      IF NOT gv_hkont EQ gs_outtab_doc2-hkont.
        IF NOT gv_hkont IS INITIAL.
          WRITE :/ sy-uline(is_lineinfo-linsz).
          gv_line_print = gc_checked.
        ENDIF.
      ENDIF.
      gv_hkont = gs_outtab_doc2-hkont.
    WHEN 'GT_OUTTAB_LIST22'.
      READ TABLE gt_outtab_list22 INTO gs_outtab_list22
      INDEX is_lineinfo-tabindex.
      IF gs_outtab_list22-gsber = '****' AND
         gs_outtab_list22-pswsl = '*****'.
        WRITE :/ sy-uline(is_lineinfo-linsz).
      ENDIF.
      IF gs_outtab_list22-gsber = space AND
         gs_outtab_list22-pswsl = '*****'.
        WRITE :/ sy-uline(is_lineinfo-linsz).
      ENDIF.
  ENDCASE.
*
ENDFORM.                    "handle_group_level_change
*&---------------------------------------------------------------------*
*&      Form  set_hir_fieldcat
*&---------------------------------------------------------------------*
*       Set the field catalog for Hirechical List.
*----------------------------------------------------------------------*
*      <--XT_FCAT         Field catalog Table
*      -->IV_HEADER_NAME  Header Table Name
*      -->IV_ITEM_NAME    Item Table Name
*      -->IV_STRUCTURE_NAME1  Header Structure Name
*      -->IV_STRUCTURE_NAME2  Item   Structure Name
*----------------------------------------------------------------------*
FORM set_hir_fieldcat USING    iv_header_name     TYPE slis_tabname
                               iv_item_name       TYPE slis_tabname
                               iv_structure_name1 TYPE dd02l-tabname
                               iv_structure_name2 TYPE dd02l-tabname
                      CHANGING xt_fcat       TYPE slis_t_fieldcat_alv.
**
  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      i_program_name         = gv_repid
      i_internal_tabname     = iv_header_name
      i_structure_name       = iv_structure_name1
    CHANGING
      ct_fieldcat            = xt_fcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
**
  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      i_program_name         = gv_repid
      i_internal_tabname     = iv_item_name
      i_structure_name       = iv_structure_name2
    CHANGING
      ct_fieldcat            = xt_fcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
**
ENDFORM.                    " set_hir_fieldcat

*&---------------------------------------------------------------------*
*&      Form  set_simple_fieldcat
*&---------------------------------------------------------------------*
*       Set the field catalog for For single List.
*----------------------------------------------------------------------*
*      <--XT_FCAT         Field catalog Table
*      -->IV_STRUCTURE_NAME1  Header Structure Name
*----------------------------------------------------------------------*
FORM set_simple_fieldcat USING    iv_structure_name1 TYPE dd02l-tabname
                         CHANGING xt_fcat     TYPE slis_t_fieldcat_alv.
**
  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      i_program_name         = gv_repid
      i_structure_name       = iv_structure_name1
    CHANGING
      ct_fieldcat            = xt_fcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
**
ENDFORM.           "set_simple_fieldcat.

*&--------------------------------------------------------------------*
*&      Form  flow_logic_for_alv
*&--------------------------------------------------------------------*
*       Procedure to print the ALV lists as per selection.
*---------------------------------------------------------------------*
FORM flow_logic_for_alv.
* This Procedure sets the logic for printing the alv
* As per the selected options.

*  PERFORM clear_alv_tables.
  CASE gv_counter_outtab.
    WHEN gc_first_list.
      IF x_bseg = 'X' OR x_heade = 'X'.
        PERFORM bseg_vs_index.
        gv_counter_outtab = gc_first_list.
        PERFORM display_alv_document_list TABLES gt_outtab_list1
                                                 gt_outtab_list2.
      ELSE.
        MOVE  gc_third_list   TO gv_counter_outtab.
        PERFORM flow_logic_for_alv.
      ENDIF.
    WHEN gc_third_list.
      IF x_index = 'X'.
        PERFORM index_vs_bseg.
        MOVE  gc_third_list   TO gv_counter_outtab.
        PERFORM display_alv_document_list TABLES gt_outtab_list1
                                                 gt_outtab_list2.
      ELSE.
        MOVE  gc_17th_list   TO gv_counter_outtab.
        PERFORM flow_logic_for_alv.
      ENDIF.
    WHEN gc_17th_list.
      IF x_rfblg = 'X'.
        IF  sy-dbsys NE 'ORACLE' OR sy-saprl LE '31I'.
          PERFORM rfblg_vs_bkpf.
        ELSE.
          PERFORM rfblg_vs_bkpf_fast.
        ENDIF.
        gv_counter_outtab = gc_17th_list.
        PERFORM display_alv_summary_list TABLES gt_outtab_list1.
      ELSE.
        MOVE  gc_sixth_list   TO gv_counter_outtab.
        PERFORM flow_logic_for_alv.
      ENDIF.
    WHEN gc_sixth_list.
      IF x_clear = 'X'.
        PERFORM clearing_check.
        gv_counter_outtab = gc_sixth_list.
        PERFORM display_alv_document_list TABLES gt_outtab_list1
                                                 gt_outtab_list2.
      ELSE.
        MOVE  gc_eighth_list   TO gv_counter_outtab.
        PERFORM flow_logic_for_alv.
      ENDIF.
    WHEN gc_eighth_list.
      IF x_f070 = 'X'.
        PERFORM f070.
        gv_counter_outtab = gc_eighth_list.
        PERFORM display_alv_document_list TABLES gt_outtab_doc1
                                                 gt_outtab_doc2.
      ELSE.
        MOVE  gc_eleventh_list   TO gv_counter_outtab.
        PERFORM flow_logic_for_alv.
      ENDIF.
    WHEN gc_eleventh_list.
      IF x_f190 = 'X'.
        PERFORM f190.
        gv_counter_outtab = gc_eleventh_list.
        PERFORM display_alv_document_list TABLES gt_outtab_doc1
                                                 gt_outtab_doc2.
      ELSE.
        MOVE  gc_31st_list   TO gv_counter_outtab.
        PERFORM flow_logic_for_alv.
      ENDIF.
    WHEN gc_31st_list.
      IF x_opdate = 'X'.
        PERFORM offene_posten.
        gv_counter_outtab = gc_31st_list.
        PERFORM display_alv_document_list TABLES gt_outtab_list11
                                                 gt_outtab_list12.
      ELSE.
        MOVE  gc_23rd_list   TO gv_counter_outtab.
        PERFORM flow_logic_for_alv.
      ENDIF.
    WHEN gc_23rd_list.
      IF x_duplic = 'X'.
        PERFORM duplicate_indexes.
        gv_counter_outtab = gc_23rd_list.
        PERFORM display_alv_document_list TABLES gt_outtab_list1
                                                 gt_outtab_list2.
      ELSE.
        MOVE  gc_25th_list   TO gv_counter_outtab.
        PERFORM flow_logic_for_alv.
      ENDIF.
    WHEN gc_25th_list.
      IF x_bila = 'X'.
        PERFORM fbila.
*        gv_counter_outtab = gc_25th_list.
        PERFORM display_alv_document_list TABLES gt_outtab_doc1
                                                 gt_outtab_doc2.
      ELSE.
        MOVE 99 TO gv_counter_outtab.
      ENDIF.
  ENDCASE.
*
ENDFORM.                    "flow_logic_for_alv

*&--------------------------------------------------------------------*
*&      Form  Clear_alv_tables
*&--------------------------------------------------------------------*
*       Initialize all Variables and Tables.
*---------------------------------------------------------------------*
FORM clear_alv_tables.
* Clear Internal Table structure.
  CLEAR : gt_outtab_list1,  gs_outtab_list1,
          gt_outtab_list2,  gs_outtab_list2,
          gt_outtab_list3,  gs_outtab_list3 ,
          gt_outtab_list4,  gs_outtab_list4 ,
          gt_outtab_doc1,   gs_outtab_doc1,
          gt_outtab_doc2,   gs_outtab_doc2 ,
          gs_outtab_list11, gs_outtab_list12,
          gs_outtab_list21, gs_outtab_list22,
          gs_outtab_list23, gs_outtab_list24,
          gs_outtab_list25, gs_outtab_list29,
          gt_outtab_list11, gt_outtab_list12,
          gt_outtab_list21, gt_outtab_list22,
          gt_outtab_list23, gt_outtab_list24,
          gt_outtab_list25, gt_outtab_list26,
          gt_outtab_list27, gt_outtab_list28,
          gt_outtab_list29, gt_outtab_doc3,
          gs_outtab_doc3,   gt_outtab_doc4,
          gs_outtab_doc4,   gt_outtab_summ1,
          gs_outtab_summ1,  gt_outtab_led.
* Refresh Internal Tables.
  REFRESH :  gt_outtab_list1,  gt_outtab_list2,
             gt_outtab_list3,  gt_outtab_list4,
             gt_outtab_doc1,   gt_outtab_doc2 ,
             gt_outtab_list11, gt_outtab_list12,
             gt_outtab_list21, gt_outtab_list22,
             gt_outtab_list23, gt_outtab_list24,
             gt_outtab_list25, gt_outtab_list26,
             gt_outtab_list27, gt_outtab_list28,
             gt_outtab_list29, gt_outtab_doc3,
             gt_outtab_doc4,   gt_outtab_summ1,
             gt_outtab_led,    gt_foot_line.
* Clear Variables.
  CLEAR   :  gv_head_line1,    gv_head_line2,
             gv_head_line3,    gv_head_line4,
             gv_head_line5,    gv_head_line6,
             gv_head_line7,    gv_head_line8,
             gv_foot_line1,    gv_foot_line2,
             gv_foot_line3,    gv_foot_line4,
             gv_foot_line5,    gv_foot_line6,
             gv_foot_line7,    gv_foot_line8.
*
ENDFORM.                    "Clear_alv_tables
*&---------------------------------------------------------------------*
*&      Form  write_footer_lines
*&---------------------------------------------------------------------*
*       Procedure to Print the Lines at List Footer.
*----------------------------------------------------------------------*
FORM  write_footer_lines.
**
  DATA : lv_uline_print    TYPE c.
  CLEAR : lv_uline_print.
  LOOP AT gt_foot_line
  WHERE list_no = gv_counter_outtab.
    IF lv_uline_print IS INITIAL.
      ULINE (100).
      lv_uline_print = gc_checked.
    ENDIF.
*
    WRITE:/ sy-vline,
            gt_foot_line-line_print,
        100 sy-vline.
    ULINE (100).
  ENDLOOP.
ENDFORM.                    "write_footer_lines
*
*&---------------------------------------------------------------------*
*&      Form  handle_event_user_command
*&---------------------------------------------------------------------*
*       Procedure to Handle the User Interaction.
*----------------------------------------------------------------------*
*      -->R_UCOMM         User Action.
*      -->RS_SELFIELD     Line selected by the user.
*----------------------------------------------------------------------*
FORM handle_event_user_command USING r_ucomm     TYPE syucomm
                               rs_selfield TYPE slis_selfield. "#EC *
*
*  DATA: sel_field(30)."#EC NEEDED"Field at selection
*
  CASE r_ucomm.
    WHEN '&IC1'.
      CLEAR h_clear.
      CLEAR h_beln2.
      CLEAR excute_tr.
      IF rs_selfield-tabname = 'GT_OUTTAB_LIST2'.
        READ TABLE gt_outtab_list2
        INTO       gs_outtab_list2
        INDEX      rs_selfield-tabindex.
        MOVE-CORRESPONDING gs_outtab_list2 TO h_clear.      "#EC ENHOK
        MOVE gs_outtab_list2-b_tbl   TO h_clear-koart.
      ENDIF.
      IF rs_selfield-tabname = 'GT_OUTTAB_LIST1'.
        READ TABLE gt_outtab_list1
        INTO       gs_outtab_list1
        INDEX      rs_selfield-tabindex.
      ENDIF.
      CASE sy-lsind.
        WHEN 1.
          IF rs_selfield-sel_tab_field = 'GV_EXECUTE'.
            excute_tr = 1.
          ELSE.
            READ LINE sy-lilli INDEX sy-listi.
          ENDIF.
          PERFORM line_selection_1.
        WHEN 2.
          PERFORM line_selection_2.
      ENDCASE.
    WHEN OTHERS.
  ENDCASE.
ENDFORM.                    " handle_event_user_command
*&---------------------------------------------------------------------*
*&      Module  STATUS_3000  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_3000 OUTPUT.
  SET PF-STATUS 'MAINSTAT'.
*  SET TITLEBAR 'xxx'.
*
  PERFORM write_headerline_selection_1
          USING h_clear.

  PERFORM get_at_selection
          USING h_clear.

  NEW-LINE.
  ULINE (100).
  NEW-LINE.
*
  LEAVE TO LIST-PROCESSING AND RETURN TO SCREEN 0.
  LEAVE SCREEN.
ENDMODULE.                 " STATUS_3000  OUTPUT
*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_3000  INPUT
*&---------------------------------------------------------------------*
MODULE user_command_3000 INPUT.
*
  IF gd_ok_code = 'BACK' OR gd_ok_code = 'RW'.
    LEAVE SCREEN.
  ENDIF.
  IF gd_ok_code = '&IC1'.
    PERFORM line_selection_2.
  ENDIF.
*
ENDMODULE.                 " USER_COMMAND_3000  INPUT

AT USER-COMMAND.
  PERFORM line_selection_2.
**-------------------------------------------------------------------**
** END OF CHANGES                                              C5053256
**-------------------------------------------------------------------**
*&---------------------------------------------------------------------*
*&      Form  authority_check
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
form authority_check .
  IF repair   = 'X' OR
     x_delind = 'X' OR
     x_delhd  = 'X' OR
     x_repvz  = 'X'.

    AUTHORITY-CHECK OBJECT 'S_DEVELOP'
             ID 'DEVCLASS' dummy
             ID 'OBJTYPE' FIELD 'DEBUG'
             ID 'OBJNAME' dummy
             ID 'P_GROUP' dummy
             ID 'ACTVT' FIELD '02'.

    IF sy-subrc NE 0.
      MESSAGE e519.
    ENDIF.
  ENDIF.

endform.                    " authority_check

*Text symbol text£º
*001:Gen. Data Selection
*002:Reconcil.
*003:Indexes
*004:Account Select.
*005:Repair Indicat.
*006:Doc. Selection
*007:Output
*008:Clearing
*009:Change transaction figures now?
*010:Documents vs Indexes
*011:Indexes vs Documents
*012:Find Missing BKPF
*013:Find Missing BSEG
*014:Check Clearing
*015:More Detailed
*016:Detailed
*017:Only Summary
*018:All Items
*019:Open Items
*020:Cleared Items
*021:Doc. Trans. Figs
*022:Indexes Trans.Figs
*023:Open Items Total
*024:Find Duplicate Indexes
*025:Check Accounts/FS
*026:No SKB1 data record, transaction figures could not be adjusted for:
*027:No KNB1 data record, transaction figures could not be adjusted for:
*028:No LFB1 data record, transaction figures could not be adjusted for:
*029:Data Rcrds Changed
*030:Before
*031:After
*032:Delta
*033:SKB1-XKRES = Space
*034:and SKB1-XOPVW = "X"
*035:Master record must be corrected, no check possible
*036:Inconsistent Clearing
*037:Data Rec. in Incorrect Table
*038:Other Line Item:
*039:Material Acct
*040:G/L acct
*041:Recon. Acct
*042:Cust.
*043:Vendor
*044:vs BSEG
*045:SKB1-XOPVW=Space&BSEG-AUGBL<>Space, No Update
*046:SKB1-XOPVW=Space&BSEG-AUGBL<>Space
*047:XOPVW = X for Mat. Acct; No BSEG Update
*048:SKB1-XRES Initial; Can Be Deleted
*049:SKB1-XOPVW = X for Account Type M; Correct Master Record First
*050:BSEG-XOPVW = X for Account Type M; Correct Master Record First
*051:KOART_AUS_BSCHL:
*052:No Further Checks
*053:Incorrect KOART and BSCHL; No Further Checks
*054:Mat. acct master record is OI basis; BSEG-XOPVW not set
*055:INCON_CLEARING; No Further Checks
*056:Deleted
*057:Created
*058:Updated
*059:Document
*060:Modified
*061:No Errors
*062:RFBLGs Checked:
*063:RFBLGs Initial:
*064:BKPFs Missing:
*065:CoCd Doc.Number FYear
*066:Statements/Errors
*067:No Error in Reconciliation
*068:Errors Found
*069:Clearing Checked
*070:Indexes Read
*071:BSIS/BSAS Entries with ALE Extern.
*072:External Account Mgt; SKB1-WMETH=X
*073:GLT0 Data Record w/o Mstr Rec
*074:BSIK/BSAK-LIFNR w/o Master
*075:BSIK/BSAK Entries with ALE Extern.
*076:LFC* w/o Master
*077:BSID-/BSAD-KUNNR w/o Master
*078:BSID/BSAD Entries with ALE Extern.
*079:KNC* w/o Master
*080:Extern.ALE
*081:Update Incorrect
*082:Update Successful
*083:Indexes Found
*084:Display Entries in Idx Tab.
*085:Data Recs.
*086:FYear Variant
*087:First Day of Period
*088:could not be determined
*089:Last Day of Period
*090:Open Item Total Before
*092:BSID-/BSAD-HKONT w/o Master
*093:BSIK-/BSAK_HKONT w/o Master
*094:BSIS-/BSAS-HKONT w/o Master
*095:BSIS/BSAS Entries w/o SKB1-XKRES
*096:No Data Records for Company Code
*097:In Tables BSIS or BSAS for Key Specified
*098:Open Item Total/Account Balance Carryfwd
*099:In Tables BSID or BSAD for Key Specified
*100:Total Customer Open Items/Rec. Acct Balance
*101:In Tables BSIK or BSAK for Key Specified
*102:Total Vendor Open Items/Recon. Account Balance
*103:Acct is ALE Sender
*104:Comparison at HKONT, GSBER, PSWSL Level
*105:Error On
*106:Duplicate Indexes Comparison
*107:In Comparisn
*108:Duplic. Indexes In
*109:In
*110:vs
*301:Reconciliation BKPF/BSEG vs Indexes
*302:CCDE
*303:BELNR
*304:Year
*305:Comparison
*306:Account
*307:Report
*308:Tab.
*309:Umsks
*310:Umskz
*311:ClDat
*312:Augbl
*313:AssNo
*314:S
*315:PK
*316:Wrbtr
*317:Dmbtr
*318:Pswbt
*319:XK
*320:XO
*321:XH
*322:Table
*323:BKPF
*324:BSEG
*325:BSIS
*326:BSAS
*327:BSID
*328:BSAD
*329:BSIK
*330:BSAK
*331:Error/Messages
*332:Reconciliation
*334:Account Type
*335:Error in Doc. Sequence in Reconciliation Indexes-Docs
*336:Documents
*337:Difference
*338:Critical Accounts(Acct Type/Acct No./Mess.)
*339:RLDNR
*340:Indexes
*341:Balance
*342:Debit
*343:Credit
*344:GL Type
*345:DMBTR
*346:DMBE2
*347:DMBE3
*348:HKONT
*349:Field
*350:PSWDT
*351:PSWSL
*352:XARCH
*353:Company Code
*354:GJAHR
*355:BUSAR
*356:RTCUR
*357:SpG/L
*358:Error Message
*359:BSIM
*360:RLDNR
*361:Rep. Balance
*362:TransBal
*363:Key
*370:No account will be checked
*371:At least one account must be selected
*372:Remember to select an account type
*373:Confirm
*374:New General Ledger Active
*375:GLT0 cannot be adjusted
*376:No reconciliation type specified
*377:Specify at least one reconciliation type
*378:No account type selected
*379:Select at least one account type
*380:Update run; continue?
*381:No fiscal year specified
*382:Specify a fiscal year
*384:Fixed point arithem. must be deactivated
*385:Company code does not exist
*386:Document Header w/o Items
*387:Document does not bal. to zero or incorrectBSEG-SHKZG
*388:Company Code
*389:Run terminated - posting performed during run
*390:Document that caused termination:
*391:Check Date:
*392:Check Time
*393:Documents without items or that do not balance to zero found; repair not possible
*394:No critical documents found; repair possible
*395:Year
*396:Carryfw
*397:Compare
*398:Bal.
*399:Level
*401:Critical Accounts in Company Code
*402:Check Clearing
*403:Summary of Clearing Check
*404:No Reparable Differences Found
*405:Correct transaction figures now? Company codes with critical documents will not be corrected.
*410:Ledger
*411:HSL Fields: Currency
*412:Cur. type
*413:KSL Fields: Currency
*415:No Differences Found
*417:Summary: Reconciliation BSEG vs INDEX (Update Run)
*418:Summary: Reconciliation BSEG vs INDEX (Test Run)
*419:Summary: Reconciliation INDEX vs BSEG (Update Run)
*420:Summary: Reconciliation INDEX vs BSEG (Test Run)
*421:Find Missing Doc. Headers
*422:No errors occurred in reconciliation to find missing document headers
*423:Summary:
*424:Error
*425:Entries Checked
*426:No Update Run
*427:Fiscal Year Variant
*428:not found. Company code was not checked
*429:Total of Open Items for Acct Balan.
*430:From reconciliation accounts  only possible for all customers
*431:From reconciliation accounts only possible for all vendors
*433:No Company Codes Checked
*434:Duplicate Indexs
*436:Invalid Combination of Selection Parameters
*437:No Differences Found
*500:Started:
*501:Finished:
*502:Runtime:
*550:Level
*551:Compare
*552:No Differences Found
*553:Not checked - check requires area from 01 to

*554:(complete year)
*Selection text£º
*C_BSEG:        Check BSEG for Clearng Info
*PROTOC:        Detailed
*PROTOS:        Summary
*PROTOX:        More Detailed
*P_ANY:        Cleared and Open Items
*P_AUGBL:D       .
*P_AUGDT:D       .
*P_BELNR:D       .
*P_BLART:D       .
*P_BUDAT:D       .
*P_BUKRS:D       .
*P_CL:        Only Cleared Items
*P_CPUDT:D       .
*P_GJAHR:D       .
*P_GSBER:D       .
*P_HKONT:D       .
*P_KUNNR:D       .
*P_LIFNR:D       .
*P_MATNR:D       .
*P_MONAT:D       .
*P_OI:        Open Items Only
*P_PSWSL:D       .
*P_UMSKS:D       .
*P_UMSKZ:D       .
*P_WAERS:D       .
*P_XBLNR:D       .
*REPAIR:        Create/Repair Index
*X_BILA:        Check Financial Statements
*X_BSEG:        Documents vs Indexes
*X_CLEAR:        Check Clearing
*X_DEBI:        Check Customers
*X_DELHD:        Delete BKPF without BSEG
*X_DELIND:        Delete Index without BSEG
*X_DUPLIC:        Find Duplicate Index
*X_F070:        Documents-Transaction Figures
*X_F190:        Indexes - Transaction Figures
*X_HEADE:        Find Missing BSEG
*X_INDEX:        Indexes vs Documents
*X_KREDI:        Check Vendors
*X_MATNR:        Check Material
*X_OPDATE:        Open Items vs Financial State.
*X_REPVZ:        Repair Transaction Figures
*X_RFBLG:        Find Missing BKPF
*X_SAKO:        Check General Ledger
