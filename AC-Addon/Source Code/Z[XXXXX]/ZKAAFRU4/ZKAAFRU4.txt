*&---------------------------------------------------------------------*
*& Report  ZKAAFRU4                                                    *
*&                                                                     *
*&---------------------------------------------------------------------*
*&                                                                     *
*&                                                                     *
*&---------------------------------------------------------------------*

                           .
REPORT ZKAAFRU4 MESSAGE-ID CO.
************************************************************************
* selection of order confirmations with missing CO documents
************************************************************************

TABLES: AFRU, COBK, RESB, AFKO.

DATA:
  AFRU_BT_GES LIKE AFRUB OCCURS 0 WITH HEADER LINE,
  AFRU_BT     LIKE AFRUB OCCURS 0 WITH HEADER LINE,
  OPR_ITAB    LIKE SFC_ITAB OCCURS 0 WITH HEADER LINE,
  BEGIN OF GT_FAIL_GES OCCURS 0,
    AUFNR LIKE CAUFVD-AUFNR,
  END    OF GT_FAIL_GES,
  BEGIN OF GT_FAIL OCCURS 0,
    AUFNR LIKE CAUFVD-AUFNR,
  END    OF GT_FAIL,
  BEGIN OF GT_NOCOST OCCURS 0,
    AUFNR LIKE AFRU-AUFNR,
    RUECK LIKE AFRU-RUECK,
    RMZHL LIKE AFRU-RMZHL,
    VORNR LIKE AFRU-VORNR,
  END   OF GT_NOCOST,
  BEGIN OF GT_FIRST_CONF OCCURS 0,                                  "INS
    RUECK LIKE AFRU-RUECK,                                          "INS
    RMZHL LIKE AFRU-RMZHL,                                          "INS
  END   OF GT_FIRST_CONF,                                           "INS
  G_FIRST_CONF TYPE XFELD,                                          "INS
  G_MEM_ID_FIRST_CONF(40) TYPE C,                                   "INS
  CAUFVD LIKE CAUFVD,
  AFVGD LIKE AFVGD,
  RCR01 LIKE RCR01.

* ---   Dialogtabelle f¨¹r R¨¹ckmeldungen   ---
DATA: BEGIN   OF AFRU_DIA_TAB OCCURS 0.
        INCLUDE STRUCTURE RULST.
DATA: END OF AFRU_DIA_TAB.
* ---   Tabelle der erzeugten R¨¹ckmeldungen zum aktuellen Auftrag   ---
DATA: BEGIN OF RUECK_TAB OCCURS 0.
        INCLUDE STRUCTURE AFRUD.
DATA: END   OF RUECK_TAB.
* ---   Tabelle mit Zusatzfelder f¨¹r Dialogstruktur   ---
DATA: BEGIN   OF AFVGD_DIAL OCCURS 0,
        RUECK LIKE AFVGD-RUECK,
        OBJNR LIKE AFVGD-OBJNR.
        INCLUDE STRUCTURE COOPRINF.
DATA: END OF AFVGD_DIAL.
* ---   Steuerschl¨¹ssel des Vorgangs   ---
DATA: BEGIN OF T430_STRU.
        INCLUDE STRUCTURE T430.
DATA: END   OF T430_STRU.

DATA: G_AUFNR_OLD LIKE CAUFVD-AUFNR.
DATA: FLG_NOCOST  LIKE RC27X-FLG_SEL.
CONSTANTS:
  CON_YX VALUE 'X',
  CHNULL06   LIKE AFVGD-APLFL VALUE '000000',     "Initialwert 6 x Null
  MAX_RMZHL  LIKE AFVGD-RMZHL VALUE 99999999.     "max. Wert R¨¹ckm.z#hl.

SELECT-OPTIONS:
  S_AUFNR FOR AFRU-AUFNR,
  S_RUECK FOR AFRU-RUECK,
  S_RMZHL FOR AFRU-RMZHL,
  S_ERSDA FOR AFRU-ERSDA.

SELECTION-SCREEN SKIP 1.
PARAMETERS:
  P_BUDAT LIKE AFRU-BUDAT,
  TESTRUN LIKE COFI_SCR-FLG_TEST DEFAULT CON_YX.

* Initialisierungen                                                 "INS
  G_MEM_ID_FIRST_CONF = 'FIRST_CONF'.                               "INS

* Achtung: Report ruft sich selbst auf, um eine auftragsweise Buchung
* von Istkosten durchzuf¨¹hren.
  IMPORT AFRU_BT FROM MEMORY ID SY-REPID.
  IF SY-SUBRC = 0.
    IMPORT G_FIRST_CONF FROM MEMORY ID G_MEM_ID_FIRST_CONF.         "INS
*   Aufruf der Kostenbelegerstellung
    PERFORM POST_ACTUAL_COSTS USING P_BUDAT.
    EXPORT GT_FAIL FLG_NOCOST TO MEMORY ID SY-REPID.
    EXIT.
  ENDIF.

  PERFORM SELECT_AFRU
          TABLES S_AUFNR
                 S_RUECK
                 S_RMZHL
                 S_ERSDA.
  IF AFRU_BT_GES[] IS INITIAL.
    WRITE: /5 'Can not find incorrect confirmations for ',
           /5 'specified selection criteria.'.
    EXIT.
  ELSE.
    SORT AFRU_BT_GES BY AUFNR RMZHL.
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    IF TESTRUN IS INITIAL.
      LOOP AT AFRU_BT_GES.
        REFRESH AFRU_BT.
        APPEND AFRU_BT_GES TO AFRU_BT.

*       Erste R¨¹ckmeldung?                                          "INS
        READ TABLE GT_FIRST_CONF WITH KEY RUECK = AFRU_BT_GES-RUECK "INS
                                          RMZHL = AFRU_BT_GES-RMZHL."INS
        IF SY-SUBRC IS INITIAL.                                     "INS
          DELETE GT_FIRST_CONF INDEX SY-TABIX.                      "INS
          G_FIRST_CONF = 'X'.                                       "INS
        ELSE.                                                       "INS
          CLEAR G_FIRST_CONF.                                       "INS
        ENDIF.                                                      "INS
        EXPORT G_FIRST_CONF TO MEMORY ID G_MEM_ID_FIRST_CONF.       "INS

*       Aufruf je R¨¹ckmeldung
        EXPORT AFRU_BT TO MEMORY ID SY-REPID.
        SUBMIT (SY-REPID) AND RETURN.
        IMPORT GT_FAIL FLG_NOCOST FROM MEMORY ID SY-REPID.
        LOOP AT GT_FAIL.
          APPEND GT_FAIL TO GT_FAIL_GES.
        ENDLOOP.
        IF NOT FLG_NOCOST IS INITIAL.
          GT_NOCOST-AUFNR = AFRU_BT_GES-AUFNR.
          GT_NOCOST-RUECK = AFRU_BT_GES-RUECK.
          GT_NOCOST-RMZHL = AFRU_BT_GES-RMZHL.
          GT_NOCOST-VORNR = AFRU_BT_GES-VORNR.
          APPEND GT_NOCOST.
        ENDIF.
      ENDLOOP.
    ENDIF.
    DELETE ADJACENT DUPLICATES FROM GT_FAIL_GES.
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    WRITE: /5 'Confirmations with missing CO documents: '. SKIP.
    WRITE: /5 'Order ' , 17 'Confirmation ' , 32 'Counter ',
           42 'ERSDA ' , 55 'LMNGA ' , 72 'XMNGA '.
    LOOP AT AFRU_BT_GES.
      WRITE: /5 AFRU_BT_GES-AUFNR , 17 AFRU_BT_GES-RUECK ,
             32 AFRU_BT_GES-RMZHL , 42 AFRU_BT_GES-ERSDA ,
             55 AFRU_BT_GES-LMNGA , 72 AFRU_BT_GES-XMNGA.
    ENDLOOP.
    SKIP.
    DESCRIBE TABLE AFRU_BT_GES LINES SY-TABIX.
    WRITE: /5 SY-TABIX, ' Confirmations selected'.
    SKIP.
    DESCRIBE TABLE GT_FAIL_GES LINES SY-TABIX.
    IF SY-TABIX > 0.
      WRITE: /5 SY-TABIX, 'Orders with error'.
      WRITE: /5 'Order'.
      LOOP AT GT_FAIL_GES.
        WRITE: /5 GT_FAIL_GES-AUFNR.
      ENDLOOP.
    ENDIF.
    SKIP.
    DESCRIBE TABLE GT_NOCOST LINES SY-TABIX.
    IF SY-TABIX > 0.
      WRITE: /5 SY-TABIX, 'Confirmations without costs'.
      WRITE: /5 'Order        ConfNo     ConfCnt  Operation'.
      LOOP AT GT_NOCOST.
        WRITE: /5 GT_NOCOST-AUFNR, GT_NOCOST-RUECK,
                  GT_NOCOST-RMZHL, GT_NOCOST-VORNR.
      ENDLOOP.
    ENDIF.
  ENDIF.

*&---------------------------------------------------------------------*
*&      Form  SELECT_AFRU
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*

FORM SELECT_AFRU TABLES P_S_AUFNR STRUCTURE S_AUFNR
                        P_S_RUECK STRUCTURE S_RUECK
                        P_S_RMZHL STRUCTURE S_RMZHL
                        P_S_ERSDA STRUCTURE S_ERSDA.

DATA: BEGIN OF LT_RUECK OCCURS 0,
        RUECK LIKE AFKO-RUECK,
      END   OF LT_RUECK.
DATA: BEGIN OF LT_COBK OCCURS 0,
        REFBN LIKE COBK-REFBN,
        AWORG LIKE COBK-AWORG,
      END   OF LT_COBK.
DATA: BEGIN OF LT_COBK1 OCCURS 0,
        REFBN LIKE COBK-REFBN,
        AWORG LIKE COBK-AWORG,
      END   OF LT_COBK1.

  IF NOT P_S_AUFNR[] IS INITIAL.
    SELECT RUECK FROM AFKO INTO TABLE LT_RUECK
            WHERE AUFNR IN P_S_AUFNR.
    CLEAR P_S_RUECK.
    P_S_RUECK-SIGN = 'I'.
    P_S_RUECK-OPTION = 'EQ'.
    LOOP AT LT_RUECK.
      P_S_RUECK-LOW = LT_RUECK-RUECK.
      APPEND P_S_RUECK.
    ENDLOOP.
  ENDIF.

  SELECT * FROM AFRU INTO CORRESPONDING FIELDS OF TABLE AFRU_BT_GES
          WHERE RUECK IN P_S_RUECK
            AND RMZHL IN P_S_RMZHL
            AND ERSDA IN P_S_ERSDA
**            AND ORIND = '2'
** select also process orders: ORIND = '6'
            AND ( ORIND = '2' OR ORIND = '6'  )
            AND APLZL = 0              "order confirmation
            AND STOKZ = ' '
            AND STZHL = 0
          ORDER BY PRIMARY KEY.
  CHECK NOT AFRU_BT_GES[] IS INITIAL.

* Jeweils erste R¨¹ckmeldung merken                                  "INS
  SELECT RUECK MIN( RMZHL ) FROM AFRU INTO TABLE GT_FIRST_CONF      "INS
   WHERE RUECK IN P_S_RUECK                                         "INS
     AND APLZL = 0                                                  "INS
     AND STOKZ = ' '                                                "INS
     AND STZHL = 0                                                  "INS
   GROUP BY RUECK.                                                  "INS

  LOOP AT AFRU_BT_GES.
    LT_COBK1-REFBN = AFRU_BT_GES-RUECK.
    LT_COBK1-AWORG = AFRU_BT_GES-RMZHL.
    APPEND LT_COBK1.
  ENDLOOP.
  SELECT REFBN AWORG FROM COBK INTO TABLE LT_COBK
         FOR ALL ENTRIES IN LT_COBK1
         WHERE REFBT = 'R'
           AND AWTYP = 'AFRU'
           AND REFBN = LT_COBK1-REFBN
           AND AWORG = LT_COBK1-AWORG.
  SORT LT_COBK BY REFBN AWORG.
  LOOP AT AFRU_BT_GES.
    READ TABLE LT_COBK WITH KEY REFBN = AFRU_BT_GES-RUECK
                                AWORG = AFRU_BT_GES-RMZHL
                                BINARY SEARCH
                       TRANSPORTING NO FIELDS.
    CHECK SY-SUBRC = 0.
    DELETE AFRU_BT_GES.
  ENDLOOP.

ENDFORM.                               " SELECT_AFRU

*-----------------------------------------------------------------------
FORM POST_ACTUAL_COSTS USING I_BUDAT LIKE AFRU-BUDAT.

  DATA: AUFNR_PRE LIKE ORD_PRE OCCURS 0 WITH HEADER LINE.
* ---   Sicherungstabelle der einzulesenden Auftr#ge   ---
  DATA: TMP_AUFNR_PRE LIKE ORD_PRE OCCURS 0 WITH HEADER LINE.
  DATA: BEGIN OF AFRU_PRE OCCURS 0,
          RUECK LIKE AFRU-RUECK,
          RMZHL LIKE AFRU-RMZHL,
        END   OF AFRU_PRE.
  DATA: BEGIN OF ITAB OCCURS 0,
          RUECK LIKE AFRU-RUECK,
          RMZHL LIKE AFRU-RMZHL,
          TABIX LIKE SY-TABIX,
        END   OF ITAB.
* ---   Umbewertungstbelle f¨¹r simulierten WE und WA im A.Netz   ---
  DATA: BEGIN OF TMP_UMB_TAB OCCURS 0.
          INCLUDE STRUCTURE CONF_UMB.
  DATA: END   OF TMP_UMB_TAB.
* ---   Funktionen zur Istkostenermittlung laut RWIN-Schnittstelle   ---
  DATA: BEGIN OF TKOMP OCCURS 0,
          FUNCTION LIKE TRWPR-FUNCTION,
        END   OF TKOMP.
* ---   Tabelle f¨¹r Meldungen aus der Budgetverprobung   ---
*  DATA: TMP_MESG    LIKE MESG OCCURS 0.                            "DEL
  DATA: TCA11_STR   LIKE TCA11.
* --- Hilfsfelder   ---
  DATA: TMP_CMFNR   LIKE CMFP-NR,
        TMP_GJAHR   LIKE COEP-GJAHR,
        TMP_POST    LIKE RC27X-FLG_SEL,
        TMP_SUBRC   LIKE SY-SUBRC,
        TMP_TABIX   LIKE SY-TABIX,
        TABIX   LIKE SY-TABIX,
        L_AUFNR_OLD LIKE CAUFVD-AUFNR.
  CONSTANTS:
        APLID_PPRU LIKE CMFP-APLID    VALUE 'PPRU',
        EVENT      LIKE TRWPR-EVENT   VALUE 'RUECK',
      MAX_RMZHL  LIKE AFVGD-RMZHL VALUE 99999999, "max. Wert R¨¹ckm.z#hl.
        PROCESS    LIKE TRWPR-PROCESS VALUE 'FAUF'.

  REFRESH AUFNR_PRE.
  LOOP AT AFRU_BT.
    AUFNR_PRE-AUFNR = AFRU_BT-AUFNR.
    APPEND AUFNR_PRE.
    AFRU_BT-AUFNR_T = AFRU_BT-AUFNR.
    AFRU_BT-VBKZ = 'I'.
    MODIFY AFRU_BT TRANSPORTING VBKZ AUFNR_T.
  ENDLOOP.
  SORT AUFNR_PRE BY AUFNR.
  DELETE ADJACENT DUPLICATES FROM AUFNR_PRE.
  CHECK NOT AUFNR_PRE[] IS INITIAL.
* Tabelle der betroffenen Auftr#ge kopieren, da der Baustein
* CO_DB_ORDER_PRE_READ Auftragsnummern l#scht, wenn die Daten
* in der gleichen Task bereits zuvor bereitgestellt wurden
  TMP_AUFNR_PRE[] = AUFNR_PRE[].
  CLEAR TCA11_STR.
  TCA11_STR-FLG_ALT = CON_YX.
  TCA11_STR-FLG_OPR = CON_YX.
* Auftragsdaten (Kopf und Vorg#nge) einlesen
  CALL FUNCTION 'CO_DB_ORDER_PRE_READ'
       EXPORTING
            FLG_CHECK          = CON_YX
            OBJECTS            = TCA11_STR
            FLG_NO_GUI_MESSAGE = CON_YX
            FLG_NO_BANF        = CON_YX
       TABLES
            ORD_PRE_IMP        = TMP_AUFNR_PRE
       EXCEPTIONS
            NOT_FOUND          = 01
            RELEASE_NO_CHANGE  = 02.
* Interne Tabelle neu aufbauen
  CALL FUNCTION 'CO_IT_SET_FLG_ITAB_NEW'.
* gesamte Itab der Vorg#nge und Untervorg#nge bereitstellen
  CALL FUNCTION 'CO_IT_OPR_READ_COMPLETE'
       EXPORTING
            FLG_UVO  = CON_YX
       TABLES
            OPR_ITAB = OPR_ITAB.
*
  REFRESH ITAB.
  LOOP AT AFRU_BT.
    ITAB-RUECK = AFRU_BT-RUECK.
    ITAB-RMZHL = AFRU_BT-RMZHL.
    ITAB-TABIX = SY-TABIX.
    APPEND ITAB.
  ENDLOOP.
  SORT ITAB BY RUECK RMZHL.
* Wenn Kopfr¨¹ckmeldung, dann Dummyr¨¹ckmeldungen f¨¹r betroffene
* Vorg#nge dazugenerieren
  CLEAR L_AUFNR_OLD.
  LOOP AT AFRU_BT.
    IF AFRU_BT-AUFNR <> L_AUFNR_OLD.
*     Auftragskopf einlesen
      CALL FUNCTION 'CO_BT_CAUFV_READ_WITH_KEY'
           EXPORTING
                AUFNR_ACT      = AFRU_BT-AUFNR
                NO_DIALOG_INFO = CON_YX
           IMPORTING
                CAUFVD_EXP     = CAUFVD
           EXCEPTIONS
                NOT_FOUND      = 1
                OTHERS         = 2.
      L_AUFNR_OLD = CAUFVD-AUFNR.
    ENDIF.
*   Pr¨¹fen, ob f¨¹r Kopfr¨¹ckmeldung die tempor#ren R¨¹ckmeldungen
*   bereits aus anderen R¨¹ckmeldeprozessen vorhanden sind
*   tempor#re R¨¹ckmeldungen f¨¹r Kopfr¨¹ckmeldung aufbauen
    PERFORM ADD_DUMMY_CONF_FOR_ALL_OPER USING AFRU_BT
                                              'H'
                                              CAUFVD-AUFPL
                                              I_BUDAT.
  ENDLOOP.

* Funktion zur Istkostenermittlung aus RWIN-Schnittstelle bereitstellen
* Gesch#ftsjahr setzen
  TMP_GJAHR = SY-DATLO(4).
  CALL FUNCTION 'RWIN_CHECK'
       EXPORTING
            EVENT   = EVENT
            GJAHR   = TMP_GJAHR
            PROCESS = PROCESS
       TABLES
            TKOMP   = TKOMP.
* Istkostenermittlung erfolgt auftragsweise
  LOOP AT AUFNR_PRE.
    CLEAR TMP_POST.
*   Auftragskopf einlesen
    CALL FUNCTION 'CO_BT_CAUFV_READ_WITH_KEY'
         EXPORTING
              AUFNR_ACT      = AUFNR_PRE-AUFNR
              NO_DIALOG_INFO = CON_YX
         IMPORTING
              CAUFVD_EXP     = CAUFVD
         EXCEPTIONS
              NOT_FOUND      = 1
              OTHERS         = 2.
    CHECK SY-SUBRC = 0.
*   Istkostenermittlung nur wenn "Kalkulationsvariate Ist gesetzt" ist
    CHECK NOT CAUFVD-KLVARI IS INITIAL.
    IF NOT CAUFVD-PRODNET IS INITIAL AND
       CAUFVD-AUFNR <> CAUFVD-LEAD_AUFNR.
*     Im Auftragsnetz bei untergeordneten Auftr#gen ist der letzte
*     Vorgang zu bestimmen
      PERFORM DET_LAST_OPER USING CAUFVD-AUFNR TMP_SUBRC.
      IF TMP_SUBRC = 0.
*       Die r¨¹ckgemeldeten Daten zum letzten Vorgang sind f¨¹r das
*       CO bereitzustellen, damit die Bewertung des simulierten WE und
*       WA's erfolgen kann.
        REFRESH TMP_UMB_TAB.
        LOOP AT AFRU_BT WHERE AUFNR_T = CAUFVD-AUFNR
                        AND   VBKZ    = 'I'
                        AND   APLZL IS INITIAL.
*         Kopfr¨¹ckmeldungen sammeln
          MOVE-CORRESPONDING AFRU_BT TO TMP_UMB_TAB.
          APPEND TMP_UMB_TAB.
        ENDLOOP.
*       Daten in FUGR CORF ¨¹bernehmen
        CALL FUNCTION 'CO_RU_FILL_CONF_TAB_LAST_OPR'
             TABLES
                  CONF_TAB = TMP_UMB_TAB
             EXCEPTIONS
                  OTHERS   = 0.
      ENDIF.
    ENDIF.
    LOOP AT TKOMP.
*     CO-Baustein zur Kostenermittlung aufrufen
      CALL FUNCTION TKOMP-FUNCTION
           EXPORTING
                CAUFVD_IMP = CAUFVD
                PROTOCOL   = SPACE
           EXCEPTIONS
*               NO_COSTING = 01.                                    "DEL
                NO_COSTING = 01                                     "INS
                NO_KALKTAB = 02.                                    "INS
**     Meldungen der Budgetverprobung einlesen                      "DEL
*      CALL FUNCTION 'MESSAGES_GIVE'                                "DEL
*           TABLES                                                  "DEL
*                T_MESG = TMP_MESG.                                 "DEL
*      IF NOT TMP_MESG[] IS INITIAL.                                "DEL
**       Sind Meldungen aus der Budgetverprobung vorhanden, so ist auf
**       alle F#lle das Protokoll anzuzeigen, unabh. vom Cust.-Parameter
*        FREE TMP_MESG.                                             "DEL
*      ENDIF.                                                       "DEL
*     Meldungen der Budgetverprobung in Kostenprotokoll ¨¹bernehmen
      CALL FUNCTION 'CM_F_SMSG_MESSAGES_READ'.
*     Enth#lt das Kostenprotokoll Fehlermeldungen ?
      CALL FUNCTION 'CK_F_COSTING_PROTOCOL'
           EXPORTING
                APLID        = APLID_PPRU
                PROTOCOL     = 'E'
           EXCEPTIONS
                ERRORS_FOUND = 01.
*     pr¨¹fen, ob Fehler bei der Istkostenermittlung ?
      IF SY-SUBRC = 0.
*       keine Fehler bei der Istkostenermittlung
        TMP_POST = CON_YX.
*       Ist der aktuelle Auftrag Bestandteil eines Auftragsnetzes, so
*       m¨¹ssen bei einer Simulation des Wareneingangs mit sofortigem
*       Warenausgang die ermittelten Werte im untergeordneten Auftrags-
*       kopf und in der auftragsverursachenden Reservierung fortge-
*       schrieben werden.
        DATA: BEGIN OF LT_AUFNRLOCK OCCURS 0,
                AUFNR LIKE CAUFVD-AUFNR,
              END   OF LT_AUFNRLOCK,
              LT_KALKTAB   LIKE CKKALKTAB  OCCURS 0 WITH HEADER LINE,
              LT_RESBDIR   LIKE RESBDIRCNF OCCURS 0 WITH HEADER LINE,
              LS_AFPOD     LIKE AFPOD,
              L_TABIX      LIKE SY-TABIX.
        CONSTANTS: AENDERN    LIKE TC10-TRTYP  VALUE 'V'.
        CONSTANTS: TYPPS_H LIKE CKKALKTAB-TYPPS VALUE 'H'.

*         Kalkulationstabelle zum aktuellen Auftrag bereitstellen
          CALL FUNCTION 'CK_F_ORDER_KALKTAB_GET'
               EXPORTING
                    AUFNR       = CAUFVD-AUFNR
               TABLES
                    KALKTAB_IST = LT_KALKTAB
               EXCEPTIONS
                    NOT_FOUND   = 1
                    OTHERS      = 2.
        IF NOT LT_KALKTAB[] IS INITIAL.
          CLEAR FLG_NOCOST.
        ELSE.
          FLG_NOCOST = CON_YX.
        ENDIF.
        IF CAUFVD-AUFNR <> CAUFVD-LEAD_AUFNR AND
           NOT CAUFVD-LEAD_AUFNR IS INITIAL.
          LOOP AT LT_KALKTAB WHERE TYPPS = TYPPS_H
                             AND NOT WRTFW_KPF IS INITIAL.

            READ TABLE LT_AUFNRLOCK WITH KEY AUFNR = CAUFVD-AUFNR
                                             BINARY SEARCH.
            IF SY-SUBRC <> 0.
              L_TABIX = SY-TABIX.
              CALL FUNCTION 'CO_RU_ORDER_LOCK'
                   EXPORTING
                        AUFNR_IMP            = CAUFVD-AUFNR
                        AUTYP_IMP            = CAUFVD-AUTYP
                   EXCEPTIONS
                        ORDER_ALREADY_LOCKED = 1
                        OTHERS               = 2.
              IF SY-SUBRC <> 0.
*               Auftrag konnte nicht gesperrt werden
                MESSAGE A889(CO) WITH 'AUFNR' CAUFVD-AUFNR 'LOCKED'.
              ENDIF.
              LT_AUFNRLOCK-AUFNR = CAUFVD-AUFNR.
              INSERT LT_AUFNRLOCK INDEX L_TABIX.
*             Ungesperrt eingelesene Auftragsdaten m¨¹ssen nachgelesen
*             werden. Dazu sind zuerst Auftragsdaten aus den
*             Belegtabellen zu entfernen
              REFRESH TMP_AUFNR_PRE.
              TMP_AUFNR_PRE-AUFNR = CAUFVD-AUFNR.
              APPEND TMP_AUFNR_PRE.
              CALL FUNCTION 'CO_IT_DEL_ORDER_FROM_DOC_TAB'
                   TABLES
                        AUFNR_TAB = TMP_AUFNR_PRE.
*             Auftragsdaten neu nachlesen
              CLEAR TCA11_STR.
              TCA11_STR-FLG_ALT = CON_YX.
              TCA11_STR-FLG_OPR = CON_YX.
*             Auftragsdaten (Kopf und Vorg#nge) einlesen
              CALL FUNCTION 'CO_DB_ORDER_PRE_READ'
                   EXPORTING
                        FLG_CHECK          = CON_YX
                        OBJECTS            = TCA11_STR
                        FLG_NO_GUI_MESSAGE = CON_YX
                        FLG_NO_BANF        = CON_YX
                        TRTYP_IMP          = AENDERN
                   TABLES
                        ORD_PRE_IMP        = TMP_AUFNR_PRE
                   EXCEPTIONS
                        NOT_FOUND          = 01
                        RELEASE_NO_CHANGE  = 02.
*             Interne Tabelle neu aufbauen
              CALL FUNCTION 'CO_IT_SET_FLG_ITAB_NEW'.
            ENDIF.
*           erste Auftragspositionen bestimmen
          CALL FUNCTION 'CO_BI_AFPO_SET'                    "160428
               EXPORTING                                    "160428
                    AUFNR_ACT       = CAUFVD-AUFNR          "160428
               EXCEPTIONS                                   "160428
                    ENTRY_NOT_FOUND = 1                     "160428
                    TABLE_EMPTY     = 2                     "160428
                    OTHERS          = 3.                    "160428
          IF SY-SUBRC = 0.                                  "160428
            CALL FUNCTION 'CO_BI_AFPO_GET'                  "160428
                 EXPORTING                                  "160428
                      AUFNR_ACT     = CAUFVD-AUFNR          "160428
                 IMPORTING                                  "160428
                      AFPOD_EXP     = LS_AFPOD              "160428
                 EXCEPTIONS                                 "160428
                      EOF           = 1                     "160428
                      OTHERS        = 2.                    "160428
            ENDIF.
            IF SY-SUBRC <> 0.
              MESSAGE A889(CO) WITH 'AUFNR' CAUFVD-AUFNR 'NOT FOUND'.
            ENDIF.
*           Direktfertigungsbaugruppe einlesen
            READ TABLE LT_RESBDIR WITH KEY RSNUM = CAUFVD-ARSNR
                                           RSPOS = CAUFVD-ARSPS
                                           BINARY SEARCH.
            L_TABIX = SY-TABIX.
            IF SY-SUBRC <> 0.
*             Reservierung sperren
              CALL FUNCTION 'CO_ZF_RESERVATION_LOCK'
                   EXPORTING
                        RSNUM                = CAUFVD-ARSNR
                   EXCEPTIONS
                        RESER_ALREADY_LOCKED = 1
                        SYSTEM_FAILURE       = 2
                        OTHERS               = 3.
              IF SY-SUBRC <> 0.
*               Reservierung konnte nicht gesperrt werden
                MESSAGE A889(CO) WITH 'RSNUM' CAUFVD-ARSNR 'LOCKED'.
              ENDIF.
              SELECT SINGLE
                     RSNUM RSPOS RSART
                     MEINS ENMNG
                     KZEAR ENWRT
                     FROM RESB
                     INTO CORRESPONDING FIELDS OF LT_RESBDIR
                     WHERE RSNUM = CAUFVD-ARSNR
                     AND   RSPOS = CAUFVD-ARSPS.
              IF SY-SUBRC <> 0.
                MESSAGE A889 WITH 'RSNUM' CAUFVD-ARSNR 'NOT FOUND'.
              ENDIF.
              INSERT LT_RESBDIR INDEX L_TABIX.
            ENDIF.
*           Wert der entnommenen Baugruppe fortschreiben
            IF LT_KALKTAB-STZHL IS INITIAL.
              LT_RESBDIR-ENWRT = LT_RESBDIR-ENWRT
                               - LT_KALKTAB-WRTFW_KPF.
            ELSE.
              LT_RESBDIR-ENWRT = LT_RESBDIR-ENWRT
                               + LT_KALKTAB-WRTFW_KPF.
            ENDIF.
            MODIFY LT_RESBDIR INDEX L_TABIX.
*           Wareneingangswert der Auftragsposition fortschreiben
            LS_AFPOD-WEWRT = LT_RESBDIR-ENWRT.
            CALL FUNCTION 'CO_BI_AFPO_PUT'                  "160428
                 EXPORTING                                  "160428
                      AFPOD_NEW = LS_AFPOD                  "160428
                 EXCEPTIONS                                 "160428
                      NOT_FOUND = 1                         "160428
                      OTHERS    = 2.                        "160428
          ENDLOOP.
        ENDIF.
      ELSE.
*       ein Fehler trat auf: Auftrag merken
        GT_FAIL-AUFNR = CAUFVD-AUFNR.
        APPEND GT_FAIL.
      ENDIF.
    ENDLOOP.
    IF NOT GT_FAIL[] IS INITIAL.
      EXIT.
    ENDIF.
  ENDLOOP.
* von hier alle Meldungen wieder auf Bildschirm senden "P40K057784 4.0B
  CALL FUNCTION 'CM_F_INITIALIZE'      "P40K057784 4.0B
       EXPORTING                       "P40K057784 4.0B
            MSG_ON_SCREEN = CON_YX     "P40K057784 4.0B
       EXCEPTIONS                      "P40K057784 4.0B
            OTHERS        = 1.         "P40K057784 4.0B
  CALL FUNCTION 'MESSAGES_STOP'        "P40K057784 4.0B
       EXCEPTIONS                      "P40K057784 4.0B
            OTHERS = 1.                "P40K057784 4.0B
* Nicht buchen bei Fehlern aus der Istkostenermittlung
  CHECK GT_FAIL[] IS INITIAL.

* Aufruf der Verbuchung der Auftragsdaten, falls n#tig     "note 127662
  IF NOT LT_AUFNRLOCK[] IS INITIAL.                        "note 127662
    CALL FUNCTION 'CO_ZV_ORDER_POST'                       "note 127662
         EXPORTING                                         "note 127662
              EXT_FLG             = CON_YX                 "note 127662
              FLG_ACT             = CON_YX                 "note 127662
              FLG_USER            = CON_YX                 "note 127662
              TRANS_TYP           = AENDERN                "note 127662
              FLG_CALLED_FROM_PDC = CON_YX                 "note 127662
         EXCEPTIONS                                        "note 127662
              OTHERS              = 1.                     "note 127662
    CALL FUNCTION 'CO_RU_VB_CONFIRMATION_POST' IN UPDATE TASK
         TABLES
              RESB_DIR = LT_RESBDIR                        "note 127662
         EXCEPTIONS
              OTHERS   = 0.
  ENDIF.                                                   "note 127662

  COMMIT WORK.

ENDFORM.

*-----------------------------------------------------------------------
FORM ADD_DUMMY_CONF_FOR_ALL_OPER USING IT_AFRUB LIKE AFRUB
                                       ADC_AKTYP LIKE RC27S-AKTYP
                                       ADC_AUFPL LIKE AFVGD-AUFPL
                                       I_BUDAT   LIKE AFRU-BUDAT.
*----------------------------------------------------------------------*
*       bei R¨¹ckmeldung zum Auftragskopf sind tempor#r R¨¹ckmeldes#tze  *
*       zu allen r¨¹ckmeldepflichtigen Vorg#ngen in die Belegtabelle    *
*       einzuf¨¹gen                                                     *
*----------------------------------------------------------------------*

DATA: BEGIN OF TMP_AFVGDG_TAB OCCURS 0.
        INCLUDE STRUCTURE AFVGDGET.
DATA: END   OF TMP_AFVGDG_TAB.
DATA: BEGIN OF TMP_AFRUD.
        INCLUDE STRUCTURE AFRUD.
DATA: END   OF TMP_AFRUD.
DATA: BEGIN OF TMP_AFRUD_SAV.
        INCLUDE STRUCTURE AFRUD.
DATA: END   OF TMP_AFRUD_SAV.
DATA: TMP_LMNGA TYPE F,               "r¨¹ckgemeldete Gutmenge
      TMP_RMNGA TYPE F,               "r¨¹ckgemeldete Nacharbeitsmenge
      TMP_XMNGA TYPE F,               "r¨¹ckgemeldeter Ausschuss
      TMP_SMENG LIKE AFRUD-LMNGA,     "r¨¹ckgemeldete Menge gesamt
      TMP_ABARB LIKE AFRUD-ABARB,     "Abarbeitungsgrad
      TMP_FLG_XMNGA LIKE RC27X-FLG_SEL, "Kennzeichen Ausschu# gesetzt
      TMP_TABIX LIKE SY-TABIX.        "Index zum Lesen der Tabelle
DATA: MENG1_F   TYPE F,                         "Floatingpoint-Hilfsfeld
      MENG2_F   TYPE F,                         "Floatingpoint-Hilfsfeld
      MENG3_F   TYPE F.                         "Floatingpoint-Hilfsfeld
DATA: L_ACTIVITY_NO_FIX TYPE XFELD.   "Keine fixen Leistungen       "INS


* Kennzeichen Auftragsr¨¹ckmeldung im CORF setzen
  CALL FUNCTION 'CO_RU_SET_FLG_ORDER_CONF'.
* Aufragskopfdaten in CORF setzen
  CALL FUNCTION 'CO_RU_SET_CAUFVD'
       EXPORTING
            CAUFVD_IMP = CAUFVD.

  IF G_FIRST_CONF IS INITIAL.                                       "INS
    L_ACTIVITY_NO_FIX = 'X'.                                        "INS
  ELSE.                                                             "INS
    CLEAR L_ACTIVITY_NO_FIX.                                        "INS
  ENDIF.                                                            "INS

* Reset Kennzeichen Ausschu# gesetzt
  CLEAR TMP_FLG_XMNGA.
* Original-R¨¹ckmeldung retten
  MOVE-CORRESPONDING IT_AFRUB TO TMP_AFRUD_SAV.
  IF CAUFVD-FLG_ARBEI IS INITIAL
     OR caufvd-autyp = '40'.
    TMP_LMNGA = IT_AFRUB-LMNGA.
    TMP_RMNGA = IT_AFRUB-RMNGA.
    TMP_XMNGA = IT_AFRUB-XMNGA.
    IF NOT IT_AFRUB-MEINH IS INITIAL AND
       IT_AFRUB-MEINH <> CAUFVD-GMEIN.
*     Umrechnung Gutmenge in Mengeneinheit des Auftragskopfes
      PERFORM CONV_CNF_MEINH_TO_HDR_GMEIN USING TMP_LMNGA IT_AFRUB-MEINH
                                                TMP_LMNGA CAUFVD-GMEIN.
*     Umrechnung Nacharbeitsmenge in Mengeneinheit des Auftragskopfes
      PERFORM CONV_CNF_MEINH_TO_HDR_GMEIN USING TMP_RMNGA IT_AFRUB-MEINH
                                                TMP_RMNGA CAUFVD-GMEIN.
*     Umrechnung Ausschu# in Mengeneinheit des Auftragskopfes
      PERFORM CONV_CNF_MEINH_TO_HDR_GMEIN USING TMP_XMNGA IT_AFRUB-MEINH
                                                TMP_XMNGA CAUFVD-GMEIN.
    ENDIF.
  ELSE.
*   Abarbeitungsgrad merken
    TMP_ABARB = IT_AFRUB-ABARB.
    TMP_ABARB = TMP_ABARB -  CAUFVD-ABARB.
    IF TMP_ABARB < 0.
      TMP_ABARB = 0.
    ENDIF.
  ENDIF.
* alle Vorg#nge des Auftrags bereitstellen
  CALL FUNCTION 'CO_BO_OPR_OF_ORDER_GET'
       EXPORTING
            AUFNR_IMP = CAUFVD-AUFNR
       TABLES
            AFVGD_GET = TMP_AFVGDG_TAB.
  SORT TMP_AFVGDG_TAB BY APLFL VORNR UVORN.
  DESCRIBE TABLE TMP_AFVGDG_TAB LINES TMP_TABIX.
* Soll-Leistungen zu allen r¨¹ckmeldepflichtigen Vorg#ngen ermitteln
  WHILE TMP_TABIX > 0.
    READ TABLE TMP_AFVGDG_TAB INDEX TMP_TABIX.
    IF SY-SUBRC <> 0.
      EXIT.
    ENDIF.
*   keine alternative Vorg#nge
    IF TMP_AFVGDG_TAB-FLGAT = '2'.
      TMP_TABIX = TMP_TABIX - 1.
      CHECK 1 = 2.
    ENDIF.
    MOVE TMP_AFVGDG_TAB TO AFVGD.
*   Zusatzdaten der Dialogstruktur ¨¹bernehmen
    PERFORM FILL_AFVGD_DIAL_DATA.
*   keine alternative Vorg#nge, keine gel#schten Vorg#nge
*   nur r¨¹ckmeldef#hige Vorg#nge
    IF AFVGD-FLGAT = '2'   OR
       NOT AFVGD-FLG_LOE IS INITIAL OR
       AFVGD-FLG_RCK = '3'.
      TMP_TABIX = TMP_TABIX - 1.
      CHECK 1 = 2.
    ENDIF.
    IF AFVGD-ARBID <> RCR01-ARBID.
*     Arbeitsplatzdaten aktualisieren
      IF NOT AFVGD-ARBID IS INITIAL.
        CALL FUNCTION 'CO_RU_DET_ARBPL'
             EXPORTING
                  ARBID_IMP = AFVGD-ARBID
                  PLNTY_IMP = AFVGD-PLNTY
                  STTAG_IMP = TMP_AFRUD_SAV-BUDAT
                  WERKS_IMP = AFVGD-WERKS
             IMPORTING
                  RCR01_EXP = RCR01.
      ELSE.
        CLEAR RCR01.
      ENDIF.
    ENDIF.
*   Originalr¨¹ckmeldung einsetzen
    TMP_AFRUD = TMP_AFRUD_SAV.
    IF ( caufvd-flg_arbei IS INITIAL
       OR caufvd-autyp = '40' )
       AND TMP_AFRUD_SAV-ABARB IS INITIAL.
*     r¨¹ckgemeldete Gutmenge umrechnen in Vorgangs-Mengeneinheit
      PERFORM CONV_HDR_GMEIN_TO_OPR_MEINH
                             USING TMP_LMNGA       CAUFVD-GMEIN
                                   MENG1_F         AFVGD-MEINH
                                   AFVGD-UMREZ     AFVGD-UMREN.
      TMP_AFRUD-LMNGA = MENG1_F.
*     r¨¹ckgemeldete Nacharbeitsmenge umrechnen in Vorgangs-Mengeneinheit
      PERFORM CONV_HDR_GMEIN_TO_OPR_MEINH
                             USING TMP_RMNGA       CAUFVD-GMEIN
                                   MENG2_F         AFVGD-MEINH
                                   AFVGD-UMREZ     AFVGD-UMREN.
      TMP_AFRUD-RMNGA = MENG2_F.
*     r¨¹ckgemeldeten Ausschu# umrechnen in Vorgangs-Mengeneinheit
      PERFORM CONV_HDR_GMEIN_TO_OPR_MEINH
                             USING TMP_XMNGA       CAUFVD-GMEIN
                                   MENG3_F         AFVGD-MEINH
                                   AFVGD-UMREZ     AFVGD-UMREN.
      TMP_AFRUD-XMNGA = MENG3_F.
*     Ausschu# nur beim letzten r¨¹ckmeldef#higen Vorgang der Grundfolge
*     einsetzen, sonst Ausschu# zur Gutmenge addieren
      IF AFVGD-APLFL <> CHNULL06    OR
         NOT AFVGD-SUMNR IS INITIAL OR
         NOT TMP_FLG_XMNGA IS INITIAL.
        TMP_AFRUD-LMNGA = MENG1_F
                        + MENG2_F
                        + MENG3_F.
        CLEAR: TMP_AFRUD-RMNGA,
               TMP_AFRUD-XMNGA,
               TMP_AFRUD-GRUND.
      ELSE.
        TMP_FLG_XMNGA = CON_YX.
      ENDIF.
*     r¨¹ckgemeldete Mengeneinheit = Vorgangsmengeneinheit
      TMP_AFRUD-MEINH = AFVGD-MEINH.
*     Soll-Leistung mit r¨¹ckgemeldeter Menge in Vorgangsmengeneinheit
*     berechnen
      TMP_SMENG = TMP_AFRUD-LMNGA + TMP_AFRUD-RMNGA + TMP_AFRUD-XMNGA
                + AFVGD-LMNGA     + AFVGD-RMNGA     + AFVGD-XMNGA.
      CALL FUNCTION 'CO_RU_DATA_SUGGEST_DEP_ON_FLG'
           EXPORTING
                ACTIVITY_FLAG     = CON_YX
                AFRUD_IMP         = TMP_AFRUD
                AFVGD_IMP         = AFVGD
                SMENG_IMP         = TMP_SMENG
                I_ACTIVITY_NO_FIX = L_ACTIVITY_NO_FIX               "INS
           IMPORTING
                AFRUD_EXP         = TMP_AFRUD.
*     keine Mengen bei Untervorg#ngen
      IF NOT AFVGD-SUMNR IS INITIAL.
        CLEAR: TMP_AFRUD-LMNGA,
               TMP_AFRUD-RMNGA,
               TMP_AFRUD-XMNGA,
               TMP_AFRUD-MEINH.
      ENDIF.
    ENDIF.
    IF NOT CAUFVD-FLG_ARBEI IS INITIAL OR
       NOT TMP_AFRUD_SAV-ABARB IS INITIAL.
*     Abarbeitungsgrad wurde angegeben
      TMP_AFRUD-ABARB = TMP_AFRUD_SAV-ABARB. "Abarbeitungsgrad
      IF NOT caufvd-flg_arbei IS INITIAL
         OR  caufvd-autyp NE '40'.
*       Arbeit wurde ¨¹ber den Abarbeitungsgrad zur¨¹ckgemeldet
        TMP_AFRUD-ISMNW = AFVGD-ARBEI    "Arbeit
                        * TMP_ABARB / 100.
        TMP_AFRUD-ISMNE = AFVGD-ARBEH.   "Einheit der Arbeit
        TMP_AFRUD-LEARR = AFVGD-LARNT.   "Leistungsart der Arbeit
      ELSE.
*       Abarbeitungsgrad zu Leistungen wurde gemeldet
*       Soll-Leistung mit Delta-Abarbeitungsgrad berechnen
        TMP_SMENG = AFVGD-MGVRG * TMP_ABARB / 100.
        CALL FUNCTION 'CO_RU_DATA_SUGGEST_DEP_ON_FLG'
             EXPORTING
                  ACTIVITY_FLAG     = CON_YX
                  AFRUD_IMP         = TMP_AFRUD
                  AFVGD_IMP         = AFVGD
                  SMENG_IMP         = TMP_SMENG
                  I_ACTIVITY_NO_FIX = L_ACTIVITY_NO_FIX             "INS
              IMPORTING
                  AFRUD_EXP         = TMP_AFRUD.
        TMP_AFRUD-LMNGA = TMP_SMENG.
        TMP_AFRUD-MEINH = AFVGD-MEINH.
        CLEAR: TMP_AFRUD-RMNGA,
               TMP_AFRUD-XMNGA.
      ENDIF.
    ENDIF.

*   Teil-/Endr¨¹ckmeldung, Ausbuchen                    "P40K053422 4.0A
    TMP_AFRUD-AUERU = TMP_AFRUD_SAV-AUERU.             "P40K053422 4.0A
    TMP_AFRUD-AUSOR = TMP_AFRUD_SAV-AUSOR.             "P40K053422 4.0A
*   Buchungsdatum
    IF I_BUDAT IS INITIAL.
      TMP_AFRUD-BUDAT = TMP_AFRUD_SAV-BUDAT.
    ELSE.
      TMP_AFRUD-BUDAT = I_BUDAT.
    ENDIF.
*   r¨¹ckgemeldeter Arbeitsplatz = Soll-Arbeitsplatz
    TMP_AFRUD-ARBID = AFVGD-ARBID.     "interne Id des Arbeitsplatzes
    TMP_AFRUD-WERKS = AFVGD-WERKS.     "Werk
    TMP_AFRUD-KOSTL = AFVGD-KOSTL.     "Kostenstelle
    TMP_AFRUD-KOKRS = AFVGD-KOKRS.     "Kostenrechnungskreis

*   Dummy-Eintrag aufnehmen
*   Schl¨¹ssel der R¨¹ckmeldung setzen
    TMP_AFRUD-MANDT = SY-MANDT.
    TMP_AFRUD-RUECK = AFVGD-RUECK.
    TMP_AFRUD-RMZHL = MAX_RMZHL.
*   Vorgangsschl¨¹sseldaten ¨¹bernehmen
    TMP_AFRUD-AUFNR = CAUFVD-AUFNR.
    IF ADC_AUFPL IS INITIAL.
      TMP_AFRUD-AUFPL = CAUFVD-AUFPL.
    ELSE.
      TMP_AFRUD-AUFPL = ADC_AUFPL.
    ENDIF.
    TMP_AFRUD-APLZL = AFVGD-APLZL.
    TMP_AFRUD-APLFL = AFVGD-APLFL.
    TMP_AFRUD-VORNR = AFVGD-VORNR.
    TMP_AFRUD-UVORN = AFVGD-UVORN.
    TMP_AFRUD-SUMNR = AFVGD-SUMNR.
*   Schl¨¹ssel der Kopfr¨¹ckmeldung
    TMP_AFRUD-RUECK_MST = TMP_AFRUD_SAV-RUECK.
    TMP_AFRUD-RMZHL_MST = TMP_AFRUD_SAV-RMZHL.

    IF ADC_AKTYP = 'H'.
*     R¨¹ckmeldung in Belegtabelle aufnehmen
      CALL FUNCTION 'CO_RU_DI_AFRU_INSERT'
           EXPORTING
                AFRUD_INS = TMP_AFRUD
           TABLES
                DIATAB_CNF = AFRU_DIA_TAB.
    ELSE.
*     R¨¹ckmeldung in Belegtabelle aktualisieren
      CALL FUNCTION 'CO_RU_DI_AFRU_UPDATE'
           EXPORTING
                AFRUD_NEW = TMP_AFRUD.
    ENDIF.
*   R¨¹ckmeldung in Tabelle der erzeugten R¨¹ckmeldungen aufnehmen
    RUECK_TAB = TMP_AFRUD.
    APPEND RUECK_TAB.
*   Index f¨¹r Vorg#nger-Vorgang setzen
    TMP_TABIX = TMP_TABIX - 1.
  ENDWHILE.
* Tabelle der Vorg#nge freigeben
  FREE TMP_AFVGDG_TAB.
* Originalr¨¹ckmeldung wieder einsetzen
  MOVE-CORRESPONDING TMP_AFRUD_SAV TO IT_AFRUB.

ENDFORM.

*-----------------------------------------------------------------------
FORM DET_LAST_OPER USING DLO_AUFNR DLO_SUBRC.

  DATA: BEGIN OF TMP_VORNR_TAB OCCURS 0,
          VORNR LIKE AFVGD-VORNR,
          INDBT LIKE AFVGD-INDBT,
        END   OF TMP_VORNR_TAB.
* Tabelle der Vorgangs-Vorg#nger
  DATA: BEGIN OF PRE_DEC_TAB OCCURS 0.
          INCLUDE STRUCTURE PRE_DEC.
  DATA: END   OF PRE_DEC_TAB.
* Steuerschl¨¹ssel des Vorgangs
  DATA: BEGIN OF T430_STRU.
          INCLUDE STRUCTURE T430.
  DATA: END   OF T430_STRU.
  DATA: TMP_LOEKZ  LIKE AFVGD-FLG_LOE, "Kennz.: Vorgang gel#scht
        TMP_PREDEC LIKE RC27X-FLG_SEL, "Kennz.: PRE_DEC_TAB aufgebaut
        TMP_UVORN LIKE AFVGD-UVORN.    "Nummer des Untervorgangs
* Objektarten
  DATA: BEGIN OF OBJ,
          POS VALUE 'O',               "Vorgang (Operation)
          SOP VALUE 'U',               "Untervorgang (Suboperation)
        END   OF OBJ.
  DATA: AFVGD LIKE AFVGD.
  DATA: BEGIN OF FLAG_RUECK,
          MEIL  LIKE T430-RUEK VALUE '1',    "Meilenstein
          NOTW  LIKE T430-RUEK VALUE '2',    "R¨¹ckmeldung notwendig
          NICHT LIKE T430-RUEK VALUE '3',    "R¨¹ckmeldung nicht m#glich
          MOEGL LIKE T430-RUEK VALUE ' ',    "R¨¹ckmeldung m#glich
        END   OF FLAG_RUECK.

  CLEAR: TMP_VORNR_TAB,
         TMP_UVORN.
  DLO_SUBRC = 4.
  LOOP AT OPR_ITAB WHERE OBJECT EQ OBJ-POS
                   AND   AUFNR = DLO_AUFNR
                   AND   APLFL = CHNULL06.
    IF OPR_ITAB-VORNR > TMP_VORNR_TAB-VORNR.
      TMP_VORNR_TAB-VORNR = OPR_ITAB-VORNR.
      TMP_VORNR_TAB-INDBT = OPR_ITAB-INDEX_PLPO.
    ENDIF.
  ENDLOOP.
  IF NOT TMP_VORNR_TAB-VORNR IS INITIAL.
    APPEND TMP_VORNR_TAB.
  ENDIF.
  CLEAR TMP_PREDEC.
  LOOP AT TMP_VORNR_TAB.
*   Vorgangsdaten bereitstellen
    CALL FUNCTION 'CO_BT_AFVG_READ_WITH_INDEX'
         EXPORTING
              INDEX           = TMP_VORNR_TAB-INDBT
              FLG_STA_CHK     = CON_YX
         IMPORTING
              AFVGD_EXP       = AFVGD
              FLG_STA_LOE     = TMP_LOEKZ
         EXCEPTIONS
              ERROR_READ_AFVG = 1
              OTHERS          = 2.
    CHECK SY-SUBRC = 0.
*   Steuerschl¨¹ssel-Tabelle zum Vorgang bereitstellen
    IF T430_STRU-STEUS <> AFVGD-STEUS.
      CALL FUNCTION 'T430_READ'
           EXPORTING
                STEUS  = AFVGD-STEUS
           IMPORTING
                STRUCT = T430_STRU.
    ENDIF.
    IF NOT TMP_LOEKZ IS INITIAL          OR
       T430_STRU-RUEK = FLAG_RUECK-NICHT OR
       T430_STRU-RUEK = FLAG_RUECK-MOEGL.
*     Vorgang ist gel#scht                  bzw.
*     Vorgang darf nicht r¨¹ckgmeldet werden bzw.
*     Vorgang ist nur r¨¹ckmeldef#hig, aber nicht pflichtig
      IF TMP_PREDEC IS INITIAL.
        TMP_PREDEC = CON_YX.
*       Tabelle der Vorg#nger zu allen Vorg#ngen eines Auftrags
        CALL FUNCTION 'CO_IT_AFVG_PREDEC_DET_COMPLETE'
             EXPORTING
                  AUFNR_ACT   = DLO_AUFNR
             TABLES
                  PRE_DEC_TAB = PRE_DEC_TAB
             EXCEPTIONS
                  NO_PRE_DEC  = 01.
      ENDIF.
      LOOP AT PRE_DEC_TAB WHERE AUFNR_B = DLO_AUFNR
                          AND   AUFNR_V = DLO_AUFNR
                          AND   FLGNR_B = CHNULL06
                          AND   FLGNR_V = CHNULL06
                          AND   VORNR_B = AFVGD-VORNR.
*       Vorg#nger-Vorgang in der Grundfolge gefunden
        TMP_VORNR_TAB-VORNR = PRE_DEC_TAB-VORNR_V.
        TMP_VORNR_TAB-INDBT = PRE_DEC_TAB-IPLPO_V.
        APPEND TMP_VORNR_TAB.
        EXIT.
      ENDLOOP.
    ELSE.
*     letzter r¨¹ckmeldepflichtiger Vorgang gefunden
      DLO_SUBRC = 0.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF DLO_SUBRC <> 0.
*   kein r¨¹ckmeldepflichtiger Vorgang gefunden,
*   deshalb den letzten r¨¹ckmeldef#higen Vorgang suchen
    REFRESH TMP_VORNR_TAB.
    CLEAR: TMP_VORNR_TAB,
           TMP_UVORN.
    DLO_SUBRC = 4.
    LOOP AT OPR_ITAB WHERE OBJECT EQ OBJ-POS
                     AND   AUFNR = DLO_AUFNR
                     AND   APLFL = CHNULL06.
      IF OPR_ITAB-VORNR > TMP_VORNR_TAB-VORNR.
        TMP_VORNR_TAB-VORNR = OPR_ITAB-VORNR.
        TMP_VORNR_TAB-INDBT = OPR_ITAB-INDEX_PLPO.
      ENDIF.
    ENDLOOP.
    IF NOT TMP_VORNR_TAB-VORNR IS INITIAL.
      APPEND TMP_VORNR_TAB.
    ENDIF.
    LOOP AT TMP_VORNR_TAB.
*     Vorgangsdaten bereitstellen
      CALL FUNCTION 'CO_BT_AFVG_READ_WITH_INDEX'
           EXPORTING
                INDEX           = TMP_VORNR_TAB-INDBT
                FLG_STA_CHK     = CON_YX
           IMPORTING
                AFVGD_EXP       = AFVGD
                FLG_STA_LOE     = TMP_LOEKZ
           EXCEPTIONS
                ERROR_READ_AFVG = 1
                OTHERS          = 2.
      CHECK SY-SUBRC = 0.
*     Steuerschl¨¹ssel-Tabelle zum Vorgang bereitstellen
      IF T430_STRU-STEUS <> AFVGD-STEUS.
        CALL FUNCTION 'T430_READ'
             EXPORTING
                  STEUS  = AFVGD-STEUS
             IMPORTING
                  STRUCT = T430_STRU.
      ENDIF.
      IF NOT TMP_LOEKZ IS INITIAL OR
         T430_STRU-RUEK = FLAG_RUECK-NICHT.
        IF TMP_PREDEC IS INITIAL.
          TMP_PREDEC = CON_YX.
*         Tabelle der Vorg#nger zu allen Vorg#ngen eines Auftrags
          CALL FUNCTION 'CO_IT_AFVG_PREDEC_DET_COMPLETE'
               EXPORTING
                    AUFNR_ACT   = DLO_AUFNR
               TABLES
                    PRE_DEC_TAB = PRE_DEC_TAB
               EXCEPTIONS
                    NO_PRE_DEC  = 01.
        ENDIF.
*       Vorgang ist gel#scht bzw. darf nicht r¨¹ckgemeldet werden
        LOOP AT PRE_DEC_TAB WHERE AUFNR_B = DLO_AUFNR
                            AND   AUFNR_V = DLO_AUFNR
                            AND   FLGNR_B = CHNULL06
                            AND   FLGNR_V = CHNULL06
                            AND   VORNR_B = AFVGD-VORNR.
*         Vorg#nger-Vorgang in der Grundfolge gefunden
          TMP_VORNR_TAB-VORNR = PRE_DEC_TAB-VORNR_V.
          TMP_VORNR_TAB-INDBT = PRE_DEC_TAB-IPLPO_V.
          APPEND TMP_VORNR_TAB.
          EXIT.
        ENDLOOP.
      ELSE.
*       letzter r¨¹ckgemeldef#higer Vorgang gefunden
        DLO_SUBRC = 0.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.
  FREE TMP_VORNR_TAB.

ENDFORM.

*-----------------------------------------------------------------------
FORM CONV_CNF_MEINH_TO_HDR_GMEIN USING IN_MENGE    TYPE F
                                       IN_EINHEIT  LIKE AFRUD-MEINH
                                       OUT_MENGE   TYPE F
                                       OUT_EINHEIT LIKE CAUFVD-GMEIN.

DATA: LS_AFPOD LIKE AFPOD.

  CALL FUNCTION 'CO_BT_HEADER_POSITION_READ'
       EXPORTING
            AUFNR_ACT          = CAUFVD-AUFNR
            POSNR_ACT          = 01
       IMPORTING
            AFPOD_EXP          = LS_AFPOD
       EXCEPTIONS
            HEADER_NOT_FOUND   = 1
            POSITION_NOT_FOUND = 2
            OTHERS             = 3.
  CHECK SY-SUBRC = 0.
  IF IN_EINHEIT = OUT_EINHEIT.
*   R¨¹ckmeldemengeneinheit und Kopfmengeneinheit sind identisch,
*   daher kein Umrechnen
    OUT_MENGE = IN_MENGE.
    EXIT.
  ENDIF.
  IF NOT LS_AFPOD-MEINS IS INITIAL AND
     LS_AFPOD-MEINS = IN_EINHEIT   AND
     NOT LS_AFPOD-UMREN IS INITIAL AND
     NOT LS_AFPOD-UMREZ IS INITIAL.
*   Umrechnungsfaktor ist definiert
*   Basis- und R¨¹ckmeldemengeneinheit sind identisch
*   Umrechnung erfolgt ¨¹ber Umrechnungsfaktor
    CALL FUNCTION 'CO_RU_UNIT_CONVERSION'
         EXPORTING
              MEINH   = IN_EINHEIT
              MEINS   = OUT_EINHEIT
              MGAME   = IN_MENGE
              UMREZ   = LS_AFPOD-UMREZ
              UMREN   = LS_AFPOD-UMREN
         IMPORTING
              O_MGLME = OUT_MENGE
         EXCEPTIONS
              OTHERS  = 01.
    IF SY-SUBRC <> 0.
      MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
              RAISING CONVERSION_ERROR.
    ENDIF.
    EXIT.
  ENDIF.
* Umrechnung erfolgt nicht ¨¹ber Umrechnungsfaktor des Auftragskopfes
* Umrechnung erfolgt ¨¹ber die Angaben im Mat.stamm bzw. in Tab. T006
  CALL FUNCTION 'CO_RU_UNIT_CONVERSION'
       EXPORTING
            MEINH   = IN_EINHEIT
            MEINS   = OUT_EINHEIT
            BASIS   = LS_AFPOD-MEINS
            MATNR   = CAUFVD-MATNR
            MGAME   = IN_MENGE
       IMPORTING
            O_MGLME = OUT_MENGE
       EXCEPTIONS
            OTHERS  = 01.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
            RAISING CONVERSION_ERROR.
  ENDIF.

ENDFORM.

*-----------------------------------------------------------------------
FORM CONV_HDR_GMEIN_TO_OPR_MEINH USING IN_MENGE    TYPE F
                                       IN_EINHEIT  LIKE CAUFVD-GMEIN
                                       OUT_MENGE   TYPE F
                                       OUT_EINHEIT LIKE AFVGD-MEINH
                                       OPR_UMREZ   LIKE AFVGD-UMREZ
                                       OPR_UMREN   LIKE AFVGD-UMREN.

DATA: LS_AFPOD LIKE AFPOD.

  CALL FUNCTION 'CO_BT_HEADER_POSITION_READ'
       EXPORTING
            AUFNR_ACT          = CAUFVD-AUFNR
            POSNR_ACT          = 01
       IMPORTING
            AFPOD_EXP          = LS_AFPOD
       EXCEPTIONS
            HEADER_NOT_FOUND   = 1
            POSITION_NOT_FOUND = 2
            OTHERS             = 3.
  CHECK SY-SUBRC = 0.
  IF IN_EINHEIT = OUT_EINHEIT.
*   R¨¹ckmeldemengeneinheit und Kopfmengeneinheit sind identisch,
*   daher kein Umrechnen
    OUT_MENGE = IN_MENGE.
    EXIT.
  ENDIF.
  IF NOT LS_AFPOD-MEINS IS INITIAL AND
     LS_AFPOD-MEINS = IN_EINHEIT   AND
     NOT LS_AFPOD-UMREN IS INITIAL AND
     NOT LS_AFPOD-UMREZ IS INITIAL.
*   Umrechnungsfaktor ist definiert
*   Basis- und R¨¹ckmeldemengeneinheit sind identisch
*   Umrechnung erfolgt ¨¹ber Umrechnungsfaktor
    CALL FUNCTION 'CO_RU_UNIT_CONVERSION'
         EXPORTING
              MEINH   = IN_EINHEIT
              MEINS   = OUT_EINHEIT
              MGAME   = IN_MENGE
              UMREZ   = LS_AFPOD-UMREZ
              UMREN   = LS_AFPOD-UMREN
         IMPORTING
              O_MGLME = OUT_MENGE
         EXCEPTIONS
              OTHERS  = 01.
    IF SY-SUBRC <> 0.
      MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
              WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
              RAISING CONVERSION_ERROR.
    ENDIF.
    EXIT.
  ENDIF.
* Umrechnung erfolgt nicht ¨¹ber Umrechnungsfaktor des Auftragskopfes
* Umrechnung erfolgt ¨¹ber die Angaben im Mat.stamm bzw. in Tab. T006
  CALL FUNCTION 'CO_RU_UNIT_CONVERSION'
       EXPORTING
            MEINH   = IN_EINHEIT
            MEINS   = OUT_EINHEIT
            BASIS   = LS_AFPOD-MEINS
            MATNR   = CAUFVD-MATNR
            MGAME   = IN_MENGE
       IMPORTING
            O_MGLME = OUT_MENGE
       EXCEPTIONS
            OTHERS  = 01.
  IF SY-SUBRC <> 0.
    MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4
            RAISING CONVERSION_ERROR.
  ENDIF.

ENDFORM.

*-----------------------------------------------------------------------
FORM FILL_AFVGD_DIAL_DATA.

  DATA: TMP_RUECK LIKE AFVGD-RUECK.
* interne Tabelle lesen
  TMP_RUECK = AFVGD-RUECK.
  READ TABLE AFVGD_DIAL WITH KEY TMP_RUECK BINARY SEARCH.
  IF SY-SUBRC <> 0.
*   zus#tzliche Felder der Dialogstruktur AFVGD versorgen
    PERFORM SET_AFVGD_DIALOG_DATA USING CAUFVD-AUFNR.
  ENDIF.
* Daten in Zusatzfelder der Dialogstruktur AFVGD ¨¹bertragen
  MOVE-CORRESPONDING AFVGD_DIAL TO AFVGD.
* Werk zum Arbeitsplatz aus Auftragskopf ¨¹bernehmen, wenn initial
  IF AFVGD-WERKS IS INITIAL.
    AFVGD-WERKS = CAUFVD-WERKS.
  ENDIF.

ENDFORM.

*-----------------------------------------------------------------------
FORM SET_AFVGD_DIALOG_DATA USING ADD_AUFNR LIKE CAUFVD-AUFNR.

DATA: TMP_RUECK LIKE AFRUD-RUECK.

* zus#tzliche Felder mit Daten versorgen
  PERFORM ADD_AFVGD_DIALOG_DATA.

  IF AFVGD-SUMNR IS INITIAL.
*   Kennzeichen Untervorgang setzen
*-----------------------------------------------------------------------
*   Eintrag in ITAB suchen mit Vorgangs- und Untervorgangs-Nr
    LOOP AT OPR_ITAB WHERE OBJECT EQ 'U'
                     AND   AUFNR = ADD_AUFNR
                     AND   APLFL = AFVGD-APLFL
                     AND   VORNR = AFVGD-VORNR.
      AFVGD_DIAL-FLG_UVO = CON_YX.
      EXIT.
    ENDLOOP.
  ENDIF.
* F¨¹r alternative Folgen R¨¹ckmeldekennzeichen zur¨¹cksetzen
  IF AFVGD-FLGAT = '2'.
    CLEAR: AFVGD_DIAL-FLG_RCK,
           AFVGD_DIAL-FLG_MST,
           AFVGD_DIAL-FLG_AWE.
  ENDIF.
* Tabelle der Dialogzusatzfelder lesen
  TMP_RUECK = AFVGD_DIAL-RUECK.
  READ TABLE AFVGD_DIAL WITH KEY TMP_RUECK BINARY SEARCH.
  CASE SY-SUBRC.
    WHEN 0.
    WHEN 4.
*     Tabelleneintrag mit Zusatzfelder der Dialogstruktur einf¨¹gen
      INSERT AFVGD_DIAL INDEX SY-TABIX.
    WHEN 8.
*     Tabelleneintrag mit Zusatzfelder der Dialogstruktur anh#ngen
      APPEND AFVGD_DIAL.
  ENDCASE.

ENDFORM.

*-----------------------------------------------------------------------
FORM ADD_AFVGD_DIALOG_DATA.

DATA: TMP_ARBID LIKE AFVGD-ARBID,
      TMP_WERKS LIKE AFVGD-WERKS.

* Arbeitsplatz bereitstellen
  IF NOT AFVGD-ARBII IS INITIAL.
    TMP_ARBID = AFVGD-ARBII.
  ELSEIF NOT AFVGD-ARBID IS INITIAL.
      TMP_ARBID = AFVGD-ARBID.
  ENDIF.
* Werk bereitstellen
  IF NOT AFVGD-WERKI IS INITIAL.
    TMP_WERKS = AFVGD-WERKI.
  ELSEIF NOT AFVGD-WERKS IS INITIAL.
      TMP_WERKS = AFVGD-WERKS.
    ELSEIF NOT CAUFVD-WERKS IS INITIAL.
        TMP_WERKS = CAUFVD-WERKS.
  ENDIF.
  IF NOT TMP_ARBID IS INITIAL.
*   Arbeitsplatz muss noch dazugelesen werden
    CALL FUNCTION 'CO_RU_DET_ARBPL'
         EXPORTING
              ARBID_IMP = TMP_ARBID
              PLNTY_IMP = CAUFVD-PLNTY
              STTAG_IMP = SY-DATLO
              WERKS_IMP = TMP_WERKS
         IMPORTING
              RCR01_EXP = RCR01
         EXCEPTIONS
               WORCK_CENTER_NOT_FOUND = 1.
*   Arbeitsplatzreferenz ¨¹bernehmen
    AFVGD-ARBPL = RCR01-ARBPL.
  ENDIF.
* Reset Zusatzfelder der Dialogstruktur
  CLEAR: AFVGD_DIAL.
* Tabelle mit Zusatzfelder der Dialogstruktur f¨¹llen
  MOVE-CORRESPONDING AFVGD TO AFVGD_DIAL.
* Systemstatus ¨¹bernehmen
  IF NOT AFVGD-OBJNR IS INITIAL.
    CLEAR AFVGD_DIAL-VSTTXT.
    CALL FUNCTION 'STATUS_TEXT_EDIT'
         EXPORTING
              OBJNR            = AFVGD-OBJNR
              ONLY_ACTIVE      = CON_YX
              SPRAS            = SY-LANGU
         IMPORTING
              LINE             = AFVGD_DIAL-VSTTXT
         EXCEPTIONS
              OBJECT_NOT_FOUND = 01.
    IF SY-SUBRC = 01.
      MESSAGE A888 WITH SY-REPID.
    ENDIF.
  ENDIF.

* Kennzeichen Meilenstein setzen
*-----------------------------------------------------------------------
* Steuerschl¨¹ssel-Tabelle zum Vorgang bereits gelesen
  CALL FUNCTION 'T430_READ'
       EXPORTING
            STEUS  = AFVGD-STEUS
       IMPORTING
            STRUCT = T430_STRU.
* wenn Meilenstein, dann Kennzeichen setzen
* nicht bei Nachbearbeitungsvorg#ngen
  IF T430_STRU-RUEK = '1' AND
     AFVGD-SUMNR IS INITIAL AND
     T430_STRU-REWORK IS INITIAL.
     AFVGD_DIAL-FLG_MST = CON_YX.
  ENDIF.
* Kennzeichen r¨¹ckmeldepflichtiger Vorgang ¨¹bernehmen
*-----------------------------------------------------------------------
  AFVGD_DIAL-FLG_RCK = T430_STRU-RUEK.
* Nachbearbeitungsvorgang kann kein Meilenstein sein
*-----------------------------------------------------------------------
  IF AFVGD_DIAL-FLG_RCK = '1' AND
     ( NOT AFVGD-SUMNR IS INITIAL OR
       NOT T430_STRU-REWORK IS INITIAL ).
    AFVGD_DIAL-FLG_RCK = '2'.
  ENDIF.
* In Proze#auftr#gen d¨¹rfen nur Phasen zur¨¹ckgemeldet werden
*-----------------------------------------------------------------------
* Kennzeichen automatischer WE bei R¨¹ckmeldung dieses Vorgangs
*-----------------------------------------------------------------------
  AFVGD_DIAL-FLG_AWE = T430_STRU-AUTWE.
* Kennzeichen gel#schter Vorgang setzen
*-----------------------------------------------------------------------
  IF NOT AFVGD-OBJNR IS INITIAL.
    CALL FUNCTION 'STATUS_CHECK'       "pr¨¹fen, ob Vorgang gel#scht
         EXPORTING
              OBJNR  = AFVGD-OBJNR
              STATUS = 'I0013'
         EXCEPTIONS
             STATUS_NOT_ACTIVE = 01.
    IF SY-SUBRC = 0.                   "Vorgang nicht gel#scht
      AFVGD_DIAL-FLG_LOE = CON_YX.
    ENDIF.
*   Kennzeichen freigegebener Vorgang setzen
*-----------------------------------------------------------------------
    CALL FUNCTION 'STATUS_CHECK'       "pr¨¹fen, ob Vorgang frei
         EXPORTING
              OBJNR  = AFVGD-OBJNR
              STATUS = 'I0002'
         EXCEPTIONS
             STATUS_NOT_ACTIVE = 01.
    IF SY-SUBRC = 0.                   "Vorgang freigegeben
      AFVGD_DIAL-FLG_FRE = CON_YX.
    ENDIF.
*   Kennzeichen offener Vorgang setzen
*-----------------------------------------------------------------------
    CALL FUNCTION 'STATUS_CHECK'       "pr¨¹fen, ob Vorgang endr¨¹ckgemeld
         EXPORTING
              OBJNR  = AFVGD-OBJNR
              STATUS = 'I0009'
         EXCEPTIONS
             STATUS_NOT_ACTIVE = 01.
    IF SY-SUBRC <> 0.                  "Vorgang noch offen
      CALL FUNCTION 'STATUS_CHECK'     "pr¨¹fen, ob Vorgang erledigt
           EXPORTING
                OBJNR  = AFVGD-OBJNR
                STATUS = 'I0015'
           EXCEPTIONS
               STATUS_NOT_ACTIVE = 01.
    ENDIF.
    IF SY-SUBRC <> 0.                  "Vorgang nicht endr¨¹ckgemeldet
      AFVGD_DIAL-FLG_OFF = CON_YX.     "Kennzeichen offener Vorgang
    ENDIF.
  ELSE.
*   Kennzeichen bei Serienauftrag immer gesetzt
    AFVGD_DIAL-FLG_FRE = CON_YX.     "Kennzeichen Vorgang freigegeben
    AFVGD_DIAL-FLG_OFF = CON_YX.     "Kennzeichen offener Vorgang
  ENDIF.

ENDFORM.

*Selection text£º
*P_BUDAT:D       Posting Date
*S_AUFNR:D       Order
*S_ERSDA:D       Entered on
*S_RMZHL:D       Counter
*S_RUECK:D       Confirmation
*TESTRUN:D       Test Run
