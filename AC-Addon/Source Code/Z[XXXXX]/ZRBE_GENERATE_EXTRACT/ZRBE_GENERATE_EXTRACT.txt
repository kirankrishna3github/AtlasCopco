*&---------------------------------------------------------------------*
*& Report  ZRBE_GENERATE_EXTRACT
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*
REPORT ZRBE_GENERATE_EXTRACT.
*&---------------------------------------------------------------------*
*& Report ZRBE_GENERATE_EXTRACT *
*& *
*&---------------------------------------------------------------------*
*& *
*& *
*&---------------------------------------------------------------------*
*---------------------------------------------------
* Type-pools
*---------------------------------------------------vla
TYPE-POOLS: abap, icon.
* Table declaration
*----------------------------------------------------------------------*
TABLES: t000, dd03l, trdir, tstc, tstcp, sapwldir, sscrfields, usr02,
d010sinf, dd04t, dd02v, dd02l, tstct, tstcv, tsp01, tbtco,
rs38m, rgsel, smp_dyntxt.
*----------------------------------------------------------------------*
* Selection screen definition
*----------------------------------------------------------------------*
*RBE extract info...
SELECTION-SCREEN BEGIN OF BLOCK info WITH FRAME TITLE text-015.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(65) text-001.
PARAMETERS: client LIKE t000-mandt no-display.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN ULINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) text-002.
SELECTION-SCREEN POSITION POS_LOW.
PARAMETERS: monifrom(7) TYPE c. "transaction monitor start time
SELECTION-SCREEN COMMENT 48(2) text-003.
SELECTION-SCREEN POSITION POS_HIGH.
PARAMETERS: moni_to(7) TYPE c. "transaction monitor end time
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(23) text-018.
SELECTION-SCREEN POSITION POS_LOW.
PARAMETERS: tq_from(7) TYPE c. "test step query start time
SELECTION-SCREEN COMMENT 48(2) text-019.
SELECTION-SCREEN POSITION POS_HIGH.
PARAMETERS: tq_to(7) TYPE c. "test step query end time
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT 1(31) text-020.
PARAMETERS: smax TYPE i DEFAULT 1000 NO-DISPLAY.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN ULINE.
SELECTION-SCREEN END OF BLOCK info.
*Data extract options...
*SELECTION-SCREEN BEGIN OF BLOCK dataop WITH FRAME TITLE text-016.
*
*SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN POSITION 5.
*PARAMETERS: workload RADIOBUTTON GROUP data.
*SELECTION-SCREEN COMMENT 10(60) text-004.
*SELECTION-SCREEN END OF LINE.
*
*SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN POSITION 5.
*PARAMETERS: all RADIOBUTTON GROUP data DEFAULT 'X'.
*SELECTION-SCREEN COMMENT 10(60) text-005.
*SELECTION-SCREEN END OF LINE.
*
*SELECTION-SCREEN END OF BLOCK dataop.
*read xml file specification...
SELECTION-SCREEN BEGIN OF BLOCK readfilespec WITH FRAME TITLE text-025.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 8(24) text-026.
PARAMETERS: readpath LIKE rlgrap-filename.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK readfilespec.
*Download and file specification...
*Where to write the extract....
SELECTION-SCREEN BEGIN OF BLOCK filespec WITH FRAME TITLE text-017.
*SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT 1(22) text-006.
*SELECTION-SCREEN END OF LINE.
*SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN POSITION 5.
*SELECTION-SCREEN COMMENT 8(24) text-008.
*SELECTION-SCREEN POSITION POS_LOW.
PARAMETERS: apppath1 LIKE rlgrap-filename No-display.
*SELECTION-SCREEN END OF LINE.
*SELECTION-SCREEN ULINE.
*Where to download the extract from....
*SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT 1(33) text-012.
*SELECTION-SCREEN END OF LINE.
*
*SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN COMMENT 8(24) text-014.
*SELECTION-SCREEN POSITION POS_LOW.
PARAMETERS: apppath2 LIKE rlgrap-filename No-display.
*SELECTION-SCREEN END OF LINE.
*SELECTION-SCREEN ULINE.
*Spool and filename info....
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 8(24) text-011.
PARAMETERS: pcpath LIKE rlgrap-filename
DEFAULT 'c:\temp\rbe_extract.xml'.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK filespec.
PARAMETERS: all(1) type C DEFAULT 'X' No-display.
PARAMETERS: workload(1) type C DEFAULT 'A' No-display.
*----------------------------------------------------------------------*
* Constant declaration
*----------------------------------------------------------------------*
CONSTANTS: c_buflen TYPE i VALUE 1024,
trans_login(8) TYPE c VALUE 'Login_Pw',
NULL type c value ''.
*----------------------------------------------------------------------*
* Global data declaration
*----------------------------------------------------------------------*
*15 keys for org. units. keys16-20 can be added later if needed...
TYPES: BEGIN OF StructNodes,
NodeId type string,
END OF StructNodes.
TYPES: BEGIN OF ExtractInfo,
ExtractId type String,
ProjectId type String,
ExecutionDate TYPE String,
ApplicationServer TYPE String,
Language TYPE String,
USERID Type String,
TransactionTimeFrameStart TYPE String,
TransactionTimeFrameEnd TYPE String,
SQLTimeFrameStart TYPE String,
SQLTimeFrameEnd TYPE String,
END OF ExtractInfo.
TYPES:BEGIN OF SystemInfo,
InstallNumber TYPE STRING,
Release TYPE STRING,
SystemID TYPE STRING,
ClientInfo TYPE STRING,
END OF SystemInfo.
TYPES: BEGIN OF WorkLoad,
TimeFrame TYPE STRING,
TaskType TYPE STRING,
TCode TYPE STRING,
UserAccount TYPE STRING,
UserGroup TYPE STRING,
Value TYPE STRING,
END OF WorkLoad.
TYPES : BEGIN OF OrgUnit,
Name TYPE STRING,
Value TYPE STRING,
TextE TYPE STRING,
TextL TYPE STRING,
END OF OrgUnit.
TYPES : BEGIN OF OrgRel,
Rel1 TYPE STRING,
Value1 TYPE STRING,
Rel2 TYPE STRING,
Value2 TYPE STRING,
END OF OrgRel.
*Misc Log at end of Extract
TYPES : BEGIN OF log,
txt TYPE string,
END OF log.
DATA: vkey1(15) TYPE c,
vkey2(15) TYPE c,
vkey3(15) TYPE c,
vkey4(15) TYPE c,
vkey5(15) TYPE c,
vkey6(15) TYPE c,
vkey7(15) TYPE c,
vkey8(15) TYPE c,
vkey9(15) TYPE c,
vkey10(15) TYPE c,
vkey11(15) TYPE c,
vkey12(15) TYPE c,
vkey13(15) TYPE c,
vkey14(15) TYPE c,
vkey15(15) TYPE c.
* VKEY16(15) TYPE C,
* VKEY17(15) TYPE C,
* VKEY18(15) TYPE C,
* VKEY19(15) TYPE C,
* VKEY20(15) TYPE C.
DATA: BEGIN OF it_user_data,
bname LIKE usr02-bname, " Benutzername
class LIKE usr02-class, " Benutzergruppe
END OF it_user_data.
DATA: BEGIN OF report_list OCCURS 1,
name LIKE sapwlmem-entry_id,
END OF report_list.
*Data for extract info...
DATA: BEGIN OF cat_node OCCURS 1,
node_id(32) TYPE c.
DATA: END OF cat_node.
DATA: extractid LIKE sys_uid,
structureid(4) TYPE c,
extract_option TYPE c.
*Data declarations for ORG info...
DATA: org_tab(80) OCCURS 1 WITH HEADER LINE. " ORG-Tabellen
DATA: BEGIN OF org_outtab OCCURS 1, " Ausgabetabelle
tabelle(15) TYPE c,
feld(15) TYPE c,
feldbez(15) TYPE c,
wert(15) TYPE c,
wertbez(80) TYPE c,
wertebez(80) TYPE c,
vkey1(5) TYPE c,
vkey2(5) TYPE c,
vkey3(5) TYPE c,
vkey4(5) TYPE c,
vkey5(5) TYPE c,
vkey6(5) TYPE c,
vkey7(5) TYPE c,
vkey8(5) TYPE c,
vkey9(5) TYPE c,
vkey10(5) TYPE c,
vkey11(5) TYPE c,
vkey12(5) TYPE c,
vkey13(5) TYPE c,
vkey14(5) TYPE c,
vkey15(5) TYPE c,
vkey16(5) TYPE c,
vkey17(5) TYPE c,
vkey18(5) TYPE c,
vkey19(5) TYPE c,
vkey20(5) TYPE c,
seq(1) TYPE c,
END OF org_outtab.
*Data declaration for MAT info...
DATA: BEGIN OF tab OCCURS 1,
line(80) TYPE c,
END OF tab.
DATA: duplicate_fields(15) TYPE c OCCURS 1 WITH HEADER LINE,
duplicate_field_count TYPE i.
*Data declarations for file processing...
DATA: output_mode(1) TYPE c VALUE 'O',
append_mode(1) TYPE c VALUE 'A',
tagstr(20) TYPE c,
filetype LIKE rlgrap-filetype VALUE 'ASC',
err_code(1) TYPE c.
DATA: BEGIN OF txt_lines OCCURS 1,
text(1800) TYPE c,
END OF txt_lines.
*Data for date validation and comparision and selection screen...
RANGES: montime FOR sapwldir-startdate OCCURS 1,
tq_time FOR sapwldir-startdate OCCURS 1.
DATA: fromdate LIKE syst-datum,
todate LIKE syst-datum.
DATA: BEGIN OF ss_time_frame OCCURS 1,
filler(14) TYPE c,
value(7) TYPE c,
END OF ss_time_frame.
* Instate of radiobutton in non-unicode abap where spool jobs
* are supported, the parameter is initialize here to hold
* both report nearly equal.
DATA: appserv1(1) TYPE c VALUE 'X'.
DATA: appserv2(1) TYPE c VALUE 'X'.
DATA: app_to_pc VALUE 'X'.
DATA: lv_all_query VALUE 'X'.
*************shankar*********************
TYPES : BEGIN OF systemdetail,
sysdetailsname type string,
sysdetails type string,
END OF systemdetail.
TYPES : BEGIN OF conditionids,
id type string,
query type string,
END OF conditionids.
DATA: Iconditionids type table of conditionids.
DATA: waconditionids like line of Iconditionids.
DATA: loc_filepath type string.
DATA: l_code TYPE x.
DATA: license_number(10) TYPE c.
DATA: systemdetails TYPE TABLE OF systemdetail.
DATA: wasystemdetails LIKE LINE OF systemdetails.
DATA: ST002T type T002T.
DATA: APPENDWORKLOAD(1) type c.
data: file(255) TYPE c.
TYPES: BEGIN OF READXML,
element type string,
value type string,
END OF READXML.
DATA: IREADXML type table of READXML.
DATA: WAREADXML like line of IREADXML.
DATA : BEGIN OF OP,
conditionid type string,
keydate type sy-datum,
key1 type string,
key2 type string,
key3 type string,
key4 type string,
key5 type string,
key6 type string,
key7 type string,
key8 type string,
key9 type string,
key10 type string,
key11 type string,
key12 type string,
count type i,
END OF OP.
DATA: fromdatetable type string.
DATA: todatetable type string.
*****xml***
DATA : globalquery(1) type c.
DATA : validatexml(1) type c.
DATA : ISDATESELECTED(1) type c.
DATA: BEGIN of stfieldselect,
line type string,
END OF stfieldselect.
DATA: Ifieldselect like table of stfieldselect.
DATA: wafieldselect like line of Ifieldselect.
DATA: BEGIN of stwherecondition,
line type string,
END OF stwherecondition.
DATA: Iwherecondition like table of stwherecondition.
DATA: wawherecondition like line of Iwherecondition.
DATA: BEGIN of stgroupby,
line type string,
END OF stgroupby.
DATA: Igroupby like table of stgroupby.
DATA: wagroupby like line of Igroupby.
*DATA : BEGIN OF QUERYCONDITION,
* conditionid type string,
* datefield type string,
* dateselect type string,
* fieldselect like stfieldselect occurs 0,
* tablename type string,
* count type string,
* wherecondition like stwherecondition occurs 0,
* groupby like stgroupby occurs 0,
* END OF QUERYCONDITION.
DATA : BEGIN OF QUERYCONDITION,
conditionid type string,
datefield type string,
dateselect type string,
fieldselect type string,
tablename type string,
count type string,
wherecondition type string,
groupby type string,
checkfields type string,
jcheckfields type string,
END OF QUERYCONDITION.
DATA : IQUERYCONDITION like table of QUERYCONDITION.
DATA : waquerycondition like line of IQUERYCONDITION.
*****xml**
***output*****
DATA : BEGIN OF STQUERYRESULTOP,
resulttable like OP occurs 0,
END OF STQUERYRESULTOP.
DATA: IQUERYRESULTOP like table of STQUERYRESULTOP.
DATA: WAQUERYRESULTOP like line of IQUERYRESULTOP.
TYPES: BEGIN OF ExtractFile,
ExtractInfo Type ExtractInfo occurs 0 ,
systemdetails Type systemdetail occurs 0,
Workload Type Workload occurs 0,
* Queryconditions like querycondition occurs 0,
queryresultoutput like STQUERYRESULTOP occurs 0,
OrgUnit Type OrgUnit occurs 0,
OrgRel Type OrgRel occurs 0,
log TYPE log OCCURS 0,
END OF ExtractFile.
Data : ExtFile Type Table of ExtractFile with header line.
DATA : ROOT Type Table of ExtractFile with header line.
DATA : waroot like line of ROOT.
Data : waExtFile like line of ExtFile.
Data : waExtractInfo Type ExtractInfo.
Data : waSystemInfo Type SystemInfo.
Data : waWorkLoad Type Workload.
*Data : waQueryInfo Type QueryInfo.
Data : waOrgUnit Type OrgUnit.
Data : waOrgRel Type OrgRel.
Data : waNodes type StructNodes.
DATA : walog TYPE log.
***output*****
**********shankar***********************
*----------------------------------------------------------------------*
* Program initialization
*----------------------------------------------------------------------*
INITIALIZATION.
PERFORM app_init.
AT SELECTION-SCREEN OUTPUT.
LOOP AT SCREEN.
IF screen-name = 'WORKLOAD' AND lv_all_query = ' '.
IF screen-name = 'TQ_FROM'.
screen-input = 0.
MODIFY SCREEN.
ENDIF.
IF screen-name = 'TQ_TO'.
screen-input = 0.
MODIFY SCREEN.
ENDIF.
ENDIF.
ENDLOOP.
AT SELECTION-SCREEN ON VALUE-REQUEST FOR pcpath.
PERFORM ws_filename_get CHANGING pcpath.
AT SELECTION-SCREEN ON VALUE-REQUEST FOR readpath.
PERFORM ws_readfilename_get CHANGING readpath.
AT SELECTION-SCREEN ON VALUE-REQUEST FOR monifrom.
PERFORM select_time_frame TABLES ss_time_frame
USING 'S' 'T'. "start time flag
AT SELECTION-SCREEN ON VALUE-REQUEST FOR tq_from.
PERFORM select_time_frame TABLES ss_time_frame
USING 'S' 'Q'. "start time flag
AT SELECTION-SCREEN ON VALUE-REQUEST FOR moni_to.
PERFORM select_time_frame TABLES ss_time_frame
USING 'E' 'T'. "end time flag
AT SELECTION-SCREEN ON VALUE-REQUEST FOR tq_to.
PERFORM select_time_frame TABLES ss_time_frame
USING 'E' 'Q'. "end time flag
AT SELECTION-SCREEN.
PERFORM validate_readxml.
PERFORM validate_client USING sscrfields-ucomm.
PERFORM validate_txnmonitor_date USING sscrfields-ucomm.
PERFORM validate_table_query_date USING sscrfields-ucomm.
PERFORM validate_package_size USING sscrfields-ucomm.
* PERFORM cmd USING sscrfields-ucomm.
*----------------------------------------------------------------------*
* Start of program...
*----------------------------------------------------------------------*
START-OF-SELECTION.
***********shankar*********************
Call function 'SAPGUI_PROGRESS_INDICATOR'
exporting
* PERCENTAGE = 0
text = 'Collecting System Details'.
CALL 'GET_ACCESS_INFO'
ID 'CODE' FIELD l_code
ID 'LICENSE' FIELD license_number.
MOVE 'CODE' TO wasystemdetails-sysdetailsname.
MOVE l_code TO wasystemdetails-sysdetails.
APPEND wasystemdetails TO systemdetails.
MOVE 'LICENSE' TO wasystemdetails-sysdetailsname.
MOVE license_number TO wasystemdetails-sysdetails.
APPEND wasystemdetails TO systemdetails.
MOVE 'BASIS RELEASE' TO wasystemdetails-sysdetailsname.
MOVE syst-saprl TO wasystemdetails-sysdetails.
APPEND wasystemdetails TO systemdetails.
MOVE 'SYSTEM NAME' TO wasystemdetails-sysdetailsname.
MOVE syst-sysid TO wasystemdetails-sysdetails.
APPEND wasystemdetails TO systemdetails.
MOVE 'CLIENT' TO wasystemdetails-sysdetailsname.
MOVE syst-mandt TO wasystemdetails-sysdetails.
APPEND wasystemdetails TO systemdetails.
MOVE 'LOCLANG' TO wasystemdetails-sysdetailsname.
Select single * from T002T into ST002T
where SPRSL EQ SY-LANGU and SPRAS EQ 'E'.
MOVE ST002T-SPTXT TO wasystemdetails-sysdetails.
APPEND wasystemdetails TO systemdetails.
move readpath to file.
Perform read_xml_from_front-end.
If validatexml = 'Y'.
Exit.
Endif.
perform Get_Query_results.
*********shankar***********************
PERFORM app_start.
*----------------------------------------------------------------------*
* Subroutine and macro definitions...
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
* Form APP_INIT
*----------------------------------------------------------------------*
FORM app_init.
DATA: workload_dir LIKE SWNCGLDIR OCCURS 1 WITH HEADER LINE,
num_lines LIKE syst-index.
*Construct valid month/year dates for transaction monitor time frame...
app_to_pc = ' '.
PERFORM wkl_workload_get_directory TABLES workload_dir.
DESCRIBE TABLE workload_dir LINES num_lines.
IF num_lines > 0.
LOOP AT workload_dir WHERE periodtype = 'M' AND component <> 'TOTAL'.
CONCATENATE workload_dir-periodstrt+4(2)
workload_dir-periodstrt+0(4)
INTO ss_time_frame-value SEPARATED BY '/'.
APPEND ss_time_frame.
ENDLOOP.
ELSE.
CONCATENATE syst-datum+4(2) syst-datum+0(4)
INTO ss_time_frame-value SEPARATED BY '/'.
APPEND ss_time_frame.
ENDIF.
*Delete duplicates in case of info from multiple app. servers...
SORT ss_time_frame BY value+3(4) value(2) ASCENDING.
DELETE ADJACENT DUPLICATES FROM ss_time_frame COMPARING value.
*Default path for file on application server according to operating sys
IF syst-opsys = 'WN' OR syst-opsys = 'WN32' OR
syst-opsys = 'Windows NT' OR syst-opsys = 'PM'.
apppath1 = 'c:\temp\rbe_extract.txt'.
ELSE.
apppath1 = '/tmp/rbe_extract.txt'.
ENDIF.
CLEAR: ss_time_frame, workload_dir.
FREE: workload_dir.
ENDFORM. " APP_INIT
*----------------------------------------------------------------------*
* Form APP_START
*----------------------------------------------------------------------*
FORM app_start.
*Generate extract file as spool file or file on application server...
IF appserv1 = 'X'.
IF appserv1 = 'X'.
PERFORM open_extract_file USING output_mode.
ENDIF.
PERFORM generate_extractid. "generate unique id
PERFORM key. "set org. unit keys
PERFORM set_workload_dates. "set date range for workload extract
* PERFORM set_table_query_dates. "set data range for tables
PERFORM extract_info. "write info specific to extract
PERFORM system_info. "write info specific to system
PERFORM wkl TABLES report_list. "get workload info
* PERFORM tra TABLES report_list. "get transaction/report info
FREE report_list. CLEAR report_list.
PERFORM org. "get org. unit info
PERFORM orgrel. "get relationships between org. units
loop at IREADXML into WAREADXML.
IF wareadxml-element eq 'PROJECTID'.
move wareadxml-value to waExtractInfo-projectid.
endif.
endloop.
Append waExtractInfo to waExtFile-ExtractInfo.
Append waExtFile to ExtFile.
MOVE ExtFile[] to ROOT[].
Perform GENERATE_XML.
IF appserv1 = 'X'.
PERFORM close_extract_file.
ENDIF.
*Get data for queries generated from RBE tool...
IF all = 'X'.
IF appserv1 = 'X'.
PERFORM open_extract_file USING append_mode.
PERFORM close_extract_file.
ENDIF.
ELSE. "tag strings below required for import of extract file...
IF appserv1 = 'X'.
PERFORM open_extract_file USING append_mode.
ENDIF.
tagstr = '~QUERY'. PERFORM write_content USING tagstr.
tagstr = '~NOT_AVAILABLE'. PERFORM write_content USING tagstr.
IF appserv1 = 'X'.
PERFORM close_extract_file.
ENDIF.
ENDIF.
ENDIF.
*Execute button was pressed and user wants to download the extract file.
*Inform this can only be done via pushbutton on selection screen...
IF appserv2 = 'X'.
* MESSAGE s162(00) WITH 'File successfully written to Application'
* ' server.'.
ENDIF.
ENDFORM. " APP_START
*---------------------------------------------------------------------*
* FORM WKL *
*---------------------------------------------------------------------*
FORM wkl TABLES p_report_list STRUCTURE report_list.
DATA: wl_dir LIKE SWNCGLDIR OCCURS 1 WITH HEADER LINE,
user_data LIKE it_user_data OCCURS 1 WITH HEADER LINE,
memory_stat LIKE SWNCGLAGGMEMORY OCCURS 1 WITH HEADER LINE,
tmp_counter(10) TYPE c,
l_str(c_buflen) TYPE c.
DATA: BEGIN OF workload_stat OCCURS 1,
startdate(6) TYPE c,
tasktype(2) TYPE c,
entry_id LIKE trdir-name,
account LIKE sapwlmem-account,
counter TYPE i,
END OF workload_stat.
DATA: systemid type SWNCSYSID.
*get time frame of statistics available...
PERFORM wkl_workload_get_directory TABLES wl_dir.
tagstr = '~WORKLOAD'.
PERFORM write_content USING tagstr.
*Process monthly data for all servers in system...
LOOP AT wl_dir WHERE periodtype = 'M' AND COMPONENT <> 'TOTAL'.
IF wl_dir-PERIODSTRT IN montime.
*Function gets workload data...
*moving system id to local variable
MOVE syst-sysid to systemid.
* calling worklod functions
CALL FUNCTION 'SWNC_GET_WORKLOAD_STATISTIC'
EXPORTING
SYSTEMID = systemid
INSTANCE = wl_dir-Component
PERIODTYPE = wl_dir-periodtype
PERIODSTRT = wl_dir-periodstrt
IMPORTING
MEMORY = memory_stat[].
*IF SY-SUBRC <> 0.
** MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
** WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
*ENDIF.
* CALL FUNCTION 'SAPWL_WORKLOAD_GET_STATISTIC'
* EXPORTING
* periodtype = wl_dir-periodtype
** hostid = wl_dir-COMPONENT
* startdate = wl_dir-PERIODSTRT
* only_application_statistic = ''
* TABLES
* memory_statistic = memory_stat.
*make sure further processing is for data in selected client only...
* DELETE memory_stat WHERE NOT mandt = client.
* delete transaction 'Login_PW'
* DELETE memory_stat WHERE entry_id+0(8) = trans_login.
*collect required info from all servers into workload_stat...
LOOP AT memory_stat.
CASE memory_stat-tasktype.
WHEN '01' OR '02' OR '03' OR '04' OR '05' OR '06' OR '07' OR
'08' OR '09' OR 'FE' OR 'FF' OR 'FD'.
MOVE: wl_dir-PERIODSTRT+0(6) TO workload_stat-Startdate,
memory_stat-tasktype TO workload_stat-tasktype,
memory_stat-entry_id TO workload_stat-entry_id,
memory_stat-account TO workload_stat-account,
memory_stat-counter TO workload_stat-counter.
COLLECT workload_stat.
WHEN OTHERS.
ENDCASE.
ENDLOOP.
FREE memory_stat.
ENDIF.
ENDLOOP.
*get the user names and account groups...
SELECT bname class FROM usr02 CLIENT SPECIFIED
INTO TABLE user_data WHERE mandt = client.
SORT user_data BY bname class.
*Output workload statistics to extract file...
LOOP AT workload_stat.
READ TABLE user_data WITH KEY bname = workload_stat-account
BINARY SEARCH.
IF syst-subrc NE 0.
CLEAR user_data.
ENDIF.
tmp_counter = workload_stat-counter.
CONDENSE tmp_counter.
CONCATENATE extractid workload_stat-startdate
workload_stat-tasktype workload_stat-entry_id
workload_stat-account user_data-class tmp_counter
INTO l_str SEPARATED BY '|'.
waWorkLoad-TimeFrame = workload_stat-startdate.
waWorkLoad-TaskType = workload_stat-tasktype.
waWorkLoad-TCode = workload_stat-entry_id.
waWorkLoad-UserAccount = workload_stat-account.
waWorkLoad-UserGroup = user_data-class.
waWorkLoad-Value = tmp_counter.
* CLEAR APPENDWORKLOAD.
*
* loop at IREADXML into WAREADXML.
*
* IF WAREADXML-value EQ waWorkLoad-TCode.
* MOVE 'X' to APPENDWORKLOAD.
* EXIT.
* ENDIF.
*
* endloop.
* IF APPENDWORKLOAD = 'X'.
Append waWorkLoad to waExtFile-WorkLoad.
* ENDIF.
* CLEAR APPENDWORKLOAD.
PERFORM write_content USING l_str.
*gather name of reports/transactions used in system -- used in form tra
p_report_list-name = workload_stat-entry_id.
COLLECT p_report_list.
ENDLOOP.
CLEAR: tagstr, wl_dir, user_data, workload_stat.
FREE: wl_dir, user_data, workload_stat.
ENDFORM. "WKL
*---------------------------------------------------------------------*
* FORM WkL_WORKLOAD_GET_DIRECTORY *
*---------------------------------------------------------------------*
FORM wkl_workload_get_directory TABLES dir STRUCTURE SWNCGLDIR.
*get dates and server info for available statistics in system
* CALL FUNCTION 'SAPWL_WORKLOAD_GET_DIRECTORY'
* TABLES
* directory = dir.
CALL FUNCTION 'SWNC_GET_WORKLOAD_DIRECTORY'
TABLES
WORKLOAD_DIRECTORY = dir.
ENDFORM. "WKL_WORKLOAD_GET_DIRECTORY
*---------------------------------------------------------------------*
* FORM tra *
*---------------------------------------------------------------------*
FORM tra TABLES p_report_list STRUCTURE report_list.
DATA: idx TYPE i,
l_str(c_buflen) TYPE c,
prefix TYPE c.
DATA: BEGIN OF it_report OCCURS 1,
name LIKE trdir-name,
typ(2) TYPE c,
cnam LIKE trdir-cnam,
subc LIKE trdir-subc,
rstat LIKE trdir-rstat,
appl LIKE trdir-appl,
text_d LIKE textpool-entry,
text_e LIKE textpool-entry,
END OF it_report.
DATA: BEGIN OF it_transaction OCCURS 1,
tcode LIKE tstc-tcode,
typ(2) TYPE c,
flag TYPE c, " Parameter-Flag
param LIKE tstcp-param,
text_d LIKE tstct-ttext,
text_e LIKE tstct-ttext,
END OF it_transaction.
DATA: BEGIN OF it_undefined OCCURS 1,
name LIKE sapwlmem-entry_id,
typ(2) TYPE c,
END OF it_undefined.
IF NOT report_list IS INITIAL.
*create list of reports and transactions used without duplicates...
SORT report_list BY name.
DELETE ADJACENT DUPLICATES FROM report_list.
*separate reports and transactions and classify as:
*SAP or cutomer and used or not used
DATA: tcode LIKE tstc-tcode,
report LIKE trdir-name.
CLEAR: it_transaction, it_report.
LOOP AT p_report_list.
* report
report = p_report_list-name.
SELECT SINGLE name subc cnam rstat appl FROM trdir INTO
(trdir-name, trdir-subc, trdir-cnam, trdir-rstat, trdir-appl)
WHERE name = report.
IF syst-subrc = 0 AND trdir-subc <> 'I'.
*entry is a report
prefix = trdir-name(1).
IF prefix = 'Y' OR prefix = 'Z'.
*customer report -- used
it_report-name = trdir-name.
it_report-typ = 'R1'.
it_report-cnam = trdir-cnam.
it_report-subc = trdir-subc.
it_report-rstat = trdir-rstat.
it_report-appl = trdir-appl.
APPEND it_report.
ELSE.
*SAP report -- used
it_report-name = trdir-name.
it_report-typ = 'R2'.
it_report-cnam = trdir-cnam.
it_report-subc = trdir-subc.
it_report-rstat = trdir-rstat.
it_report-appl = trdir-appl.
APPEND it_report.
ENDIF.
ELSEIF syst-subrc = 0 AND trdir-subc = 'I'.
*do nothing for include programs...
ELSE.
tcode = p_report_list-name.
SELECT SINGLE tcode pgmna FROM tstc INTO
  (tstc-tcode, tstc-pgmna)
WHERE tcode = tcode.
IF syst-subrc = 0.
*entry is a transaction
prefix = tstc-tcode(1).
IF prefix = 'Y' OR prefix = 'Z'.
*customer transaction -- used
it_transaction-tcode = tstc-tcode.
it_transaction-typ = 'T1'.
ELSE.
*SAP transaction -- used
it_transaction-tcode = tstc-tcode.
it_transaction-typ = 'T2'.
ENDIF.
IF tstc-pgmna = ''.
*parameter transaction
SELECT SINGLE param FROM tstcp INTO (tstcp-param)
WHERE tcode = tstc-tcode.
IF syst-subrc = 0.
it_transaction-flag = 'P'.
it_transaction-param = tstcp-param.
APPEND it_transaction.
ELSE.
it_transaction-flag = 'P'.
it_transaction-param = ''.
APPEND it_transaction.
ENDIF.
ELSE.
*normal transaction
it_transaction-flag = 'T'.
it_transaction-param = tstc-pgmna.
APPEND it_transaction.
ENDIF.
ELSE.
*entry was neither a report nor a transaction...
it_undefined-name = p_report_list-name.
it_undefined-typ = 'ZZ'.
APPEND it_undefined.
ENDIF.
ENDIF.
ENDLOOP.
*determine transactions not used in system...
CLEAR: it_transaction.
SELECT tcode pgmna FROM tstc INTO (tstc-tcode, tstc-pgmna)
WHERE tcode LIKE 'Y%' OR tcode LIKE 'Z%'.
READ TABLE report_list WITH KEY name = tstc-tcode BINARY SEARCH.
IF syst-subrc <> 0.
*customer transaction -- not used
it_transaction-tcode = tstc-tcode.
it_transaction-typ = 'T0'.
IF tstc-pgmna = ''.
*parameter transaction
SELECT SINGLE param FROM tstcp INTO (tstcp-param)
WHERE tcode = tstc-tcode.
IF syst-subrc = 0.
it_transaction-flag = 'P'.
it_transaction-param = tstcp-param.
APPEND it_transaction.
ELSE.
it_transaction-flag = 'P'.
it_transaction-param = ''.
APPEND it_transaction.
ENDIF.
ELSE.
*normal transaction
it_transaction-flag = 'T'.
it_transaction-param = tstc-pgmna.
APPEND it_transaction.
ENDIF.
ENDIF.
ENDSELECT.
ENDIF.
*determine reports not used in system...
CLEAR: it_report.
SELECT name subc cnam rstat appl FROM trdir INTO
(trdir-name, trdir-subc, trdir-cnam, trdir-rstat, trdir-appl)
WHERE name LIKE 'Y%' AND subc <> 'I' OR
name LIKE 'Z%' AND subc <> 'I'.
READ TABLE report_list WITH KEY name = trdir-name BINARY SEARCH.
IF syst-subrc <> 0.
*customer report -- not used
it_report-name = trdir-name.
it_report-typ = 'R0'.
it_report-cnam = trdir-cnam.
it_report-subc = trdir-subc.
it_report-rstat = trdir-rstat.
it_report-appl = trdir-appl.
APPEND it_report.
ENDIF.
ENDSELECT.
*get description text for customer transactions....
SORT it_transaction DESCENDING.
DELETE ADJACENT DUPLICATES FROM it_transaction
COMPARING tcode flag param text_d text_e.
LOOP AT it_transaction WHERE tcode(1) = 'Y'
OR tcode(1) = 'Z'.
idx = syst-tabix.
PERFORM tra_trans_text_get USING it_transaction-tcode
CHANGING it_transaction-text_e
it_transaction-text_d.
MODIFY it_transaction INDEX idx.
ENDLOOP.
*get description text for customer reports...
SORT it_report DESCENDING.
DELETE ADJACENT DUPLICATES FROM it_report
COMPARING name cnam subc rstat appl text_d text_e.
LOOP AT it_report.
idx = syst-tabix.
PERFORM tra_report_text_get USING it_report-name
CHANGING it_report-text_e
it_report-text_d.
MODIFY it_report INDEX idx.
ENDLOOP.
tagstr = '~TRANSACTION'.
PERFORM write_content USING tagstr.
*output transaction list to extract file
SORT it_transaction.
LOOP AT it_transaction.
CONCATENATE extractid it_transaction-tcode it_transaction-typ
it_transaction-flag '*' '*' '*' '*'
it_transaction-text_e it_transaction-text_d
INTO l_str SEPARATED BY '|'.
PERFORM write_content USING l_str.
CLEAR l_str.
ENDLOOP.
*output report list to extract file
SORT it_report.
LOOP AT it_report.
CONCATENATE extractid it_report-name it_report-typ '*'
it_report-cnam it_report-subc it_report-rstat
it_report-appl it_report-text_e it_report-text_d
INTO l_str SEPARATED BY '|'.
PERFORM write_content USING l_str.
CLEAR l_str.
ENDLOOP.
*output entries for which there was no data...
SORT it_undefined.
DELETE ADJACENT DUPLICATES FROM it_undefined.
LOOP AT it_undefined.
CONDENSE it_undefined-name.
CONCATENATE extractid it_undefined-name it_undefined-typ
'*' '*' '*' '*' '*' '*' '*' INTO l_str SEPARATED BY '|'.
PERFORM write_content USING l_str.
CLEAR l_str.
ENDLOOP.
CLEAR: tagstr, it_report, it_transaction, it_undefined.
FREE: it_report, it_transaction, it_undefined.
ENDFORM. "TRA
*----------------------------------------------------------------------*
* Form tra_report_text_get
*----------------------------------------------------------------------*
FORM tra_report_text_get USING p_name LIKE trdir-name
CHANGING p_text_e LIKE textpool-entry
p_text_d LIKE textpool-entry.
DATA: pool LIKE textpool OCCURS 1 WITH HEADER LINE,
text_e LIKE textpool-entry,
text_d LIKE textpool-entry,
text_x LIKE textpool-entry.
*get report title in english
CLEAR: p_text_e, p_text_d, pool[].
READ TEXTPOOL p_name INTO pool LANGUAGE 'E'.
READ TABLE pool WITH KEY id = 'R'.
IF syst-subrc = 0.
text_e = pool-entry.
ELSE.
CLEAR text_e.
ENDIF.
*get report title in german
CLEAR: pool[].
READ TEXTPOOL p_name INTO pool LANGUAGE 'D'.
READ TABLE pool WITH KEY id = 'R'.
IF syst-subrc = 0.
text_d = pool-entry.
ELSE.
CLEAR text_d.
ENDIF.
*get report title in log-on language if not english or german...
IF syst-langu = 'E'.
text_x = text_e.
ELSEIF syst-langu = 'D'.
text_x = text_d.
ELSE.
CLEAR: pool[].
READ TEXTPOOL p_name INTO pool LANGUAGE syst-langu.
READ TABLE pool WITH KEY id = 'R'.
IF syst-subrc = 0.
text_x = pool-entry.
ELSE.
CLEAR text_x.
ENDIF.
ENDIF.
*Assign text entries in english and german
IF text_e <> ''.
p_text_e = text_e. " English
ELSE.
p_text_e = text_x. " syst-langu
ENDIF.
IF text_e <> ''.
p_text_d = text_d. " English
ELSE.
p_text_d = text_x. " syst-langu
ENDIF.
FREE pool.
ENDFORM. " get_report_text
*----------------------------------------------------------------------*
* Form tra_trans_text_get
*----------------------------------------------------------------------*
FORM tra_trans_text_get USING p_tcode LIKE tstc-tcode
CHANGING p_text_e LIKE tstct-ttext
p_text_d LIKE tstct-ttext.
DATA: it_tstct LIKE tstct OCCURS 1 WITH HEADER LINE,
text_e LIKE tstct-ttext,
text_d LIKE tstct-ttext,
text_x LIKE tstct-ttext.
CLEAR: it_tstct[].
*get transaction description on english, german, and log-on language
SELECT * FROM tstct INTO TABLE it_tstct
WHERE tcode = p_tcode
AND ( sprsl = 'E' OR sprsl = 'D' OR sprsl = syst-langu ).
IF syst-subrc = 0.
READ TABLE it_tstct WITH KEY tcode = p_tcode sprsl = 'E'.
IF syst-subrc = 0.
text_e = it_tstct-ttext.
ELSE.
CLEAR text_e.
ENDIF.
READ TABLE it_tstct WITH KEY tcode = p_tcode sprsl = 'D'.
IF syst-subrc = 0.
text_d = it_tstct-ttext.
ELSE.
CLEAR text_d.
ENDIF.
READ TABLE it_tstct WITH KEY tcode = p_tcode sprsl = syst-langu.
IF syst-subrc = 0.
text_x = it_tstct-ttext.
ELSE.
CLEAR text_x.
ENDIF.
*Assign text entries in english and german
IF text_e <> ''.
p_text_e = text_e. " English
ELSE.
p_text_e = text_x. " syst-langu
ENDIF.
IF text_d <> ''.
p_text_d = text_d. " English
ELSE.
p_text_d = text_x. " syst-langu
ENDIF.
ELSE.
CLEAR: p_text_e, p_text_d.
ENDIF.
FREE it_tstct.
ENDFORM. " get_report_text
*---------------------------------------------------------------------*
* FORM ORG_WORK *
*---------------------------------------------------------------------*
FORM org_work TABLES tab.
DATA: tabname(15) TYPE c,
tabfeld(15) TYPE c,
txt1(50) TYPE c,
key1(15) TYPE c,
key2(15) TYPE c,
key3(15) TYPE c,
key4(15) TYPE c,
key5(15) TYPE c,
key6(15) TYPE c,
key7(15) TYPE c,
key8(15) TYPE c,
key9(15) TYPE c,
key10(15) TYPE c.
DATA: a TYPE i,
tabname2(4) TYPE c.
DATA: BEGIN OF org_outtab_x OCCURS 1.
INCLUDE STRUCTURE org_outtab.
DATA: END OF org_outtab_x.
DATA: no_tab TYPE i.
a = 0.
tagstr = '~ORGUNIT'.
PERFORM write_content USING tagstr.
LOOP AT org_tab.
IF org_tab(1) <> '*' AND org_tab <> ''.
TRANSLATE org_tab TO UPPER CASE.
IF org_tab <> '--'.
CASE a.
WHEN 0. tabname = org_tab.
WHEN 1.
tabfeld = org_tab.
CLEAR: key1, key2, key3, key4, key5.
CLEAR: key6, key7, key8, key9, key10.
WHEN 2. txt1 = org_tab.
WHEN 3. key1 = org_tab.
WHEN 4. key2 = org_tab.
WHEN 5. key3 = org_tab.
WHEN 6. key4 = org_tab.
WHEN 7. key5 = org_tab.
WHEN 8. key6 = org_tab.
WHEN 9. key7 = org_tab.
WHEN 10. key8 = org_tab.
WHEN 11. key9 = org_tab.
WHEN 12. key10 = org_tab.
ENDCASE.
a = a + 1.
CONTINUE.
ELSE.
* Check if table exist
IF NOT tabname IS INITIAL.
PERFORM check_org_tables_exist USING tabname CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field TABFELD exist
IF NOT tabfeld IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname tabfeld
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field TXT1 exist
IF NOT txt1 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname txt1
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY1 exist
IF NOT key1 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key1
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY2 exist
IF NOT key2 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key2
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY3 exist
IF NOT key3 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key3
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY4 exist
IF NOT key4 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key4
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY5 exist
IF NOT key5 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key5
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY6 exist
IF NOT key6 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key6
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY7 exist
IF NOT key7 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key7
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY8 exist
IF NOT key8 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key8
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY9 exist
IF NOT key9 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key9
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
* Check if field KEY10 exist
IF NOT key10 IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname key10
CHANGING no_tab.
IF no_tab = 1.
CLEAR no_tab.
CONTINUE.
ENDIF.
ENDIF.
CASE tabname.
WHEN 'TVTWT' OR 'TVKOT' OR 'TSPAT' OR 'TKEBT'
OR 'TVSTT' OR 'TTDST' OR 'TGSBT' OR 'FM01T'.
org_outtab-seq = '1'.
tabname2(4) = tabname(4).
PERFORM org_read_table TABLES org_outtab_x
USING tabname2 tabfeld txt1
key1 key2 key3 key4 key5
key6 key7 key8 key9 key10
'E' org_outtab-seq.
org_outtab_x[] = org_outtab[].
CLEAR org_outtab.
REFRESH org_outtab.
LOOP AT org_outtab_x.
org_outtab = org_outtab_x.
org_outtab-seq = '2'.
PERFORM org_read_table TABLES org_outtab_x
USING tabname tabfeld txt1
key1 key2 key3 key4 key5
key6 key7 key8 key9 key10
'E' org_outtab-seq.
org_outtab-seq = '4'.
PERFORM org_read_table TABLES org_outtab_x
USING tabname tabfeld txt1
key1 key2 key3 key4 key5
key6 key7 key8 key9 key10
sy-langu org_outtab-seq.
org_outtab-seq = '3'.
PERFORM org_read_table TABLES org_outtab_x
USING tabname tabfeld txt1
key1 key2 key3 key4 key5
key6 key7 key8 key9 key10
sy-langu org_outtab-seq.
ENDLOOP.
WHEN OTHERS.
org_outtab-seq = '0'.
PERFORM org_read_table TABLES org_outtab_x
USING tabname tabfeld txt1
key1 key2 key3 key4 key5
key6 key7 key8 key9 key10
'E' org_outtab-seq.
ENDCASE.
PERFORM match_org_outtab TABLES org_outtab.
*output org info to extract file...
PERFORM org_out TABLES org_outtab.
*release memory...
FREE: org_outtab.
a = 0.
ENDIF.
ENDIF.
ENDLOOP.
CLEAR: tagstr.
FREE: org_tab, org_outtab_x.
ENDFORM. "ORG_WORK
*---------------------------------------------------------------------*
* FORM MATCH_ORG_OUTTAB *
*---------------------------------------------------------------------*
FORM match_org_outtab TABLES org_outtab STRUCTURE org_outtab.
DATA:org_outtab_1 LIKE org_outtab OCCURS 1.
DATA:org_outtab_1h LIKE org_outtab.
DATA:org_outtab_h LIKE org_outtab.
DATA: line TYPE i.
FIELD-SYMBOLS <wert> TYPE c.
SORT org_outtab BY tabelle feld wert seq.
LOOP AT org_outtab INTO org_outtab_h.
IF sy-tabix = 1.
MOVE org_outtab_h-tabelle TO org_outtab_1h-tabelle.
MOVE org_outtab_h-feld TO org_outtab_1h-feld.
MOVE org_outtab_h-feldbez TO org_outtab_1h-feldbez.
MOVE org_outtab_h-wert TO org_outtab_1h-wert.
MOVE org_outtab_h-wertbez TO org_outtab_1h-wertbez.
MOVE org_outtab_h-wertebez TO org_outtab_1h-wertebez.
MOVE org_outtab_h-seq TO org_outtab_1h-seq.
CONTINUE.
ENDIF.
IF org_outtab_h-tabelle = org_outtab_1h-tabelle
AND org_outtab_h-feld = org_outtab_1h-feld
AND org_outtab_h-wert = org_outtab_1h-wert.
IF org_outtab_1h-seq = org_outtab_h-seq
AND org_outtab_1h-seq = '3'.
CONTINUE.
ENDIF.
org_outtab_1h-wertebez = org_outtab_h-wertbez.
MOVE org_outtab_h-seq TO org_outtab_1h-seq.
ELSE.
IF org_outtab_1h-wertbez IS INITIAL.
MOVE org_outtab_1h-wertebez TO org_outtab_1h-wertbez.
ENDIF.
APPEND org_outtab_1h TO org_outtab_1.
MOVE org_outtab_h-tabelle TO org_outtab_1h-tabelle.
MOVE org_outtab_h-feld TO org_outtab_1h-feld.
MOVE org_outtab_h-feldbez TO org_outtab_1h-feldbez.
MOVE org_outtab_h-wert TO org_outtab_1h-wert.
MOVE org_outtab_h-wertbez TO org_outtab_1h-wertbez.
MOVE org_outtab_h-wertebez TO org_outtab_1h-wertebez.
MOVE org_outtab_h-seq TO org_outtab_1h-seq.
ENDIF.
ENDLOOP.
IF org_outtab_1h-wertbez IS INITIAL.
MOVE org_outtab_1h-wertebez TO org_outtab_1h-wertbez.
ENDIF.
APPEND org_outtab_1h TO org_outtab_1.
org_outtab[] = org_outtab_1[].
ASSIGN org_outtab-wert TO <wert>.
LOOP AT org_outtab.
line = sy-tabix.
TRANSLATE org_outtab TO UPPER CASE.
<wert> = org_outtab-wert.
MODIFY org_outtab INDEX line.
ENDLOOP.
SORT org_outtab BY feld wert.
DELETE ADJACENT DUPLICATES FROM org_outtab COMPARING feld wert.
FREE org_outtab_1.
ENDFORM. "MATCH_ORG_OUTTAB
*---------------------------------------------------------------------*
* FORM ORG_READ_TABLE *
*---------------------------------------------------------------------*
FORM org_read_table TABLES org_outtab_x STRUCTURE org_outtab
USING value(tabname) TYPE c
value(tabfeld) TYPE c
value(txt1) TYPE c
value(key1) TYPE c
value(key2) TYPE c
value(key3) TYPE c
value(key4) TYPE c
value(key5) TYPE c
value(key6) TYPE c
value(key7) TYPE c
value(key8) TYPE c
value(key9) TYPE c
value(key10) TYPE c
language
sequence TYPE c.
DATA: BEGIN OF wa OCCURS 1,
field0(240) TYPE c,
field1(240) TYPE c,
field2(240) TYPE c,
field3(240) TYPE c,
field4(240) TYPE c,
field5(240) TYPE c,
field6(240) TYPE c,
field7(240) TYPE c,
field8(240) TYPE c,
field9(240) TYPE c,
field10(240) TYPE c,
field11(240) TYPE c,
END OF wa,
str(72) TYPE c,
fields LIKE str OCCURS 1,
where LIKE str OCCURS 1.
*select fields
IF sequence NE '1'.
APPEND txt1 TO fields.
ENDIF.
APPEND tabfeld TO fields.
IF NOT key1 IS INITIAL. APPEND key1 TO fields. ENDIF.
IF NOT key2 IS INITIAL. APPEND key2 TO fields. ENDIF.
IF NOT key3 IS INITIAL. APPEND key3 TO fields. ENDIF.
IF NOT key4 IS INITIAL. APPEND key4 TO fields. ENDIF.
IF NOT key5 IS INITIAL. APPEND key5 TO fields. ENDIF.
IF NOT key6 IS INITIAL. APPEND key6 TO fields. ENDIF.
IF NOT key7 IS INITIAL. APPEND key7 TO fields. ENDIF.
IF NOT key8 IS INITIAL. APPEND key8 TO fields. ENDIF.
IF NOT key9 IS INITIAL. APPEND key9 TO fields. ENDIF.
IF NOT key10 IS INITIAL. APPEND key10 TO fields. ENDIF.
org_outtab-tabelle = tabname.
org_outtab-feld = tabfeld.
org_outtab-feldbez = tabfeld.
*where cond - local language.
CONCATENATE org_outtab-feld 'NE ''''' INTO str SEPARATED BY space.
APPEND str TO where.
CASE sequence.
WHEN '0' OR '1'.
WHEN '2' OR '4'.
CONCATENATE 'AND SPRAS = ''' language '''' INTO str.
APPEND str TO where.
CONCATENATE 'AND' org_outtab-feld '= '''
INTO str SEPARATED BY space.
CONCATENATE str org_outtab_x-wertbez '''' INTO str.
APPEND str TO where.
WHEN '3'.
MOVE 'AND SPRAS NE ''E'' AND SPRAS NE ''' TO str.
CONCATENATE str language '''' INTO str.
APPEND str TO where.
CONCATENATE 'AND' org_outtab-feld '= '''
INTO str SEPARATED BY space.
CONCATENATE str org_outtab_x-wertbez '''' INTO str.
APPEND str TO where.
ENDCASE.
* select data
SELECT (fields)
FROM (tabname) CLIENT SPECIFIED
INTO wa
WHERE mandt = client AND (where).
IF wa-field0 CA '|'.
REPLACE '|' WITH space INTO wa-field0.
ENDIF.
org_outtab-wertbez = wa-field0.
org_outtab-wertebez = wa-field0.
org_outtab-wert = wa-field1.
CASE key10.
WHEN vkey1. org_outtab-vkey1 = wa-field11.
WHEN vkey2. org_outtab-vkey2 = wa-field11.
WHEN vkey3. org_outtab-vkey3 = wa-field11.
WHEN vkey4. org_outtab-vkey4 = wa-field11.
WHEN vkey5. org_outtab-vkey5 = wa-field11.
WHEN vkey6. org_outtab-vkey6 = wa-field11.
WHEN vkey7. org_outtab-vkey7 = wa-field11.
WHEN vkey8. org_outtab-vkey8 = wa-field11.
WHEN vkey9. org_outtab-vkey9 = wa-field11.
WHEN vkey10. org_outtab-vkey10 = wa-field11.
WHEN vkey11. org_outtab-vkey11 = wa-field11.
WHEN vkey12. org_outtab-vkey12 = wa-field11.
WHEN vkey13. org_outtab-vkey13 = wa-field11.
WHEN vkey14. org_outtab-vkey14 = wa-field11.
WHEN vkey15. org_outtab-vkey15 = wa-field11.
* WHEN vkey16. org_outtab-vkey16 = wa-field11.
* WHEN vkey17. org_outtab-vkey17 = wa-field11.
* WHEN vkey18. org_outtab-vkey18 = wa-field11.
* WHEN vkey19. org_outtab-vkey19 = wa-field11.
* WHEN vkey20. org_outtab-vkey20 = wa-field11.
ENDCASE.
CASE key9.
WHEN vkey1. org_outtab-vkey1 = wa-field10.
WHEN vkey2. org_outtab-vkey2 = wa-field10.
WHEN vkey3. org_outtab-vkey3 = wa-field10.
WHEN vkey4. org_outtab-vkey4 = wa-field10.
WHEN vkey5. org_outtab-vkey5 = wa-field10.
WHEN vkey6. org_outtab-vkey6 = wa-field10.
WHEN vkey7. org_outtab-vkey7 = wa-field10.
WHEN vkey8. org_outtab-vkey8 = wa-field10.
WHEN vkey9. org_outtab-vkey9 = wa-field10.
WHEN vkey10. org_outtab-vkey10 = wa-field10.
WHEN vkey11. org_outtab-vkey11 = wa-field10.
WHEN vkey12. org_outtab-vkey12 = wa-field10.
WHEN vkey13. org_outtab-vkey13 = wa-field10.
WHEN vkey14. org_outtab-vkey14 = wa-field10.
WHEN vkey15. org_outtab-vkey15 = wa-field10.
* WHEN vkey16. org_outtab-vkey16 = wa-field10.
* WHEN vkey17. org_outtab-vkey17 = wa-field10.
* WHEN vkey18. org_outtab-vkey18 = wa-field10.
* WHEN vkey19. org_outtab-vkey19 = wa-field10.
* WHEN vkey20. org_outtab-vkey20 = wa-field10.
ENDCASE.
CASE key8.
WHEN vkey1. org_outtab-vkey1 = wa-field9.
WHEN vkey2. org_outtab-vkey2 = wa-field9.
WHEN vkey3. org_outtab-vkey3 = wa-field9.
WHEN vkey4. org_outtab-vkey4 = wa-field9.
WHEN vkey5. org_outtab-vkey5 = wa-field9.
WHEN vkey6. org_outtab-vkey6 = wa-field9.
WHEN vkey7. org_outtab-vkey7 = wa-field9.
WHEN vkey8. org_outtab-vkey8 = wa-field9.
WHEN vkey9. org_outtab-vkey9 = wa-field9.
WHEN vkey10. org_outtab-vkey10 = wa-field9.
WHEN vkey11. org_outtab-vkey11 = wa-field9.
WHEN vkey12. org_outtab-vkey12 = wa-field9.
WHEN vkey13. org_outtab-vkey13 = wa-field9.
WHEN vkey14. org_outtab-vkey14 = wa-field9.
WHEN vkey15. org_outtab-vkey15 = wa-field9.
* WHEN vkey16. org_outtab-vkey16 = wa-field9.
* WHEN vkey17. org_outtab-vkey17 = wa-field9.
* WHEN vkey18. org_outtab-vkey18 = wa-field9.
* WHEN vkey19. org_outtab-vkey19 = wa-field9.
* WHEN vkey20. org_outtab-vkey20 = wa-field9.
ENDCASE.
CASE key7.
WHEN vkey1. org_outtab-vkey1 = wa-field8.
WHEN vkey2. org_outtab-vkey2 = wa-field8.
WHEN vkey3. org_outtab-vkey3 = wa-field8.
WHEN vkey4. org_outtab-vkey4 = wa-field8.
WHEN vkey5. org_outtab-vkey5 = wa-field8.
WHEN vkey6. org_outtab-vkey6 = wa-field8.
WHEN vkey7. org_outtab-vkey7 = wa-field8.
WHEN vkey8. org_outtab-vkey8 = wa-field8.
WHEN vkey9. org_outtab-vkey9 = wa-field8.
WHEN vkey10. org_outtab-vkey10 = wa-field8.
WHEN vkey11. org_outtab-vkey11 = wa-field8.
WHEN vkey12. org_outtab-vkey12 = wa-field8.
WHEN vkey13. org_outtab-vkey13 = wa-field8.
WHEN vkey14. org_outtab-vkey14 = wa-field8.
WHEN vkey15. org_outtab-vkey15 = wa-field8.
* WHEN vkey16. org_outtab-vkey16 = wa-field8.
* WHEN vkey17. org_outtab-vkey17 = wa-field8.
* WHEN vkey18. org_outtab-vkey18 = wa-field8.
* WHEN vkey19. org_outtab-vkey19 = wa-field8.
* WHEN vkey20. org_outtab-vkey20 = wa-field8.
ENDCASE.
CASE key6.
WHEN vkey1. org_outtab-vkey1 = wa-field7.
WHEN vkey2. org_outtab-vkey2 = wa-field7.
WHEN vkey3. org_outtab-vkey3 = wa-field7.
WHEN vkey4. org_outtab-vkey4 = wa-field7.
WHEN vkey5. org_outtab-vkey5 = wa-field7.
WHEN vkey6. org_outtab-vkey6 = wa-field7.
WHEN vkey7. org_outtab-vkey7 = wa-field7.
WHEN vkey8. org_outtab-vkey8 = wa-field7.
WHEN vkey9. org_outtab-vkey9 = wa-field7.
WHEN vkey10. org_outtab-vkey10 = wa-field7.
WHEN vkey11. org_outtab-vkey11 = wa-field7.
WHEN vkey12. org_outtab-vkey12 = wa-field7.
WHEN vkey13. org_outtab-vkey13 = wa-field7.
WHEN vkey14. org_outtab-vkey14 = wa-field7.
WHEN vkey15. org_outtab-vkey15 = wa-field7.
* WHEN vkey16. org_outtab-vkey16 = wa-field7.
* WHEN vkey17. org_outtab-vkey17 = wa-field7.
* WHEN vkey18. org_outtab-vkey18 = wa-field7.
* WHEN vkey19. org_outtab-vkey19 = wa-field7.
* WHEN vkey20. org_outtab-vkey20 = wa-field7.
ENDCASE.
CASE key5.
WHEN vkey1. org_outtab-vkey1 = wa-field6.
WHEN vkey2. org_outtab-vkey2 = wa-field6.
WHEN vkey3. org_outtab-vkey3 = wa-field6.
WHEN vkey4. org_outtab-vkey4 = wa-field6.
WHEN vkey5. org_outtab-vkey5 = wa-field6.
WHEN vkey6. org_outtab-vkey6 = wa-field6.
WHEN vkey7. org_outtab-vkey7 = wa-field6.
WHEN vkey8. org_outtab-vkey8 = wa-field6.
WHEN vkey9. org_outtab-vkey9 = wa-field6.
WHEN vkey10. org_outtab-vkey10 = wa-field6.
WHEN vkey11. org_outtab-vkey11 = wa-field6.
WHEN vkey12. org_outtab-vkey12 = wa-field6.
WHEN vkey13. org_outtab-vkey13 = wa-field6.
WHEN vkey14. org_outtab-vkey14 = wa-field6.
WHEN vkey15. org_outtab-vkey15 = wa-field6.
* WHEN vkey16. org_outtab-vkey16 = wa-field6.
* WHEN vkey17. org_outtab-vkey17 = wa-field6.
* WHEN vkey18. org_outtab-vkey18 = wa-field6.
* WHEN vkey19. org_outtab-vkey19 = wa-field6.
* WHEN vkey20. org_outtab-vkey20 = wa-field6.
ENDCASE.
CASE key4.
WHEN vkey1. org_outtab-vkey1 = wa-field5.
WHEN vkey2. org_outtab-vkey2 = wa-field5.
WHEN vkey3. org_outtab-vkey3 = wa-field5.
WHEN vkey4. org_outtab-vkey4 = wa-field5.
WHEN vkey5. org_outtab-vkey5 = wa-field5.
WHEN vkey6. org_outtab-vkey6 = wa-field5.
WHEN vkey7. org_outtab-vkey7 = wa-field5.
WHEN vkey8. org_outtab-vkey8 = wa-field5.
WHEN vkey9. org_outtab-vkey9 = wa-field5.
WHEN vkey10. org_outtab-vkey10 = wa-field5.
WHEN vkey11. org_outtab-vkey11 = wa-field5.
WHEN vkey12. org_outtab-vkey12 = wa-field5.
WHEN vkey13. org_outtab-vkey13 = wa-field5.
WHEN vkey14. org_outtab-vkey14 = wa-field5.
WHEN vkey15. org_outtab-vkey15 = wa-field5.
* WHEN vkey16. org_outtab-vkey16 = wa-field5.
* WHEN vkey17. org_outtab-vkey17 = wa-field5.
* WHEN vkey18. org_outtab-vkey18 = wa-field5.
* WHEN vkey19. org_outtab-vkey19 = wa-field5.
* WHEN vkey20. org_outtab-vkey20 = wa-field5.
ENDCASE.
CASE key3.
WHEN vkey1. org_outtab-vkey1 = wa-field4.
WHEN vkey2. org_outtab-vkey2 = wa-field4.
WHEN vkey3. org_outtab-vkey3 = wa-field4.
WHEN vkey4. org_outtab-vkey4 = wa-field4.
WHEN vkey5. org_outtab-vkey5 = wa-field4.
WHEN vkey6. org_outtab-vkey6 = wa-field4.
WHEN vkey7. org_outtab-vkey7 = wa-field4.
WHEN vkey8. org_outtab-vkey8 = wa-field4.
WHEN vkey9. org_outtab-vkey9 = wa-field4.
WHEN vkey10. org_outtab-vkey10 = wa-field4.
WHEN vkey11. org_outtab-vkey11 = wa-field4.
WHEN vkey12. org_outtab-vkey12 = wa-field4.
WHEN vkey13. org_outtab-vkey13 = wa-field4.
WHEN vkey14. org_outtab-vkey14 = wa-field4.
WHEN vkey15. org_outtab-vkey15 = wa-field4.
* WHEN vkey16. org_outtab-vkey16 = wa-field4.
* WHEN vkey17. org_outtab-vkey17 = wa-field4.
* WHEN vkey18. org_outtab-vkey18 = wa-field4.
* WHEN vkey19. org_outtab-vkey19 = wa-field4.
* WHEN vkey20. org_outtab-vkey20 = wa-field4.
ENDCASE.
CASE key2.
WHEN vkey1. org_outtab-vkey1 = wa-field3.
WHEN vkey2. org_outtab-vkey2 = wa-field3.
WHEN vkey3. org_outtab-vkey3 = wa-field3.
WHEN vkey4. org_outtab-vkey4 = wa-field3.
WHEN vkey5. org_outtab-vkey5 = wa-field3.
WHEN vkey6. org_outtab-vkey6 = wa-field3.
WHEN vkey7. org_outtab-vkey7 = wa-field3.
WHEN vkey8. org_outtab-vkey8 = wa-field3.
WHEN vkey9. org_outtab-vkey9 = wa-field3.
WHEN vkey10. org_outtab-vkey10 = wa-field3.
WHEN vkey11. org_outtab-vkey11 = wa-field3.
WHEN vkey12. org_outtab-vkey12 = wa-field3.
WHEN vkey13. org_outtab-vkey13 = wa-field3.
WHEN vkey14. org_outtab-vkey14 = wa-field3.
WHEN vkey15. org_outtab-vkey15 = wa-field3.
* WHEN vkey16. org_outtab-vkey16 = wa-field3.
* WHEN vkey17. org_outtab-vkey17 = wa-field3.
* WHEN vkey18. org_outtab-vkey18 = wa-field3.
* WHEN vkey19. org_outtab-vkey19 = wa-field3.
* WHEN vkey20. org_outtab-vkey20 = wa-field3.
ENDCASE.
CASE key1.
WHEN vkey1. org_outtab-vkey1 = wa-field2.
WHEN vkey2. org_outtab-vkey2 = wa-field2.
WHEN vkey3. org_outtab-vkey3 = wa-field2.
WHEN vkey4. org_outtab-vkey4 = wa-field2.
WHEN vkey5. org_outtab-vkey5 = wa-field2.
WHEN vkey6. org_outtab-vkey6 = wa-field2.
WHEN vkey7. org_outtab-vkey7 = wa-field2.
WHEN vkey8. org_outtab-vkey8 = wa-field2.
WHEN vkey9. org_outtab-vkey9 = wa-field2.
WHEN vkey10. org_outtab-vkey10 = wa-field2.
WHEN vkey11. org_outtab-vkey11 = wa-field2.
WHEN vkey12. org_outtab-vkey12 = wa-field2.
WHEN vkey13. org_outtab-vkey13 = wa-field2.
WHEN vkey14. org_outtab-vkey14 = wa-field2.
WHEN vkey15. org_outtab-vkey15 = wa-field2.
* WHEN vkey16. org_outtab-vkey16 = wa-field2.
* WHEN vkey17. org_outtab-vkey17 = wa-field2.
* WHEN vkey18. org_outtab-vkey18 = wa-field2.
* WHEN vkey19. org_outtab-vkey19 = wa-field2.
* WHEN vkey20. org_outtab-vkey20 = wa-field2.
ENDCASE.
IF tabname = 'T001L'.
DATA: too1lkey(15) TYPE c.
IF vkey1 = 'WERKS'.
too1lkey = org_outtab-vkey1.
CLEAR org_outtab-vkey1.
ENDIF.
IF vkey2 = 'WERKS'.
too1lkey = org_outtab-vkey2.
CLEAR org_outtab-vkey2.
ENDIF.
IF vkey3 = 'WERKS'.
too1lkey = org_outtab-vkey3.
CLEAR org_outtab-vkey3.
ENDIF.
IF vkey4 = 'WERKS'.
too1lkey = org_outtab-vkey4.
CLEAR org_outtab-vkey4.
ENDIF.
IF vkey5 = 'WERKS'.
too1lkey = org_outtab-vkey5.
CLEAR org_outtab-vkey5.
ENDIF.
IF vkey6 = 'WERKS'.
too1lkey = org_outtab-vkey6.
CLEAR org_outtab-vkey6.
ENDIF.
IF vkey7 = 'WERKS'.
too1lkey = org_outtab-vkey7.
CLEAR org_outtab-vkey7.
ENDIF.
IF vkey8 = 'WERKS'.
too1lkey = org_outtab-vkey8.
CLEAR org_outtab-vkey8.
ENDIF.
IF vkey9 = 'WERKS'.
too1lkey = org_outtab-vkey9.
CLEAR org_outtab-vkey9.
ENDIF.
IF vkey10 = 'WERKS'.
too1lkey = org_outtab-vkey10.
CLEAR org_outtab-vkey10.
ENDIF.
IF vkey1 = 'LGORT'.
CONCATENATE org_outtab-vkey1 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
IF vkey2 = 'LGORT'.
CONCATENATE org_outtab-vkey2 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
IF vkey3 = 'LGORT'.
CONCATENATE org_outtab-vkey3 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
IF vkey4 = 'LGORT'.
CONCATENATE org_outtab-vkey4 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
IF vkey5 = 'LGORT'.
CONCATENATE org_outtab-vkey5 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
IF vkey6 = 'LGORT'.
CONCATENATE org_outtab-vkey6 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
IF vkey7 = 'LGORT'.
CONCATENATE org_outtab-vkey7 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
IF vkey8 = 'LGORT'.
CONCATENATE org_outtab-vkey8 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
IF vkey9 = 'LGORT'.
CONCATENATE org_outtab-vkey9 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
IF vkey10 = 'LGORT'.
CONCATENATE org_outtab-vkey10 '-' too1lkey
INTO org_outtab-wert.
ENDIF.
ENDIF.
IF sy-subrc = 0.
APPEND org_outtab.
ELSE.
IF sequence = '2' OR sequence = '3' OR sequence = '4'.
org_outtab-wert = org_outtab_x-wertbez.
org_outtab-wertbez = space.
org_outtab-wertebez = space.
APPEND org_outtab.
ENDIF.
ENDIF.
ENDSELECT.
FREE: wa, fields, where.
ENDFORM. "ORG_READ_TABLE
*---------------------------------------------------------------------*
* FORM ORG_OUT *
*---------------------------------------------------------------------*
FORM org_out TABLES org_outtab STRUCTURE org_outtab.
DATA: l_str(c_buflen) TYPE c.
LOOP AT org_outtab.
IF org_outtab-wert IS INITIAL.
CONTINUE.
ELSE.
CONCATENATE extractid
org_outtab-feld
org_outtab-wert org_outtab-wertbez
org_outtab-wertebez
INTO l_str SEPARATED BY '|'.
waOrgUnit-Name = org_outtab-feld.
waOrgUnit-Value = org_outtab-wert.
waOrgUnit-TextE = org_outtab-wertbez.
waOrgUnit-TextL = org_outtab-wertebez.
Append waOrgUnit to waExtFile-OrgUnit.
PERFORM write_content USING l_str.
ENDIF.
ENDLOOP.
ENDFORM. "ORG_OUT
*---------------------------------------------------------------------*
* FORM orgrel_work *
*---------------------------------------------------------------------*
FORM orgrel_work TABLES tab.
DATA: tabname(15) TYPE c,
tabfeld(15) TYPE c,
jointab1(15) TYPE c,
joinkey1(15) TYPE c,
jointab2(15) TYPE c,
joinkey2(15) TYPE c,
field2(15) TYPE c,
soption(15) TYPE c.
DATA: a TYPE i.
DATA: no_tab TYPE i.
a = 0.
tagstr = '~ORGREL'.
PERFORM write_content USING tagstr.
LOOP AT org_tab.
IF org_tab(1) <> '*' AND org_tab <> ''.
TRANSLATE org_tab TO UPPER CASE.
IF org_tab <> '--'.
CASE a.
WHEN 0. tabname = org_tab.
WHEN 1.
tabfeld = org_tab.
CLEAR: jointab1, joinkey1,
jointab2, joinkey2,
field2, soption.
WHEN 2. jointab1 = org_tab.
WHEN 3. joinkey1 = org_tab.
WHEN 4. jointab2 = org_tab.
WHEN 5. joinkey2 = org_tab.
WHEN 6. field2 = org_tab.
WHEN 7. soption = org_tab.
ENDCASE.
a = a + 1.
CONTINUE.
ELSE.
IF jointab2 IS INITIAL
AND joinkey2 IS INITIAL.
jointab2 = jointab1.
joinkey2 = joinkey1.
CLEAR jointab1.
CLEAR joinkey1.
ENDIF.
IF field2 IS INITIAL
AND soption IS INITIAL.
field2 = jointab2.
soption = joinkey2.
CLEAR jointab2.
CLEAR joinkey2.
ENDIF.
* Check if table exist
IF NOT tabname IS INITIAL.
PERFORM check_org_tables_exist USING tabname CHANGING no_tab.
IF no_tab = 1.
CLEAR: no_tab, tabname, jointab1, jointab2,
tabfeld, joinkey1, joinkey2, field2, soption.
a = 0.
CONTINUE.
ENDIF.
ENDIF.
* Check if jointable1 exist
IF NOT jointab1 IS INITIAL.
PERFORM check_org_tables_exist USING jointab1 CHANGING no_tab.
IF no_tab = 1.
CLEAR: no_tab, tabname, jointab1, jointab2,
tabfeld, joinkey1, joinkey2, field2, soption.
a = 0.
CONTINUE.
ENDIF.
ENDIF.
* Check if join-table2 exist
IF NOT jointab2 IS INITIAL.
PERFORM check_org_tables_exist USING jointab2 CHANGING no_tab.
IF no_tab = 1.
CLEAR: no_tab, tabname, jointab1, jointab2,
tabfeld, joinkey1, joinkey2, field2, soption.
a = 0.
CONTINUE.
ENDIF.
ENDIF.
* Check if field TABFELD exist
IF NOT tabfeld IS INITIAL
AND NOT tabname IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname tabfeld
CHANGING no_tab.
IF no_tab = 1.
CLEAR: no_tab, tabname, jointab1, jointab2,
tabfeld, joinkey1, joinkey2, field2, soption.
a = 0.
CONTINUE.
ENDIF.
ENDIF.
* Check if field JOINKEY1 exist
IF NOT joinkey1 IS INITIAL
AND NOT tabname IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname joinkey1
CHANGING no_tab.
IF no_tab = 1.
CLEAR: no_tab, tabname, jointab1, jointab2,
tabfeld, joinkey1, joinkey2, field2, soption.
a = 0.
CONTINUE.
ENDIF.
ENDIF.
IF NOT joinkey1 IS INITIAL
AND NOT jointab1 IS INITIAL.
PERFORM check_org_tab_field_exist
USING jointab1 joinkey1
CHANGING no_tab.
IF no_tab = 1.
CLEAR: no_tab, tabname, jointab1, jointab2,
tabfeld, joinkey1, joinkey2, field2, soption.
a = 0.
CONTINUE.
ENDIF.
ENDIF.
* Check if field JOINKEY2 exist
IF NOT joinkey2 IS INITIAL
AND NOT tabname IS INITIAL.
PERFORM check_org_tab_field_exist
USING tabname joinkey2
CHANGING no_tab.
IF no_tab = 1.
CLEAR: no_tab, tabname, jointab1, jointab2,
tabfeld, joinkey1, joinkey2, field2, soption.
a = 0.
CONTINUE.
ENDIF.
ENDIF.
IF NOT joinkey2 IS INITIAL.
PERFORM check_org_tab_field_exist
USING jointab2 joinkey2
CHANGING no_tab.
IF no_tab = 1.
CLEAR: no_tab, tabname, jointab1, jointab2,
tabfeld, joinkey1, joinkey2, field2, soption.
a = 0.
CONTINUE.
ENDIF.
ENDIF.
* Check if field FIELD2 exist
IF NOT field2 IS INITIAL
AND NOT jointab1 IS INITIAL.
PERFORM check_org_tab_field_exist
USING jointab1 field2
CHANGING no_tab.
IF no_tab = 1.
CLEAR: no_tab, tabname, jointab1, jointab2,
tabfeld, joinkey1, joinkey2, field2, soption.
a = 0.
CONTINUE.
ENDIF.
ENDIF.
PERFORM orgrel_read_table USING tabname tabfeld
jointab1 joinkey1
jointab2 joinkey2
field2 soption.
a = 0.
ENDIF.
ENDIF.
ENDLOOP.
CLEAR: tagstr.
FREE: org_tab.
ENDFORM. "ORGREL_WORK
*---------------------------------------------------------------------*
* FORM ORGREL_READ_TABLE *
*---------------------------------------------------------------------*
FORM orgrel_read_table USING value(tabname) TYPE c
value(tabfield) TYPE c
value(jointab1) TYPE c
value(joinkey1) TYPE c
value(jointab2) TYPE c
value(joinkey2) TYPE c
value(field2) TYPE c
value(soption) TYPE c.
DATA: BEGIN OF wa OCCURS 1,
mandt(3) TYPE c,
tabname(15) TYPE c,
fieldname1(15) TYPE c,
tabfield(15) TYPE c,
fieldname2(15) TYPE c,
field2(15) TYPE c,
jointab1(15) TYPE c,
joinkey1(15) TYPE c,
jointab2(15) TYPE c,
joinkey2(15) TYPE c,
soption(1) TYPE c,
END OF wa,
BEGIN OF wb OCCURS 1,
mandt(3) TYPE c,
tabname(15) TYPE c,
fieldname1(15) TYPE c,
tabfield(15) TYPE c,
fieldname2(15) TYPE c,
field2(15) TYPE c,
jointab1(15) TYPE c,
joinkey1(15) TYPE c,
jointab2(15) TYPE c,
joinkey2(15) TYPE c,
soption(1) TYPE c,
END OF wb,
str(72) TYPE c,
fields LIKE str OCCURS 1,
where LIKE str OCCURS 1,
loop TYPE i,
places TYPE p.
* select fields
CLEAR wa.
REFRESH wa.
wa-mandt = client.
wa-tabname = tabname.
wa-fieldname1 = tabfield.
wa-fieldname2 = field2.
wa-jointab1 = jointab1.
wa-joinkey1 = joinkey1.
wa-jointab2 = jointab2.
wa-joinkey2 = joinkey2.
wa-soption = soption.
IF NOT tabfield IS INITIAL.
CONCATENATE tabfield 'AS TABFIELD' INTO str SEPARATED BY ' '.
APPEND str TO fields.
ENDIF.
IF NOT joinkey1 IS INITIAL.
CONCATENATE joinkey1 'AS JOINKEY1' INTO str SEPARATED BY ' '.
APPEND str TO fields.
ELSE.
IF NOT field2 IS INITIAL.
CONCATENATE field2 'AS FIELD2' INTO str SEPARATED BY ' '.
APPEND str TO fields.
ENDIF.
ENDIF.
loop = 0.
LOOP AT fields INTO str.
IF str CS ' AS '.
DESCRIBE FIELD str LENGTH places IN CHARACTER MODE.
SUBTRACT sy-fdpos FROM places.
IF places > 0.
SHIFT str RIGHT BY places PLACES.
SHIFT str LEFT DELETING LEADING space.
ENDIF.
ENDIF.
CASE loop.
WHEN 0.
CONCATENATE str 'NE ''''' INTO str SEPARATED BY space.
APPEND str TO where.
ADD 1 TO loop.
WHEN OTHERS.
CONCATENATE 'AND' str 'NE ''''' INTO str SEPARATED BY space.
APPEND str TO where.
ADD 1 TO loop.
ENDCASE.
ENDLOOP.
* select data
SELECT (fields)
FROM (tabname) CLIENT SPECIFIED
INTO CORRESPONDING FIELDS OF wa
WHERE mandt = client AND (where).
APPEND wa.
ENDSELECT.
* LOOP AT WA.
* TRANSLATE WA-TABFIELD TO UPPER CASE.
* SORT WA BY FIELDNAME1 TABFIELD.
* DELETE ADJACENT DUPLICATES FROM WA COMPARING FIELDNAME1 TABFIELD.
* ENDLOOP.
IF NOT joinkey1 IS INITIAL.
SORT wa BY tabfield joinkey1.
DELETE ADJACENT DUPLICATES FROM wa COMPARING tabfield joinkey1.
LOOP AT wa.
CLEAR: fields, where.
REFRESH: fields, where.
loop = 0.
IF NOT joinkey1 IS INITIAL.
CONCATENATE joinkey1 'AS JOINKEY1' INTO str SEPARATED BY ' '.
APPEND str TO fields.
ENDIF.
IF NOT joinkey2 IS INITIAL.
CONCATENATE joinkey2 'AS JOINKEY2' INTO str SEPARATED BY ' '.
APPEND str TO fields.
ELSE.
IF NOT field2 IS INITIAL.
CONCATENATE field2 'AS FIELD2' INTO str SEPARATED BY ' '.
APPEND str TO fields.
ENDIF.
ENDIF.
LOOP AT fields INTO str.
IF str CS ' AS '.
DESCRIBE FIELD str LENGTH places IN CHARACTER MODE.
SUBTRACT sy-fdpos FROM places.
IF places > 0.
SHIFT str RIGHT BY places PLACES.
SHIFT str LEFT DELETING LEADING space.
ENDIF.
ENDIF.
CASE loop.
WHEN 0.
CONCATENATE str ' EQ '' ' wa-joinkey1 '''' INTO str.
APPEND str TO where.
ADD 1 TO loop.
WHEN OTHERS.
CONCATENATE 'AND' str 'NE ''''' INTO str SEPARATED BY space.
APPEND str TO where.
ADD 1 TO loop.
ENDCASE.
ENDLOOP.
wb = wa.
SELECT (fields)
FROM (jointab1) CLIENT SPECIFIED
INTO CORRESPONDING FIELDS OF wb
WHERE mandt = client AND (where).
APPEND wb.
ENDSELECT.
ENDLOOP.
wa[] = wb[].
REFRESH wb.
IF NOT joinkey2 IS INITIAL.
SORT wa BY tabfield joinkey1 joinkey2.
DELETE ADJACENT DUPLICATES FROM wa
COMPARING tabfield joinkey1 joinkey2.
ELSE.
SORT wa BY tabfield joinkey1 field2.
DELETE ADJACENT DUPLICATES FROM wa
COMPARING tabfield joinkey1 field2.
ENDIF.
ENDIF.
IF NOT joinkey2 IS INITIAL.
LOOP AT wa.
CLEAR: fields, where.
REFRESH: fields, where.
loop = 0.
IF NOT joinkey2 IS INITIAL.
CONCATENATE joinkey2 'AS JOINKEY2' INTO str SEPARATED BY ' '.
APPEND str TO fields.
ENDIF.
IF NOT field2 IS INITIAL.
CONCATENATE field2 'AS FIELD2' INTO str SEPARATED BY ' '.
APPEND str TO fields.
ENDIF.
LOOP AT fields INTO str.
IF str CS ' AS '.
DESCRIBE FIELD str LENGTH places IN CHARACTER MODE.
SUBTRACT sy-fdpos FROM places.
IF places > 0.
SHIFT str RIGHT BY places PLACES.
SHIFT str LEFT DELETING LEADING space.
ENDIF.
ENDIF.
CASE loop.
WHEN 0.
CONCATENATE str ' EQ '' ' wa-joinkey2 '''' INTO str.
APPEND str TO where.
ADD 1 TO loop.
WHEN OTHERS.
CONCATENATE 'AND' str 'NE ''''' INTO str SEPARATED BY space.
APPEND str TO where.
ADD 1 TO loop.
ENDCASE.
ENDLOOP.
wb = wa.
SELECT (fields)
FROM (jointab2) CLIENT SPECIFIED
INTO CORRESPONDING FIELDS OF wb
WHERE mandt = client AND (where).
APPEND wb.
ENDSELECT.
ENDLOOP.
wa[] = wb[].
REFRESH wb.
SORT wa BY tabfield joinkey2 field2.
DELETE ADJACENT DUPLICATES FROM wa
COMPARING tabfield joinkey2 field2.
ENDIF.
LOOP AT wa WHERE tabname = 'T001L'.
CONCATENATE wa-field2 '-' wa-tabfield INTO wa-field2.
MODIFY wa.
ENDLOOP.
CASE wa-soption.
WHEN 'S'.
SORT wa BY field2 tabfield.
DELETE ADJACENT DUPLICATES FROM wa COMPARING field2 tabfield.
WHEN OTHERS.
SORT wa BY tabfield field2.
DELETE ADJACENT DUPLICATES FROM wa COMPARING tabfield field2.
ENDCASE.
LOOP AT wa.
IF wa-tabfield IS INITIAL
OR wa-field2 IS INITIAL.
CONTINUE.
ELSE.
CONCATENATE
extractid
wa-fieldname1
wa-tabfield
wa-fieldname2
wa-field2
INTO str SEPARATED BY '|'.
CONDENSE str.
waOrgRel-Rel1 = wa-fieldname1.
waOrgRel-Value1 = wa-tabfield.
waOrgRel-Rel2 = wa-fieldname2.
waOrgRel-Value2 = wa-field2.
Append waOrgRel to waExtFile-OrgRel.
PERFORM write_content USING str.
ENDIF.
ENDLOOP.
FREE: wa, fields, where.
ENDFORM. "ORGREL_READ_TABLE
*&---------------------------------------------------------------------*
*& Form check_org_tables_exist
*&---------------------------------------------------------------------*
FORM check_org_tables_exist USING p_tabname
CHANGING p_no_tab.
* Check if Tabname exists
SELECT SINGLE tabname FROM dd02l INTO (dd02l-tabname)
WHERE tabname = p_tabname.
IF sy-subrc <> 0.
p_no_tab = 1.
ENDIF.
ENDFORM. " check_org_tables_exist
*&---------------------------------------------------------------------*
*& Form CHECK_ORG_TAB_Field_EXIST
*&---------------------------------------------------------------------*
FORM check_org_tab_field_exist USING p_tabname
p_field
CHANGING p_no_tab.
SELECT SINGLE fieldname FROM dd03l INTO (dd03l-fieldname)
WHERE tabname = p_tabname
AND fieldname = p_field.
IF sy-subrc <> 0.
p_no_tab = 1.
ENDIF.
ENDFORM. " CHECK_ORG_TAB_Field_EXIST
*&---------------------------------------------------------------------*
*& Form OPEN_EXTRACT_FILE
*&---------------------------------------------------------------------*
FORM open_extract_file USING p_mode.
DATA: len TYPE i.
*open a new file on the application server for output...
IF p_mode = 'O'.
OPEN DATASET apppath1 FOR OUTPUT IN TEXT MODE ENCODING DEFAULT.
IF syst-subrc NE 0.
len = STRLEN( apppath1 ).
WRITE: / 'There was an error opening the file in output mode:',
AT /1(len) apppath1 COLOR 6.
SKIP 2.
WRITE: / 'Please check that the directory exists on the',
'application server:', syst-host.
STOP.
ENDIF.
ENDIF.
*open a file on the application server for appending more data...
IF p_mode = 'A'.
OPEN DATASET apppath1 FOR APPENDING IN TEXT MODE ENCODING DEFAULT.
IF syst-subrc NE 0.
len = STRLEN( apppath1 ).
WRITE: / 'There was an error opening the file in append mode:',
AT /1(len) apppath1 COLOR 6.
SKIP 2.
WRITE: / 'Please check that the file and directory exists',
'on the application server:', syst-host.
STOP.
ENDIF.
ENDIF.
ENDFORM. " OPEN_EXTRACT_FILE
*&---------------------------------------------------------------------*
*& Form CLOSE_EXTRACT_FILE
*&---------------------------------------------------------------------*
FORM close_extract_file.
*close file on application server...
CLOSE DATASET apppath1.
ENDFORM. " CLOSE_EXTRACT_FILE
*&---------------------------------------------------------------------*
*& Form WRITE_TO_FILE
*&---------------------------------------------------------------------*
FORM write_to_file USING p_this.
*write data to file...
TRANSFER p_this TO apppath1.
IF syst-subrc NE 0.
WRITE: / 'There was an error writing to the file.' COLOR 6.
EXIT.
ENDIF.
ENDFORM. " WRITE_TO_FILE
*&---------------------------------------------------------------------*
*& Form SET_WORKLOAD_DATES
*&---------------------------------------------------------------------*
FORM set_workload_dates.
DATA: fromdate LIKE syst-datum,
todate LIKE syst-datum.
CLEAR: fromdate, todate.
*change format from mm/yyyy to yyyymmdd
montime-sign = 'I'.
montime-option = 'BT'.
*fromdate is the first day in the month....
fromdate+0(4) = monifrom+3(4).
fromdate+4(2) = monifrom+0(2).
fromdate+6(2) = '01'.
*todate is the last day in the month...
IF NOT moni_to IS INITIAL.
todate+0(4) = moni_to+3(4).
todate+4(2) = moni_to+0(2).
todate+6(2) = '01'.
ELSE.
todate = fromdate.
ENDIF.
* Get last day of last month
PERFORM last_day_of_months CHANGING todate.
montime-low = fromdate.
montime-high = todate.
APPEND montime.
ENDFORM. " SET_WORKLOAD_DATES
*&---------------------------------------------------------------------*
*& Form VALIDATE_TXNMONITOR_DATE
*&---------------------------------------------------------------------*
FORM validate_txnmonitor_date USING value(p_ucomm)
LIKE sscrfields-ucomm.
*At least the from month should be specified....
IF p_ucomm <> 'FC03' AND p_ucomm <> 'FC04'.
IF monifrom IS INITIAL.
MESSAGE e162(00) WITH 'Please specify at least one month in the'
'transaction monitor time frame.'.
STOP.
ENDIF.
IF moni_to IS INITIAL.
MESSAGE e162(00) WITH 'Please specify To month for Transaction'
'Monitor Timeframe.'.
STOP.
ENDIF.
PERFORM month_year_validity USING monifrom.
PERFORM month_year_validity USING moni_to.
PERFORM from_less_than_to USING monifrom moni_to.
READ TABLE ss_time_frame WITH KEY value = monifrom.
IF sy-subrc = 0.
ELSE.
MESSAGE i162(00) WITH 'Time frame for transaction monitor'
'not available (Start time)'.
STOP.
ENDIF.
READ TABLE ss_time_frame WITH KEY value = moni_to.
IF sy-subrc = 0.
ELSE.
MESSAGE i162(00) WITH 'Time frame for transaction monitor'
'not available (End time)'.
STOP.
ENDIF.
ENDIF.
ENDFORM. " VALIDATE_TXNMONITOR_DATE
*&---------------------------------------------------------------------*
*& Form VALIDATE_TABLE_QUERY_DATE
*&---------------------------------------------------------------------*
FORM validate_table_query_date USING value(p_ucomm)
LIKE sscrfields-ucomm.
IF workload IS NOT INITIAL.
lv_all_query = ' '.
ELSE.
IF p_ucomm <> 'FC03' AND p_ucomm <> 'FC04'.
IF tq_from IS INITIAL.
MESSAGE e162(00) WITH 'Please specify at least one month in the'
'table query time frame.'.
STOP.
ENDIF.
IF tq_to IS INITIAL.
MESSAGE e162(00) WITH
'Please specify To month for the Table Query'
'Timeframe.'.
STOP.
ENDIF.
PERFORM month_year_validity USING tq_from.
PERFORM month_year_validity USING tq_to.
PERFORM from_less_than_to USING tq_from tq_to.
IF tq_to+3(4) EQ sy-datum+0(4).
IF tq_to+0(2) GT sy-datum+4(2).
MESSAGE i162(00) WITH 'Time frame for table query'
'not available (End time)'.
STOP.
ENDIF.
ELSEIF tq_to+3(4) GT sy-datum+0(4).
MESSAGE i162(00) WITH 'Time frame for table query'
'not available (End time)'.
STOP.
ENDIF.
ENDIF.
ENDIF.
ENDFORM. " VALIDATE_TABLE_QUERY_DATE
*&---------------------------------------------------------------------*
*& Form WRITE_EXTRACT_INFO
*&---------------------------------------------------------------------*
FORM write_extract_info.
DATA: l_str(2048) TYPE c,
l_extract_type(1) TYPE c.
*write info specific to the exract being created...
tagstr = '~EXTRACTINFO'.
PERFORM write_content USING tagstr.
IF all = 'X'.
l_extract_type = '1'.
ELSE.
l_extract_type = '0'.
tq_time-low+0(6) = '000000'.
tq_time-high+0(6) = '000000'.
ENDIF.
CONDENSE extractid NO-GAPS.
CONCATENATE extractid syst-datum syst-host syst-uname l_extract_type
extract_option montime-low+0(6) montime-high+0(6)
tq_time-low+0(6) tq_time-high+0(6) structureid
INTO l_str SEPARATED BY '|'.
waExtractInfo-ExecutionDate = syst-datum.
waExtractInfo-ApplicationServer = syst-host.
waExtractInfo-Language = ''.
waExtractInfo-UserID = syst-uname.
* waExtractInfo-ExtractType = l_extract_type.
* waExtractInfo-ExtractOption = extract_option.
waExtractInfo-TransactionTimeFrameStart = montime-low+0(6).
waExtractInfo-TransactionTimeFrameEnd = montime-high+0(6).
waExtractInfo-SQLTimeFrameStart = tq_time-low+0(6).
waExtractInfo-SQLTimeFrameEnd = tq_time-high+0(6).
* waExtractInfo-StructureID = structureid.
PERFORM write_content USING l_str.
LOOP AT cat_node.
CLEAR l_str.
CONCATENATE extractid cat_node-node_id INTO l_str SEPARATED BY '|'.
* waNodes-NodeId = cat_node-node_id.
* Append waNodes to waExtractInfo-Nodes.
PERFORM write_content USING l_str.
ENDLOOP.
CLEAR: tagstr.
CLEAR cat_node. REFRESH cat_node. FREE cat_node.
* Append waExtractInfo to waExtFile-ExtractInfo.
ENDFORM. " WRITE_EXTRACT_INFO
*&---------------------------------------------------------------------*
*& Form SYSTEM_INFO
*&---------------------------------------------------------------------*
FORM system_info.
DATA: l_str(50) TYPE c,
l_code TYPE x,
license_number(10) TYPE c.
*write info specific to the system program is being run on...
tagstr = '~SYSTEMINFO'.
PERFORM write_content USING tagstr.
*get installation/license number...
l_code = 0.
CALL 'GET_ACCESS_INFO'
ID 'CODE' FIELD l_code
ID 'LICENSE' FIELD license_number.
CONCATENATE license_number syst-saprl syst-sysid client '1'
INTO l_str SEPARATED BY '|'.
waSystemInfo-InstallNumber = license_number.
waSystemInfo-Release = syst-saprl.
waSystemInfo-SystemID = syst-sysid.
waSystemInfo-ClientInfo = Client.
* Append waSystemInfo to waExtfile-SystemInfo.
Move SYSTEMDETAILS to waExtfile-SYSTEMDETAILS.
PERFORM write_content USING l_str.
ENDFORM. " SYSTEM_INFO
*&---------------------------------------------------------------------*
*& Form GENERATE_EXTRACTID
*&---------------------------------------------------------------------*
FORM generate_extractid.
*generates unique id number in space and time...used as key for extract
CALL FUNCTION 'SYSTEM_GET_UNIQUE_ID'
IMPORTING
unique_id = extractid
EXCEPTIONS
OTHERS = 1.
IF syst-subrc <> 0.
STOP. "no key --> no extract
ENDIF.
waExtractInfo-ExtractId = extractid.
ENDFORM. " GENERATE_EXTRACTID
*&---------------------------------------------------------------------*
*& Form SELECT_TIME_FRAME
*&---------------------------------------------------------------------*
FORM select_time_frame TABLES p_time_frame STRUCTURE ss_time_frame
USING p_field txn_or_query.
DATA: l_lines TYPE i,
l_destrow TYPE i,
l_txt(30) TYPE c,
l_name LIKE syst-repid,
l_valselect LIKE ss_time_frame-value,
l_choice LIKE syst-tabix,
l_time_frame LIKE ss_time_frame OCCURS 1 WITH HEADER LINE,
l_scr_fields LIKE dynpread OCCURS 1 WITH HEADER LINE.
DATA: BEGIN OF sel_lines OCCURS 50. " PF4-Hilfe-Tabelle
INCLUDE STRUCTURE rgse1.
DATA: END OF sel_lines.
CLEAR: p_time_frame, l_time_frame, l_scr_fields.
REFRESH: l_time_frame, l_scr_fields.
*assign text string for pop-up box...
IF p_field = 'S'.
l_txt = 'Select Starting Month and Year'.
ELSE.
l_txt = 'Select Ending Month and Year'.
ENDIF.
*append selection screen fields that need to be read and updated...
IF txn_or_query = 'T'.
MOVE 'MONIFROM' TO l_scr_fields-fieldname. APPEND l_scr_fields.
MOVE 'MONI_TO' TO l_scr_fields-fieldname. APPEND l_scr_fields.
ELSEIF txn_or_query = 'Q'.
MOVE 'TQ_FROM' TO l_scr_fields-fieldname. APPEND l_scr_fields.
MOVE 'TQ_TO' TO l_scr_fields-fieldname. APPEND l_scr_fields.
ENDIF.
*read values on the selection screen...
l_name = syst-repid.
CALL FUNCTION 'DYNP_VALUES_READ'
EXPORTING
dyname = l_name
dynumb = syst-dynnr
translate_to_upper = 'X'
TABLES
dynpfields = l_scr_fields
EXCEPTIONS
invalid_abapworkarea = 1
invalid_dynprofield = 2
invalid_dynproname = 3
invalid_dynpronummer = 4
invalid_request = 5
no_fielddescription = 6
invalid_parameter = 7
undefind_error = 8
OTHERS = 9.
IF syst-subrc EQ 0.
*adjustment of the 'to' date field -- 'to' date can be the same or
*after the month/year in the 'from' date field.
IF p_field = 'E'.
IF txn_or_query = 'T'.
READ TABLE l_scr_fields WITH KEY fieldname = 'MONIFROM'.
ELSE.
READ TABLE l_scr_fields WITH KEY fieldname = 'TQ_FROM'.
ENDIF.
IF NOT l_scr_fields-fieldvalue IS INITIAL.
LOOP AT p_time_frame
WHERE ( ( ( value+0(2) >= l_scr_fields-fieldvalue+0(2) )
AND ( value+3(4) >= l_scr_fields-fieldvalue+3(4) ) )
OR ( value+3(4) > l_scr_fields-fieldvalue+3(4) ) ).
MOVE-CORRESPONDING p_time_frame TO l_time_frame.
APPEND l_time_frame.
ENDLOOP.
ENDIF.
ENDIF.
*adjustment of the 'from' date field -- 'from' date can be the same or
*before the month/year in the 'to' date field.
IF p_field = 'S'.
IF txn_or_query = 'T'.
READ TABLE l_scr_fields WITH KEY fieldname = 'MONI_TO'.
ELSE.
READ TABLE l_scr_fields WITH KEY fieldname = 'TQ_TO'.
ENDIF.
IF NOT l_scr_fields-fieldvalue IS INITIAL.
LOOP AT p_time_frame
WHERE ( ( ( value+0(2) <= l_scr_fields-fieldvalue+0(2) )
AND ( value+3(4) <= l_scr_fields-fieldvalue+3(4) ) )
OR ( value+3(4) < l_scr_fields-fieldvalue+3(4) ) ).
MOVE-CORRESPONDING p_time_frame TO l_time_frame.
APPEND l_time_frame.
ENDLOOP.
ENDIF.
ENDIF.
ENDIF.
DESCRIBE TABLE l_time_frame LINES l_lines. "check if table is empty
IF l_lines = 0.
l_time_frame[] = p_time_frame[].
ENDIF.
DESCRIBE TABLE l_time_frame LINES l_lines. "for proper popup dispay
l_destrow = l_lines + 3.
*show the months available for selection from the workload monitor
sel_lines[] = l_time_frame[].
rgsel-dynp_title = l_txt.
CALL FUNCTION 'G_DISPLAY_SELECTION_DYNPRO'
EXPORTING
dynp_title = rgsel-dynp_title
IMPORTING
sel_index = l_choice
TABLES
sel_table = sel_lines
EXCEPTIONS
no_lines = 1
no_line_picked = 2
OTHERS = 3.
* IF SY-SUBRC <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
* WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
* ENDIF.
IF sy-subrc NE 0.
l_valselect = ''.
ELSE.
READ TABLE l_time_frame INDEX l_choice.
l_valselect = l_time_frame-value.
ENDIF.
*update the screen field values in the internal table...
IF p_field = 'S' AND l_valselect NE ''.
IF txn_or_query = 'T'.
READ TABLE l_scr_fields WITH KEY fieldname = 'MONIFROM'.
l_scr_fields-fieldvalue = l_valselect.
MODIFY l_scr_fields INDEX syst-tabix.
ELSEIF txn_or_query = 'Q'.
READ TABLE l_scr_fields WITH KEY fieldname = 'TQ_FROM'.
l_scr_fields-fieldvalue = l_valselect.
MODIFY l_scr_fields INDEX syst-tabix.
ENDIF.
ELSEIF p_field = 'E' AND l_valselect NE ''.
IF txn_or_query = 'T'.
READ TABLE l_scr_fields WITH KEY fieldname = 'MONI_TO'.
l_scr_fields-fieldvalue = l_valselect.
MODIFY l_scr_fields INDEX syst-tabix.
ELSEIF txn_or_query = 'Q'.
READ TABLE l_scr_fields WITH KEY fieldname = 'TQ_TO'.
l_scr_fields-fieldvalue = l_valselect.
MODIFY l_scr_fields INDEX syst-tabix.
ENDIF.
ENDIF.
*update the screen field values on the screen...
CALL FUNCTION 'DYNP_VALUES_UPDATE'
EXPORTING
dyname = l_name
dynumb = syst-dynnr
TABLES
dynpfields = l_scr_fields
EXCEPTIONS
invalid_abapworkarea = 1
invalid_dynprofield = 2
invalid_dynproname = 3
invalid_dynpronummer = 4
invalid_request = 5
no_fielddescription = 6
undefind_error = 7
OTHERS = 8.
ENDFORM. " SELECT_TIME_FRAME
*&---------------------------------------------------------------------*
*& Form WRITE_CONTENT
*&---------------------------------------------------------------------*
FORM write_content USING p_txt.
* DATA: len TYPE i.
* IF appserv1 = 'X'.
* PERFORM write_to_file USING p_txt.
* ENDIF.
ENDFORM. " WRITE_CONTENT
*&---------------------------------------------------------------------*
*& Form DOWNLOAD_EXTRACT
*&---------------------------------------------------------------------*
FORM download_extract USING p_apppath p_pcpath.
*make sure path is specified for where to put the extract file...
IF p_pcpath IS INITIAL.
MESSAGE e162(00) WITH 'Please enter a path on the PC.'.
STOP.
ENDIF.
IF p_apppath IS INITIAL.
MESSAGE e162(00) WITH 'Please enter a path on the app. server.'.
STOP.
ENDIF.
PERFORM file_download USING p_apppath p_pcpath.
ENDFORM. " DOWNLOAD_EXTRACT
*&---------------------------------------------------------------------*
*& Form FILE_DOWNLOAD
*&---------------------------------------------------------------------*
FORM file_download USING p_apppath p_pcpath.
DATA: l_errmsg1(50) TYPE c,
l_errmsg2(50) TYPE c.
*make sure the directories exist on the PC and the application server...
PERFORM check_pc_dir_exists USING p_pcpath.
PERFORM check_appserv_dir_exists USING p_apppath.
LEAVE TO LIST-PROCESSING.
*open file on application server for reading....
REFRESH txt_lines. CLEAR txt_lines.
OPEN DATASET p_apppath FOR INPUT IN TEXT MODE ENCODING DEFAULT.
IF syst-subrc <> 0.
l_errmsg1 = 'The following file could not be opened on the app.'.
CONCATENATE 'server' syst-host ':' p_apppath
INTO l_errmsg2 SEPARATED BY ' '.
MESSAGE e162(00) WITH l_errmsg1 l_errmsg2.
EXIT.
ELSE.
*start reading data in file on application server....
DO.
READ DATASET p_apppath INTO txt_lines.
IF syst-subrc <> 0.
EXIT.
ENDIF.
*append data in file to internal table txt_lines...
APPEND txt_lines.
ENDDO.
CLOSE DATASET p_apppath.
*download internal table txt_lines to selected directory on PC...
PERFORM ws_download USING p_pcpath.
ENDIF.
LEAVE LIST-PROCESSING.
ENDFORM. " FILE_DOWNLOAD
*&---------------------------------------------------------------------*
*& Form WS_DOWNLOAD
*&---------------------------------------------------------------------*
FORM ws_download USING filename.
DATA: l_msg(50) TYPE c.
DATA: l_filename TYPE string.
DATA: l_filetype TYPE char10.
* Added on 08th Dec 2004
l_filename = filename.
l_filetype = filetype.
*download internal table to PC....
CALL FUNCTION 'GUI_DOWNLOAD'
EXPORTING
filename = l_filename
filetype = l_filetype
codepage = '4103'
TABLES
data_tab = txt_lines
EXCEPTIONS
file_write_error = 1
no_batch = 2
gui_refuse_filetransfer = 3
invalid_type = 4
no_authority = 5
unknown_error = 6
header_not_allowed = 7
separator_not_allowed = 8
filesize_not_allowed = 9
header_too_long = 10
dp_error_create = 11
dp_error_send = 12
dp_error_write = 13
unknown_dp_error = 14
access_denied = 15
dp_out_of_memory = 16
disk_full = 17
dp_timeout = 18
file_not_found = 19
dataprovider_exception = 20
control_flush_error = 21
OTHERS = 22.
IF sy-subrc <> 0.
MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
ELSE.
*let user know file was downloaded without problems...
l_msg = 'File download successful.'.
MESSAGE s162(00) WITH l_msg.
ENDIF.
app_to_pc = 'X'.
ENDFORM. "ws_download
*&---------------------------------------------------------------------*
*& Form check_pc_dir_exists
*&---------------------------------------------------------------------*
FORM check_pc_dir_exists USING filename.
DATA: path LIKE pcpath.
*split file and path....
CALL FUNCTION 'SO_SPLIT_FILE_AND_PATH'
EXPORTING
full_name = filename
IMPORTING
file_path = path
EXCEPTIONS
x_error = 1
OTHERS = 2.
*check the directory exists...
CALL FUNCTION 'WS_QUERY'
EXPORTING
* ENVIRONMENT = ' '
filename = path
query = 'DE'
* WINID = ' '
IMPORTING
return = err_code
EXCEPTIONS
inv_query = 1
no_batch = 2
frontend_error = 3
OTHERS = 4.
IF err_code EQ '0'.
MESSAGE e162(00) WITH 'Directory does not exist on the PC:' path.
STOP.
ENDIF.
ENDFORM. " check_pc_dir_exists
*&---------------------------------------------------------------------*
*& Form CHECK_APPSERV_DIR_EXISTS
*&---------------------------------------------------------------------*
FORM check_appserv_dir_exists USING filename.
DATA: itab LIKE salfldir OCCURS 1.
DATA: path LIKE pcpath.
*split file and path....
CALL FUNCTION 'SO_SPLIT_FILE_AND_PATH'
EXPORTING
full_name = filename
IMPORTING
file_path = path
EXCEPTIONS
x_error = 1
OTHERS = 2.
*make sure directory exists on the application server...
CALL FUNCTION 'RZL_READ_DIR'
EXPORTING
* FROMLINE = 0
name = path
nrlines = 10
* SRVNAME = ' '
TABLES
file_tbl = itab
EXCEPTIONS
argument_error = 1
not_found = 2
send_error = 3
OTHERS = 4.
IF sy-subrc NE 0.
MESSAGE e162(00)
WITH 'Directory does not exist on the app. server:' path.
STOP.
ENDIF.
ENDFORM. " CHECK_APPSERV_DIR_EXISTS
*&---------------------------------------------------------------------*
*& Form WS_FILENAME_GET
*&---------------------------------------------------------------------*
FORM ws_filename_get CHANGING p_pcpath.
DATA: filename LIKE pcpath.
*call pop-up box to help user select path and file on PC....
CALL FUNCTION 'WS_FILENAME_GET'
EXPORTING
def_filename = 'RBE_EXTRACT.XML'
def_path = 'C:\TEMP'
mask = ',RBE Extract File,*.xml.'
mode = '0'
title = 'Save RBE Extract File As'
IMPORTING
filename = filename
EXCEPTIONS
inv_winsys = 1
no_batch = 2
selection_cancel = 3
selection_error = 4
OTHERS = 5.
IF syst-subrc <> 0.
EXIT.
ELSE.
p_pcpath = filename.
ENDIF.
ENDFORM. " WS_FILENAME_GET
*---------------------------------------------------------------------*
* FORM org *
*---------------------------------------------------------------------*
FORM org.
org_tab = 'T000'. APPEND org_tab. org_tab = 'MANDT'. APPEND org_tab.
org_tab = 'MTEXT'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T001W'. APPEND org_tab. org_tab = 'WERKS'. APPEND org_tab.
org_tab = 'NAME1'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'WERKS'. APPEND org_tab.
org_tab = 'VKORG'. APPEND org_tab. org_tab = 'EKORG'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T001'. APPEND org_tab. org_tab = 'BUKRS'. APPEND org_tab.
org_tab = 'BUTXT'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'BUKRS'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TVKOT'. APPEND org_tab. org_tab = 'VKORG'. APPEND org_tab.
org_tab = 'VTEXT'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'VKORG'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TVTWT'. APPEND org_tab. org_tab = 'VTWEG'. APPEND org_tab.
org_tab = 'VTEXT'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'VTWEG'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T001L'. APPEND org_tab. org_tab = 'LGORT'. APPEND org_tab.
org_tab = 'LGOBE'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'WERKS'. APPEND org_tab.
org_tab = 'LGORT'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T024E'. APPEND org_tab. org_tab = 'EKORG'. APPEND org_tab.
org_tab = 'EKOTX'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'BUKRS'. APPEND org_tab.
org_tab = 'EKORG'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TKEBT'. APPEND org_tab. org_tab = 'ERKRS'. APPEND org_tab.
org_tab = 'ERKRS_BZ'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'ERKRS'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TGSBT'. APPEND org_tab. org_tab = 'GSBER'. APPEND org_tab.
org_tab = 'GTEXT'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'GSBER'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TKA01'. APPEND org_tab. org_tab = 'KOKRS'. APPEND org_tab.
org_tab = 'BEZEI'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'KOKRS'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'FM01T'. APPEND org_tab. org_tab = 'FIKRS'. APPEND org_tab.
org_tab = 'FITXT'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'FIKRS'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TSPAT'. APPEND org_tab. org_tab = 'SPART'. APPEND org_tab.
org_tab = 'VTEXT'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'SPART'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TVSTT'. APPEND org_tab. org_tab = 'VSTEL'. APPEND org_tab.
org_tab = 'VTEXT'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'VSTEL'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TTDST'. APPEND org_tab. org_tab = 'TPLST'. APPEND org_tab.
org_tab = 'BEZEI'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'TPLST'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T399I'. APPEND org_tab. org_tab = 'IWERK'. APPEND org_tab.
org_tab = 'IWERK'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'IWERK'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T500P'. APPEND org_tab. org_tab = 'PERSA'. APPEND org_tab.
org_tab = 'NAME1'. APPEND org_tab.
org_tab = 'MANDT'. APPEND org_tab. org_tab = 'PERSA'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
PERFORM org_work TABLES tab.
ENDFORM. "ORG
*---------------------------------------------------------------------*
* FORM orgrel *
*---------------------------------------------------------------------*
FORM orgrel.
org_tab = 'T001'. APPEND org_tab. org_tab = 'FIKRS'. APPEND org_tab.
org_tab = 'BUKRS'. APPEND org_tab. org_tab = 'S'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TKA01'. APPEND org_tab. org_tab = 'FIKRS'. APPEND org_tab.
org_tab = 'KOKRS'. APPEND org_tab. org_tab = 'S'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TKA02'. APPEND org_tab. org_tab = 'KOKRS'. APPEND org_tab.
org_tab = 'BUKRS'. APPEND org_tab. org_tab = 'S'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TKA01'. APPEND org_tab. org_tab = 'ERKRS'. APPEND org_tab.
org_tab = 'KOKRS'. APPEND org_tab. org_tab = 'S'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T001W'. APPEND org_tab. org_tab = 'IWERK'. APPEND org_tab.
org_tab = 'WERKS'. APPEND org_tab. org_tab = 'S'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TVKWZ'. APPEND org_tab. org_tab = 'WERKS'. APPEND org_tab.
org_tab = 'VKORG'. APPEND org_tab. org_tab = ' '. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T024W'. APPEND org_tab. org_tab = 'WERKS'. APPEND org_tab.
org_tab = 'EKORG'. APPEND org_tab. org_tab = ' '. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TVSWZ'. APPEND org_tab. org_tab = 'WERKS'. APPEND org_tab.
org_tab = 'VSTEL'. APPEND org_tab. org_tab = ' '. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T001L'. APPEND org_tab. org_tab = 'WERKS'. APPEND org_tab.
org_tab = 'LGORT'. APPEND org_tab. org_tab = 'S'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T001K'. APPEND org_tab. org_tab = 'BUKRS'. APPEND org_tab.
org_tab = 'T001W'. APPEND org_tab. org_tab = 'BWKEY'. APPEND org_tab.
org_tab = 'Werks'. APPEND org_tab. org_tab = 'F'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'TVKO'. APPEND org_tab. org_tab = 'BUKRS'. APPEND org_tab.
org_tab = 'VKORG'. APPEND org_tab. org_tab = 'S'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T024E'. APPEND org_tab. org_tab = 'BUKRS'. APPEND org_tab.
org_tab = 'EKORG'. APPEND org_tab. org_tab = 'F'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
org_tab = 'T500P'. APPEND org_tab. org_tab = 'BUKRS'. APPEND org_tab.
org_tab = 'PERSA'. APPEND org_tab. org_tab = 'F'. APPEND org_tab.
org_tab = '--'. APPEND org_tab.
PERFORM orgrel_work TABLES tab.
ENDFORM. "ORGREL
*---------------------------------------------------------------------*
* FORM key *
*---------------------------------------------------------------------*
FORM key.
* vkey1 = 'MANDT'.
vkey1 = 'WERKS'.
vkey2 = 'BUKRS'.
vkey3 = 'VKORG'.
vkey4 = 'VTWEG'.
vkey5 = 'LGORT'.
vkey6 = 'EKORG'.
vkey7 = 'ERKRS'.
vkey8 = 'GSBER'.
vkey9 = 'KOKRS'.
vkey10 = 'FIKRS'.
vkey11 = 'SPART'.
vkey12 = 'VSTEL'.
vkey13 = 'TPLST'.
vkey14 = 'IWERK'.
vkey15 = 'PERSA'.
ENDFORM. "KEY
*&---------------------------------------------------------------------*
*& Form validate_package_size
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* --> p1 text
* <-- p2 text
*----------------------------------------------------------------------*
FORM validate_package_size USING value(p_ucomm)
LIKE sscrfields-ucomm.
IF p_ucomm = 'FC03' AND p_ucomm = 'FC04'.
IF smax = 0.
MESSAGE e162(00) WITH
'Package Size cannot be 0. Please specify some'
'value.'.
STOP.
ENDIF.
ENDIF.
ENDFORM. " validate_package_size
*&---------------------------------------------------------------------*
*& Form validate_client
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* -->P_SSCRFIELDS_UCOMM text
*----------------------------------------------------------------------*
FORM validate_client USING value(p_ucomm)
LIKE sscrfields-ucomm.
* IF p_ucomm <> 'FC03' AND p_ucomm <> 'FC04'.
* IF client IS INITIAL.
* MESSAGE e162(00) WITH 'Please enter a Client.'.
* STOP.
* ENDIF.
* SELECT SINGLE * FROM t000 WHERE mandt EQ client.
* IF sy-subrc NE 0.
* MESSAGE e162(00) WITH 'Please enter an Existing Client.'.
* STOP.
* ENDIF.
* ENDIF.
ENDFORM. " validate_client
*&---------------------------------------------------------------------*
*& Form month_year_validity
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* -->P_MONIFROM text
* -->P_MONI_TO text
*----------------------------------------------------------------------*
FORM month_year_validity USING value(date_field).
DATA: num_from TYPE i,
num_to TYPE i,
num_str(11) TYPE c VALUE ' 0123456789'.
*Make sure dates are in mm/yyyy format...
num_from = STRLEN( date_field ).
IF ( date_field+2(1) NE '/' OR num_from NE 7 ).
MESSAGE e162(00) WITH 'Specify dates in MM/YYYY format. '.
STOP.
ENDIF.
*Make sure the mm in date is a number...
IF NOT ( date_field+0(2) CO num_str+1(10) ).
MESSAGE e162(00) WITH 'Specified month is not valid. '.
STOP.
ENDIF.
*Make sure the mm in date is between 1 and 12...
num_from = date_field+0(2).
IF ( num_from LT 1 OR num_from GT 12 ).
MESSAGE e162(00) WITH 'Specified month does not exist. '.
STOP.
ENDIF.
*Make sure the year is a number...
IF NOT ( date_field+3(4) CO num_str+1(10) ).
MESSAGE e162(00) WITH 'Specified year is not valid. '.
STOP.
ENDIF.
ENDFORM. " month_year_validity
*&---------------------------------------------------------------------*
*& Form from_less_than_to
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* -->P_MONIFROM text
* -->P_MONI_TO text
*----------------------------------------------------------------------*
FORM from_less_than_to USING value(from_date)
value(to_date).
IF ( ( ( from_date+0(2) > to_date+0(2) ) AND
( from_date+3(4) >= to_date+3(4) ) ) OR
( from_date+3(4) > to_date+3(4) ) ).
MESSAGE e162(00) WITH 'From date is after the To date.'.
STOP.
ENDIF.
ENDFORM. " from_less_than_to
* ------------------- START OF GENERATED CODE -------------------
FORM extract_info.
extract_option = 1.
structureid = 1.
cat_node = '18DF7D0DA98111D4B31A0050DA4A852B'. APPEND cat_node.
cat_node = '0E055ABEA9BB11D4B31A0050DA4A852B'. APPEND cat_node.
PERFORM write_extract_info.
ENDFORM. "EXTRACT_INFO
FORM GENERATE_XML.
DATA: L_DOM TYPE REF TO IF_IXML_ELEMENT,
M_DOCUMENT TYPE REF TO IF_IXML_DOCUMENT,
G_IXML TYPE REF TO IF_IXML,
W_STRING TYPE XSTRING,
W_SIZE TYPE I,
W_RESULT TYPE I,
W_LINE TYPE STRING,
IT_XML TYPE DCXMLLINES,
S_XML LIKE LINE OF IT_XML,
W_RC LIKE SY-SUBRC.
DATA: XML TYPE DCXMLLINES.
DATA: RC TYPE SY-SUBRC,
BEGIN OF XML_TAB OCCURS 0,
D LIKE LINE OF XML,
END OF XML_TAB.
DATA: l_filename TYPE string.
CLASS CL_IXML DEFINITION LOAD.
G_IXML = CL_IXML=>CREATE( ).
CHECK NOT G_IXML IS INITIAL.
M_DOCUMENT = G_IXML->CREATE_DOCUMENT( ).
CHECK NOT M_DOCUMENT IS INITIAL.
*WRITE: / 'Converting DATA TO DOM 1:'.
loop at root into waroot.
CALL FUNCTION 'SDIXML_DATA_TO_DOM'
EXPORTING
NAME = 'ROOT'
DATAOBJECT = waroot
IMPORTING
DATA_AS_DOM = L_DOM
CHANGING
DOCUMENT = M_DOCUMENT
EXCEPTIONS
ILLEGAL_NAME = 1
OTHERS = 2.
IF SY-SUBRC = 0.
* WRITE 'Ok'.
ELSE.
WRITE: 'Err =',
SY-SUBRC.
ENDIF.
endloop.
CHECK NOT L_DOM IS INITIAL.
W_RC = M_DOCUMENT->APPEND_CHILD( NEW_CHILD = L_DOM ).
IF W_RC IS INITIAL.
* WRITE 'Ok'.
ELSE.
WRITE: 'Err =',
W_RC.
ENDIF.
CALL FUNCTION 'SDIXML_DOM_TO_XML'
EXPORTING
DOCUMENT = M_DOCUMENT
IMPORTING
XML_AS_STRING = W_STRING
SIZE = W_SIZE
TABLES
XML_AS_TABLE = IT_XML
EXCEPTIONS
NO_DOCUMENT = 1
OTHERS = 2.
IF SY-SUBRC = 0.
* WRITE 'Ok'.
ELSE.
WRITE: 'Err =',
SY-SUBRC.
ENDIF.
LOOP AT IT_XML INTO XML_TAB-D.
APPEND XML_TAB.
ENDLOOP.
MOVE pcpath to l_filename.
  CALL FUNCTION 'GUI_DOWNLOAD'
    EXPORTING
      filename                = l_filename
      filetype                = 'BIN'
      codepage                = '4103'
    TABLES
      data_tab                = xml_tab
    EXCEPTIONS
      file_write_error        = 1
      no_batch                = 2
      gui_refuse_filetransfer = 3
      invalid_type            = 4
      no_authority            = 5
      unknown_error           = 6
      header_not_allowed      = 7
      separator_not_allowed   = 8
      filesize_not_allowed    = 9
      header_too_long         = 10
      dp_error_create         = 11
      dp_error_send           = 12
      dp_error_write          = 13
      unknown_dp_error        = 14
      access_denied           = 15
      dp_out_of_memory        = 16
      disk_full               = 17
      dp_timeout              = 18
      file_not_found          = 19
      dataprovider_exception  = 20
      control_flush_error     = 21
      OTHERS                  = 22.
IF SY-SUBRC <> 0.
MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
ENDIF.
WRITE: /
'Extract file ( as .xml File Format ) is generated Successfully at the specified location.'.
ENDFORM. "MAT
* -------------------- END OF GENERATED CODE --------------------
*&---------------------------------------------------------------------*
*& Form ws_readfilename_get
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* <--P_READPATH text
*----------------------------------------------------------------------*
form ws_readfilename_get changing p_readpath.
DATA: filename LIKE readpath.
CALL FUNCTION 'WS_FILENAME_GET'
EXPORTING
* def_filename = 'RBE_EXTRACT.TXT'
* def_path = 'C:\TEMP'
mask = '*.xml.'
mode = '0'
title = 'Read RBE Extractor Generator File from'
IMPORTING
filename = loc_filepath
EXCEPTIONS
inv_winsys = 1
no_batch = 2
selection_cancel = 3
selection_error = 4
OTHERS = 5.
p_readpath = loc_filepath.
endform. " ws_readfilename_get
*&---------------------------------------------------------------------*
*& Form validate_readxml
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* --> p1 text
* <-- p2 text
*----------------------------------------------------------------------*
form validate_readxml .
data: readxmlfileexists type c.
Move readpath to loc_filepath.
call method cl_gui_frontend_services=>file_exist
exporting
file = loc_filepath
receiving
result = readxmlfileexists
* EXCEPTIONS
* CNTL_ERROR = 1
* ERROR_NO_GUI = 2
* WRONG_PARAMETER = 3
* NOT_SUPPORTED_BY_GUI = 4
* others = 5
.
if sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
* WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
endif.
IF NOT readxmlfileexists = 'X'.
MESSAGE e162(00) WITH
'Please choose an existing xml file to read.'.
ENDIF.
endform. " validate_readxml
*&---------------------------------------------------------------------*
*& Form read_xml_from_front-end
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* --> p1 text
* <-- p2 text
*----------------------------------------------------------------------*
form read_xml_from_front-end .
*********shankar code******************
*************************************************************
* include iXML definitions
*
INCLUDE ixml_global.
************************************************************
* parameters
*SELECTION-SCREEN BEGIN OF BLOCK from WITH FRAME TITLE text-005.
*PARAMETERS: file(255) TYPE c
* DEFAULT '\\P52941\transfer\test\bigRecord.xml'
* LOWER CASE OBLIGATORY.
*SELECTION-SCREEN END OF BLOCK from.
*
*SELECTION-SCREEN BEGIN OF BLOCK dump WITH FRAME TITLE text-001.
*PARAMETERS: tree TYPE c AS CHECKBOX DEFAULT 'X',
* ascdump TYPE c AS CHECKBOX DEFAULT ' ',
* hexdump TYPE c AS CHECKBOX DEFAULT ' '.
*SELECTION-SCREEN END OF BLOCK dump.
*SELECTION-SCREEN BEGIN OF BLOCK nsmode WITH FRAME TITLE text-002.
*PARAMETERS: n_chk RADIOBUTTON GROUP ns DEFAULT 'X',
* n_on RADIOBUTTON GROUP ns,
* n_off RADIOBUTTON GROUP ns.
*SELECTION-SCREEN END OF BLOCK nsmode.
*SELECTION-SCREEN BEGIN OF BLOCK valid WITH FRAME TITLE text-003.
*PARAMETERS: v_dtd RADIOBUTTON GROUP vali DEFAULT 'X',
* v_on RADIOBUTTON GROUP vali,
* v_off RADIOBUTTON GROUP vali.
*SELECTION-SCREEN END OF BLOCK valid.
*SELECTION-SCREEN BEGIN OF BLOCK dfattr WITH FRAME TITLE text-004.
*PARAMETERS: a_on RADIOBUTTON GROUP dfa DEFAULT 'X',
* a_off RADIOBUTTON GROUP dfa.
*SELECTION-SCREEN END OF BLOCK dfattr.
*************************************************************
* on value request
*AT SELECTION-SCREEN ON VALUE-REQUEST FOR file.
* PERFORM filename_value_request CHANGING file.
************************************************************
*macros
DEFINE xml.
concatenate xmldata &1 into xmldata.
* write: / 'XML:', &1 color col_positive inverse.
END-OF-DEFINITION.
*************************************************************
* global data
*
*************************************************************
* start of selection
*
*START-OF-SELECTION.
*************shankar*****************
***************shankar****************
DATA: ixml TYPE REF TO if_ixml,
streamfactory TYPE REF TO if_ixml_stream_factory,
parser TYPE REF TO if_ixml_parser,
istream TYPE REF TO if_ixml_istream,
document TYPE REF TO if_ixml_document,
node TYPE REF TO if_ixml_node,
xmlfile TYPE string,
fpath TYPE string,
fname TYPE string,
xmldata TYPE xstring.
Move sy-mandt to client.
Move 'Y' to validatexml.
xmlfile = file.
PERFORM get_path USING xmlfile CHANGING fpath fname.
PERFORM upload_file USING fpath fname CHANGING xmldata.
*************************************************************
* xml partsing preparation
*
* create the ixml main factory
ixml = cl_ixml=>create( ).
* create a stream factory
streamfactory = ixml->create_stream_factory( ).
* create a input stream
istream = streamfactory->create_istream_xstring( string = xmldata ).
* create a ixml document
document = ixml->create_document( ).
* create a xml parser
parser = ixml->create_parser( document = document
stream_factory = streamfactory
istream = istream ).
** set namespace mode
* IF n_chk = 'X'.
** parser->set_namespace_mode( mode =
**if_ixml_parser=>co_namespace_checking ).
* ELSEIF n_on = 'X'.
* parser->set_namespace_mode( mode =
*if_ixml_parser=>co_namespace_aware ).
* ELSE.
* parser->set_namespace_mode( mode = if_ixml_parser=>co_prefix_aware
*)
*.
* ENDIF.
*
** set validation mode
* IF v_off = 'X'.
* parser->set_validating( mode = if_ixml_parser=>co_no_validation ).
* ELSEIF v_on = 'X'.
* parser->set_validating( mode = if_ixml_parser=>co_validate ).
* ELSE.
* parser->set_validating( mode = if_ixml_parser=>co_validate_if_dtd )
*.
* ENDIF.
*
** default attributes
* IF a_on = 'X'.
* parser->SET_SUPPLY_ATTR_DEFAULTS( supply = 'X' ).
* ELSE.
* parser->SET_SUPPLY_ATTR_DEFAULTS( supply = ' ' ).
* ENDIF.
* parse the xml document into DOM tree
IF parser->parse( ) <> 0.
PERFORM process_errors USING parser.
EXIT.
ELSE.
* IF tree = 'X'.
node ?= document.
PERFORM print_dom USING node.
* ENDIF.
* IF ascdump = 'X' OR hexdump = 'X'.
* PERFORM dump_file USING fname xmldata.
* ENDIF.
ENDIF.
********shankar code******************
endform. " read_xml_from_front-end
*&---------------------------------------------------------------------*
*& Form process_errors
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* -->P_PARSER text
*----------------------------------------------------------------------*
FORM process_errors USING p_parser TYPE REF TO if_ixml_parser.
DATA: error TYPE REF TO if_ixml_parse_error,
msg TYPE string,
count TYPE i,
index TYPE i,
off TYPE i.
* WRITE: /.
* WRITE: / 'PARSER-ERRORS'.
count = p_parser->num_errors( min_severity =
if_ixml_parse_error=>co_warning ).
CHECK count <> 0.
* write error messages
DO count TIMES.
index = sy-index - 1.
error = p_parser->get_error( index = index
min_severity =
if_ixml_parse_error=>co_warning ).
msg = error->get_reason( ).
off = error->get_offset( ).
IF error->get_severity( ) = if_ixml_parse_error=>co_warning.
* WRITE: / 'warn :', msg COLOR COL_GROUP INVERSE, off.
ELSE.
* WRITE: / 'error:', msg COLOR COL_NEGATIVE INVERSE, off.
ENDIF.
ENDDO.
ENDFORM. " process_errors
*---------------------------------------------------------------------*
* FORM print_tree *
*---------------------------------------------------------------------*
* ........ *
*---------------------------------------------------------------------*
FORM print_dom USING node TYPE REF TO if_ixml_node.
DATA: iterator TYPE REF TO if_ixml_node_iterator,
nodemap TYPE REF TO if_ixml_named_node_map,
attr TYPE REF TO if_ixml_node,
name TYPE string,
prefix TYPE string,
value TYPE string,
indent TYPE i,
count TYPE i,
index TYPE i.
CHECK NOT node IS INITIAL.
* ULINE.
* WRITE: /.
* WRITE: /' DOM-TREE'.
* WRITE: /.
IF node IS INITIAL. EXIT. ENDIF.
* create a node iterator
iterator = node->create_iterator( ).
* get current node
node = iterator->get_next( ).
* loop over all nodes
WHILE NOT node IS INITIAL.
indent = node->get_height( ) * 2.
indent = indent + 20.
CASE node->get_type( ).
WHEN if_ixml_node=>co_node_element.
* element node
name = node->get_name( ).
IF name = 'QUERY'.
move 'X' to globalquery.
ENDIF.
move name to wareadxml-element.
nodemap = node->get_attributes( ).
* WRITE: / 'ELEMENT :'.
* WRITE: AT indent name COLOR COL_POSITIVE INVERSE.
IF NOT nodemap IS INITIAL.
* attributes
count = nodemap->get_length( ).
DO count TIMES.
index = sy-index - 1.
attr = nodemap->get_item( index ).
name = attr->get_name( ).
prefix = attr->get_namespace_prefix( ).
value = attr->get_value( ).
* WRITE: / 'ATTRIBUTE:'.
* WRITE: AT indent name COLOR COL_HEADING INVERSE, '=',
* value COLOR COL_TOTAL INVERSE.
ENDDO.
ENDIF.
WHEN if_ixml_node=>co_node_text or
if_ixml_node=>co_node_cdata_section.
* text node
value = node->get_value( ).
if not value is initial.
************************************************check for correct xml********************
IF name = 'LICENSE'.
IF value = 'RBE01' OR value = 'RBE02' or value = license_number.
Move 'X' to validatexml.
ELSE.
Move 'Y' to validatexml.
ENDIF.
ENDIF.
IF name = 'SYSTEM_NAME'.
IF value = 'RBE01' OR value = 'RBE02' or value = syst-sysid.
Move 'X' to validatexml.
ELSE.
Move 'Y' to validatexml.
ENDIF.
ENDIF.
IF name = 'BASIS_RELEASE'.
IF value = 'RBE01' OR value = 'RBE02' or value = syst-saprl.
Move 'X' to validatexml.
ELSE.
Move 'Y' to validatexml.
ENDIF.
ENDIF.
IF name = 'LICENSE' or name = 'SYSTEM_NAME' or name =
'BASIS_RELEASE'.
IF validatexml = 'Y'.
write:
'This is not the correct system to generate the extract file by reading the specified xml file.'.
Return.
ENDIF.
ENDIF.
************************************************check for correct xml********************
IF globalquery = 'X'.
If name = 'CONDITIONID'.
move value to waquerycondition-conditionid.
endif.
If name = 'DATESELECT'.
MOVE 'X' to ISDATESELECTED.
move value to waquerycondition-dateselect.
endif.
If name = 'DATEFIELD'.
MOVE 'X' to ISDATESELECTED.
move value to waquerycondition-datefield.
endif.
If name = 'FIELDSELECT'.
* move value to wafieldselect-line.
* append wafieldselect to ifieldselect.
move value to waquerycondition-fieldselect.
endif.
If name = 'COUNT'.
* move ifieldselect[] to waquerycondition-fieldselect[].
move value to waquerycondition-count.
endif.
If name = 'TABLENAME'.
move value to waquerycondition-tablename.
endif.
IF name = 'WHERECONDITION'.
* move value to wawherecondition-line.
* append wawherecondition to iwherecondition.
move value to waquerycondition-wherecondition.
ENDIF.
IF name = 'GROUPBY'.
* move iwherecondition[] to waquerycondition-wherecondition[].
* move value to wagroupby-line.
* append wagroupby to igroupby.
move value to waquerycondition-groupby.
ENDIF.
IF name = 'CHECKFIELDS'.
MOVE value TO waquerycondition-checkfields.
ENDIF.
IF name = 'JCHECKFIELDS'.
MOVE value TO waquerycondition-jcheckfields.
ENDIF.
IF name = 'END'.
* move igroupby[] to waquerycondition-groupby[].
append waquerycondition to Iquerycondition.
clear waquerycondition.
* clear ifieldselect[].
* clear iwherecondition[].
* clear igroupby[].
clear globalquery.
clear validatexml.
clear ISDATESELECTED.
ENDIF.
ENDIF.
move value to wareadxml-value.
append wareadxml to Ireadxml.
endif.
* WRITE: / 'TEXT :'.
* WRITE: AT indent value COLOR COL_GROUP INVERSE.
ENDCASE.
* advance to next node
node = iterator->get_next( ).
ENDWHILE.
loop at ireadxml into wareadxml.
* write:/ 'element: '.
* write: wareadxml-element.
* write:/ 'value '.
* write: wareadxml-value.
endloop.
ENDFORM. "traverse_dom
*---------------------------------------------------------------------*
* FORM filename_value_request
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
* --> FILENAME
*---------------------------------------------------------------------*
FORM filename_value_request CHANGING filename.
DATA: directory TYPE string,
filetable TYPE filetable,
line TYPE LINE OF filetable,
rc TYPE i.
CALL METHOD cl_gui_frontend_services=>get_temp_directory
CHANGING
temp_dir = directory.
CALL METHOD cl_gui_frontend_services=>file_open_dialog
EXPORTING
window_title = 'XML Conformance Tests'
initial_directory = directory
file_filter = '*.xml'
multiselection = ' '
CHANGING
file_table = filetable
rc = rc.
IF rc = 1.
READ TABLE filetable INDEX 1 INTO line.
filename = line-filename.
ENDIF.
ENDFORM. "filename_value_request
*---------------------------------------------------------------------*
* FORM get_path
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
* --> FILENAME
* --> BASEDIR
*---------------------------------------------------------------------*
FORM get_path USING file TYPE string
CHANGING filepath TYPE string
filename TYPE string.
DATA: BEGIN OF dir OCCURS 0, name(80), END OF dir,
len TYPE i.
SPLIT file AT '\' INTO TABLE dir.
IF sy-subrc <> 0.
SPLIT file AT '/' INTO TABLE dir.
ENDIF.
DESCRIBE TABLE dir LINES len.
LOOP AT dir.
IF sy-tabix = len.
filename = dir-name.
EXIT.
ENDIF.
CONCATENATE filepath dir-name '\' INTO filepath.
ENDLOOP.
ENDFORM. "get_path
*---------------------------------------------------------------------*
* FORM upload_xml_file
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
* --> P_FILENAME
* --> P_XML_DATA
*---------------------------------------------------------------------*
FORM upload_file USING filebase TYPE string
filename TYPE string
CHANGING xmldata TYPE xstring.
CONSTANTS: line_size TYPE i VALUE 255.
DATA: BEGIN OF xml_tab OCCURS 0,
raw(line_size) TYPE x,
END OF xml_tab,
file TYPE string,
size TYPE i.
CONCATENATE filebase filename INTO file.
* upload the xml file
CALL FUNCTION 'GUI_UPLOAD'
EXPORTING
filename = file
filetype = 'BIN'
has_field_separator = ' '
header_length = 0
IMPORTING
filelength = size
TABLES
data_tab = xml_tab
EXCEPTIONS
OTHERS = 1.
IF sy-subrc <> 0.
CLEAR: xmldata.
EXIT.
ELSE.
DATA: len TYPE i.
len = size.
LOOP AT xml_tab.
IF len <= line_size. EXIT. ENDIF.
CONCATENATE xmldata xml_tab-raw(line_size)
INTO xmldata IN BYTE MODE.
len = len - line_size.
ENDLOOP.
IF len > 0.
CONCATENATE xmldata xml_tab-raw(len)
INTO xmldata IN BYTE MODE.
len = len - size.
ENDIF.
ENDIF.
ENDFORM. " upload_xml_file
*---------------------------------------------------------------------*
* FORM write_file
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
* --> FILE
* --> BIN
* --> ASC
*---------------------------------------------------------------------*
FORM dump_file USING file TYPE string bin TYPE xstring.
CONSTANTS: line_size TYPE i VALUE 60.
DATA: head(15) TYPE c,
val TYPE c,
len TYPE i,
pos TYPE i,
pos2 TYPE i,
siz TYPE i,
bo TYPE i,
ln TYPE i,
err_off TYPE i,
cln(4) TYPE c.
FIELD-SYMBOLS: <c_val> TYPE c, <x_val> TYPE x.
* replace CR LF in ascii dump
CLASS cl_abap_char_utilities DEFINITION LOAD.
DATA: crlf(2) TYPE c, cr TYPE c, lf TYPE c.
crlf = cl_abap_char_utilities=>cr_lf.
cr = crlf+0(1).
lf = crlf+1(1).
* init character conv: hex <-> char
ASSIGN val TO <x_val> CASTING.
ASSIGN val TO <c_val>.
* get byte order, note:
<c_val> = space.
IF <x_val>+0(1) = '20'.
bo = 0.
ELSEIF <x_val>+1(1) = '20'.
bo = 1.
ELSE.
bo = 3. "unknown
ENDIF.
* convert xstring -> xtable
DATA: xtab(line_size) TYPE x OCCURS 0 WITH HEADER LINE.
pos = 0.
len = xstrlen( bin ).
WHILE pos < len.
APPEND bin+pos TO xtab.
ADD line_size TO pos.
ENDWHILE.
* IF ascdump = 'X'.
* write ascii lines
* WRITE: /.
* WRITE: / 'ASC DUMP:', file.
ln = 1. cln = ln.
* WRITE: / 'ASC', cln, ':'.
pos2 = 0.
LOOP AT xtab.
DATA: nl TYPE i VALUE 0.
* write char string
pos = 0.
WHILE pos < line_size.
IF pos2 = len. EXIT. ENDIF.
* convert character
IF bo = 0.
<x_val> = xtab+pos(1).
ELSE.
<x_val>+1 = xtab+pos(1).
ENDIF.
* write character
IF <c_val> <> cr AND <c_val> <> lf.
IF pos2 <> err_off OR err_off <> 0.
* WRITE: <c_val> COLOR COL_POSITIVE INVERSE NO-GAP.
ELSE.
* WRITE: <c_val> COLOR COL_NEGATIVE INVERSE NO-GAP.
ENDIF.
nl = 0.
ELSE.
* start new line
IF nl = 0.
ADD 1 TO ln. cln = ln.
* WRITE: / 'ASC', cln, ':'.
ENDIF.
nl = 1.
ENDIF.
ADD 1 TO pos.
ADD 1 TO pos2.
ENDWHILE.
ENDLOOP.
* ENDIF.
* IF hexdump = 'X'.
* WRITE: / 'HEX DUMP:', file.
* write hex + ascii lines
ln = 0.
pos2 = 0.
LOOP AT xtab.
* write hex string
ADD 1 TO ln. cln = ln.
* WRITE: / 'HEX', cln, ':'.
pos = 0.
pos2 = ( sy-tabix - 1 ) * line_size.
WHILE pos < line_size.
IF pos2 = len. EXIT. ENDIF.
<x_val> = xtab+pos(1).
* WRITE: <x_val>(1) COLOR COL_GROUP INVERSE NO-GAP.
ADD 1 TO pos.
ADD 1 TO pos2.
ENDWHILE.
* write char string
* WRITE: / 'ASC', cln, ':'.
val = space.
pos = 0.
pos2 = ( sy-tabix - 1 ) * line_size.
WHILE pos < line_size.
IF pos2 = len. EXIT. ENDIF.
IF bo = 0.
<x_val> = xtab+pos(1).
ELSE.
<x_val>+1 = xtab+pos(1).
ENDIF.
WRITE: <c_val> COLOR COL_GROUP INVERSE.
ADD 1 TO pos.
ADD 1 TO pos2.
ENDWHILE.
ENDLOOP.
* ENDIF.
ENDFORM. "write_file
*&---------------------------------------------------------------------*
*& Form Get_Query_results
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* --> p1 text
* <-- p2 text
*----------------------------------------------------------------------*
form Get_Query_results .
DATA: Query_data like table of OP.
DATA: loc_Query_data like table of OP.
DATA: waquery_data like line of Query_data.
DATA: str(72) TYPE c,
fields LIKE str OCCURS 1,
where LIKE str OCCURS 1,
table type string,
group LIKE str OCCURS 1.
DATA: fieldselectstr type string.
DATA: dateselectstr type string.
DATA: datefieldstr type string.
DATA: countstr type string.
DATA: wherestr type string.
DATA: groupstr type string.
DATA: fieldall type string.
DATA: tablestr type string.
DATA: fullcount type i.
data : fieldname type table of string.
data : tables type table of string.
data : wheres type table of string.
data : groups type table of string.
PERFORM set_table_query_dates_local.
PERFORM check_tablefield_exist_system TABLES iquerycondition.
loop at Iquerycondition into waquerycondition.
append waquerycondition-dateselect to fields.
MOVE waquerycondition-dateselect to dateselectstr.
MOVE waquerycondition-fieldselect to fieldselectstr.
MOVE waquerycondition-datefield to datefieldstr.
MOVE waquerycondition-count to countstr.
MOVE waquerycondition-wherecondition to wherestr.
MOVE waquerycondition-groupby to groupstr.
MOVE waquerycondition-tablename to tablestr.
CONCATENATE dateselectstr fieldselectstr countstr INTO fieldall SEPARATED
BY SPACE.
Concatenate '' wherestr '' into wherestr.
Concatenate '' groupstr '' into groupstr.
move waquerycondition-tablename to table.
IF ( dateselectstr is initial AND datefieldstr is initial ).
IF wherestr is initial.
SELECT Count(*) into fullcount FROM (tablestr).
move fullcount to waquery_data-count.
append waquery_data to loc_query_data.
clear fullcount.
ELSE.
Append wherestr to wheres.
SELECT Count(*) into fullcount FROM (tablestr) where (wheres).
move fullcount to waquery_data-count.
append waquery_data to loc_query_data.
clear fullcount.
clear wheres.
ENDIF.
ELSE.
IF wherestr is initial.
IF fieldselectstr is initial.
Append dateselectstr to fieldname.
Append countstr to fieldname.
Append tablestr to tables.
Append datefieldstr to groups.
Append datefieldstr to wheres.
Append 'BETWEEN' to wheres.
Append fromdatetable to wheres.
APPEND 'AND' to wheres.
APPEND todatetable to wheres.
SELECT (fieldname) into corresponding fields of table
Query_data FROM (tables)
where (wheres) group by (groups).
If Query_data is initial.
Move '0' to waquery_data-count.
Append waquery_data to Query_data.
endif.
move Query_data[] to loc_query_data[].
clear fullcount.
clear fieldname.
clear groups.
clear wheres.
clear tables.
ELSE.
Append dateselectstr to fieldname.
Append fieldselectstr to fieldname.
Append countstr to fieldname.
Append tablestr to tables.
Append groupstr to groups.
Append datefieldstr to wheres.
Append 'BETWEEN' to wheres.
Append fromdatetable to wheres.
APPEND 'AND' to wheres.
APPEND todatetable to wheres.
SELECT (fieldname) into corresponding fields of table
Query_data FROM (tables)
where (wheres) group by (groups).
If Query_data is initial.
Move '0' to waquery_data-count.
Append waquery_data to Query_data.
endif.
move Query_data[] to loc_query_data[].
clear fullcount.
clear fieldname.
clear groups.
clear wheres.
clear tables.
ENDIF.
ELSE.
IF fieldselectstr is initial.
Append dateselectstr to fieldname.
Append countstr to fieldname.
Append tablestr to tables.
Append datefieldstr to groups.
Append '(' to wheres.
Append datefieldstr to wheres.
Append 'BETWEEN' to wheres.
Append fromdatetable to wheres.
APPEND 'AND' to wheres.
APPEND todatetable to wheres.
Append ')' to wheres.
APPEND 'AND' to wheres.
APPEND wherestr to wheres.
SELECT (fieldname) into corresponding fields of table
Query_data FROM (tables)
where (wheres) group by (groups).
If Query_data is initial.
Move '0' to waquery_data-count.
Append waquery_data to Query_data.
endif.
move Query_data[] to loc_query_data[].
clear fullcount.
clear fieldname.
clear groups.
clear wheres.
clear tables.
ELSE.
Append dateselectstr to fieldname.
Append fieldselectstr to fieldname.
Append countstr to fieldname.
Append tablestr to tables.
Append groupstr to groups.
Append '(' to wheres.
Append datefieldstr to wheres.
Append 'BETWEEN' to wheres.
Append fromdatetable to wheres.
APPEND 'AND' to wheres.
APPEND todatetable to wheres.
Append ')' to wheres.
APPEND 'AND' to wheres.
APPEND wherestr to wheres.
SELECT (fieldname) into corresponding fields of table
Query_data FROM (tables)
where (wheres) group by (groups).
If Query_data is initial.
Move '0' to waquery_data-count.
Append waquery_data to Query_data.
endif.
move Query_data[] to loc_query_data[].
clear fullcount.
clear fieldname.
clear groups.
clear wheres.
clear tables.
ENDIF.
ENDIF.
ENDIF.
clear fields.
clear where.
clear group.
clear tablestr.
clear wherestr.
loop at loc_query_data into waquery_data.
move waquerycondition-conditionid to waquery_data-conditionid.
Modify loc_query_data from waquery_data.
endloop.
move loc_query_data[] to query_data[].
clear loc_query_data[].
move query_data[] to waqueryresultop-resulttable[].
clear query_data[].
append waqueryresultop to Iqueryresultop.
endloop.
move Iqueryresultop[] to waextfile-queryresultoutput[].
endform. " Get_Query_results
*&---------------------------------------------------------------------*
*& Form set_table_query_dates_local
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* --> p1 text
* <-- p2 text
*----------------------------------------------------------------------*
FORM set_table_query_dates_local .
CLEAR: fromdate, todate.
*change format from mm/yyyy to yyyymmdd
tq_time-sign = 'I'.
tq_time-option = 'EQ'.
*fromdate is the first day in the month....
fromdate+0(4) = tq_from+3(4).
fromdate+4(2) = tq_from+0(2).
fromdate+6(2) = '01'.
tq_time-low = fromdate.
CONCATENATE fromdatetable '''' into fromdatetable.
CONCATENATE fromdatetable fromdate into fromdatetable.
CONCATENATE fromdatetable '''' into fromdatetable.
IF tq_from IS INITIAL. tq_time-low = ''. ENDIF.
*todate is the last day in the month...
IF NOT tq_to IS INITIAL.
tq_time-option = 'BT'.
todate+0(4) = tq_to+3(4).
todate+4(2) = tq_to+0(2).
todate+6(2) = '01'.
* Get last day of last month
PERFORM last_day_of_months CHANGING todate.
tq_time-high = todate.
CONCATENATE todatetable '''' into todatetable.
CONCATENATE todatetable todate into todatetable.
CONCATENATE todatetable '''' into todatetable.
ELSE.
tq_time-high = ''.
ENDIF.
APPEND tq_time.
ENDFORM. " set_table_query_dates_local
*&---------------------------------------------------------------------*
*& Form LAST_DAY_OF_MONTHS
*&---------------------------------------------------------------------*
FORM last_day_of_months CHANGING p_todate .
DATA: januar(2) VALUE '01',
december(2) VALUE '12',
lowdate(4) VALUE '1800',
frist(2) VALUE '01'.
DATA: BEGIN OF highdate,
j(4) VALUE '9999',
m(2) VALUE '12',
t(2) VALUE '31',
END OF highdate.
DATA: last_day_of_month LIKE sy-datum.
DATA: BEGIN OF date,
j(4),
m(2),
t(2),
END OF date.
DATA: zahl TYPE i.
date = p_todate.
IF date-m LT januar OR date-m GT december.
MESSAGE e401(5d) WITH p_todate
RAISING day_in_no_date.
ENDIF.
IF date-j LT lowdate.
MESSAGE e401(5d) WITH p_todate
RAISING day_in_no_date.
ENDIF.
IF date-j EQ highdate-j AND
date-m EQ highdate-m.
last_day_of_month = highdate.
ELSE.
IF date-m EQ december.
zahl = date-j + 1.
UNPACK zahl TO date-j.
date-m = frist.
ELSE.
zahl = date-m + 1.
UNPACK zahl TO date-m.
ENDIF.
* Erster des Folgemonats
date-t = frist.
last_day_of_month = date.
SUBTRACT 1 FROM last_day_of_month.
p_todate = last_day_of_month.
ENDIF.
ENDFORM. " LAST_DAY_OF_MONTHS
*&---------------------------------------------------------------------*
*& Form check_tablefield_exist_system
*&---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
* -->P_IQUERYCONDITION text
*----------------------------------------------------------------------*
FORM check_tablefield_exist_system TABLES p_iquerycondition
STRUCTURE querycondition.
DATA: BEGIN OF field_list,
conditionid(32),
tabname(1024),
fieldname(1024),
error,
missing(1024),
END OF field_list.
DATA: field LIKE field_list OCCURS 0 WITH HEADER LINE.
DATA: wa_field LIKE LINE OF field.
DATA: condition LIKE querycondition.
DATA: id(32),
table(1024).
DATA: fieldtab LIKE txt_lines OCCURS 0 WITH HEADER LINE.
DATA: tab LIKE txt_lines OCCURS 0 WITH HEADER LINE.
DATA: int TYPE i.
DATA: log LIKE walog OCCURS 0 WITH HEADER LINE.
DATA: logline LIKE LINE OF log.
DATA: tadir TYPE tadir,
dd03l TYPE dd03l.
DATA: tmpstr(1024).
LOOP AT p_iquerycondition INTO condition.
wa_field-error = ' '.
wa_field-missing = ''.
wa_field-conditionid = condition-conditionid.
* table 1 checkfields
IF NOT condition-checkfields IS INITIAL.
SPLIT condition-checkfields AT '|' INTO TABLE tab.
* tab contains 2 entries -> 0 Tabname
* -> 1 Fields
READ TABLE tab INDEX 1.
IF sy-subrc EQ 0.
wa_field-tabname = tab.
ENDIF.
READ TABLE tab INDEX 2.
IF sy-subrc EQ 0.
SPLIT tab AT ' ' INTO TABLE fieldtab.
LOOP AT fieldtab.
wa_field-fieldname = fieldtab.
APPEND wa_field TO field.
ENDLOOP.
ENDIF.
ENDIF.
CLEAR: tab, fieldtab.
REFRESH: tab, fieldtab.
* table 2 checkfields
IF NOT condition-jcheckfields IS INITIAL.
SPLIT condition-jcheckfields AT '|' INTO TABLE tab.
* tab contains 2 entries -> 0 Tabname
* -> 1 Fields
READ TABLE tab INDEX 1.
IF sy-subrc EQ 0.
wa_field-tabname = tab.
ENDIF.
READ TABLE tab INDEX 2.
IF sy-subrc EQ 0.
SPLIT tab AT ' ' INTO TABLE fieldtab.
LOOP AT fieldtab.
wa_field-fieldname = fieldtab.
APPEND wa_field TO field.
ENDLOOP.
ENDIF.
ENDIF.
ENDLOOP.
LOOP AT field.
SELECT SINGLE * FROM tadir INTO tadir WHERE
pgmid = 'R3TR' AND
object = 'TABL' AND
obj_name = field-tabname.
IF sy-subrc NE 0.
field-error = 'X'.
MODIFY field.
ENDIF.
IF NOT field-fieldname IS INITIAL.
SELECT SINGLE * FROM dd03l INTO dd03l WHERE
tabname = field-tabname AND
fieldname = field-fieldname.
ENDIF.
IF sy-subrc NE 0.
field-missing = field-fieldname.
MODIFY field.
ENDIF.
ENDLOOP.
SORT p_iquerycondition BY conditionid.
SORT field BY conditionid.
* Deleting wrong Conditions and write log
DATA: tmp TYPE string.
LOOP AT field.
IF field-conditionid = tmp.
CONTINUE.
ENDIF.
tmp = field-conditionid.
IF field-error = ' ' AND field-missing = ''.
CONTINUE.
ENDIF.
DELETE p_iquerycondition WHERE
conditionid = field-conditionid.
IF field-error = 'X'.
CONCATENATE 'Table not found' field-tabname field-conditionid
INTO logline-txt SEPARATED BY '|'.
ELSEIF NOT field-missing IS INITIAL.
CONCATENATE 'Field missing in table' field-tabname field-missing
field-conditionid INTO logline-txt SEPARATED BY '|'.
ELSE.
CONTINUE.
ENDIF.
APPEND logline TO log.
CLEAR logline.
ENDLOOP.
MOVE log[] TO waextfile-log[].
ENDFORM. " check_tablefield_exist_system
