*----------------------------------------------------------------------*
*   INCLUDE RFZ30FOR                                                   *
*----------------------------------------------------------------------*

*---------------------------------------------------------------------*
*       FORM TOP_OF_PAGE                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM top_of_page.                                           "#EC CALLED

  IF  pri_params-linsz EQ 0
  OR  pri_params-linsz GE 132.
    PERFORM top_of_page_132.
  ELSE.
    PERFORM top_of_page_70.
  ENDIF.

ENDFORM.                    "top_of_page

*---------------------------------------------------------------------*

FORM top_of_page_70.

  DATA: BEGIN OF lb_l,            " left block
          len            TYPE i,
          line1(30)      TYPE c,
          line2(30)      TYPE c,
          line3(30)      TYPE c,
        END OF   lb_l.
  DATA: BEGIN OF lb_r,            " rigth block
          pos            TYPE i,
          len            TYPE i,
          line1(30)      TYPE c,
          line2(30)      TYPE c,
          line3(30)      TYPE c,
        END OF   lb_r.
  DATA: BEGIN OF lb_c,            " center block
          pos            TYPE i,
          len            TYPE i,
          line1(100)     TYPE c,
          line2(100)     TYPE c,
          line3(100)     TYPE c,
        END OF   lb_c.

  DATA: line_len         TYPE i,
        lc_len           TYPE i,
        lc_pos           TYPE i,
        lc_text1(30)     TYPE c,
        lc_text2(30)     TYPE c,
        lc_text3         LIKE sy-uname,
        lc_text4(6)      TYPE c,
        lc_title(100)    TYPE c,
        lc_title4(100)   TYPE c,
        ls_t001s         LIKE t001s,
        ls_fsabe         LIKE fsabe,
*        lc_laufd(10)     TYPE C,
        lc_c2(2)         TYPE c.

  line_len = pri_params-linsz.
* if only sumlist should be displayed, type of list should be set up
* once again (important for printing of sum lists)
  IF gc_type_of_list IS INITIAL.
    IF     p_asum EQ 'X'.
      gc_type_of_list = 'AR'.
    ELSEIF p_csum EQ 'X'.
      gc_type_of_list = 'CO'.
    ELSEIF p_wsum EQ 'X'.
      gc_type_of_list = 'CU'.
    ELSEIF p_msum EQ 'X'.
      gc_type_of_list = 'ME'.
    ELSEIF p_bsum EQ 'X'.
      gc_type_of_list = 'BA'.
    ENDIF.
  ENDIF.

* fill left block
  PERFORM read_t001  USING g_zbukr.
  PERFORM read_t000.
  IF NOT g_zbukr IS INITIAL.
    lb_l-line1 = t001-butxt.
    lb_l-line2 = t001-ort01.
    CONCATENATE text-007 g_zbukr
           INTO lb_l-line3 SEPARATED BY space.
  ELSE.
    " cross company code
    lb_l-line1 = t000-mtext.
    lb_l-line2 = t000-ort01.
    CONCATENATE text-051 sy-mandt
           INTO lb_l-line3 SEPARATED BY space.
  ENDIF.
  PERFORM top_of_page_length USING lb_l-line1
                                   lb_l-line2
                                   lb_l-line3
                          CHANGING lb_l-len.

* fill right block
  WRITE: sy-datum DD/MM/YYYY TO lc_text1,
         sy-uzeit            TO lc_text2,
         sy-uname            TO lc_text3,
         sy-pagno            TO lc_text4 RIGHT-JUSTIFIED.
  CONCATENATE lc_text1 '/' lc_text2
         INTO lb_r-line1 SEPARATED BY space.
  CONCATENATE text-004 sy-uname
         INTO lb_r-line2 SEPARATED BY space.
  lb_r-line3 = text-050.
  PERFORM top_of_page_length USING lb_r-line1
                                   lb_r-line2
                                   ' '
                          CHANGING lb_r-len.
  PERFORM output_length USING lb_r-line1 lc_len.
  IF lc_len LT lb_r-len.
    PERFORM output_length USING lc_text2 lc_len.
    lc_pos = lb_r-len - lc_len.
    CONCATENATE lc_text1 '/'
           INTO lb_r-line1 SEPARATED BY space.
    WRITE lc_text2(lc_len) TO lb_r-line1+lc_pos(lc_len).
  ENDIF.
  PERFORM output_length USING lb_r-line2 lc_len.
  IF lc_len LT lb_r-len.
    PERFORM output_length USING lc_text3 lc_len.
    lc_pos = lb_r-len - lc_len.
    lb_r-line2 = text-004.
    WRITE lc_text3(lc_len) TO lb_r-line2+lc_pos(lc_len).
  ENDIF.
  lc_len = lb_r-len - 5.
  WRITE lc_text4(6) TO lb_r-line3+lc_len(6).
  lb_r-pos = line_len - lb_r-len.

* fill center block
  lb_c-pos = lb_l-len + 2.
  lb_c-len = lb_r-pos - lb_c-pos - 1.
  IF zw_xvorl EQ space.
    lc_title = text-001.
  ELSE.
    lc_title = text-002.
  ENDIF.
  PERFORM top_of_page_cline1 USING lc_title lc_len.
  IF lc_len GT lb_c-len
  OR lc_len EQ 0.
    IF zw_xvorl EQ space.
      lc_title = text-101.
    ELSE.
      lc_title = text-102.
    ENDIF.
    PERFORM top_of_page_cline1 USING lc_title lc_len.
    IF lc_len GT lb_c-len
    OR lc_len EQ 0.
      lc_title = '&LAUFD / &LAUFI'.
      PERFORM top_of_page_cline1 USING lc_title lc_len.
    ENDIF.
  ENDIF.
  IF lc_len GT 0.
    IF lc_len GE lb_c-len.
      lb_c-line1 = lc_title.
    ELSE.
      lc_pos = lb_c-len / 2 - lc_len / 2.
      WRITE lc_title(lc_len) TO lb_c-line1+lc_pos(lc_len).
    ENDIF.
  ENDIF.
  CASE gc_type_of_list.
    WHEN 'MA'.
      lc_title = space.
      IF ( p_regul EQ space
      OR   p_ausna EQ space ).
        IF p_regul EQ 'X'.
          lc_title = text-021.
        ELSE.
          lc_title = text-020.
        ENDIF.
      ENDIF.
    WHEN 'LE'.  lc_title = text-003.
    WHEN 'AR'.  lc_title = text-041.
    WHEN 'CO'.  lc_title = text-042.
    WHEN 'CU'.  lc_title = text-043.
    WHEN 'ME'.  lc_title = text-044.
    WHEN 'BA'.  lc_title = text-045.
  ENDCASE.
  PERFORM output_length USING lc_title lc_len.
  IF lc_len GT lb_c-len
  OR lc_len EQ 0.
    CASE gc_type_of_list.
      WHEN 'MA'.  lc_title = space.
      WHEN 'LE'.  lc_title = text-003.
      WHEN 'AR'.  lc_title = text-103.
      WHEN 'CO'.  lc_title = text-104.
      WHEN 'CU'.  lc_title = text-105.
      WHEN 'ME'.  lc_title = text-106.
      WHEN 'BA'.  lc_title = text-107.
    ENDCASE.
    PERFORM output_length USING lc_title lc_len.
  ENDIF.
  IF lc_len GT 0.
    IF lc_len GE lb_c-len.
      lb_c-line2 = lc_title.
    ELSE.
      lc_pos = lb_c-len / 2 - lc_len / 2.
      WRITE lc_title(lc_len) TO lb_c-line2+lc_pos(lc_len).
    ENDIF.
  ENDIF.
  lc_title = p_title2.
  PERFORM output_length USING lc_title lc_len.
  IF lc_len GT 0.
    IF lc_len GE lb_c-len.
      lb_c-line3 = lc_title.
    ELSE.
      lc_pos = lb_c-len / 2 - lc_len / 2.
      WRITE lc_title(lc_len) TO lb_c-line3+lc_pos(lc_len).
    ENDIF.
  ENDIF.

  FORMAT INTENSIFIED ON.
* first line
  WRITE:  AT        1(lb_l-len) lb_l-line1,
          AT lb_c-pos(lb_c-len) lb_c-line1,
          AT lb_r-pos(lb_r-len) lb_r-line1.
  NEW-LINE.
* second line
  WRITE:  AT        1(lb_l-len) lb_l-line2,
          AT lb_c-pos(lb_c-len) lb_c-line2,
          AT lb_r-pos(lb_r-len) lb_r-line2.
  NEW-LINE.
* third line
  WRITE:  AT        1(lb_l-len) lb_l-line3,
          AT lb_c-pos(lb_c-len) lb_c-line3,
          AT lb_r-pos(lb_r-len) lb_r-line3.
  NEW-LINE.
* fourth line
  IF gc_type_of_list EQ 'MA'.
    READ TABLE gt_sort_main WITH KEY
                           fieldname = 'BUSAB'
                           tabname   = g_tabname_header.
    IF   sy-subrc             EQ 0
*   AND  gt_sort_main-spos    EQ '02'
    AND  gt_header_main-busab NE space.

      sy-fdpos = STRLEN( text-013 ).
      PERFORM output_length USING text-013 sy-fdpos.
      CALL FUNCTION 'CORRESPONDENCE_DATA_BUSAB'
        EXPORTING
          i_bukrs         = gt_header_main-zbukr
          i_busab         = gt_header_main-busab
          i_langu         = sy-langu
        IMPORTING
          e_t001s         = ls_t001s
          e_fsabe         = ls_fsabe
        EXCEPTIONS
          busab_not_found = 1
          OTHERS          = 2.
      IF sy-subrc NE 0.
        CLEAR: ls_t001s, ls_fsabe.
      ENDIF.
      CONCATENATE ls_fsabe-salut  ls_t001s-sname  '  ' ls_fsabe-abtei
                  ls_fsabe-function
             INTO lc_title4 SEPARATED BY space.
      WRITE: AT 1(sy-fdpos) text-013, lc_title4.
      NEW-LINE.
    ENDIF.
  ENDIF.

ENDFORM.                    "top_of_page_70

*---------------------------------------------------------------------*

FORM top_of_page_length USING p1 p2 p3
                     CHANGING pl.

  DATA:   ll      TYPE i.

  PERFORM output_length USING p1 pl.
  PERFORM output_length USING p2 ll.
  IF ll GT pl.  pl = ll.  ENDIF.
  PERFORM output_length USING p3 ll.
  IF ll GT pl.  pl = ll.  ENDIF.

ENDFORM.                    "top_of_page_length

*---------------------------------------------------------------------*

FORM top_of_page_cline1 CHANGING p_title p_len.

  DATA  lc_laufd(10)    TYPE c.

  WRITE zw_laufd  TO lc_laufd DD/MM/YYYY.
  REPLACE:
    '&LAUFD' WITH lc_laufd INTO p_title,
    '&LAUFI' WITH zw_laufi INTO p_title.
  PERFORM output_length USING p_title p_len.

ENDFORM.                    "top_of_page_cline1

*---------------------------------------------------------------------*
*       FORM TOP_OF_PAGE_132                                          *
*---------------------------------------------------------------------*
*       altes Standardformat                                          *
*---------------------------------------------------------------------*
FORM top_of_page_132.                                       "#EC CALLED

  DATA: lc_laufd(10)  TYPE c,
        lc_text(100)  TYPE c,
        lc_title1 LIKE p_title2,
        lc_title2 LIKE p_title2,
        lc_title3 LIKE p_title2,
        ls_t001s LIKE t001s,
        ls_fsabe LIKE fsabe.

  DATA: li_len  TYPE i,
        li_len2 TYPE i,
        li_len3 TYPE i,
        li_pos  TYPE i,
        li_pos2 TYPE i,
        li_pos3 TYPE i,
        li_pos4 TYPE i.
  DATA: l_time TYPE i.

  WRITE zw_laufd  TO lc_laufd DD/MM/YYYY.

* fill the central title lines
  IF zw_xvorl EQ space.
    lc_text = text-001.
  ELSE.
    lc_text = text-002.
  ENDIF.

  REPLACE:
    '&LAUFD' WITH lc_laufd INTO lc_text,
    '&LAUFI' WITH zw_laufi INTO lc_text.

* if only sumlist should be displayed, type of list should be set up
* once again (important for printing of sum lists)
  IF gc_type_of_list IS INITIAL.
    IF p_asum EQ 'X'.
      gc_type_of_list = 'AR'.
    ELSEIF p_csum EQ 'X'.
      gc_type_of_list = 'CO'.
    ELSEIF p_wsum EQ 'X'.
      gc_type_of_list = 'CU'.
    ELSEIF p_msum EQ 'X'.
      gc_type_of_list = 'ME'.
    ELSEIF p_bsum EQ 'X'.
      gc_type_of_list = 'BA'.
    ENDIF.
  ENDIF.

  lc_title2 = p_title2.
  IF   gc_type_of_list EQ 'MA'       AND
     ( p_regul         EQ space OR
       p_ausna         EQ space    ).
    IF p_regul EQ 'X'.
      lc_title1 = text-021.
    ELSE.
      lc_title1 = text-020.
    ENDIF.
  ELSEIF gc_type_of_list EQ 'LE'.
    lc_title1 = text-003.
  ELSEIF gc_type_of_list EQ 'AR'.
    lc_title1 = text-041.
  ELSEIF gc_type_of_list EQ 'CO'.
    lc_title1 = text-042.
  ELSEIF gc_type_of_list EQ 'CU'.
    lc_title1 = text-043.
  ELSEIF gc_type_of_list EQ 'ME'.
    lc_title1 = text-044.
  ELSEIF gc_type_of_list EQ 'BA'.
    lc_title1 = text-045.
  ENDIF.

  PERFORM read_t001  USING g_zbukr.
  PERFORM read_t000.

  FORMAT INTENSIFIED ON.

* calculate output positions
  PERFORM output_length USING text-004 li_len.
  PERFORM output_length USING text-005 li_len2.
  IF li_len2 < li_len.
    li_len2 = li_len.
  ENDIF.
  PERFORM output_length USING text-006 li_len.
  IF li_len2 < li_len.
    li_len2 = li_len.
  ENDIF.                        " li_len2 = maxlen( text-004, 005, 006)

  li_len3 = STRLEN( sy-uname ).
  IF li_len3 LT 10.                    " username shorter than date
    li_len3 = 10.
  ENDIF.

  li_pos2 = 126 - li_len3 - li_len2.   " position for text-004, 005, 006
  li_pos3 = 130 - li_len3.             " position for name, date, time

  IF gx_noexpa EQ 'X'.
    li_pos2 = li_pos2 - 3.
    li_pos3 = li_pos3 - 3.
  ENDIF.

  PERFORM output_length USING lc_text li_len.
  li_pos  = 60 - ( li_len / 2 ).

  PERFORM output_length USING lc_title2 li_len.
  li_pos4 = 60 - ( li_len / 2 ).

*first line
  IF NOT g_zbukr IS INITIAL.
    WRITE AT 1 t001-butxt.
  ELSE.
    WRITE AT 1 t000-mtext.     "Mandant, falls bkrs-uebergreifend
  ENDIF.
  WRITE AT li_pos(75) lc_text .
  WRITE: AT li_pos2 sy-datum DD/MM/YYYY, '/ '.

  l_time = li_pos3 - li_pos2.
  IF l_time < 12 .
    l_time = li_pos2 + 13.
    WRITE AT l_time(li_len3) sy-uzeit.
  ELSE.
    WRITE AT li_pos3(li_len3) sy-uzeit.
  ENDIF.
  NEW-LINE.

* second line
  IF NOT g_zbukr IS INITIAL.
    WRITE AT 1 t001-ort01.
  ELSE.
    WRITE AT 1 t000-ort01.     "Mandant, falls bkrs-uebergreifend
  ENDIF.
  IF lc_title1 NE space.
    PERFORM output_length USING lc_title1 li_pos.
    li_pos = 60 - li_pos / 2.
    WRITE AT li_pos lc_title1.
  ENDIF.
  WRITE AT li_pos2(li_len2) text-004.
  WRITE AT li_pos3(li_len3) sy-uname.
  NEW-LINE.

* third line.
  IF NOT g_zbukr IS INITIAL.
    WRITE: AT 1(*) text-007, g_zbukr.
  ELSE.
    WRITE: AT 1(*) text-051, sy-mandt.
  ENDIF.
  WRITE: AT li_pos2 text-050, AT li_pos3 sy-pagno LEFT-JUSTIFIED.
  WRITE AT li_pos4 lc_title2.

* fourth line ?
  NEW-LINE.
  IF gc_type_of_list EQ 'MA'.
    READ TABLE gt_sort_main WITH KEY fieldname = 'BUSAB'
                              tabname  = g_tabname_header.
    IF sy-subrc EQ 0             AND
*      gt_sort_main-spos EQ '02' AND
       gt_header_main-busab NE space.

      CALL FUNCTION 'CORRESPONDENCE_DATA_BUSAB'
        EXPORTING
          i_bukrs         = gt_header_main-zbukr
          i_busab         = gt_header_main-busab
          i_langu         = sy-langu
        IMPORTING
          e_t001s         = ls_t001s
          e_fsabe         = ls_fsabe
        EXCEPTIONS
          busab_not_found = 1
          OTHERS          = 2.
      IF sy-subrc NE 0.
        CLEAR: ls_t001s, ls_fsabe.
      ENDIF.
      CONCATENATE ls_fsabe-salut  ls_t001s-sname  '  ' ls_fsabe-abtei
                  ls_fsabe-function INTO lc_title3 SEPARATED BY space.
      WRITE: AT 1(*) text-013, lc_title3.
    ENDIF.
  ENDIF.

ENDFORM.                    "top_of_page

*---------------------------------------------------------------------*
*       FORM TOP_OF_LIST                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM top_of_list.                                           "#EC CALLED

  DATA:  l_header_main LIKE gt_header_main OCCURS 20,   "// Note 964746
         BEGIN OF l_vblnr OCCURS 20,                    "// Note 964746
           lifnr          LIKE reguh-lifnr,             "// Note 964746
           kunnr          LIKE reguh-kunnr,             "// Note 964746
           empfg          LIKE reguh-empfg,             "// Note 964746
           vblnr          LIKE reguh-vblnr,             "// Note 964746
           vblnr_cnt      TYPE i,                       "// Note 964746
         END OF l_vblnr.                                "// Note 964746

  gx_start_of_list = 'X'.

  IF g_list_anzahl IS INITIAL.                     " start note 1241670
    DESCRIBE TABLE gt_output_main LINES g_list_anzahl.
  ENDIF.
  IF g_list_count GE g_list_anzahl.
    CLEAR g_list_count.
  ENDIF.
  g_list_count = g_list_count + 1.
  READ TABLE gt_output_main INDEX g_list_count.
  IF sy-subrc = 0.                                 " end   note 1241670
* IF g_sollzeilen = 0.                             " start note 1158897
    DESCRIBE TABLE gt_output_main-poken LINES g_sollzeilen.
    IF p_asum IS NOT INITIAL
    OR p_csum IS NOT INITIAL
    OR p_wsum IS NOT INITIAL
    OR p_msum IS NOT INITIAL
    OR p_bsum IS NOT INITIAL
    OR g_sollzeilen > 0.
      g_sollzeilen = 99999999.
      DESCRIBE TABLE gt_output_main-header LINES g_sollzeilen2.
    ELSE.
      DESCRIBE TABLE gt_output_main-header LINES g_sollzeilen.
      g_sollzeilen2 = g_sollzeilen.
    ENDIF.
    g_zeilenzahl = 0.
    g_zeilenzahl_last = 0.
  ENDIF.                                             " end note 1158897

  CALL FUNCTION 'REUSE_ALV_LIST_LAYOUT_INFO_GET'
    IMPORTING
      et_sort       = gt_sort_main[]
    EXCEPTIONS
      no_infos      = 1
      program_error = 2
      OTHERS        = 3.

  IF g_printing IS INITIAL.                       "// Start Note 964746
    LOOP AT gt_header_main.
      MOVE-CORRESPONDING gt_header_main TO l_vblnr.
      l_vblnr-vblnr_cnt = 1.
      COLLECT l_vblnr.
      READ TABLE l_vblnr INDEX sy-tabix.
      IF l_vblnr-vblnr_cnt < 2.
        APPEND gt_header_main TO l_header_main.
      ENDIF.
    ENDLOOP.
    READ TABLE gt_header_main INDEX 1.
    LOOP AT gt_output_main WHERE zbukr = gt_header_main-zbukr
                             AND hwaer = gt_header_main-hwaer.
      CLEAR gt_output_main-header[].
      APPEND LINES OF l_header_main TO gt_output_main-header.
      CLEAR gt_output_main-item[].
      APPEND LINES OF gt_item_main TO gt_output_main-item.
      MODIFY gt_output_main.
      EXIT.
    ENDLOOP.
  ENDIF.                                          "// End   Note 964746

* when withholding tax output is wished, get the position to display
* the information
  PERFORM get_wt_position.

ENDFORM.                    "top_of_list

*---------------------------------------------------------------------*
*       FORM BEFORE_LINE_OUTPUT                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  RS_LININFO                                                    *
*---------------------------------------------------------------------*
FORM before_line_output USING rs_lineinfo TYPE slis_lineinfo. "#EC CALLED

* -------------- write adrs ? --------------------------------------

  IF rs_lineinfo-tabname EQ g_tabname_header.
    IF rs_lineinfo-tabindex GT 0.      " AND gt_header_main-expa = 'X'.
      PERFORM write_adrs USING rs_lineinfo.
      gx_topskip = 'X'.
      IF rs_lineinfo-subtot IS INITIAL.                  " note 1158897
        g_zeilenzahl = g_zeilenzahl + 1.                 " note 1158897
      ENDIF.                                             " note 1158897
    ELSEIF rs_lineinfo-tabindex EQ 0.
      IF gx_topskip NE 'X'.
        FORMAT COLOR COL_BACKGROUND INTENSIFIED ON.
        NEW-LINE.
        WRITE AT 1(rs_lineinfo-linsz) sy-uline.
      ENDIF.
      CLEAR  gx_topskip.
    ENDIF.

  ENDIF.

ENDFORM.                    "before_line_output


*---------------------------------------------------------------------*
*       FORM after_line_output                                        *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  rs_lineinfo                                                   *
*---------------------------------------------------------------------*
FORM after_line_output USING rs_lineinfo TYPE slis_lineinfo. "#EC CALLED

* only continue, if withholding tax output is desired
  CHECK NOT p_witht IS INITIAL.
  CHECK NOT gn_wabzg_width IS INITIAL.
* is the actual line an item line
  IF rs_lineinfo-tabname EQ g_tabname_item.
    PERFORM write_wt USING rs_lineinfo.
  ENDIF.

ENDFORM.                    "after_line_output
*---------------------------------------------------------------------*
*       FORM END_OF_LIST                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM end_of_list.                                           "#EC CALLED
  CLEAR gx_firstadrsout.

  CHECK p_edit IS INITIAL.

  PERFORM write_poken_tab.
  PERFORM write_sum_lists.

* CHECK FIRST ROUND AND NOT MODIFICATION MODE.
  CHECK gx_firstround EQ 'X'.
  gs_layout_main-list_append = 'X'.
  CLEAR gx_firstround.

*---- iterativ call of ALV for all remaining copmany codes -----------
  LOOP AT gt_output_main.
    CHECK sy-tabix GE 2.
    PERFORM write_lists_for_company USING sy-tabix.
  ENDLOOP.

*----- company code indepentdent sum list output -------------------*

  SORT gt_output_main BY hwaer.
  DESCRIBE TABLE gt_output_main LINES sy-tabix.
  CHECK sy-tabix GT 1.          "more than one company code involved?

  PERFORM write_sum_lists2.

  SORT gt_output_main BY zbukr.


*  reset parameters for list printing
  CLEAR gs_layout_main-list_append.
  READ TABLE gt_output_main INDEX 1.
  REFRESH gt_header_main.
  APPEND LINES OF gt_output_main-header TO gt_header_main.
  READ TABLE gt_header_main INDEX 1.
  REFRESH gt_item_main.
  APPEND LINES OF gt_output_main-item TO gt_item_main.

ENDFORM.                    "end_of_list

*---------------------------------------------------------------------*
*       FORM USER_COMMAND                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  R_UCOMM                                                       *
*  -->  RS_SELFIELD                                                   *
*---------------------------------------------------------------------*
FORM user_command USING r_ucomm     LIKE sy-ucomm           "#EC CALLED
                        rs_selfield TYPE slis_selfield.

  CASE r_ucomm.

    WHEN '&ODN' OR '&OUP' OR '&SUM'.
      PERFORM check_sortorderb.

    WHEN '&RNT' OR '&LIS'.

      IF NOT rs_selfield-before_action IS INITIAL.      "// Note 964746

        IF p_regul IS INITIAL AND
          p_ausna IS INITIAL.
          CLEAR gc_type_of_list.
          EXIT.
        ENDIF.

        SORT gt_output_main BY zbukr.

* schmutziges Abfangen von ALV, setze alles auf Startwerte
* lese Buchungskreis des ersten Eintrags, l#sche die Buchungskreis-
* ¨¹bergreifenden Summentabellen, keine Appendliste mehr
        READ TABLE gt_output_main INDEX 1.     "Get first bukr
        g_zbukr = gt_output_main-zbukr.  "set it to the startvalue
*       rs_selfield-refresh        = 'X'.
        gx_firstround              = 'X'.
*       gs_layout_main-list_append = space.
        gc_type_of_list = 'MA'.

        REFRESH gt_area2.
        REFRESH gt_coun2.
        REFRESH gt_curr2.
        REFRESH gt_meth2.
        REFRESH gt_bank2.
        g_printing = 'X'.                               "// Note 964746

      ELSE. "NOT ( rs_selfield-after_action IS INITIAL. )// Note 964746

        CLEAR g_printing.                               "// Note 964746

      ENDIF.                                            "// Note 964746

    WHEN '&OL0' .
      IF NOT rs_selfield-before_action IS INITIAL.
*       switch to maintenance mode (from display mode)
        CHECK p_edit IS INITIAL.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            text_question = text-057
          IMPORTING
            answer        = gc_answer.
        IF gc_answer = '1'.
          PERFORM switch_to_maintenance.
          r_ucomm = '&F03'.
        ELSE.
          CLEAR r_ucomm.
        ENDIF.
      ELSE.
*       determine new position for withholding tax stuff
        CHECK NOT p_edit IS INITIAL.
        PERFORM get_wt_position.
      ENDIF.

  ENDCASE.

ENDFORM.                    "user_command

*---------------------------------------------------------------------*
*       FORM F4_FOR_VARIANT                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*

FORM f4_for_variant USING    p_save
                             p_handle
                             p_header
                             p_item
                             p_pamname
                    CHANGING p_variant LIKE disvariant
                             par_var   LIKE disvariant-variant.

  DATA: lc_exit(1) TYPE c,
        l_variant LIKE disvariant,
        nof4 TYPE c.

  CLEAR nof4.

  LOOP AT SCREEN.
    IF  screen-name EQ p_pamname AND screen-input EQ 0.
      nof4 = 'X'.
    ENDIF.
  ENDLOOP.

  p_variant-report    = sy-repid.
  p_variant-handle    = p_handle.



  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant       = p_variant
      i_save           = p_save
      i_tabname_header = p_header
      i_tabname_item   = p_item
    IMPORTING
      e_exit           = lc_exit
      es_variant       = l_variant
    EXCEPTIONS
      not_found        = 2.

  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S'      NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  IF lc_exit = space AND nof4 EQ space.
    p_variant = l_variant.
    par_var   = p_variant-variant.
  ENDIF.

ENDFORM.                    "f4_for_variant

*---------------------------------------------------------------------*
*       FORM CHECK_VARIANT                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_V                                                           *
*  -->  P_HANDLE                                                      *
*  -->  P_VARIANT                                                     *
*---------------------------------------------------------------------*
FORM check_variant USING    par_var
                            p_handle
                            p_varxx
                   CHANGING p_variant  LIKE disvariant.

  IF NOT par_var IS INITIAL.

    MOVE par_var   TO p_variant-variant.
    MOVE p_handle  TO p_variant-handle.
    MOVE sy-repid  TO p_variant-report.
    SET CURSOR FIELD p_varxx.

    CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
      EXPORTING
        i_save        = g_save
      CHANGING
        cs_variant    = p_variant
      EXCEPTIONS
        wrong_input   = 1
        not_found     = 2
        program_error = 3
        OTHERS        = 4.

    IF sy-subrc <> 0.
      CLEAR p_variant.
      p_variant-report = g_repid.
      p_variant-handle = p_handle.
    ENDIF.
  ELSE.
    CLEAR p_variant.
    p_variant-report = g_repid.
    p_variant-handle = p_handle.
  ENDIF.
ENDFORM.                    "check_variant

*&---------------------------------------------------------------------*
*&      Form  store_ADRS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_RS_LINEINFO  text                                          *
*----------------------------------------------------------------------*
FORM store_adrs.

  DATA: li_count TYPE i,
        li_outlen TYPE i,
        li_outlen2 TYPE i,
        lx_noadrs(1) TYPE c,
        lx_noabw(1) TYPE c,
        lx_nobank(1) TYPE c,
        lc_bankn(40)  TYPE c,
        lc_subrc      LIKE sy-subrc,
        lc_banka(101) TYPE c,
        lc_banka2 LIKE bnka-banka,
        lc_xabwz      LIKE regud-xabwz,
        ln_numlines(1) TYPE n.

  DATA: hilfe TYPE i.

  DATA ls_adrs TYPE gs_adrs.

  DATA: l_add_print LIKE adrs_print,
        l_add_short_form LIKE szad_field-addr_short,
        l_add_data_carrier LIKE szad_field-addr_dc,
        l_add_data_carrier_0 LIKE szad_field-addr_dc.
*       l_sender_country LIKE szad_field-send_cntry.

  STATICS:   st_fudsc_exist      TYPE c,
             st_sender_country   LIKE szad_field-send_cntry,
             st_sender_language  LIKE sy-langu,
             st_lit_language     LIKE sy-langu.          " note 1337633

  DATA: l_t002            TYPE t002.                     " note 1337633

  FIELD-SYMBOLS: <fs0>,
                 <fs1>.

  DATA: lc_vorlage1(8)    TYPE c,                           " HW 815319
        lc_vorlage2(8)    TYPE c.                           " HW 815319
  DATA: lc_ort01          LIKE bnka-ort01,                  " HW 842128
        lc_brnch          LIKE bnka-brnch.               " note 1387281

  DATA: lp_madrz          LIKE adrs-anzzl,
        l_madrz           LIKE adrs-anzzl.

  lp_madrz = p_madrz.

  CHECK lp_madrz GT 0.

* check, if first adress is equal to second, or if first adress is
* empty ----> fill with second adress.
  PERFORM check_adresses .

* Name
  CLEAR adrs.
  adrs-name1 = gt_header_main-name1.
  adrs-name2 = gt_header_main-name2.
  adrs-stras = gt_header_main-stras .
  adrs-pfach = gt_header_main-pfach .
  adrs-pstl2 = gt_header_main-pstl2.
  adrs-land1 = gt_header_main-land1 .
  adrs-pstlz = gt_header_main-pstlz .
  adrs-pfort = gt_header_main-pfort .
  adrs-ort01 = gt_header_main-ort01 .
  adrs-pstl2 = gt_header_main-pstl2 .
  adrs-regio = gt_header_main-regio.
  adrs-inlnd = t001-land1.
  adrs-anzzl = lp_madrz.

*------ Sprachen anpassen ----------------------- notes 957345, 1337633
  IF st_fudsc_exist IS INITIAL.
    st_fudsc_exist = 'X'.
    CALL FUNCTION 'FUNCTION_EXISTS'
      EXPORTING
        funcname           = 'ADDR_DEFAULT_SENDER_COUNTRY'
      EXCEPTIONS
        function_not_exist = 1
        OTHERS             = 2.
    IF sy-subrc = 0.
      CALL FUNCTION 'ADDR_DEFAULT_SENDER_COUNTRY'           "#EC EXISTS
        IMPORTING
          ev_sender_country = st_sender_country.
      SELECT SINGLE * FROM t005 INTO t005
                      WHERE land1 = st_sender_country.
      st_sender_language = t005-spras.
    ENDIF.

    IF p_inland IS NOT INITIAL.
      SELECT SINGLE * FROM t005 INTO t005
                      WHERE land1 = p_inland.
      st_sender_country  = p_inland.
      st_sender_language = t005-spras.
    ENDIF.
    IF p_litspr IS NOT INITIAL.
      SELECT SINGLE * FROM t002 INTO l_t002
                      WHERE spras = p_litspr.
      IF sy-subrc = 0.
        st_lit_language = p_litspr.
      ENDIF.
    ENDIF.
  ENDIF.

  IF reguh-adrnr IS INITIAL.
    IF NOT st_sender_country IS INITIAL.
      adrs-inlnd = st_sender_country.
      adrs-spras = st_lit_language.                      " note 1337633
    ENDIF.
    CALL FUNCTION 'ADDRESS_INTO_PRINTFORM'
      EXPORTING
        adrswa_in  = adrs
      IMPORTING
        adrswa_out = adrs.
  ELSE.
* falls Postfachadresse gepflegt ist -> abweichende Region nicht in
* REGUH vorhanden
    CLEAR adrs.

* unterschiedliche Addressbildaufbau
    CALL FUNCTION 'ADDRESS_INTO_PRINTFORM'
      EXPORTING
        address_type              = '1'
        address_number            = reguh-adrnr
        number_of_lines           = lp_madrz
        sender_country            = st_sender_country
        language_for_country_name = st_sender_language   " note 1337633
        receiver_language         = st_lit_language         " note 1337633
      IMPORTING
        address_printform         = l_add_print
        address_short_form        = l_add_short_form
        address_data_carrier      = l_add_data_carrier
        address_data_carrier_0    = l_add_data_carrier_0
        number_of_used_lines      = adrs-anzzl.

* fill adrs
    MOVE-CORRESPONDING l_add_print TO adrs.
    adrs-linek = l_add_short_form.
    adrs-lined = l_add_data_carrier.
    adrs-lined0 = l_add_data_carrier_0.

  ENDIF.

  ASSIGN adrs-line0(g_adrlen) TO <fs0>.
  ASSIGN ls_adrs-sline1(g_adrlen) TO <fs1>.

  lx_noadrs = 'X'.

  DO 9 TIMES.
    IF <fs0> IS INITIAL.
      ASSIGN <fs0>+g_adrlen TO <fs0> RANGE adrs.
      CONTINUE.
    ENDIF.

    <fs1> = <fs0>.
    ASSIGN <fs0>+g_adrlen TO <fs0> RANGE adrs.
    CLEAR lx_noadrs.
    li_count = li_count + 1.
    CHECK li_count LT lp_madrz.
    ASSIGN <fs1>+g_adrlen TO <fs1> RANGE ls_adrs.
  ENDDO.
  ln_numlines = li_count.

  IF gx_hrflag EQ 'X'.
    CONCATENATE text-010 gt_header_main-pernr INTO ls_adrs-sline0
      SEPARATED BY ' '.
  ELSEIF gt_header_main-lifnr NE space.
    CONCATENATE text-008 gt_header_main-lifnr INTO ls_adrs-sline0
      SEPARATED BY ' '.
  ELSEIF gt_header_main-kunnr NE space.
    CONCATENATE text-009 gt_header_main-kunnr INTO ls_adrs-sline0
      SEPARATED BY ' '.
  ELSE.  "Alle anderen: Partner (z.B. SAKNR gefuellt)
    ls_adrs-sline0 = text-054.
  ENDIF.


  IF  gt_header_main-znme1 NE space OR
       reguh-zadnr NE reguh-adrnr.
    CLEAR adrs.
    adrs-name1 = gt_header_main-znme1.
    adrs-name2 = gt_header_main-znme2.
    adrs-stras = gt_header_main-zstra.
    adrs-pfach = gt_header_main-zpfac.
    adrs-pfort = gt_header_main-zpfor.
    adrs-land1 = gt_header_main-zland.
    adrs-pstl2 = gt_header_main-zpst2.
    adrs-pstlz = gt_header_main-zpstl.
    adrs-ort01 = gt_header_main-zort1.
    adrs-regio = gt_header_main-zregi.
    adrs-inlnd = t001-land1.
    adrs-anzzl = lp_madrz.

    IF reguh-zadnr IS INITIAL.
      IF NOT st_sender_country IS INITIAL.
        adrs-inlnd = st_sender_country.
        adrs-spras = st_lit_language.                    " note 1337633
      ENDIF.
      CALL FUNCTION 'ADDRESS_INTO_PRINTFORM'
        EXPORTING
          adrswa_in  = adrs
        IMPORTING
          adrswa_out = adrs.
    ELSE.
* falls Postfachadresse gepflegt ist -> abweichende Region nicht in
* REGUH vorhanden
      CLEAR adrs.
      CLEAR: l_add_print,
             l_add_short_form,
             l_add_data_carrier,
             l_add_data_carrier_0.

* unterschiedliche Addressbildaufbau
      CALL FUNCTION 'ADDRESS_INTO_PRINTFORM'
        EXPORTING
          address_type              = '1'
          address_number            = reguh-zadnr
          number_of_lines           = lp_madrz
          sender_country            = st_sender_country
          language_for_country_name = st_sender_language " note 1337633
          receiver_language         = st_lit_language       " note 1337633
        IMPORTING
          address_printform         = l_add_print
          address_short_form        = l_add_short_form
          address_data_carrier      = l_add_data_carrier
          address_data_carrier_0    = l_add_data_carrier_0
          number_of_used_lines      = adrs-anzzl.

* fill adrs
      MOVE-CORRESPONDING l_add_print TO adrs.

      adrs-linek = l_add_short_form.
      adrs-lined = l_add_data_carrier.
      adrs-lined0 = l_add_data_carrier_0.

    ENDIF.

    ASSIGN adrs-line0(g_adrlen) TO <fs0>.
    ASSIGN ls_adrs-eline1(g_adrlen) TO <fs1>.

    li_count = 0.
    DO 9 TIMES.
      IF <fs0> IS INITIAL.
        ASSIGN <fs0>+g_adrlen TO <fs0> RANGE adrs.
        CONTINUE.
      ENDIF.
      <fs1> = <fs0>.
      ASSIGN <fs0>+g_adrlen TO <fs0> RANGE adrs.
      li_count = li_count + 1.
      CHECK li_count LT lp_madrz.
      ASSIGN <fs1>+g_adrlen TO <fs1> RANGE ls_adrs.
    ENDDO.
  ENDIF.
  IF li_count GT ln_numlines.
    ln_numlines = li_count.
  ENDIF.
  IF gt_header_main-znme1 EQ space.
    lx_noabw = 'X'.
  ELSE.
    IF reguh-empfg+0(1) EQ '>'.
      CONCATENATE text-011 gt_header_main-empfg+0(10)
        INTO         ls_adrs-eline0
        SEPARATED BY ' '.
    ELSE.
      ls_adrs-eline0 = text-011.
    ENDIF.
  ENDIF.

* ----------- Bank

  PERFORM read_bnka USING gt_header_main-zbnks
                          gt_header_main-zbnky.

  lc_vorlage1 = 'SILNK'.                           " HW 815319, 1358663
  " Pr¨¹fen Bankname und Bankort sp#ter
  " Checking bank name and bank location later
  IF gt_header_main-zswif EQ space.
    TRANSLATE lc_vorlage1 USING 'S '.
  ENDIF.
  IF gt_header_main-ziban EQ space.
    TRANSLATE lc_vorlage1 USING 'I '.
  ENDIF.
  IF gt_header_main-zbnkl EQ space.
    TRANSLATE lc_vorlage1 USING 'L '.
  ENDIF.
  IF gt_header_main-zbnkn EQ space.
    TRANSLATE lc_vorlage1 USING 'N '.
  ELSE.
    lc_bankn = gt_header_main-zbnkn.
    CALL FUNCTION 'CONVERT_BANK_ACCOUNT_NUMBER'
      EXPORTING
        i_banks      = gt_header_main-zbnks
        i_bankk      = gt_header_main-zbnky
        i_bankn      = gt_header_main-zbnkn
        i_bkont      = gt_header_main-zbkon
        i_bkref      = gt_header_main-bkref
        i_bankl      = gt_header_main-zbnkl
      IMPORTING
        e_bankn_long = lc_bankn
        e_subrc      = lc_subrc.
  ENDIF.
  IF gt_header_main-zbkon EQ space.
    TRANSLATE lc_vorlage1 USING 'K '.
  ENDIF.
  CONDENSE lc_vorlage1 NO-GAPS.
*   Insert bank name and address via address number        note 1358663
  IF bnka-adrnr IS NOT INITIAL.
    l_madrz = STRLEN( lc_vorlage1 ).
    l_madrz = lp_madrz - l_madrz.
    IF     l_madrz > 3.
      l_madrz = 3.
    ELSEIF l_madrz < 2.
      l_madrz = 1.
    ENDIF.
    CALL FUNCTION 'ADDRESS_INTO_PRINTFORM'
      EXPORTING
        address_type              = '1'
        address_number            = bnka-adrnr
        number_of_lines           = l_madrz
        sender_country            = st_sender_country
        language_for_country_name = st_sender_language
        receiver_language         = st_lit_language
      IMPORTING
        address_printform         = l_add_print
        address_short_form        = l_add_short_form
        address_data_carrier      = l_add_data_carrier
        address_data_carrier_0    = l_add_data_carrier_0
        number_of_used_lines      = adrs-anzzl.
    CASE adrs-anzzl.
      WHEN 1.
        CONCATENATE '1'   lc_vorlage1 INTO lc_vorlage1 .
      WHEN 2.
        CONCATENATE '12'  lc_vorlage1 INTO lc_vorlage1 .
      WHEN 3.
        CONCATENATE '123' lc_vorlage1 INTO lc_vorlage1 .
    ENDCASE.
  ENDIF.
*   Insert bank name and address via bank master           note 1358663
  IF bnka-adrnr IS INITIAL
  OR adrs-anzzl EQ 0.
    CONCATENATE 'AO'  lc_vorlage1 INTO lc_vorlage1 .
    lc_banka = bnka-banka.
    lc_brnch = bnka-brnch.
    IF lc_banka EQ space AND lc_brnch EQ space.
      TRANSLATE lc_vorlage1 USING 'A '.
    ENDIF.
    IF bnka-ort01 EQ space.
      TRANSLATE lc_vorlage1 USING 'O '.
    ELSE.
      lc_ort01 = bnka-ort01.
    ENDIF.
    CONDENSE lc_vorlage1 NO-GAPS.
  ENDIF.
* - Bankwege pruefen / check bank chains                 // HW 842128
  IF p_bnkweg NE space.
    CLEAR: kbank1, kbank2, kbank3.
    MOVE-CORRESPONDING: gt_header_main TO kbank1,
                        gt_header_main TO kbank2,
                        gt_header_main TO kbank3.
    IF NOT kbank1 IS INITIAL.
      PERFORM store_check_bank_chain
              USING 'C' kbank1 ls_adrs.
    ENDIF.
    IF NOT kbank2 IS INITIAL.
      PERFORM store_check_bank_chain
              USING 'C' kbank2 ls_adrs.
    ENDIF.
    IF NOT kbank3 IS INITIAL.
      PERFORM store_check_bank_chain
              USING 'C' kbank3 ls_adrs.
    ENDIF.
  ENDIF.
* - Pruefen der verfuegbaren Zeilen / Checking available lines
  li_outlen2 = STRLEN( lc_vorlage1 ).
  IF li_outlen2 > lp_madrz.
    TRANSLATE lc_vorlage1 USING 'O '.
    CONDENSE lc_vorlage1 NO-GAPS.
  ENDIF.
  IF lc_vorlage1 CS 'N'.
    IF sy-fdpos GE lp_madrz.
      IF lc_vorlage1 CS 'S' AND lc_vorlage1 CS 'L'.
        TRANSLATE lc_vorlage1 USING 'L '.
        CONDENSE lc_vorlage1 NO-GAPS.
      ENDIF.
    ENDIF.
  ENDIF.
* - Ausgabe der Bankverbindung / Printing of bank detail
  li_count = 0.
  WHILE  lc_vorlage1 NE space  AND  li_count <= lp_madrz.
    ASSIGN ls_adrs-bline1 INCREMENT li_count
                          TO <fs0> RANGE ls_adrs.

    CASE lc_vorlage1(1).
      WHEN 'A'.
        <fs0>   = 'TB1'.
        <fs0>+4 = lc_banka.
        ls_adrs-blinea = lc_brnch.
      WHEN 'O'.
        <fs0>   = lc_ort01.
      WHEN '1'.
        <fs0>   = l_add_print-line0.
      WHEN '2'.
        <fs0>   = l_add_print-line1.
      WHEN '3'.
        <fs0>   = l_add_print-line2.
      WHEN 'S'.
        <fs0>   = 'T19'.
        <fs0>+4 = gt_header_main-zswif.
      WHEN 'I'.
        <fs0>   = 'T62'.
        <fs0>+4 = gt_header_main-ziban.
      WHEN 'L'.
        <fs0>   = 'T17'.
        <fs0>+4 = gt_header_main-zbnkl.
      WHEN 'N'.
        <fs0>   = 'T18'.
        <fs0>+4 = lc_bankn.
      WHEN 'K'.
        <fs0>   = 'T61'.
        <fs0>+4 = gt_header_main-zbkon.
    ENDCASE.

    SHIFT lc_vorlage1.
    li_count = li_count + 1.
  ENDWHILE.                                      " Ende   HW 815319
* - Ausgabe des Bankweges / store bank chain                HW 842128
  IF p_bnkweg NE space
  AND ( NOT kbank1-o_flags1 IS INITIAL
     OR NOT kbank2-o_flags2 IS INITIAL
     OR NOT kbank3-o_flags3 IS INITIAL ).
    ASSIGN ls_adrs-cline0 TO <bcfs>.
    PERFORM store_check_bank_chain
            USING 'T' kbank1 ls_adrs.
    IF NOT kbank1-o_flags1 IS INITIAL.
      PERFORM store_check_bank_chain
              USING 'S' kbank1 ls_adrs.
    ENDIF.
    IF NOT kbank2-o_flags2 IS INITIAL.
      PERFORM store_check_bank_chain
              USING 'S' kbank2 ls_adrs.
    ENDIF.
    IF NOT kbank3-o_flags3 IS INITIAL.
      PERFORM store_check_bank_chain
              USING 'S' kbank3 ls_adrs.
    ENDIF.
  ENDIF.


  IF li_count GT ln_numlines.
    ln_numlines = li_count.
  ENDIF.

  li_outlen = lp_madrz * g_adrlen.

  ASSIGN ls_adrs-bline1(li_outlen) TO <fs0> RANGE ls_adrs.
  IF <fs0> IS INITIAL.
    lx_nobank = 'X'.
  ELSE.
    ls_adrs-bline0 = text-012.
  ENDIF.

  READ TABLE gt_adrs2pf WITH KEY adrs   = ls_adrs
                                 noabw  = lx_noabw.

  IF sy-subrc EQ 0.
    gt_header_main-adrs_key = gt_adrs2pf-key.
  ELSE.
    CLEAR gt_adrs2pf.
    gt_adrs2pf-adrs = ls_adrs.
    DESCRIBE TABLE gt_adrs2pf LINES gt_header_main-adrs_key.
    gt_adrs2pf-key = gt_header_main-adrs_key + 1.
    gt_adrs2pf-noadrs = lx_noadrs.
    gt_adrs2pf-noabw = lx_noabw.
    gt_adrs2pf-nobank = lx_nobank.
    gt_adrs2pf-numlines = ln_numlines.
    APPEND gt_adrs2pf.
    ADD 1 TO gt_header_main-adrs_key.
  ENDIF.
ENDFORM.                    "store_adrs

*---------------------------------------------------------------------*
*       FORM WRITE_LISTS_FOR_COMPANY                                  *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_INDEX                                                       *
*---------------------------------------------------------------------*
FORM write_lists_for_company USING p_index LIKE sy-index.
  READ TABLE gt_output_main INDEX p_index.
  g_zbukr = gt_output_main-zbukr.
  IF p_regul IS INITIAL AND
     p_ausna IS INITIAL.
    g_sollzeilen = 999999999.              "// HW 1248093
    PERFORM write_poken_tab.               "// HW 0369220
*    PERFORM end_of_list.                   "// HW 0369220
    gs_layout_append-list_append = space.  "// HW 0369220
    PERFORM end_of_list2.                  "// HW 0369220
  ELSE.
    PERFORM write_main_list.
  ENDIF.
ENDFORM.                    "write_lists_for_company

*---------------------------------------------------------------------*
*       FORM WRITE_MAIN_LIST                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM write_main_list.

  DATA:  l_expa(1)    TYPE c,
         l_cccnt      TYPE p.

  gc_type_of_list = 'MA'.              "main list
  REFRESH gt_header_main.
  APPEND LINES OF gt_output_main-header TO gt_header_main.
  READ TABLE gt_header_main INDEX 1.
  REFRESH gt_item_main.
  APPEND LINES OF gt_output_main-item TO gt_item_main.

  DESCRIBE TABLE gt_output_main LINES l_cccnt.

  READ TABLE gt_item_main INDEX 1.
  IF sy-subrc EQ 0.

* exclude the buttons in display mode, cause changes are senseless
* deactivate the Hotspot
    IF p_edit IS INITIAL.

      PERFORM exclude_init  TABLES gt_extab[] USING : '&SUM',
                                                      '&ODN',
                                                      '&ILT',
                                                      '&OUP',
                                                      '&OAD',
                                                      '&AVE',
*                                                     '&UMC',
                                                      '&OMP',
                                                      '&XPA',
                                                      '&ETA',
                                                      '&OPT',
                                                      '&OLX',
                                                      '&ERW',
                                                      '&KOM',
                                                      '&AUF',
                                                      '&ILD',
                                                      '&CDF',
                                                      '&ODF',
                                                      '&CFI',
                                                      '&DAU',
                                                      '&DON',
                                                      '&DOF',
*                                                     '&IC1',
                                                      '&AVR',
                                                      '&MIN',
                                                      '&MAX'.
      IF sy-batch = 'X'
      OR l_cccnt  > 1.
        PERFORM exclude_init TABLES gt_extab[] USING: '&UMC',
                                                      '&IC1'.
        gs_layout_main-no_hotspot       = 'X'.
        gs_layout_main-expand_fieldname = space.
        IF NOT p_verd IS INITIAL.
*         Postenliste unterdr¨¹cken / exclude item list
          gs_print-no_print_hierseq_item = 'X'.
*         Vorraussetzung/prerequisite from note 326607
          gs_layout_main-expand_fieldname = 'EXPA'.
        ENDIF.
      ELSE.
        gs_layout_main-no_hotspot       = space.
        gs_layout_main-expand_fieldname = 'EXPA'.
*       Postenliste (nicht) expandieren / item list (not) expand
        IF NOT p_verd IS INITIAL.
          l_expa = ' '.
        ELSE.
          l_expa = 'X'.
        ENDIF.
        gt_header_main-expa = l_expa.
        MODIFY gt_header_main TRANSPORTING expa WHERE expa NE l_expa.
      ENDIF.

      IF  NOT g_print_params IS INITIAL               "/   Note 1021039
      AND NOT p_noclsz IS INITIAL.
        IF pri_params-linsz > 10.
          gs_layout_main-min_linesize = 10.
          gs_layout_main-max_linesize = pri_params-linsz.
*       ELSE.
*         gs_layout_main-min_linesize = 255.          "/ Reportstandard
        ENDIF.
        gs_print-no_change_print_params = 'X'.
      ENDIF.                                          "/   Note 1021039

      IF NOT g_print_params IS INITIAL.               "/   Note 1045061
        gs_print-print_ctrl-pri_params = pri_params.
        gs_print-print_ctrl-arc_params = arc_params.
      ENDIF.                                          "/   Note 1045061
    ENDIF.

    break extspa.
    DELETE gt_fieldcat_main WHERE tabname = 'GT_HEADER_MAIN'.
*    CALL FUNCTION 'REUSE_ALV_HIERSEQ_LIST_DISPLAY'
*         EXPORTING
*              i_callback_program      = g_repid
*              i_callback_user_command = g_user_command
*              is_layout               = gs_layout_main
*              it_fieldcat             = gt_fieldcat_main[]
*              it_sort                 = gt_sort_main[]
*              i_save                  = g_save
*              is_variant              = g_variant_main
*              it_events               = gt_events
*              it_event_exit           = gt_event_exit[]
*              i_tabname_header        = g_tabname_header
*              i_tabname_item          = g_tabname_item
*              is_keyinfo              = gs_keyinfo_main
*              is_print                = gs_print
*              it_excluding            = gt_extab[]
*         TABLES
*              t_outtab_header         = gt_header_main
*              t_outtab_item           = gt_item_main.

    CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
     EXPORTING
       i_callback_program             = g_repid
*       i_callback_pf_status_set       = g_user_command
       is_layout                      = gs_layout_main
       it_fieldcat                    = gt_fieldcat_main[]
       it_sort                        = gt_sort_main[]
       i_default                      = 'X'
       i_save                         = g_save
       is_variant                     = g_variant_main
       it_events                      = gt_events
       IT_EVENT_EXIT                  = gt_event_exit[]
      TABLES
        t_outtab                       = gt_item_main
     EXCEPTIONS
       program_error                  = 1
       OTHERS                         = 2
              .
    IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.


  ELSE.
    PERFORM end_of_list.
  ENDIF.

ENDFORM.                    "write_main_list

*---------------------------------------------------------------------*
*       FORM WRITE_POKEN_TAB                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM write_poken_tab.

  DESCRIBE TABLE gt_output_main-poken LINES sy-tabix.
  CHECK sy-tabix NE 0.

  DESCRIBE TABLE gt_output_main LINES sy-tabix.
  IF  p_edit IS INITIAL
  AND ( sy-batch = 'X' OR sy-tabix > 1 )
  AND p_verd = 'X'.
*   keine Postenliste/no items ==> no list of POKEN
    EXIT.
  ENDIF.

  gc_type_of_list = 'LE'.
  NEW-PAGE.
  IF p_edit IS INITIAL.
    gs_layout_append-no_hotspot = 'X'.
  ENDIF.
  FORMAT INTENSIFIED ON.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      i_callback_program = g_repid
      is_layout          = gs_layout_append
      it_fieldcat        = gt_fieldcat_poken
      it_events          = gt_events_leg
      is_print           = gs_print
    TABLES
      t_outtab           = gt_output_main-poken.

ENDFORM.                    "write_poken_tab

*---------------------------------------------------------------------*
*       FORM WRITE_SUM                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM write_sum TABLES p_outtab
               USING  p_fieldcat              TYPE slis_t_fieldcat_alv
                      p_sort                  TYPE slis_t_sortinfo_alv
                      p_variant               LIKE disvariant
                      p_listtype.

  DATA: lc_col_pos    LIKE gt_fieldcat_main-col_pos.

  DATA: pt_event_exit TYPE slis_t_event_exit WITH HEADER LINE.

* write only list with content * * * * * * * * * * * * * * * * * * * *
  PERFORM check_sumtable_is_empty TABLES   p_outtab
                                  CHANGING gx_is_empty.
  CHECK gx_is_empty IS INITIAL.

*---------------------- Feldkataloge modifizieren ---------------------
*-----------------------Modify field catalogues -----------------------
  CASE p_listtype.
    WHEN 'BA'.
*     mindestens eine lange Kontonummer / at least one long account no.
      IF fl_gs_bank_ubknt = 'X'.
        LOOP AT p_fieldcat INTO gt_fieldcat_main.
          CASE gt_fieldcat_main-fieldname.
            WHEN 'UBKNT'.
              gt_fieldcat_main-no_out = 'X'.
              lc_col_pos              = gt_fieldcat_main-col_pos.
              MODIFY p_fieldcat FROM gt_fieldcat_main.
            WHEN 'UBKNT_LONG'.
              gt_fieldcat_main-no_out  = space.
              gt_fieldcat_main-col_pos = lc_col_pos .
              MODIFY p_fieldcat FROM gt_fieldcat_main.
          ENDCASE.
        ENDLOOP.
      ENDIF.
    WHEN OTHERS.
  ENDCASE.
*----------------------------------------------------------------------


  REFRESH gt_extab[].
  IF p_edit IS INITIAL.
    PERFORM exclude_init  TABLES gt_extab[] USING : '&SUM',
                                                    '&ODN',
                                                    '&ILT',
                                                    '&OUP',
                                                    '&OAD',
                                                    '&AVE',
                                                    '&UMC',
                                                    '&OMP',
                                                    '&XPA',
                                                    '&ETA',
                                                    '&OPT',
                                                    '&OLX',
                                                    '&ERW',
                                                    '&KOM',
                                                    '&AUF',
                                                    '&ILD',
                                                    '&CDF',
                                                    '&ODF',
                                                    '&CFI',
                                                    '&DAU',
                                                    '&DON',
                                                    '&DOF',
                                                    '&IC1',
                                                    '&AVR',
                                                    '&MIN',
                                                    '&MAX',
                                                    '&XXL',
                                                    '&AQW',
                                                    '&ABC',
                                                    '&OL0',
                                                    '&LFO'.
  ENDIF.

  gc_type_of_list = p_listtype.
  NEW-PAGE.
  FORMAT INTENSIFIED ON.

  IF p_edit IS INITIAL.
    gs_layout_append-no_hotspot = 'X'.

    IF pri_params-linsz > 10.                         "/   note 1071860
      gs_layout_main-min_linesize = 10.
      gs_layout_main-max_linesize = pri_params-linsz.
*   ELSE.
*     gs_layout_main-min_linesize = 255.              "/ Reportstandard
    ENDIF.
    gs_print-no_change_print_params = p_noclsz.
    IF NOT g_print_params IS INITIAL.
      gs_print-print_ctrl-pri_params = pri_params.
      gs_print-print_ctrl-arc_params = arc_params.
    ENDIF.                                            "/   note 1071860
  ENDIF.

  REFRESH gt_event_exit[].
  IF p_edit IS INITIAL.
    pt_event_exit-ucomm = '&RNT'.
    pt_event_exit-after = 'X'.
    pt_event_exit-before = 'X'.
    APPEND pt_event_exit TO gt_event_exit.
  ENDIF.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      i_callback_program = g_repid
      is_layout          = gs_layout_append
      it_fieldcat        = p_fieldcat
      it_event_exit      = gt_event_exit[]
      it_sort            = p_sort
      i_save             = g_save
      is_variant         = p_variant
      it_events          = gt_events_leg
      is_print           = gs_print
      it_excluding       = gt_extab[]           "// HW 0369220
    TABLES
      t_outtab           = p_outtab.

ENDFORM.                    "write_sum

*---------------------------------------------------------------------*
*       FORM WRITE_SUM_LISTS                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM write_sum_lists.

  IF NOT p_asum IS INITIAL.
    PERFORM write_sum TABLES gt_output_main-area
                      USING  gt_fieldcat_area
                             gt_sort_area[]
                             g_variant_area
                             'AR'.
  ENDIF.
  IF NOT p_csum IS INITIAL.
    PERFORM write_sum TABLES gt_output_main-coun
                      USING  gt_fieldcat_coun
                             gt_sort_coun[]
                             g_variant_coun
                             'CO'.
  ENDIF.

  IF NOT p_wsum IS INITIAL.
    PERFORM write_sum TABLES gt_output_main-curr
                      USING  gt_fieldcat_curr
                             gt_sort_curr[]
                             g_variant_curr
                             'CU'.
  ENDIF.

  IF NOT p_msum IS INITIAL.
    PERFORM write_sum TABLES gt_output_main-meth
                      USING  gt_fieldcat_meth
                             gt_sort_meth[]
                             g_variant_meth
                             'ME'           .
  ENDIF.

  IF NOT p_bsum IS INITIAL.
    PERFORM write_sum TABLES gt_output_main-bank
                      USING  gt_fieldcat_bank
                             gt_sort_bank[]
                             g_variant_bank
                             'BA'.
  ENDIF.
ENDFORM.                    "write_sum_lists

*---------------------------------------------------------------------*
*       FORM WRITE_SUM_LISTS2                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM write_sum_lists2.

  LOOP AT gt_output_main INTO wagt_output_main.
    IF NOT p_asum IS INITIAL.
      APPEND LINES OF wagt_output_main-area TO gt_area2.
    ENDIF.
    IF NOT p_csum IS INITIAL.
      APPEND LINES OF wagt_output_main-coun TO gt_coun2.
    ENDIF.
    IF NOT p_wsum IS INITIAL.
      APPEND LINES OF wagt_output_main-curr TO gt_curr2.
    ENDIF.
    IF NOT p_msum IS INITIAL.
      APPEND LINES OF wagt_output_main-meth TO gt_meth2.
    ENDIF.
    IF NOT p_bsum IS INITIAL.
      APPEND LINES OF wagt_output_main-bank TO gt_bank2.
    ENDIF.
  ENDLOOP.

  CLEAR g_zbukr.
  IF NOT p_asum IS INITIAL.
    PERFORM write_sum TABLES gt_area2
                      USING  gt_fieldcat_area2
                             gt_sort_area2[]
                             g_variant_area2
                             'AR'.
  ENDIF.
  IF NOT p_csum IS INITIAL.
    PERFORM write_sum TABLES gt_coun2
                      USING  gt_fieldcat_coun2
                             gt_sort_coun2[]
                             g_variant_coun2
                             'CO'.
  ENDIF.

  IF NOT p_wsum IS INITIAL.
    PERFORM write_sum TABLES gt_curr2
                      USING  gt_fieldcat_curr2
                             gt_sort_curr2[]
                             g_variant_curr2
                             'CU'.
  ENDIF.

  IF NOT p_msum IS INITIAL.
    PERFORM write_sum TABLES gt_meth2
                      USING  gt_fieldcat_meth2
                             gt_sort_meth2[]
                             g_variant_meth2
                             'ME'           .
  ENDIF.

  IF NOT p_bsum IS INITIAL.
    PERFORM write_sum TABLES gt_bank2
                      USING  gt_fieldcat_bank2
                             gt_sort_bank2[]
                             g_variant_bank2
                             'BA'.
  ENDIF.
ENDFORM.                    "write_sum_lists2

*---------------------------------------------------------------------*
*       FORM PRINT_HEADING                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_INFO                                                        *
*  -->  P_LEN                                                         *
*  -->  P_ANZLIN                                                      *
*  -->  P_SHOWEMPTY                                                   *
*---------------------------------------------------------------------*
FORM print_heading USING p_info TYPE gs_adrs
                         p_len
                         p_anzlin LIKE p_madrz
                         p_showempty.

  DATA: li_outlen        TYPE i,
        li_outlen1       TYPE i,
        li_outlen2       TYPE i,
        li_outlen3       TYPE i,
        li_outlen4       TYPE i,
        li_temp          TYPE i,
        lc_text          LIKE p_info-bline0,
        lc_c1            TYPE c VALUE ' ',
        lc_text_017(20)  TYPE c,
        lc_text_018(20)  TYPE c,
        lc_text_019(20)  TYPE c,
        lc_text_061(20)  TYPE c,
        lc_text_062(20)  TYPE c.

  FIELD-SYMBOLS: <fs0>,
                 <fs1>,
                 <fs2>.
  DATA: li_adrslen TYPE i,
        li_pos1a TYPE i,
        li_pos1b TYPE i,
        li_pos2a TYPE i,
        li_pos2b TYPE i,
        li_pos3a TYPE i,
        li_pos3b TYPE i,
        li_pos4  TYPE i,
        li_len1  TYPE i,
        li_len2  TYPE i,
        li_len3  TYPE i,
        li_count TYPE i,
        li_round TYPE i,
        ln_reserve TYPE n.

  FIELD-SYMBOLS: <fst>, <fste>.

  ASSIGN p_info-sline1(g_adrlen) TO <fs0> RANGE p_info.
  ASSIGN p_info-eline1(g_adrlen) TO <fs1> RANGE p_info.
  ASSIGN p_info-bline1(g_adrlen) TO <fs2> RANGE p_info.

  IF p_len > 249.
    li_len1 = li_len2 = li_len3 = 79.
  ELSE.
    li_len1 = li_len2 = li_len3 = ( p_len - 2 ) / 3 - 3.
  ENDIF.

  li_pos1a = ( p_len - 1 ) MOD 3 .

  IF li_pos1a GE 1.
    li_len1 = li_len1 + 1.
    IF li_pos1a EQ 2.
      li_len2 = li_len2 + 1.
    ENDIF.
  ENDIF.

  li_pos1a = 1.
  li_pos1b = li_pos1a + 2.
  li_pos2a = li_pos1b + li_len1 + 1.
  li_pos2b = li_pos2a + 2.
  li_pos3a = li_pos2b + li_len2 + 1.
  li_pos3b = li_pos3a + 2.
  li_pos4  = li_pos3b + li_len3 + 1.

  li_count = li_round = 1.

  WHILE li_count LE p_anzlin AND li_round LE 9.             " HW 1164988

    CASE <fs2>(3).
      WHEN 'T17'.                 " Bankleitzahl
        lc_text = text-017.
        PERFORM output_length USING lc_text li_outlen4.
        IF li_outlen4 > li_outlen3.
          li_outlen3 = li_outlen4.
        ENDIF.
        lc_text = <fs2>+4.
        PERFORM output_length USING lc_text li_outlen2.
        IF li_outlen2 > li_outlen1.
          li_outlen1 = li_outlen2.
        ENDIF.
      WHEN 'T18'.                 " Kontonummer
        lc_text = text-018.
        PERFORM output_length USING lc_text li_outlen4.
        IF li_outlen4 > li_outlen3.
          li_outlen3 = li_outlen4.
        ENDIF.
        lc_text = <fs2>+4.
        PERFORM output_length USING lc_text li_outlen2.
        IF li_outlen2 > li_outlen1.
          li_outlen1 = li_outlen2.
        ENDIF.
      WHEN 'T19'.                 " SWIFT
        lc_text = text-019.
        PERFORM output_length USING lc_text li_outlen4.
        IF li_outlen4 > li_outlen3.
          li_outlen3 = li_outlen4.
        ENDIF.
        lc_text = <fs2>+4.
        PERFORM output_length USING lc_text li_outlen2.
        IF li_outlen2 > li_outlen1.
          li_outlen1 = li_outlen2.
        ENDIF.
      WHEN 'T61'.                 " Kontrollschl¨¹ssel
        lc_text = text-061.
        PERFORM output_length USING lc_text li_outlen4.
        IF li_outlen4 > li_outlen3.
          li_outlen3 = li_outlen4.
        ENDIF.
        lc_text = <fs2>+4.
        PERFORM output_length USING lc_text li_outlen2.
        IF li_outlen2 > li_outlen1.
          li_outlen1 = li_outlen2.
        ENDIF.
      WHEN 'T62'.                 " IBAN
        lc_text = text-062.
        PERFORM output_length USING lc_text li_outlen4.
        IF li_outlen4 > li_outlen3.
          li_outlen3 = li_outlen4.
        ENDIF.
        lc_text = <fs2>+4.
        PERFORM output_length USING lc_text li_outlen2.
        IF li_outlen2 > li_outlen1.
          li_outlen1 = li_outlen2.
        ENDIF.
    ENDCASE.

    ASSIGN <fs2>+g_adrlen TO <fs2> RANGE p_info.
    li_round = li_round + 1.
  ENDWHILE.

  li_outlen = li_outlen3 + li_outlen1 + 1.
  IF li_outlen < li_len3.
    lc_text_017 = text-017.
    lc_text_018 = text-018.
    lc_text_019 = text-019.
    lc_text_061 = text-061.
    li_outlen   = li_outlen3.
  ELSE.
    lc_text_017 = text-067.
    lc_text_018 = text-068.
    lc_text_019 = text-069.
    lc_text_061 = text-065.
    li_outlen   = 6.
  ENDIF.
  lc_text_062 = text-062.

  ASSIGN lc_text+li_len3(2) TO <fst>.
  li_count = li_len3 - 1.
  ASSIGN lc_text+li_count(1) TO <fste>.

  ASSIGN p_info-bline1(g_adrlen) TO <fs2> RANGE p_info.
  li_count = li_round = 1.

  WHILE li_count LE p_anzlin AND li_round LE 9.

    CASE <fs2>(3).
      WHEN 'TB1'.                 " Bankname + Zweigstelle der Bank
        lc_text = <fs2>+4.
        sy-tfill = 1 + STRLEN( lc_text ).
        lc_text+sy-tfill = p_info-blinea.
        IF <fst> > space.
          <fste> = '>'.
        ENDIF.
        <fs2> = lc_text.
      WHEN 'T17'.                 " Bankleitzahl
        CONCATENATE lc_text_017(li_outlen) lc_c1 <fs2>+4
          INTO lc_text
          IN CHARACTER MODE
          RESPECTING BLANKS.
        IF <fst> > space.
          <fste> = '>'.
        ENDIF.
        <fs2> = lc_text.
      WHEN 'T18'.                 " Kontonummer
        CONCATENATE lc_text_018(li_outlen) lc_c1 <fs2>+4
          INTO lc_text
          IN CHARACTER MODE
          RESPECTING BLANKS.
        IF <fst> > space.
          <fste> = '>'.
        ENDIF.
        <fs2> = lc_text.
      WHEN 'T19'.                 " SWIFT
        CONCATENATE lc_text_019(li_outlen) lc_c1 <fs2>+4
          INTO lc_text
          IN CHARACTER MODE
          RESPECTING BLANKS.
        IF <fst> > space.
          <fste> = '>'.
        ENDIF.
        <fs2> = lc_text.
      WHEN 'T61'.                 " Kontrollschl¨¹ssel
        CONCATENATE lc_text_061(li_outlen) lc_c1 <fs2>+4
          INTO lc_text
          IN CHARACTER MODE
          RESPECTING BLANKS.
        <fs2> = lc_text.
      WHEN 'T62'.                 " IBAN
        CONCATENATE lc_text_062(li_outlen) lc_c1 <fs2>+4
          INTO lc_text
          IN CHARACTER MODE
          RESPECTING BLANKS.
        IF <fst> > space.
          <fste> = '>'.
        ENDIF.
        <fs2> = lc_text.
    ENDCASE.

    ASSIGN <fs2>+g_adrlen TO <fs2> RANGE p_info.
    li_round = li_round + 1.
  ENDWHILE.                                                 " HW 1164988

  ASSIGN p_info-bline1(g_adrlen) TO <fs2> RANGE p_info.
  li_count = li_round = 1.

  NEW-LINE.
* Reserve lines, so the adressblock wont be divided
  CLEAR ln_reserve.
  ln_reserve = p_madrz + 4.
  RESERVE ln_reserve LINES.
  WRITE AT 1(p_len) sy-uline.
  FORMAT INTENSIFIED OFF.

  IF NOT p_info-sline0 IS INITIAL.
    PERFORM output_length USING p_info-sline0 sy-fdpos.
    IF sy-fdpos > li_len1.
      sy-fdpos = li_len1.
    ENDIF.
    WRITE AT  li_pos1b(sy-fdpos) p_info-sline0.
  ENDIF.
  IF NOT p_info-eline0 IS INITIAL.
    PERFORM output_length USING p_info-eline0 sy-fdpos.
    IF sy-fdpos > li_len2.
      sy-fdpos = li_len2.
    ENDIF.
    WRITE AT li_pos2b(sy-fdpos) p_info-eline0.
  ENDIF.
  IF NOT p_info-bline0 IS INITIAL.
    PERFORM output_length USING p_info-bline0 sy-fdpos.
    IF sy-fdpos > li_len2.
      sy-fdpos = li_len2.
    ENDIF.
    WRITE AT  li_pos3b(sy-fdpos) p_info-bline0.
  ENDIF.

  FORMAT INTENSIFIED ON.
  WHILE li_count LE p_anzlin AND li_round LE 9.

    IF NOT p_showempty IS INITIAL   OR
       NOT ( <fs0> IS INITIAL AND
             <fs1> IS INITIAL AND
             <fs2> IS INITIAL ).
      NEW-LINE.
      WRITE AT: li_pos1a '|',
                li_pos1b(li_len1) <fs0>,
                li_pos2a '|',
                li_pos2b(li_len2) <fs1>,
                li_pos3a '|',
                li_pos3b(li_len3) <fs2>,
                li_pos4  '|'.
      li_count = li_count + 1.
    ENDIF.

    ASSIGN <fs0>+g_adrlen TO <fs0> RANGE p_info.
    ASSIGN <fs1>+g_adrlen TO <fs1> RANGE p_info.
    ASSIGN <fs2>+g_adrlen TO <fs2> RANGE p_info.
    li_round = li_round + 1.
  ENDWHILE.
  FORMAT INTENSIFIED OFF.
  IF p_anzlin GT 0.
    NEW-LINE.
    WRITE AT 1(p_len) sy-uline.
  ENDIF.

  IF p_info-cline0 NE space.                                " HW 842128
    IF p_anzlin EQ 0.
      NEW-LINE.
      WRITE AT 1(p_len) sy-uline.
    ENDIF.
    IF NOT p_info-cline0 IS INITIAL.
      PERFORM output_length USING p_info-cline0 sy-fdpos.
      IF sy-fdpos > li_len2.
        sy-fdpos = li_len2.
      ENDIF.
      WRITE AT  li_pos3b(sy-fdpos) p_info-cline0.
    ENDIF.
    FORMAT INTENSIFIED ON.
    ASSIGN p_info-cline1 TO <fs2>.
    WHILE  <fs2>+0(10) NE space.
      IF <fs2>+0(1) = 'N'.
        ASSIGN <fs2>+li_len3(1) TO <fst>.
        IF <fst> > space.
          li_temp = li_len3 - 1.
          ASSIGN <fs2>+li_temp(1) TO <fst>.
          <fst>      = '>'.
        ENDIF.
        <fs2>+0(1) = space.
      ENDIF.
      NEW-LINE.
      WRITE AT: li_pos1a '|',
                li_pos2a '|',
                li_pos3a '|',
                li_pos3b(li_len3) <fs2>,
                li_pos4  '|'.
      ASSIGN <fs2>+g_adrlen TO <fs2> RANGE p_info.
    ENDWHILE.
    NEW-LINE.
    WRITE AT 1(p_len) sy-uline.
  ENDIF.

ENDFORM.                    "print_heading

*---------------------------------------------------------------------*
*       FORM APPEND_TO_RANGE                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  PT_RANGE                                                      *
*  -->  VALUE(P_FIELDNAME)                                            *
*---------------------------------------------------------------------*
FORM append_to_range TABLES pt_range STRUCTURE gr_fieldname
                     USING  value(p_fieldname).

  CLEAR pt_range.
  pt_range-sign = 'I'.
  pt_range-option = 'EQ'.
  pt_range-low = p_fieldname.
  APPEND pt_range.


ENDFORM.                               " APPEND_TO_RANGE

*&---------------------------------------------------------------------*
*&      Form  WRITE_ADRS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_RS_LINEINFO  text                                          *
*----------------------------------------------------------------------*
FORM write_adrs USING rs_lineinfo TYPE slis_lineinfo.


  FORMAT COLOR COL_BACKGROUND INTENSIFIED ON.
  IF gs_lastadrskey  EQ gt_header_main-adrs_key AND
     gx_firstadrsout EQ 'X'.
    EXIT.
  ENDIF.

  gs_lastadrskey = gt_header_main-adrs_key.

  READ TABLE gt_adrs2pf WITH KEY key = gt_header_main-adrs_key.

  CHECK gt_adrs2pf-noadrs NE 'X' OR
        gt_adrs2pf-noabw  NE 'X' OR
        gt_adrs2pf-nobank NE 'X' .

  PERFORM print_heading USING gt_adrs2pf-adrs
                              rs_lineinfo-linsz
                              p_madrz
                              space.

  gx_firstadrsout = 'X'.

ENDFORM.                               " WRITE_ADRS
*&---------------------------------------------------------------------*
*&      Form  CHECK_FOR_ENTRIES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_GT_HEADER  text
*      <--P_GX_ENTRIES  text
*----------------------------------------------------------------------*
FORM check_for_entries USING pt_output_main STRUCTURE gt_output_main
                       CHANGING px_entries.
  IF NOT ( p_regul IS INITIAL AND p_ausna IS INITIAL ).
    DESCRIBE TABLE pt_output_main-header LINES sy-tabix.
  ELSEIF NOT p_asum IS INITIAL.
    DESCRIBE TABLE pt_output_main-area LINES sy-tabix.
  ELSEIF NOT p_csum IS INITIAL.
    DESCRIBE TABLE pt_output_main-coun LINES sy-tabix.
  ELSEIF NOT p_wsum IS INITIAL.
    DESCRIBE TABLE pt_output_main-curr LINES sy-tabix.
  ELSEIF NOT p_msum IS INITIAL.
    DESCRIBE TABLE pt_output_main-meth LINES sy-tabix.
  ELSEIF NOT p_bsum IS INITIAL.
    DESCRIBE TABLE pt_output_main-bank LINES sy-tabix.
  ELSE.
    CLEAR sy-tabix.
  ENDIF.
  IF sy-tabix GT 0.
    px_entries = 'X'.
  ELSE.
    CLEAR px_entries.
  ENDIF.
ENDFORM.                               " CHECK_FOR_ENTRIES
*---------------------------------------------------------------------*
*       FORM CHECK_ADRESSES                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM check_adresses  .

* test, if the first adress is empty (HR)
  IF gt_header_main-name1 EQ space.
* copy alternate payee to vendor
    gt_header_main-name1 = gt_header_main-znme1.
    gt_header_main-name2 = gt_header_main-znme2.
    gt_header_main-stras = gt_header_main-zstra.
    gt_header_main-pfach = gt_header_main-zpfac.
    gt_header_main-pfort = gt_header_main-zpfor.
    gt_header_main-pstl2 = gt_header_main-zpst2.
    gt_header_main-land1 = gt_header_main-zland.
    gt_header_main-pstlz = gt_header_main-zpstl.
    gt_header_main-ort01 = gt_header_main-zort1.
    gt_header_main-regio = gt_header_main-zregi.
  ENDIF.

* Konto-Owner initial, no Check
  IF gt_header_main-koinh IS INITIAL
     AND NOT ( gt_header_main-zbnky IS INITIAL ).
* put name of alternate payee in 'koinh'
    gt_header_main-koinh = gt_header_main-znme1.
  ENDIF.

* same vendor and alternate payee  ?
  IF gt_header_main-name1 EQ gt_header_main-znme1 AND
     gt_header_main-name2 EQ gt_header_main-znme2 AND
     gt_header_main-stras EQ gt_header_main-zstra AND
     gt_header_main-pfach EQ gt_header_main-zpfac AND
     gt_header_main-pstl2 EQ gt_header_main-zpst2 AND
     gt_header_main-land1 EQ gt_header_main-zland AND
     gt_header_main-pstlz EQ gt_header_main-zpstl AND
     gt_header_main-ort01 EQ gt_header_main-zort1 AND
     gt_header_main-regio EQ gt_header_main-zregi AND
     reguh-adrnr EQ reguh-zadnr.

* delete alternate payee
    gt_header_main-znme1 = space.
    gt_header_main-znme2 = space.
    gt_header_main-zstra = space.
    gt_header_main-zpfac = space.
    gt_header_main-zpst2 = space.
    gt_header_main-zland = space.
    gt_header_main-zpstl = space.
    gt_header_main-zort1 = space.
    gt_header_main-zregi = space.
    gt_header_main-pfort = gt_header_main-zpfor.
    gt_header_main-zpfor = space.
  ENDIF.


ENDFORM.                               " CHECK_ADRESSES
*&---------------------------------------------------------------------*
*&      Form  CHECK_SUMTABLE_IS_EMPTY
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM check_sumtable_is_empty TABLES l_outtab
                             CHANGING is_empty.

* when list to ouput is empty, dont show it
* for example the sum-lists of exceptions

  is_empty = space.
  CHECK p_edit IS INITIAL.
  DESCRIBE TABLE l_outtab LINES sy-tfill.     "list is empty ?
  IF sy-tfill = 0.
    is_empty = 'X'.                    "give back flag when empty
  ENDIF.

ENDFORM.                               " CHECK_SUMTABLE_IS_EMPTY
*&---------------------------------------------------------------------*
*&      Form  CHECK_SORTORDERB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM check_sortorderb.

  CALL FUNCTION 'REUSE_ALV_LIST_LAYOUT_INFO_GET'
    IMPORTING
      et_sort       = gt_sort_main[]
    EXCEPTIONS
      no_infos      = 1
      program_error = 2
      OTHERS        = 3.
  IF sy-subrc NE 0.
    EXIT.
  ENDIF.

  READ TABLE gt_sort_main WITH KEY fieldname = 'ZBUKR'
                                   tabname   = g_tabname_header .
  IF sy-subrc NE 0.
    CLEAR gt_sort_main.
  ENDIF.


  IF NOT gt_sort_main-spos = 1.   "company code already first criteria ?
    SORT gt_sort_main BY spos.
    IF sy-subrc = 0 .             "delete cc when not on first position
      DELETE gt_sort_main WHERE fieldname EQ 'ZBUKR'
                          AND   tabname   EQ g_tabname_header.
    ENDIF.
    gt_sort_main-fieldname = 'ZBUKR'.  "insert company code
    gt_sort_main-tabname   =  g_tabname_header .   "at top of the int.
    gt_sort_main-up        = 'X'.      "sort table
    gt_sort_main-group =   '*'.        "new page when cc changes
    INSERT gt_sort_main INDEX 1.

    LOOP AT gt_sort_main.
      gt_sort_main-spos = sy-tabix.
      MODIFY gt_sort_main.
    ENDLOOP.

    MESSAGE s481. "Company code is first sort criteria
  ENDIF.

  READ TABLE gt_sort_main WITH KEY fieldname = 'BUSAB'
                                   tabname   = g_tabname_header .
  IF sy-subrc EQ 0.
    gt_sort_main-group =   '*'.         "new page when accountant
    MODIFY gt_sort_main INDEX sy-tabix. "changes
  ENDIF.

  CALL FUNCTION 'REUSE_ALV_LIST_LAYOUT_INFO_SET'
    EXPORTING
      it_sort = gt_sort_main[].


ENDFORM.                               " CHECK_SORTORDERB
*&---------------------------------------------------------------------*
*&      Form  BERECHTIGUNG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM berechtigung.

  DATA lt_fimsg LIKE TABLE OF fimsg WITH HEADER LINE.
* Lese Fehlertabelle aus LD und konvertiere in FIMSG Format
* Read error table and convert into FIMSG format
  CALL FUNCTION 'FI_PYF_AUTHORITY_OUTPUT'
    TABLES
      t_fimsg    = lt_fimsg
      t_err_auth = gt_err_auth.
  LOOP AT lt_fimsg.
    MESSAGE ID lt_fimsg-msgid TYPE lt_fimsg-msgty NUMBER lt_fimsg-msgno
      WITH lt_fimsg-msgv1 lt_fimsg-msgv2 lt_fimsg-msgv3 lt_fimsg-msgv4.
  ENDLOOP.

  IF flg_pernr_err = 'X'.
    IF sy-batch = space.
      MESSAGE i675(fs).
    ELSE.
      MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.

ENDFORM.                               " BERECHTIGUNG
*&---------------------------------------------------------------------*
*&      Form  SORT_SUM_DETAILS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sort_sum_details TABLES it_sort_table
                      USING  name1
                             name2
                             name3
                             name4.

  DATA lt_sort_table LIKE gt_sort_area.

  lt_sort_table-fieldname = name1.
  lt_sort_table-up = 'X'.
  lt_sort_table-spos = '1'.
  lt_sort_table-subtot = ''.
  APPEND lt_sort_table TO it_sort_table.

  CLEAR lt_sort_table.
  lt_sort_table-fieldname = name2.
  lt_sort_table-up = 'X'.
  lt_sort_table-spos = '2'.
  lt_sort_table-subtot = 'X'.
  APPEND lt_sort_table TO it_sort_table.

  CLEAR lt_sort_table.
  lt_sort_table-fieldname = name3.
  lt_sort_table-up = 'X'.
  lt_sort_table-spos = '3'.
  lt_sort_table-subtot = ''.
  APPEND lt_sort_table TO it_sort_table.

  CHECK name4 NE space.
  CLEAR lt_sort_table.
  lt_sort_table-fieldname = name4.
  lt_sort_table-up = 'X'.
  lt_sort_table-spos = '4'.
  lt_sort_table-subtot = ''.
  APPEND lt_sort_table TO it_sort_table.

ENDFORM.                               " SORT_SUM_DETAILS

*&---------------------------------------------------------------------*
*&      Form  SORT_SUM_CURR_AND_BANK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM sort_sum_curr_and_bank.

* Fieldcat of the currency sumlist
  gt_sort_curr-fieldname  = 'WAERS'.
  gt_sort_curr-spos       = '1'.
  gt_sort_curr-subtot     = 'X'.
  gt_sort_curr-up         = 'X'.
  APPEND gt_sort_curr.

  CLEAR gt_sort_curr.
  gt_sort_curr-fieldname  = 'ZLAND'.
  gt_sort_curr-spos       = '2'.
  gt_sort_curr-subtot     = 'X'.
  gt_sort_curr-up         = 'X'.
  APPEND gt_sort_curr.

  CLEAR gt_sort_curr.
  gt_sort_curr-fieldname  = 'RZAWE'.
  gt_sort_curr-spos       = '3'.
  gt_sort_curr-subtot     = ''.
  gt_sort_curr-up         = 'X'.
  APPEND gt_sort_curr.

* Fieldcat of the bank sumlist
  gt_sort_bank-fieldname  = 'UBNKS'.
  gt_sort_bank-spos       = '1'.
  gt_sort_bank-subtot     = space.
  gt_sort_bank-up         = 'X'.
  APPEND gt_sort_bank .

  CLEAR gt_sort_bank.
  gt_sort_bank-fieldname  = 'UBNKY'.
  gt_sort_bank-spos       = '2'.
  gt_sort_bank-subtot     = space.
  gt_sort_bank-up         = 'X'.
  APPEND gt_sort_bank .

  CLEAR gt_sort_bank.
  gt_sort_bank-fieldname  = 'UBANK'.
  gt_sort_bank-spos       = '4'.
  gt_sort_bank-subtot     = 'X'.
  gt_sort_bank-up         = 'X'.
  APPEND gt_sort_bank .

  CLEAR gt_sort_bank.
  gt_sort_bank-fieldname  = 'UBKNT'.
  gt_sort_bank-spos       = '3'.
  gt_sort_bank-subtot     = space.
  gt_sort_bank-up         = 'X'.
  APPEND gt_sort_bank .

  CLEAR gt_sort_bank.
  gt_sort_bank-fieldname  = 'UBKON'.
  gt_sort_bank-spos       = '5'.
  gt_sort_bank-subtot     = space.
  gt_sort_bank-up         = 'X'.
  APPEND gt_sort_bank .

  CLEAR gt_sort_bank.
  gt_sort_bank-fieldname  = 'WAERS'.
  gt_sort_bank-spos       = '6'.
  gt_sort_bank-subtot     = space.
  gt_sort_bank-up         = 'X'.
  APPEND gt_sort_bank .


ENDFORM.                               " SORT_SUM_CURR_AND_BANK

*&---------------------------------------------------------------------*
*&      Form  MODIFY_FIELDCAT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_PT_FIELDCAT_AREA  text
*----------------------------------------------------------------------*
FORM modify_fieldcat TABLES   it_fieldcat_space LIKE gt_fieldcat_area.

  LOOP AT it_fieldcat_space WHERE fieldname = 'RZAWE'.
    it_fieldcat_space-outputlen      = 20.
    it_fieldcat_space-ddic_outputlen = 20.
    MODIFY it_fieldcat_space.
  ENDLOOP.

ENDFORM.                               " MODIFY_FIELDCAT

*&---------------------------------------------------------------------*
*&      Form  MODIFY_DDTEXT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM modify_ddtext TABLES pt_fieldcat_space LIKE gt_fieldcat_area
                   USING name1 name2.


  DATA lt_fieldcat LIKE pt_fieldcat_space.

  IF name1 NE space.
    READ TABLE pt_fieldcat_space INTO lt_fieldcat
                    WITH KEY fieldname = name1.
    MODIFY pt_fieldcat_space FROM lt_fieldcat
                             TRANSPORTING seltext_l
                                          seltext_m
                                          seltext_s
                                          reptext_ddic
                             WHERE fieldname = name2.
  ENDIF.

  READ TABLE pt_fieldcat_space INTO lt_fieldcat
                  WITH KEY fieldname = 'RZAWE'.
  IF sy-subrc = 0.
    MODIFY pt_fieldcat_space FROM lt_fieldcat
                           TRANSPORTING seltext_l
                                        seltext_m
                                        seltext_s
                                        reptext_ddic
                           WHERE fieldname = 'TEXT1'.
  ENDIF.

ENDFORM.                               " MODIFY_DDTEXT


*&---------------------------------------------------------------------*
*&      Form  SWITCH_TO_MAINTENANCE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM switch_to_maintenance.

  SUBMIT (sy-repid)
          WITH p_asum   = p_asum
          WITH p_ausna  = p_ausna
          WITH p_bsum   = p_bsum
          WITH p_csum   = p_csum
          WITH p_edit   = 'X'
          WITH p_f110   = p_f110
          WITH p_madrz  = p_madrz
          WITH p_msum   = p_msum
          WITH p_param  = p_param
          WITH p_regul  = p_regul
          WITH p_title2 = p_title2
          WITH p_varar  = p_varar
          WITH p_varar2 = p_varar2
          WITH p_varba  = p_varba
          WITH p_varba2 = p_varba2
          WITH p_varco  = p_varco
          WITH p_varco2 = p_varco2
          WITH p_varcu  = p_varcu
          WITH p_varcu2 = p_varcu2
          WITH p_vari   = p_vari
          WITH p_varme  = p_varme
          WITH p_varme2 = p_varme2
          WITH p_verd   = p_verd
          WITH p_wsum   = p_wsum
          WITH p_witht  = p_witht
          WITH s_dkonto IN s_dkonto
          WITH s_hausb  IN s_hausb
          WITH s_kkonto IN s_kkonto
          WITH s_pokekz IN s_pokekz
          WITH s_sachb  IN s_sachb
          WITH s_zahlw  IN s_zahlw
          WITH s_zgsber IN s_zgsber
          WITH s_zlspr  IN s_zlspr
          WITH s_zusatz IN s_zusatz
          WITH zw_absbu IN zw_absbu
          WITH zw_alesl = zw_alesl
          WITH zw_edisl = zw_edisl
          WITH zw_laufd = zw_laufd
          WITH zw_laufi = zw_laufi
          WITH zw_xvorl = zw_xvorl
          WITH zw_zbukr IN zw_zbukr
          AND RETURN.

ENDFORM.                               " SWITCH_TO_MAINTENANCE

*&---------------------------------------------------------------------*
*&      Form  WRITE_WT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_RS_LINEINFO  text
*----------------------------------------------------------------------*
FORM write_wt USING is_lineinfo TYPE slis_lineinfo.

  DATA ln_edit TYPE n.

  CHECK gt_item_main-poken IS INITIAL.

* move the output stuff 2 fields right if we are in maintenance mode
  IF p_edit IS INITIAL.
    ln_edit = 3.
  ELSE.
    ln_edit = 5.
  ENDIF.

  IF NOT is_lineinfo-tabindex IS INITIAL.
*   display deductions for item
    PERFORM determine_wt.


    READ TABLE gt_wt_item INDEX 1.
    IF sy-subrc EQ 0.

*     Skonto
      NEW-LINE.
      WRITE: sy-vline.
      WRITE AT is_lineinfo-linsz sy-vline.
      NEW-LINE.
      WRITE: sy-vline.
      WRITE AT ln_edit text-060.
      WRITE AT (gn_wabzg_width) gt_item_main-wskto
                                       UNDER gt_item_main-wabzg
                                    CURRENCY gt_item_main-waers.
      WRITE AT is_lineinfo-linsz sy-vline.

*     Withholding tax items
      LOOP AT gt_wt_item.
        NEW-LINE.
        WRITE sy-vline.

        WRITE AT ln_edit gt_wt_item-witht.
        WRITE            gt_wt_item-text40.

        WRITE AT (gn_wabzg_width) gt_wt_item-wt_qbshb
                                          UNDER gt_item_main-wabzg
                                       CURRENCY gt_item_main-waers.
        WRITE AT is_lineinfo-linsz sy-vline.
      ENDLOOP.

    ENDIF.
  ELSE.
*   display deductions for sum
    READ TABLE gt_wt_pay INDEX 1.
    IF sy-subrc EQ 0.

*     Skonto
      NEW-LINE.
      WRITE: sy-vline.
      WRITE AT is_lineinfo-linsz sy-vline.
      NEW-LINE.
      WRITE: sy-vline.
      WRITE AT ln_edit text-060.
      WRITE AT (gn_wabzg_width) gt_header_main-rwskt
                                         UNDER gt_item_main-wabzg
                                      CURRENCY gt_header_main-waers.

      WRITE AT is_lineinfo-linsz sy-vline.

*     Withholding tax items
      LOOP AT gt_wt_pay.
        NEW-LINE.
        WRITE sy-vline.

        WRITE AT ln_edit gt_wt_pay-witht.
        WRITE            gt_wt_pay-text40.

        WRITE AT (gn_wabzg_width) gt_wt_pay-wt_qbshb
                                         UNDER gt_item_main-wabzg
                                      CURRENCY gt_header_main-waers.

        WRITE AT is_lineinfo-linsz sy-vline.

      ENDLOOP.

    ENDIF.
    REFRESH gt_wt_pay.
  ENDIF.

  REFRESH gt_wt_item.

ENDFORM.                               " WRITE_WT

*&---------------------------------------------------------------------*
*&      Form  GET_WT_POSITION
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_wt_position.

* determine where to print the withholding tax information
  DATA: lt_fieldcat TYPE slis_t_fieldcat_alv,
        ls_fieldcat TYPE slis_fieldcat_alv.

  CLEAR gn_wabzg_width.

* get the fieldcat
  CALL FUNCTION 'REUSE_ALV_LIST_LAYOUT_INFO_GET'
    IMPORTING
      et_fieldcat = lt_fieldcat.

  READ TABLE lt_fieldcat INTO ls_fieldcat
                             WITH KEY tabname   = g_tabname_item
                                      fieldname = 'WABZG'.

  IF sy-subrc EQ 0 AND ls_fieldcat-no_out IS INITIAL.
    gn_wabzg_width = ls_fieldcat-outputlen.
  ELSE.
    CLEAR gn_wabzg_width.
  ENDIF.


ENDFORM.                               " GET_WT_POSITION

*&---------------------------------------------------------------------*
*&      Form  DETERMINE_WT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM determine_wt.

  DATA: lt_t059z  LIKE t059z OCCURS 1 WITH HEADER LINE,
        lt_t059u  LIKE t059u OCCURS 1 WITH HEADER LINE,
        ls_regupw LIKE regupw.

  CLEAR: gt_wt_item[],
         gt_wt_pay.

*--------------------- read extended withholding tax info from proposal
  SELECT * FROM regupw INTO ls_regupw
                       WHERE laufd      EQ zw_laufd
                       AND   laufi      EQ zw_laufi
                       AND   bukrs      EQ gt_item_main-bukrs
                       AND   belnr      EQ gt_item_main-belnr
                       AND   gjahr      EQ gt_item_main-gjahr
                       AND   buzei      EQ gt_item_main-buzei
                       AND   wt_withcd  NE space
                       AND   wt_stat    EQ space
                       AND   wt_qbshb   NE 0.

    CALL FUNCTION 'FI_WT_READ_T059Z'
      EXPORTING
        i_bukrs     = gt_item_main-bukrs
        i_type      = ls_regupw-witht
        i_wt_withcd = ls_regupw-wt_withcd
      TABLES
        t_t059z     = lt_t059z
      EXCEPTIONS
        not_found   = 1
        OTHERS      = 2.

    IF sy-subrc NE 0.
      REFRESH lt_t059z.
    ENDIF.

    IF lt_t059z-wt_posin = '1'.        "withholding tax standard posting

      CALL FUNCTION 'FI_WT_READ_T059U'
        EXPORTING
          i_bukrs   = gt_item_main-bukrs
          i_type    = ls_regupw-witht
        TABLES
          t_t059u   = lt_t059u
        EXCEPTIONS
          not_found = 1
          OTHERS    = 2.
      IF sy-subrc NE 0.
        REFRESH lt_t059u.
      ENDIF.

      MOVE-CORRESPONDING lt_t059u  TO gt_wt_item.
      MOVE-CORRESPONDING ls_regupw TO gt_wt_item.
      APPEND gt_wt_item.

      MOVE-CORRESPONDING lt_t059u  TO gt_wt_pay.
      MOVE-CORRESPONDING ls_regupw TO gt_wt_pay.
      COLLECT gt_wt_pay.

    ENDIF.

  ENDSELECT.

ENDFORM.                               " DETERMINE_WT
*&---------------------------------------------------------------------*
*&      Form  read_busab
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_T042_ABSBU  text
*      <--P_GT_REGUH_BUSAB  text
*----------------------------------------------------------------------*
FORM read_busab USING    ic_absbu
                         ic_laufi
                CHANGING ct_reguh STRUCTURE reguh_lst.


  STATICS: st_lfb1 LIKE TABLE OF lfb1 WITH HEADER LINE,
           st_knb1 LIKE TABLE OF knb1 WITH HEADER LINE.

  IF NOT ct_reguh-kunnr IS INITIAL.
    IF st_knb1-kunnr NE ct_reguh-kunnr.
      REFRESH st_knb1.
    ENDIF.
    READ TABLE st_knb1 WITH KEY kunnr = ct_reguh-kunnr
                                bukrs = ic_absbu.
    IF sy-subrc NE 0.
      SELECT SINGLE * FROM knb1 INTO st_knb1
                         WHERE kunnr EQ ct_reguh-kunnr
                         AND   bukrs EQ ic_absbu.
      APPEND st_knb1.
    ENDIF.
    ct_reguh-busab = st_knb1-busab.
  ELSEIF NOT ct_reguh-lifnr IS INITIAL AND ic_laufi+5(1) NE 'P'
                                       AND ic_laufi+5(1) NE 'J'.
    IF st_lfb1-lifnr NE ct_reguh-lifnr.
      REFRESH st_lfb1.
    ENDIF.
    READ TABLE st_lfb1 WITH KEY lifnr = ct_reguh-lifnr
                                bukrs = ic_absbu.
    IF sy-subrc NE 0.
      SELECT SINGLE * FROM lfb1 INTO st_lfb1
                         WHERE lifnr EQ ct_reguh-lifnr
                         AND   bukrs EQ ic_absbu.
      APPEND st_lfb1.
    ENDIF.
    ct_reguh-busab = st_lfb1-busab.
  ELSE.
    CLEAR ct_reguh-busab.
  ENDIF.

ENDFORM.                    " read_busab
*&---------------------------------------------------------------------*
*&      Form  company_account_auth
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM company_account_auth.

  DATA: l_fbtch(2) TYPE n.

  IF reguh-laufi+5(1) NE 'P'.                "Pr¨¹fung f¨¹r FI-Best#nde
*   only proposal ?
    IF reguh-xvorl EQ space.            "checks for FI-data
      l_fbtch = 23.
    ELSE.
      l_fbtch = 13.
    ENDIF.

    AUTHORITY-CHECK OBJECT 'F_REGU_BUK'      "checks for FI-data
      ID 'BUKRS' FIELD reguh-zbukr
      ID 'FBTCH' FIELD l_fbtch.
    IF sy-subrc NE 0.
      gt_err_auth-autob = 'F_REGU_BUK'.
      gt_err_auth-field = 'BUKRS'.
      gt_err_auth-value = reguh-zbukr.
      gt_err_auth-actvt = l_fbtch.
      COLLECT gt_err_auth.
      REJECT.
    ENDIF.

    CLEAR gt_err_auth.
    gt_err_auth-autob = 'F_REGU_KOA'.
    gt_err_auth-field = 'KOART'.
    gt_err_auth-value = space.
    gt_err_auth-actvt = l_fbtch.
    IF reguh-lifnr IS INITIAL  AND reguh-kunnr IS INITIAL.
      AUTHORITY-CHECK OBJECT 'F_REGU_KOA'
        ID 'KOART' FIELD 'S'
        ID 'FBTCH' FIELD l_fbtch.
      IF sy-subrc NE 0.
        gt_err_auth-value = 'S'.
        COLLECT gt_err_auth.
        REJECT.
      ENDIF.
    ELSE.
      IF NOT reguh-lifnr IS INITIAL.
        AUTHORITY-CHECK OBJECT 'F_REGU_KOA'
          ID 'KOART' FIELD 'K'
          ID 'FBTCH' FIELD l_fbtch.
        IF sy-subrc NE 0.
          gt_err_auth-value = 'K'.
          COLLECT gt_err_auth.
          REJECT.
        ENDIF.
      ENDIF.
      IF NOT reguh-kunnr IS INITIAL.
        AUTHORITY-CHECK OBJECT 'F_REGU_KOA'
          ID 'KOART' FIELD 'D'
          ID 'FBTCH' FIELD l_fbtch.
        IF sy-subrc NE 0.
          gt_err_auth-value = 'D'.
          COLLECT gt_err_auth.
          REJECT.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    " company_account_auth
*&---------------------------------------------------------------------*
*&      Form  fill_business_area
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM fill_business_area.

  DATA l_factor TYPE f.

  PERFORM read_t042b USING gt_regup_lst-zbukr.

  IF NOT t042b-xkdfb IS INITIAL.
    gs_area-rbetr  = gt_regup_lst-netto.
    gs_area-rskon  = gt_regup_lst-sknto.
    gs_area-qsteu  = gt_regup_lst-qsteu.
    gs_area-abzug  = gt_regup_lst-abzug.
    gs_area-brutt  = gt_regup_lst-dmbtr.
    gs_area-netto  = gt_regup_lst-netto.
  ELSE.
    l_factor = ( gt_reguh_lst-rbetr / gt_reguh_lst-rwbtr ).
    gs_area-rbetr  = l_factor * gt_regup_lst-wnett.
    gs_area-rskon  = l_factor * gt_regup_lst-wskto.
    gs_area-qsteu  = l_factor * gt_regup_lst-wqste.
    gs_area-abzug  = l_factor * gt_regup_lst-wabzg.
    gs_area-brutt  = l_factor * gt_regup_lst-wrbtr.
    gs_area-netto  = l_factor * gt_regup_lst-wnett.
  ENDIF.

  gs_area-zbukr  = gt_reguh_lst-zbukr.
  gs_area-srtgb  = gt_regup_lst-gsber.
  gs_area-gtext  = tgsbt-gtext.
  gs_area-rzawe  = gt_reguh_lst-rzawe.
  gs_area-text1  = gt_reguh_lst-rzawx.
  gs_area-waers  = gt_reguh_lst-waers.
  gs_area-hwaer  = t001-waers.

  gs_area-rwbtr  = gt_regup_lst-wnett.
  gs_area-rwskt  = gt_regup_lst-wskto.
  gs_area-wqste  = gt_regup_lst-wqste.
  gs_area-wabzg  = gt_regup_lst-wabzg.
  gs_area-wbrut  = gt_regup_lst-wrbtr.
  gs_area-wnett  = gt_regup_lst-wnett.


  COLLECT gs_area INTO gt_output_main-area.

ENDFORM.                    " fill_business_area
*---------------------------------------------------------------------*
*       FORM END_OF_LIST2                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM end_of_list2.                                          "#EC CALLED

  DATA: first_of_append TYPE c.
  DATA: p_events TYPE slis_t_event WITH HEADER LINE.

  DEFINE table_sum_param.
    clear t_sum_param.
    t_sum_param-name = &1.
    t_sum_param-value = &2.
    if &1 ne space.
      collect t_sum_param.
    endif.
  END-OF-DEFINITION.


  table_sum_param 'P_ASUM' p_asum.
  table_sum_param 'P_CSUM' p_csum.
  table_sum_param 'P_WSUM' p_wsum.
  table_sum_param 'P_MSUM' p_msum.
  table_sum_param 'P_BSUM' p_bsum.

  CLEAR gx_firstadrsout.
  CHECK p_edit IS INITIAL.

* define first of append sum table
  CLEAR t_sum_param.
  LOOP AT t_sum_param.
    IF t_sum_param-value = 'X'.
      t_sum_param-first = 'X'.
      MODIFY t_sum_param.
      EXIT.
    ENDIF.
  ENDLOOP.

  gs_layout_append-list_append = space.
  LOOP AT gt_events_leg INTO p_events WHERE name = 'END_OF_LIST'.
    p_events-form = 'APPEND_TABLES'.
    MODIFY gt_events_leg FROM p_events.
  ENDLOOP.

  IF p_regul IS INITIAL AND
     p_ausna IS INITIAL.
    REFRESH gt_events_leg.
    p_events-name = 'TOP_OF_PAGE'.
    p_events-form = 'TOP_OF_PAGE'.
    APPEND p_events TO gt_events_leg.

    p_events-name = 'USER_COMMAND'.
    p_events-form = 'USER_COMMAND'.
    APPEND p_events TO gt_events_leg.

    IF NOT ( p_asum IS INITIAL AND
             p_csum IS INITIAL AND
             p_wsum IS INITIAL AND
             p_msum IS INITIAL AND
             p_bsum IS INITIAL ).
      p_events-name = 'END_OF_LIST'.
      p_events-form = 'APPEND_TABLES'.
      APPEND p_events TO gt_events_leg.
    ENDIF.
  ENDIF.

  LOOP AT t_sum_param WHERE first = 'X'.
    CASE t_sum_param-name.
      WHEN 'P_ASUM'.
        IF NOT p_asum IS INITIAL.
          PERFORM write_sum TABLES gt_output_main-area
                            USING  gt_fieldcat_area
                                   gt_sort_area[]
                                   g_variant_area
                                   'AR'.
        ENDIF.

      WHEN 'P_CSUM'.
        IF NOT p_csum IS INITIAL.
          PERFORM write_sum TABLES gt_output_main-coun
                            USING  gt_fieldcat_coun
                                   gt_sort_coun[]
                                   g_variant_coun
                                   'CO'.
        ENDIF.

      WHEN 'P_WSUM'.
        IF NOT p_wsum IS INITIAL.
          PERFORM write_sum TABLES gt_output_main-curr
                            USING  gt_fieldcat_curr
                                   gt_sort_curr[]
                                   g_variant_curr
                                   'CU'.
        ENDIF.

      WHEN 'P_MSUM'.
        IF NOT p_msum IS INITIAL.
          PERFORM write_sum TABLES gt_output_main-meth
                            USING  gt_fieldcat_meth
                                   gt_sort_meth[]
                                   g_variant_meth
                                   'ME'.
        ENDIF.

      WHEN 'P_BSUM'.
        IF NOT p_bsum IS INITIAL.
          PERFORM write_sum TABLES gt_output_main-bank
                            USING  gt_fieldcat_bank
                                   gt_sort_bank[]
                                   g_variant_bank
                                   'BA'.
        ENDIF.

    ENDCASE.
  ENDLOOP.

ENDFORM.                    "end_of_list2
*---------------------------------------------------------------------*
*       FORM APPEND_TABLES                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM append_tables.

  DATA: p_events TYPE slis_t_event WITH HEADER LINE.
  DATA: l_tabix LIKE sy-tabix.

  CLEAR t_sum_param.
  gs_layout_append-list_append = 'X'.
  LOOP AT gt_events_leg INTO p_events WHERE name = 'END_OF_LIST'.
    p_events-form = space.
    MODIFY gt_events_leg FROM p_events.
  ENDLOOP.

*---- iterativ call of ALV for all remaining copmany codes -----------
* ¨¹ber workarea mit gt_output_main arbeiten, sonst k#nnen die Eintr#ge
* in den Tabellen darunter umsortiert werden

  LOOP AT gt_output_main INTO wagt_output_main.
    l_tabix = sy-tabix.
    g_zbukr = wagt_output_main-zbukr.

    LOOP AT t_sum_param WHERE value = 'X'.
      IF ( t_sum_param-first EQ 'X' AND l_tabix GE '2' ) OR
         ( t_sum_param-first EQ space ).
        CASE t_sum_param-name.
          WHEN 'P_ASUM'.
            IF NOT p_asum IS INITIAL.
              PERFORM write_sum TABLES wagt_output_main-area
                                USING  gt_fieldcat_area
                                       gt_sort_area[]
                                       g_variant_area
                                       'AR'.
            ENDIF.

          WHEN 'P_CSUM'.
            IF NOT p_csum IS INITIAL.
              PERFORM write_sum TABLES wagt_output_main-coun
                                USING  gt_fieldcat_coun
                                       gt_sort_coun[]
                                       g_variant_coun
                                       'CO'.
            ENDIF.

          WHEN 'P_WSUM'.
            IF NOT p_wsum IS INITIAL.
              PERFORM write_sum TABLES wagt_output_main-curr
                                USING  gt_fieldcat_curr
                                       gt_sort_curr[]
                                       g_variant_curr
                                       'CU'.
            ENDIF.

          WHEN 'P_MSUM'.
            IF NOT p_msum IS INITIAL.
              PERFORM write_sum TABLES wagt_output_main-meth
                                USING  gt_fieldcat_meth
                                       gt_sort_meth[]
                                       g_variant_meth
                                       'ME'.
            ENDIF.

          WHEN 'P_BSUM'.
            IF NOT p_bsum IS INITIAL.
              PERFORM write_sum TABLES wagt_output_main-bank
                                USING  gt_fieldcat_bank
                                       gt_sort_bank[]
                                       g_variant_bank
                                       'BA'.
            ENDIF.

        ENDCASE.
      ENDIF.
    ENDLOOP.

  ENDLOOP.
*----- company code indepentdent sum list output----------------------*

  SORT gt_output_main BY hwaer.
  DESCRIBE TABLE gt_output_main LINES sy-tabix.
  CHECK sy-tabix GT 1.          "more than one company code involved?

  PERFORM write_sum_lists2.

*  reset parameters for list printing
  SORT gt_output_main BY zbukr.

* schmutziges Abfangen von ALV, setze alles auf Startwerte
* lese Buchungskreis des ersten Eintrags, l#sche die Buchungskreis-
* ¨¹bergreifenden Summentabellen, keine Appendliste mehr
  READ TABLE gt_output_main INTO wagt_output_main INDEX 1.
  "Get first bukr
  g_zbukr = wagt_output_main-zbukr.      "set it to the startvalue
  gx_firstround              = 'X'.

  REFRESH gt_area2.
  REFRESH gt_coun2.
  REFRESH gt_curr2.
  REFRESH gt_meth2.
  REFRESH gt_bank2.

*     gs_layout_main-list_append = space.
  CLEAR gs_layout_main-list_append.
  READ TABLE gt_output_main INTO wagt_output_main INDEX 1.
  REFRESH gt_header_main.
  APPEND LINES OF gt_output_main-header TO gt_header_main.
  READ TABLE gt_output_main INTO wagt_output_main INDEX 1.
  REFRESH gt_item_main.
  APPEND LINES OF gt_output_main-item TO gt_item_main.
  CLEAR gc_type_of_list.
ENDFORM.                    "append_tables
*---------------------------------------------------------------------*
*       FORM OUTPUT_LENGTH                                            *
*---------------------------------------------------------------------*
*       Get output length of texts from textpool                      *
*       Get correct values for double-byte characters also            *
*---------------------------------------------------------------------*
*  -->  P_TEXT                                                        *
*  <--  P_LENGTH                                                      *
*---------------------------------------------------------------------*
FORM output_length USING p_text p_length.

  CALL METHOD cl_abap_list_utilities=>dynamic_output_length
    EXPORTING
      field = p_text
    RECEIVING
      len   = p_length.

ENDFORM.                    "output_length
*------------------------------------------------------------ HW 842128
*       FORM store_check_bank_chain                                   *
*---------------------------------------------------------------------*
* Type = S:                                                           *
*  -->  <bcfs>     current line                                       *
*  <--  <bcfs>     next line                                          *
*---------------------------------------------------------------------*
FORM store_check_bank_chain
     USING     p_char  TYPE c                  " processing type
     CHANGING  p_kbank LIKE kbank1             " correspondence bank
               p_adrs  TYPE gs_adrs.           " output fields

  DATA:  BEGIN OF lc_bnklz,
           bnkl1             LIKE reguh-bnkl1,
           leer1(1)          TYPE c,
           bnks1             LIKE reguh-bnks1,
           leer2(1)          TYPE c,
           bnka1_swift       LIKE bnka-swift,
         END OF   lc_bnklz.

  CASE p_char.
    WHEN 'C'.                                  " Checking bank
      p_kbank-o_flags1 = 'TASNR'.
      IF p_kbank-btyp1 IS INITIAL.
        TRANSLATE p_kbank-o_flags1 USING 'T '.
      ELSE.
        READ TABLE gb_dd07t WITH KEY
                   domname    = 'BNTYP'
                   ddlanguage = sy-langu
                   valpos     = p_kbank-btyp1.
        IF sy-subrc NE 0.
          SELECT SINGLE * INTO gb_dd07t FROM dd07t
                 WHERE  ddlanguage = sy-langu
                   AND  domname    = 'BNTYP'
                   AND  valpos     = p_kbank-btyp1.
          IF sy-subrc = 0.
            APPEND gb_dd07t.
          ENDIF.
        ENDIF.
        p_kbank-btyp1_name = gb_dd07t-ddtext.
      ENDIF.
      IF p_kbank-bnkl1 IS INITIAL AND p_kbank-bnks1 IS INITIAL.
        TRANSLATE p_kbank-o_flags1 USING 'S A '.
      ELSEIF
        p_kbank-bnkl1 IS INITIAL OR p_kbank-bnks1 IS INITIAL.
        TRANSLATE p_kbank-o_flags1 USING 'A '.
      ELSE.
        PERFORM read_bnka
                USING p_kbank-bnks1
                      p_kbank-bnkl1.
        IF bnka-banka IS INITIAL.
          TRANSLATE p_kbank-o_flags1 USING 'A '.
        ELSE.
          p_kbank-bnka1_name  = bnka-banka.
          p_kbank-bnka1_swift = bnka-swift.
        ENDIF.
      ENDIF.
      IF p_kbank-bnkn1 IS INITIAL.
        TRANSLATE p_kbank-o_flags1 USING 'N '.
        p_kbank-bkon1_upd  = p_kbank-bkon1.
        p_kbank-bkrf1_upd  = p_kbank-bkrf1.
      ELSE.
        p_kbank-bnkn1_long = p_kbank-bnkn1.
        p_kbank-bkon1_upd  = space.
        p_kbank-bkrf1_upd  = space.
        CALL FUNCTION 'CONVERT_BANK_ACCOUNT_NUMBER'
          EXPORTING
            i_banks      = p_kbank-bnks1
            i_bankk      = p_kbank-bnkl1
            i_bankn      = p_kbank-bnkn1
            i_bkont      = p_kbank-bkon1
            i_bkref      = p_kbank-bkrf1
            i_bankl      = p_kbank-bnkl1
          IMPORTING
            e_bankn_long = p_kbank-bnkn1_long
            e_bkont      = p_kbank-bkon1_upd
            e_bkref      = p_kbank-bkrf1_upd
            e_subrc      = g_subrc.
      ENDIF.
      IF  p_kbank-bkon1_upd IS INITIAL
      AND p_kbank-bkrf1_upd IS INITIAL.
        TRANSLATE p_kbank-o_flags1 USING 'R '.
      ENDIF.
      CONDENSE p_kbank-o_flags1 NO-GAPS.

    WHEN 'T'.                                  " store title
      <bcfs> = text-090.

    WHEN 'S'.                                  " store bank data
      WHILE  p_kbank-o_flags1 NE space.
        ASSIGN <bcfs>+g_adrlen TO <bcfs> RANGE p_adrs.
        CASE p_kbank-o_flags1(1).
          WHEN 'T'.
            <bcfs>+0    = p_kbank-btyp1.
            <bcfs>+2    = p_kbank-btyp1_name.
          WHEN 'S'.
            MOVE-CORRESPONDING p_kbank TO lc_bnklz.
            CONDENSE lc_bnklz.
            <bcfs>+2    = lc_bnklz.
          WHEN 'A'.
            <bcfs>+2    = p_kbank-bnka1_name.
          WHEN 'N'.
            <bcfs>+0(1) = 'N'.
            <bcfs>+2    = p_kbank-bnkn1_long.
          WHEN 'R'.
            <bcfs>+2    = p_kbank-bkon1_upd.
            <bcfs>+5    = p_kbank-bkrf1_upd.
        ENDCASE.
        SHIFT p_kbank-o_flags1.
      ENDWHILE.
  ENDCASE.

ENDFORM.                    "store_check_bank_chain
