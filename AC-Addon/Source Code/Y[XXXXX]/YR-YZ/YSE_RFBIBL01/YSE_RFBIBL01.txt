REPORT yse_rfbibl01 MESSAGE-ID fb.
************************************************************************
*        Der Generierungsreport RFBIBLG0
*            generiert das Coding von RFBIBL02
*            RFBIBL02 wird in RFBIBL01 includiert
************************************************************************
CONSTANTS gc_filename                                       "n1592941
  TYPE fileintern                                           "n1592941
  VALUE 'FI_POSTING'.                                       "n1592941

*-----------------------------------------------------------------------
*        Tabellen
*-----------------------------------------------------------------------
TABLES:  bgr00,                        " Mappenvorsatz
         bbkpf,                        " Belegkopf + Tcode
         bbseg,                        " Belegsegment.
         bbtax,                        " Belegsteuern.
         bwith,                        " Quellensteuer
         bselk,                        " Selektionsdaten Kopf
         bselp.                        " Selektionsdaten Position

TABLES:  tbsl.                         " Buchungsschl¨¹ssel
TABLES:  t041a.                        " Ausgleichsvorg#nge
TABLES:  t100.                         " Nachrichten


DATA:   BEGIN OF ftpost OCCURS 100.
        INCLUDE STRUCTURE ftpost.
DATA:   END OF ftpost.

DATA:   BEGIN OF ftclear OCCURS 20.
        INCLUDE STRUCTURE ftclear.
DATA:   END OF ftclear.

DATA:   BEGIN OF fttax OCCURS 0.
        INCLUDE STRUCTURE fttax.
DATA:   END OF fttax.

DATA:   BEGIN OF xblntab  OCCURS 2.
        INCLUDE STRUCTURE blntab.
DATA:   END OF xblntab.


DATA:    BEGIN OF save_ftclear.
        INCLUDE STRUCTURE ftclear.
DATA:    END OF save_ftclear.

*------- Tabelle T_BBKPF enth#lt Belegkopf + Tcode  --------------------
DATA:    t_bbkpf LIKE bbkpf OCCURS 1.

*------- Tabelle T_BBSEG enth#lt Belegsegment --------------------------
DATA:    t_bbseg LIKE bbseg_di OCCURS 50.

*------- Tabelle T_BBTAX enth#lt Steuerdaten ---------------------------
DATA:    t_bbtax LIKE bbtax OCCURS 50.

*------- Tabelle T_BWITH enth#lt Quellensteuerdaten --------------------
DATA:    t_bwith LIKE bwith_di OCCURS 50.

*------- Tabelle FFILE enth#lt alle Datens#tze -------------------------
DATA:    BEGIN OF tfile OCCURS 0,
           rec  TYPE string,                             "N1847840
         END OF tfile.
DATA:    BEGIN OF efile OCCURS 100,
           rec  TYPE string,                             "N1847840
         END OF efile.
DATA:    BEGIN OF ertab OCCURS 5,
           rec  TYPE string,                             "N1847840
         END OF ertab.

*------- Feld-Informationen aus NAMETAB --------------------------------
DATA:    BEGIN OF nametab OCCURS 120.
        INCLUDE STRUCTURE dntab.
DATA:    END OF nametab.

*------- Tabelle XT001 -------------------------------------------------
DATA:    BEGIN OF xt001 OCCURS 5.
        INCLUDE STRUCTURE t001.
DATA:    END OF xt001.

*------- Tabelle XTBSL -------------------------------------------------
DATA:    BEGIN OF xtbsl OCCURS 10.
        INCLUDE STRUCTURE tbsl.
DATA:    END OF xtbsl.


*------- Tabelle XT041A ------------------------------------------------
DATA:    BEGIN OF xt041a OCCURS 5,
           auglv        LIKE t041a-auglv,
         END OF xt041a.

*begin of insertion note 1171612
*------- Tabelle XJVA ------------------------------------------------
DATA:    BEGIN OF xjva OCCURS 0,
           bukrs        LIKE t001-bukrs,
           xjvaa        LIKE t001-xjvaa, "JVA activ
           pm_active    TYPE xfeld,      "Production month activ
         END OF xjva.
*end of insertion note 1171612

*eject
*---------------------------------------------------------------------*
*        Strukturen
*---------------------------------------------------------------------*
*------- Initialstrukturen --------------------------------------------
DATA:    BEGIN OF i_bbkpf.
        INCLUDE STRUCTURE bbkpf.       " Belegkopf
DATA:    END OF i_bbkpf.

DATA:    BEGIN OF i_bbseg.
        INCLUDE STRUCTURE bbseg.       " Belegsegment
DATA:    END OF i_bbseg.

DATA:    BEGIN OF i_bbtax.
        INCLUDE STRUCTURE bbtax.       " Belegsteuern
DATA:    END OF i_bbtax.

DATA:    BEGIN OF i_bselk.
        INCLUDE STRUCTURE bselk.       " Selektionsdaten Kopf
DATA:    END OF i_bselk.

DATA:    BEGIN OF i_bselp.
        INCLUDE STRUCTURE bselp.       " Selektionsdaten Position
DATA:    END OF i_bselp.

DATA:    BEGIN OF i_bwith.
        INCLUDE STRUCTURE bwith.       " Quellensteuer
DATA:    END OF i_bwith.

*------- Hilfsstrukturen f¨¹r Direct Input ------------------------------
DATA:    BEGIN OF wa_bbseg_di.
        INCLUDE STRUCTURE bbseg_di.
DATA:    END OF wa_bbseg_di.

DATA:    BEGIN OF wa_bwith_di.
        INCLUDE STRUCTURE bwith_di.
DATA:    END OF wa_bwith_di.

DATA:    BEGIN OF trans OCCURS 0,
           x     TYPE c,
           c_00  TYPE c VALUE ' ',
           soh   TYPE c,
           c_01  TYPE c VALUE ' ',
           stx   TYPE c,
           c_02  TYPE c VALUE ' ',
           etx   TYPE c,
           c_03  TYPE c VALUE ' ',
           eot   TYPE c,
           c_04  TYPE c VALUE ' ',
           enq   TYPE c,
           c_05  TYPE c VALUE ' ',
           ack   TYPE c,
           c_06  TYPE c VALUE ' ',
           bel   TYPE c,
           c_07  TYPE c VALUE ' ',
           bs    TYPE c,
           c_08  TYPE c VALUE ' ',
           ht    TYPE c,
           c_09  TYPE c VALUE ' ',
           lf    TYPE c,
           c_0a  TYPE c VALUE ' ',
           vt    TYPE c,
           c_0b  TYPE c VALUE ' ',
           ff    TYPE c,
           c_0c  TYPE c VALUE ' ',
           cr    TYPE c,
           c_0d  TYPE c VALUE ' ',
           so    TYPE c,
           c_0e  TYPE c VALUE ' ',
           si    TYPE c,
           c_0f  TYPE c VALUE ' ',
           dle   TYPE c,
           c_10  TYPE c VALUE ' ',
           dc1   TYPE c,
           c_11  TYPE c VALUE ' ',
           dc2   TYPE c,
           c_12  TYPE c VALUE ' ',
           dc3   TYPE c,
           c_13  TYPE c VALUE ' ',
           dc4   TYPE c,
           c_14  TYPE c VALUE ' ',
           nak   TYPE c,
           c_15  TYPE c VALUE ' ',
           syn   TYPE c,
           c_16  TYPE c VALUE ' ',
           etb   TYPE c,
           c_17  TYPE c VALUE ' ',
           can   TYPE c,
           c_18  TYPE c VALUE ' ',
           em    TYPE c,                                "#EC NO_M_RISC3
           c_19  TYPE c VALUE ' ',
           sub   TYPE c,
           c_1a  TYPE c VALUE ' ',
           esc   TYPE c,
           c_1b  TYPE c VALUE ' ',
           fs    TYPE c,
           c_1c  TYPE c VALUE ' ',
           gs    TYPE c,
           c_1d  TYPE c VALUE ' ',
           rs    TYPE c,
           c_1e  TYPE c VALUE ' ',
           us    TYPE c,
           c_1f  TYPE c VALUE ' ',
         END OF trans.


*------- Workarea zum Lesen der BI-S#tze -------------------------------
*------- wa, ertab, tfile und efile muessen mindestens so lang sein
*------- wie die laengste Batchinput-Struktur BBSEG + kundeneigene
*------- Felder im Include CI_COBL_BI.
*------- Laenge der BBSEG ohne CI_COBL_BI (Stand 3.0F) 1861 Bytes
DATA:    BEGIN OF wa,
           char1(10000)  TYPE c,                        "N1847840
         END OF wa.

*eject
*---------------------------------------------------------------------*
*        Einzelfelder
*---------------------------------------------------------------------*
DATA:    beleg_count(6) TYPE c,        " Anz. Belege je Mappe
         beleg_break(6) TYPE c,        " Anz. Belege je Mappe
         bukrs          LIKE bbseg-newbk,   " Buchungskreis
         bbkpf_ok(1)    TYPE c,        " Belegkopf ¨¹bergeben
         bbseg_count(3) TYPE n,        " Anz. BSEGS pro Beleg
         bbseg_tax(1)   TYPE c.        " Steuer ¨¹ber BBSEG eingegeb

DATA:    char(40)       TYPE c,        " Char. Hilfsfeld
         char1(1)       TYPE c,        " Char. Hilfsfeld
         char2(40)      TYPE c,        " Char. Hilfsfeld
         tfile_fill(1)  TYPE c,        " X=TFILE schon gef¨¹llt
         tfsave_fill(1)  TYPE c,       " X=TFSAVE schon gef¨¹llt
         commit_count(4) TYPE n,       " Z#hler f¨¹r Commit
         all_commit LIKE tbist-aktnum. " Anzahl der Belege bis zum
" letzten COMMIT

DATA:    dyn_name(12)   TYPE c.        " Dynproname

DATA:    error_run(1)   TYPE c.        " X = error processing

DATA:    fcode(5)       TYPE c,        " Funktionscode
         function       LIKE  rfipi-funct.  " B= BDC, C= Call Trans
" D-DIRECT INPUT
DATA:    group_count(6) TYPE c,        " Anzahl Mappen
         group_open(1)  TYPE c.        " X=Mappe schon ge#ffnet

DATA:    ln_bbseg(8)    TYPE p,        " L#nge des BBSEG
         ln_bbkpf(8)    TYPE p,        " L#nge des BBKPF
         ln_bselk(8)    TYPE p,        " L#nge des BSELK
         ln_bselp(8)    TYPE p.        " L#nge des BSELP

DATA:    mode           LIKE  rfpdo-allgazmd.
DATA:    msgvn          LIKE sy-msgv1, " Hilfsfeld Message-Variable
         msgid          LIKE sy-msgid,
         msgty          LIKE sy-msgty,
         msgno          LIKE sy-msgno,
         msgv1          LIKE sy-msgv1,
         msgv2          LIKE sy-msgv2,
         msgv3          LIKE sy-msgv3,
         msgv4          LIKE sy-msgv4.

DATA:    n(2)           TYPE n,        " Hilfsfeld num.
         nodata(1)      TYPE c,        " Keine BI-Daten f¨¹r Feld
         nodata_old     LIKE nodata.   " NODATA gemerkt

DATA:    prefix_p       LIKE tcurp-prefix_p, "price-based rate prefix
         prefix_m       LIKE tcurp-prefix_p, "quantity-based rate prefix
         prodper_exist(1) TYPE C.      " Y  BBSEG-PRODPER exists
" N  BBSEG-PRODPER doesn't exist

DATA:    refe1(8)       TYPE p.        " Hilfsfeld gepackt

DATA:    satz2_count(6) TYPE c,        " Anz. S#tze(Typ2) je Trans.
         satz2_cnt_akt  LIKE satz2_count,   " Anz. S#tze(Typ2) - 1
         save_tbnam     LIKE bbseg-tbnam,   " gemerkter Tabellenname
         save_bgr00     LIKE bgr00,    " gemerkter BGR00
         subrc          LIKE sy-subrc, " Subrc
         count          TYPE i.        " Anz. Belege

DATA:    tabix(2)       TYPE n,        " Tabelleninex
         tbist_aktiv(1) TYPE c,        " Restart aktiv?
         text(200)      TYPE c,        " Messagetext
         text1(40)      TYPE c,        " Messagetext
         text2(40)      TYPE c,        " Messagetext
         text3(40)      TYPE c,        " Messagetext
         tfill_ftpost   TYPE i,        " Anz. Eintr#ge in FTPOST
         tfill_t_bbseg  TYPE i,        " Anz. Eintr#ge in T_BBSEG
         tfill_t_bwith  TYPE i,        " Anz. Eintr#ge in T_BWITH
         tfill_tfile    TYPE i,        " Anz. Eintr#ge in TFILE
         tfill_ertab    TYPE i,        " Anz. Eintr#ge in ERTAB
         tfill_ftc(3)   TYPE n,        " Anz. Eintr#ge in FTC
         tfill_ftk(3)   TYPE n,        " Anz. Eintr#ge in FTK
         tfill_ftz(3)   TYPE n,        " Anz. Eintr#ge in FTZ
         tfill_041a(1)  TYPE n.        " Anz. Eintr#ge in XT041A


DATA:    wert(60)       TYPE c,        " Hilfsfeld Feldinhalt
         wt_count       TYPE i.        " Z#hler Quellensteuer

DATA:    xbdcc          LIKE rfipi-xbdcc,   " X=BDC bei Error in CallTra
         xeof(1)        TYPE c,        " X=End of File erreicht
         xmess_bbkpf_sende(1) TYPE c,  " Message gesendet f¨¹r BBKPF
         xmess_bbseg_sende(1) TYPE c,  " Message gesendet f¨¹r BBSEG
         xmess_bbtax_sende(1) TYPE c,  " Message gesendet f¨¹r BBTAX
*        XMWST          LIKE BKPF-XMWST,    " Steuer rechnen
         xnewg(1)       TYPE c,        " X=Neue Mappe
         xftclear(1).                  " Append FTCLEAR durchfuehren?

* DATAs wichtig f¨¹r Wiederaufsetzbarkeit
DATA: aktnum LIKE tbist-aktnum.   " Z#hler f¨¹r aktuell bearbeiteter Satz
DATA: startnum LIKE tbist-aktnum.      " erster zu bearbeitender Satz
*ata: is_error.                   " ¨¹bergebene Satznummer war fehlerhaft
DATA: numerror LIKE tbist-numerror.    " Anzahl Fehler in diesem Schritt
DATA: olderror LIKE tbist-numerror.    " Anzahl Fehler aus dem
" vorherigen Job.
DATA: lasterrnum LIKE tbist-lastnum.   "Letzte Fehlernummer
DATA: nostart LIKE tbist-nostarting VALUE 'X'. " Start-Infos schreiben ?
DATA: jobid LIKE tbtco-jobname.
DATA: jobid_ext LIKE tbtco-jobname.
CONSTANTS:   pack_size TYPE i VALUE '250',
             c_msgid   LIKE sy-msgid VALUE 'FB'.

TABLES: terrd,
        tfsave.

*-----------------------------------------------------------------------
*        Konstanten und Field-Symbols
*-----------------------------------------------------------------------
DATA:    c_nodata(1)    TYPE c VALUE '/',   " Default f¨¹r NODATA
         xon                   VALUE 'X'.   " Flag eingeschaltet

DATA:    fmf1ges(1)     TYPE x VALUE '20'.  " Beide Flags aus: Input.
DATA:    fmb1num(1)     TYPE x VALUE '10'.  "       "

DATA:    max_commit(4)  TYPE n.        " Max. Belege je Commit

DATA:    rep_name_a(8)  TYPE c VALUE 'SAPMF05A'. " Mpool SAPMF05A
DATA:    rep_name_c(8)  TYPE c VALUE 'SAPLFCPD'. " Mpool SAPLFCPD
DATA:    rep_name_k(8)  TYPE c VALUE 'SAPLKACB'. " Mpool SAPLKACB

FIELD-SYMBOLS: <f1>.


*------- Aufbau des Selektionsbildes -----------------------------------
SELECTION-SCREEN SKIP 1.

PARAMETERS: ds_name     LIKE rfpdo-rfbifile.  " Dateiname

SELECTION-SCREEN SKIP 1.
SELECTION-SCREEN ULINE.
SELECTION-SCREEN SKIP 1.

PARAMETERS: fl_check    LIKE rfpdo-rfbichck,    " Datei nur pr¨¹fen
              os_xon      LIKE rfpdo-rfbioldstr,  " Alte Strukturen
              xnonunic    TYPE rfpdo-rfbinonunic.

SELECTION-SCREEN SKIP 1.
SELECTION-SCREEN ULINE.
SELECTION-SCREEN SKIP 1.
PARAMETERS: callmode    LIKE rfpdo-rfbifunct OBLIGATORY,
            max_comm(4) TYPE n DEFAULT '1000',  " Max Belege pro Commit
            pa_xprot(1) TYPE c.        " erweitertes Protokoll
*           ANZ_MODE:        A=alles N=nichts E=Error
PARAMETERS: anz_mode    LIKE rfpdo-allgazmd    DEFAULT 'N'.
*                                              NO-DISPLAY.
*           UPDATE:          S=Synchron A=Asynchron
PARAMETERS: update      LIKE rfpdo-allgvbmd    DEFAULT 'S'.
*                                              NO-DISPLAY.

* infomessages
SELECTION-SCREEN SKIP 1.
SELECTION-SCREEN BEGIN OF BLOCK bl1.
PARAMETERS: xpop  TYPE c RADIOBUTTON GROUP rbl1,
            xlog  TYPE c RADIOBUTTON GROUP rbl1,
            xinf  TYPE c RADIOBUTTON GROUP rbl1.
SELECTION-SCREEN END   OF BLOCK bl1.

*eject
************************************************************************
*        Hauptablauf
************************************************************************
CLEAR: xeof, xnewg,
       group_count, beleg_count,
       satz2_count, satz2_cnt_akt,
       error_run,
       wt_count,
       commit_count, count.
max_commit = max_comm.

*------- init log
CALL FUNCTION 'FI_MESSAGE_INIT'.

*------- Datei nur pr¨¹fen? ---------------------------------------------
IF fl_check NE space.
  PERFORM log_msg USING c_msgid 'I' '018' ds_name space space space.
ENDIF.

*------- Call Transaction .. Using ..? ---------------------------------
*F XCALL NE SPACE.
* XBDCC    = 'X'.
* FUNCTION = 'C'.
* IF FL_CHECK NE SPACE.
*   MESSAGE I022.
* ELSE.
*   MESSAGE I021.
* ENDIF.
*LSE.
* FUNCTION = 'B'.
*NDIF.


CASE callmode.
  WHEN 'B'.
    function = 'B'.
  WHEN 'C'.
    function = 'C'.
    IF sy-batch NE 'X'.
*     MESSAGE A899 WITH 'Bei Call Transaktion mu# Report im Batch'.
    ENDIF.
  WHEN 'D'.
    function = 'D'.
    IF sy-batch NE 'X'.
*     MESSAGE A899 WITH 'Bei Fast Input mu# Report im Batch laufen'.
    ENDIF.
ENDCASE.

PERFORM get_restart_info.


*IF tfile_fill IS INITIAL.              " TFILE wurde noch nicht gef¨¹llt
IF tfsave_fill IS INITIAL.
  PERFORM read_dataset_into_table_tfile.
ENDIF.

PERFORM loop_at_table_tfile.
PERFORM error_processing.
PERFORM call_bi_close_entry.
COMMIT WORK.
PERFORM log_print.
CALL FUNCTION 'DEQUEUE_ALL'.

*eject.
************************************************************************
*        Interne Perform-Routinen
************************************************************************
*eject
*-----------------------------------------------------------------------
*        Form  AUGLV_PRUEFEN
*-----------------------------------------------------------------------
*        Ausgleichsvorgang aus T041A ermitteln;
*-----------------------------------------------------------------------
FORM auglv_pruefen.
  IF tfill_041a   = 0.
    SELECT * FROM t041a.
      xt041a-auglv = t041a-auglv.
      APPEND xt041a.
    ENDSELECT.
    DESCRIBE TABLE xt041a LINES tfill_041a.
    IF tfill_041a = 0.
      PERFORM log_msg USING c_msgid 'I' '171'
                            beleg_count space space space.
      PERFORM log_abort USING c_msgid '013'.
    ENDIF.
  ENDIF.

  tabix = 0.
  IF bbkpf-auglv(1) = nodata
  OR bbkpf-auglv    = space.
    PERFORM log_msg USING c_msgid 'I' '162'
                          beleg_count space space space.
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.
  LOOP AT xt041a WHERE auglv = bbkpf-auglv.
    tabix = sy-tabix.
    EXIT.
  ENDLOOP.
  IF tabix = 0.
    PERFORM log_msg USING c_msgid 'I' '163'
                          beleg_count bbkpf-auglv space space.
    PERFORM log_msg USING c_msgid 'I' '016'
                         space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.
ENDFORM.                               "auglv_pruefen

*eject
*-----------------------------------------------------------------------
*        Form  AUGLV_SETZEN
*-----------------------------------------------------------------------
*        Ausgleichsvorgang aus T041A ermitteln;
*        entsprechenden Ausgleichsvorgang im Loop ankreuzen.
*-----------------------------------------------------------------------
*ORM AUGLV_SETZEN.
* TABIX = 0.
* IF BBKPF-AUGLV(1) = NODATA
* OR BBKPF-AUGLV    = SPACE.
*   MESSAGE I162 WITH BELEG_COUNT.
*   MESSAGE I016.
*   PERFORM DUMP_WA USING 'BBKPF'.
*   MESSAGE A013.
* ENDIF.
* LOOP AT XT041A WHERE AUGLV = BBKPF-AUGLV.
*   TABIX = SY-TABIX.
*   EXIT.
* ENDLOOP.
* IF TABIX = 0.
*   MESSAGE I163 WITH BELEG_COUNT BBKPF-AUGLV.
*   MESSAGE I016.
*   PERFORM DUMP_WA USING 'BBKPF'.
*   MESSAGE A013.
* ENDIF.
*
*------- Ausgleichsvorgang im Loop ankreuzen ---------------------------
* IF FL_CHECK = SPACE.
*   CLEAR FTA.
*   FTA-FNAM(12)   = 'RF05A-XPOS1('.
*   FTA-FNAM+12(2) = TABIX.
*   FTA-FNAM+14(1) = ')'.
*   FTA-FVAL       = 'X'.
*   APPEND FTA.
* ENDIF.
*NDFORM.

*eject
*-----------------------------------------------------------------------
*        FORM BBKPF_ERWEITERUNG_PRUEFEN.
*-----------------------------------------------------------------------
*        Falls der Kunde eine alte BBKPF-Struktur benutzt werden die
*        neuen Felder mit NODATA initialisiert.
*-----------------------------------------------------------------------
FORM bbkpf_erweiterung_pruefen.

  IF bbkpf-sende(1) NE nodata.
* ------ BBKPF-VATDATE                                       N1023317
    IF bbkpf-vatdate(1) NE nodata.                          "N1023317
* ------ BBKPF-ENHANCEMENT ERP: LDGRP(2), PROPMANO
      IF bbkpf-ldgrp(1) NE nodata.                               "/glflex
*------- BBKPF-Erweiterung um XBWAE zu 4.6C
        IF bbkpf-xbwae(1) NE nodata.
*------- BBKPF-Erweiterung um XPRFG zu 4.5B
          IF bbkpf-xprfg(1) NE nodata.
*------- BBKPF-Erweiterung zu 4.5B: AUGTX
            IF bbkpf-augtx(1) NE nodata.
*------- BBKPF-Erweiterung zu 4.5B: KURSF_M(10)
              IF bbkpf-kursf_m(1) NE nodata.

*------- BBKPF-Erweiterung zu 4.0C: STGRD(2),
                IF bbkpf-stgrd(1) NE nodata.
*------- BBKPF-Erweiterung zu 4.0A: BRNCH(4), NUMPG(3)
                  IF bbkpf-brnch(1) NE nodata.
*------- BBKPF-Erweiterung zu 3.0A: DOCID(10), BARCD(40),STODT
                    IF bbkpf-docid(1) NE nodata.
*------- BBKPF-Erweiterung zu 2.2A: XMWST(1)
                      IF bbkpf-xmwst(1) NE nodata.
*------- BBKPF-Erweiterung zu 2.1A: VBUND --
                        bbkpf-vbund(1) = nodata.
                      ENDIF.

                      bbkpf-xmwst(1) = nodata.
                    ENDIF.

                    bbkpf-docid(1) = nodata.
                    bbkpf-barcd(1) = nodata.
                    bbkpf-stodt(1) = nodata.
                  ENDIF.

                  bbkpf-brnch(1) = nodata.
                  bbkpf-numpg(1) = nodata.
                ENDIF.

                bbkpf-stgrd(1) = nodata.
              ENDIF.

              bbkpf-kursf_m(1) = nodata.
            ENDIF.

            bbkpf-augtx(1) = nodata.
          ENDIF.
          bbkpf-xprfg(1) = nodata.
        ENDIF.
        bbkpf-xbwae(1) = nodata.
      ENDIF.
      bbkpf-ldgrp(1) = nodata.                                    "/glflex
      bbkpf-propmano(1) = nodata.                                 "RE
    ENDIF.                                                  "N1023317
    bbkpf-vatdate = nodata.                                 "N1023317

    IF xmess_bbkpf_sende NE 'X'.
      PERFORM log_msg USING c_msgid 'I' '174'
                            beleg_count 'BBKPF' nodata space.
      PERFORM log_msg USING c_msgid 'I' '023' 'BBKPF' space space space.
      PERFORM log_msg USING c_msgid 'I' '024' space space space space.
      PERFORM log_msg USING c_msgid 'I' '025' 'BBKPF' space space space.
      xmess_bbkpf_sende = 'X'.
    ENDIF.
  ENDIF.
ENDFORM.                               "bbkpf_erweiterung_pruefen



*eject
*-----------------------------------------------------------------------
*        FORM BBSEG_ERWEITERUNG_PRUEFEN.
*-----------------------------------------------------------------------
*        Falls der Kunde eine alte BBSEG-Struktur benutzt, werden die
*        neuen Felder mit NODATA initialisiert.
*-----------------------------------------------------------------------
FORM bbseg_erweiterung_pruefen.

  IF bbseg-sende(1) NE nodata.

* ueberpruefen, ob die in der BBSEG-Struktur vorhandenen Includes
* aktiv sind. Wenn ja kann Erweiterungspruefung (beruecksichtigt nur
* Felder aus dem Standard) nicht durchgefuehrt werden.

    CALL FUNCTION 'DD_EXIST_TABLE'
      EXPORTING
        tabname = 'SI_BBSEGV'
        status  = 'A'
      IMPORTING
        subrc   = subrc.

    IF subrc = 0.
      PERFORM log_msg USING c_msgid 'I' '872'
                            'SI_BBSEGV' space space space.
      EXIT.
    ENDIF.
*begin of insertion note 1115584
*----BBSEG-ENHANCEMENT: fields from Include REIT_TAX_CORR_ADD
    IF bbseg-tcno(1) NE nodata.
*end of insertion note 1115584
*----BBSEG-Erweiterung: XSIWE
      IF bbseg-xsiwe(1) NE nodata.
*------- BBSEG-ENHANCEMENT ERP: SEGMNET, PSEGMNET, HKTID
        IF bbseg-segment(1) NE nodata.                          "/glflex
*------- BBSEG-Erweiterung 4.7: IBAN, VALID_FROM
          IF bbseg-valid_from(1) NE nodata.
*------- BBSEG-Erweiterung 4.7: GRANT_NBR, FKBER_LONG, ERLKZ
            IF bbseg-erlkz(1) NE nodata.

*--------BBSEG-Erweiterung CESSION_KZ
              IF bbseg-cession_kz(1) NE nodata.
*------- BBSEG-Erweiterung 4.7: DTAMS
                IF bbseg-dtams(1) NE nodata.
*------- BBSEG-Erweiterung: BKREF
                  IF bbseg-bkref(1) NE nodata.
*------- BBSEG-Erweiterung: RECNNR, E_MIVE
                    IF bbseg-recnnr(1) NE nodata.
*------- BBSEG-Erweiterung: ANRED (Anrede CpD)
                      IF bbseg-anred  NE nodata.
*------- BBSEG-Erweiterung: IDXSP
                        IF bbseg-idxsp(1) NE nodata.
*------- BBSEG-Erweiterung zu 4.6B: J_1KFREPRE, J_1KFTBUS, J_1KFTIND
                          IF bbseg-j_1kfrepre(1) NE nodata.

*------- BBSEG-Erweiterung Immobilien zu 4.5B, Umzug von KI3,
*------- WENR, GENR, GRNR, MENR, MIVE, NKSL, EMPSL, SVWNR, SBERI
*------- andere Felder: KKBER, EMPFB, KURSR_M
                            IF bbseg-wenr(1) NE nodata.
*------- BBSEG-Erweiterung zu 4.0C: PYCUR,PYAMT,BUPLA,SECCO,LSTAR,EGDEB
                              IF bbseg-pycur(1) NE nodata.
*------- BBSEG-Erweiterung zu 4.0B: DTAWS
                                IF bbseg-dtaws(1) NE nodata.
*------- BBSEG-Erweiterung zu 4.0A: XNEGP,GRICD,GRIRG,GITYP,FITYP,
*                                   STCDT,STKZN,STCD3,STCD4,...,DTWS4
                                  IF bbseg-xnegp(1) NE nodata.

*------- BBSEG-Erweiterung zu 3.1H: FIPEX
                                    IF bbseg-fipex(1) NE nodata.
*------- BBSEG-Erweiterung zu 3.0F: RSTGR
                                      IF bbseg-rstgr(1) NE nodata.
*------- BBSEG-Erweiterung zu 3.0E: VBUND,FKBER,DABRZ,XSTBA
                                        IF bbseg-vbund(1) NE nodata.
*------- BBSEG-Erweiterung zu 3.0D: WDATE, WGBKZ, XAKTZ, WNAME, WORT1,
*                                   WBZOG, WORT2, WBANK, WLZBP, DISKP,
*                                   DISKT, WINFW, WINHW, WEVWV, WSTAT,
*                                   WMWKZ, WSTKZ
                                          IF bbseg-wdate(1) NE nodata.

*------- BBSEG-Erweiterung zu 3.0A: XREF1(11), XREF2(12),
*                                   KBLPOS(3), KBLNR(10)
                                            IF bbseg-xref1(1) NE nodata.
*------- BBSEG-Erweiterung zu 2.2A: PPRCT(10), PROJK(24), UZAWE(2),
*                                   TXJCD(10), FISTL(16), GEBER(10),
*                                   DMBE2(16), DMBE3(16), PARGB(4),
                                              IF bbseg-pprct(1) NE nodata.
*------- BBSEG-Erweiterung zu 2.1D: XEGDR, RECID
                                                IF bbseg-xegdr(1) NE nodata.
*------- BBSEG-Erweiterung zu 2.1C: NPLNR, VORNR

                                                  bbseg-nplnr(1)   = nodata.
                                                  bbseg-vornr(1)   = nodata.
                                                ENDIF.

                                                bbseg-xegdr(1)   = nodata.
                                                bbseg-recid(1)   = nodata.
                                              ENDIF.

                                              bbseg-pprct(1)  = nodata.
                                              bbseg-projk(1)  = nodata.
                                              bbseg-uzawe(1)  = nodata.
                                              bbseg-txjcd(1)  = nodata.
                                              bbseg-fistl(1)  = nodata.
                                              bbseg-geber(1)  = nodata.
                                              bbseg-dmbe2(1)  = nodata.
                                              bbseg-dmbe3(1)  = nodata.
                                              bbseg-pargb(1)  = nodata.
                                              bbseg-budget_pd(1) = nodata.
                                            ENDIF.

                                            bbseg-xref1(1)   = nodata.
                                            bbseg-xref2(1)   = nodata.
                                            bbseg-kblpos(1)  = nodata.
                                            bbseg-kblnr(1)   = nodata.

                                          ENDIF.
                                          bbseg-wdate(1)   = nodata.
                                          bbseg-wgbkz(1)   = nodata.
                                          bbseg-xaktz(1)   = nodata.
                                          bbseg-wname(1)   = nodata.
                                          bbseg-wort1(1)   = nodata.
                                          bbseg-wbzog(1)   = nodata.
                                          bbseg-wort2(1)   = nodata.
                                          bbseg-wbank(1)   = nodata.
                                          bbseg-wlzbp(1)   = nodata.
                                          bbseg-diskp(1)   = nodata.
                                          bbseg-diskt(1)   = nodata.
                                          bbseg-winfw(1)   = nodata.
                                          bbseg-winhw(1)   = nodata.
                                          bbseg-wevwv(1)   = nodata.
                                          bbseg-wstat(1)   = nodata.
                                          bbseg-wmwkz(1)   = nodata.
                                          bbseg-wstkz(1)   = nodata.
                                        ENDIF.

                                        bbseg-vbund(1)   = nodata.
                                        bbseg-fkber(1)   = nodata.
                                        bbseg-dabrz(1)   = nodata.
                                        bbseg-xstba(1)   = nodata.
                                      ENDIF.

                                      bbseg-rstgr(1)   = nodata.
                                    ENDIF.

                                    bbseg-fipex(1)   = nodata.

                                  ENDIF.

                                  bbseg-xnegp(1)   = nodata.
                                  bbseg-gricd(1)   = nodata.
                                  bbseg-grirg(1)   = nodata.
                                  bbseg-gityp(1)   = nodata.
                                  bbseg-fityp(1)   = nodata.
                                  bbseg-stcdt(1)   = nodata.
                                  bbseg-stkzn(1)   = nodata.
                                  bbseg-stcd3(1)   = nodata.
                                  bbseg-stcd4(1)   = nodata.
                                  bbseg-xref3(1)   = nodata.
                                  bbseg-kidno(1)   = nodata.
                                  bbseg-dtws1(1)   = nodata.
                                  bbseg-dtws2(1)   = nodata.
                                  bbseg-dtws3(1)   = nodata.
                                  bbseg-dtws4(1)   = nodata.
                                ENDIF.

                                bbseg-dtaws(1)   = nodata.
                              ENDIF.

                              bbseg-pycur(1)   = nodata.
                              bbseg-pyamt(1)   = nodata.
                              bbseg-bupla(1)   = nodata.
                              bbseg-secco(1)   = nodata.
                              bbseg-lstar(1)   = nodata.
                              bbseg-egdeb(1)   = nodata.

                            ENDIF.
                            bbseg-wenr(1)   = nodata.
                            bbseg-genr(1)   = nodata.
                            bbseg-grnr(1)   = nodata.
                            bbseg-menr(1)   = nodata.
                            bbseg-mive(1)   = nodata.
                            bbseg-nksl(1)   = nodata.
                            bbseg-empsl(1)   = nodata.
                            bbseg-svwnr(1)   = nodata.
                            bbseg-sberi(1)   = nodata.
                            bbseg-kkber(1)   = nodata.
                            bbseg-empfb(1)   = nodata.
                            bbseg-kursr_m(1) = nodata.

                          ENDIF.
                          bbseg-j_1kfrepre(1) = nodata.
                          bbseg-j_1kftbus(1)  = nodata.
                          bbseg-j_1kftind(1)  = nodata.
                        ENDIF.
                        bbseg-idxsp(1) = nodata.
                      ENDIF.
                      bbseg-anred(1) = nodata.
                    ENDIF.
                    bbseg-recnnr(1) = nodata.
                    bbseg-e_mive(1) = nodata.
                  ENDIF.
                  bbseg-bkref(1) = nodata.
                ENDIF.
                bbseg-dtams(1) = nodata.
              ENDIF.
              bbseg-cession_kz(1) = nodata.
            ENDIF.
            bbseg-grant_nbr(1) = nodata.
            bbseg-fkber_long(1) = nodata.
            bbseg-erlkz(1) = nodata.
          ENDIF.
          bbseg-iban(1) = nodata.
          bbseg-valid_from = nodata.
        ENDIF.
        bbseg-segment(1) = nodata.                                "/glflex
        bbseg-psegment(1) = nodata.                               "/glflex
        bbseg-hktid(1) = nodata.
      ENDIF.
      bbseg-xsiwe(1) = nodata.
    ENDIF.
*begin of insertion note 1115584
    bbseg-tcno(1)            = nodata.
    bbseg-dateofservice(1)   = nodata.
    bbseg-notaxcorr(1)       = nodata.
    bbseg-diffoptrate(1)     = nodata.
    bbseg-hasdiffoptrate(1)  = nodata.
*end of insertion note 1115584
    IF xmess_bbseg_sende NE 'X'.
      PERFORM log_msg USING c_msgid 'I' '174'
                            beleg_count 'BBSEG' nodata space.
      PERFORM log_msg USING c_msgid 'I' '023'
                            'BBSEG' space space space.
      PERFORM log_msg USING c_msgid 'I' '024'
                            space space space space.
      PERFORM log_msg USING c_msgid 'I' '025'
                            'BBSEG' space space space.
      xmess_bbseg_sende = 'X'.
    ENDIF.
  ENDIF.
ENDFORM.                               "bbseg_erweiterung_pruefen

*eject
*-----------------------------------------------------------------------
*        FORM BBTAX_ERWEITERUNG_PRUEFEN.
*-----------------------------------------------------------------------
*        Falls der Kunde eine alte BBTAX-Struktur benutzt werden die
*        neuen Felder mit NODATA initialisiert.
*-----------------------------------------------------------------------
FORM bbtax_erweiterung_pruefen.

  IF bbtax-sende(1) NE nodata.
*------- BBTAX-Erweiterung zu 4.0A: H2STE(16), H3STE(16)
    bbtax-h2ste(1) = nodata.
    bbtax-h3ste(1) = nodata.


    IF xmess_bbtax_sende NE 'X'.
      PERFORM log_msg USING c_msgid 'I' '174'
                            beleg_count 'BBTAX' nodata space.
      PERFORM log_msg USING c_msgid 'I' '023'
                            'BBTAX' space space space.
      PERFORM log_msg USING c_msgid 'I' '024'
                            space space space space.
      PERFORM log_msg USING c_msgid 'I' '025'
                            'BBTAX' space space space.
      xmess_bbtax_sende = 'X'.
    ENDIF.
  ENDIF.
ENDFORM.                               "bbtax_erweiterung_pruefen


*eject
*-----------------------------------------------------------------------
*        Form  BELEG_ABSCHLIESSEN
*-----------------------------------------------------------------------
FORM beleg_abschliessen.
  CHECK fl_check = space.
  IF bbkpf-tcode = 'FB01'
  OR bbkpf-tcode = 'FBB1'                                   "P30K125019
  OR bbkpf-tcode = 'FBS1'
  OR bbkpf-tcode = 'FBV1'
  OR bbkpf-tcode = 'FBCB'.                                  "1562986
    CALL FUNCTION 'POSTING_INTERFACE_DOCUMENT'
      EXPORTING
        i_tcode  = bbkpf-tcode
      IMPORTING
        e_subrc  = subrc
        e_msgid  = msgid
        e_msgty  = msgty
        e_msgno  = msgno
        e_msgv1  = msgv1
        e_msgv2  = msgv2
        e_msgv3  = msgv3
        e_msgv4  = msgv4
      TABLES
        t_ftpost = ftpost
        t_fttax  = fttax
        t_blntab = xblntab
      EXCEPTIONS
        OTHERS   = 1.

  ELSEIF bbkpf-tcode = 'FB05' or bbkpf-tcode = 'FB05L'. "1527033
* Falls nur BSELK aber kein BSELP ¨¹bergeben wurde, so wurden die Daten
* aus der int. Tabelle SAVE_FTCLEAR noch nicht in die Tabelle FTCLEAR
* uebertragen.
    IF NOT xftclear IS INITIAL.
      ftclear = save_ftclear.
      APPEND ftclear.
    ENDIF.

    CALL FUNCTION 'POSTING_INTERFACE_CLEARING'
      EXPORTING
        i_auglv   = bbkpf-auglv
        i_tcode   = bbkpf-tcode
      IMPORTING
        e_subrc   = subrc
        e_msgid   = msgid
        e_msgty   = msgty
        e_msgno   = msgno
        e_msgv1   = msgv1
        e_msgv2   = msgv2
        e_msgv3   = msgv3
        e_msgv4   = msgv4
      TABLES
        t_ftpost  = ftpost
        t_ftclear = ftclear
        t_fttax   = fttax
        t_blntab  = xblntab
      EXCEPTIONS
        OTHERS    = 1.
  ENDIF.



  IF function = 'B'.
*------- Batch Input  ------------------------------------------------
    IF NOT sy-subrc IS INITIAL.
      IF NOT error_run IS INITIAL.
        PERFORM log_msg USING sy-msgid 'I' sy-msgno
                              sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        PERFORM log_msg USING c_msgid 'I' '622'
                              beleg_count group_count space space.
        PERFORM log_msg USING c_msgid 'I' '014'
                              'BBKPF' space space space.
      ELSE.
        PERFORM log_msg USING sy-msgid 'I' sy-msgno
                              sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        PERFORM log_msg USING c_msgid 'I' '622'
                              beleg_count group_count space space.
        PERFORM dump_wa USING 'BBKPF'.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.
    ENDIF.
    IF NOT sy-subrc IS INITIAL.
      PERFORM log_msg USING sy-msgid 'I' sy-msgno
                            sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      PERFORM log_msg USING c_msgid 'I' '622'
                            beleg_count group_count space space.
      PERFORM dump_wa USING 'BBKPF'.
      PERFORM log_abort USING c_msgid '013'.
    ENDIF.
*------- Commit Work? ------------------------------------------------
    commit_count = commit_count + 1.
    IF commit_count = max_commit.
      COMMIT WORK.
      CALL FUNCTION 'DEQUEUE_ALL'.
      CLEAR commit_count.
    ENDIF.
  ELSE.
*------- Call Transaction --------------------------------------------
    IF subrc IS INITIAL AND sy-subrc IS INITIAL.
      LOOP AT xblntab.
        IF bbkpf-tcode = 'FBV1'.                            "1975782
          PERFORM log_msg USING  'FP' 'I' '001'
                   xblntab-belnr xblntab-bukrs space space. "1975782
        ELSE.                                               "1975782
          PERFORM log_msg USING 'F5' 'I' '312'
                              xblntab-belnr xblntab-bukrs space space.
        ENDIF.                                              "1975782
      ENDLOOP.
    ELSE.
      IF NOT subrc IS INITIAL.
        PERFORM log_msg USING msgid 'I' msgno
                              msgv1 msgv2 msgv3 msgv4.
      ELSE.
        PERFORM log_msg USING sy-msgid 'I' sy-msgno
                              sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.

      PERFORM export_error_data.
    ENDIF.
    commit_count = commit_count + 1.
*------- bei Call Trans Commit Work nach jedem Beleg -------------------
    PERFORM call_bi_end_akt_number.
    COMMIT WORK.
    CALL FUNCTION 'DEQUEUE_ALL'.
  ENDIF.

  REFRESH: ftpost, ftclear, fttax, xblntab.
  CLEAR:   ftpost, ftclear, fttax, xblntab.
ENDFORM.                               "beleg_abschliessen


*eject
*-----------------------------------------------------------------------
*        Form  BELEG_ABSCHLIESSEN_OLD.
*-----------------------------------------------------------------------
FORM beleg_abschliessen_old.
* CHECK FL_CHECK = SPACE.
*
*------- Batch-Input erstellen -----------------------------------------
* IF XCALL = SPACE.
*   CALL FUNCTION 'BDC_INSERT'
*     EXPORTING TCODE     = BBKPF-TCODE
*     TABLES    DYNPROTAB = FT.
*
*------- zun#chst 'Call Transaction', nur bei Fehlern Batch-Input ------
* ELSE.
*   CALL TRANSACTION BBKPF-TCODE USING  FT
*                                MODE   ANZ_MODE
*                                UPDATE UPDATE.
*   SUBRC = SY-SUBRC.
*   PERFORM MESSAGE_CALL_TRANSACTION.
*   IF SUBRC NE 0.
*     IF GROUP_OPEN NE 'X'.
*       PERFORM MAPPE_OEFFNEN.
*     ENDIF.
*     CALL FUNCTION 'BDC_INSERT'
*       EXPORTING TCODE     = BBKPF-TCODE
*       TABLES    DYNPROTAB = FT.
*   ENDIF.
* ENDIF.
*
*------- Commit Work? ------------------------------------------------
* COMMIT_COUNT = COMMIT_COUNT + 1.
* IF COMMIT_COUNT = MAX_COMMIT.
*   COMMIT WORK.
*   CLEAR COMMIT_COUNT.
* ENDIF.
ENDFORM.                               "beleg_abschliessen_old


*eject
*-----------------------------------------------------------------------
*        Form  DATENSATZ_PRUEFEN
*-----------------------------------------------------------------------
*        Pr¨¹fung des Datensatzes (Typ 2):
*        Tabellenname angegeben und g¨¹ltig ?
*        Tabellen in richtiger Reihenfolge ¨¹bergeben ?
*-----------------------------------------------------------------------
FORM datensatz_pruefen.
  satz2_count = satz2_count + 1.

*------- wurde ein Kopfsatz ¨¹bergeben ? --------------------------------
  IF bbkpf_ok IS INITIAL.
    PERFORM log_msg USING c_msgid 'I' '151'
                          group_count space space space.
    PERFORM log_msg USING c_msgid 'I' '015'
                          space space space space.
    PERFORM dump_wa USING 'BGR00'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

*------- Kennzeichen f¨¹r Datensatz (Typ 2) gesetzt ? -------------------
  IF wa(1) NE '2'.
    PERFORM log_msg USING c_msgid 'I' '152'
                          beleg_count satz2_count wa(1) space.
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

* Daten werden wegen der Feldl#nge-Erweiterung des Feldes TBNAM
* von 10B (<4.0) auf 30B verschoben
  IF ( os_xon = xon ) AND ( error_run NE 'X' ).
    SHIFT wa BY 20 PLACES RIGHT.
    wa(31) = wa+20(11).
    IF wa+2(29) = 'SELP'.
      PERFORM bselp_field_lenght_convert CHANGING wa.
    ENDIF.
  ENDIF.

*------- Tabellenname angegeben ? --------------------------------------
  IF wa+1(1)  = nodata
  OR wa+1(30) = space.
    PERFORM log_msg USING c_msgid 'I' '153'
                          beleg_count satz2_count space space.
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

*------- erlaubte Tabellen? --------------------------------------------
  IF  wa+1(30) NE 'BBSEG'
  AND wa+1(30) NE 'BWITH'
  AND wa+1(30) NE 'BBTAX'
  AND wa+1(30) NE 'BSELK'
  AND wa+1(30) NE 'BSELP'
  AND wa+1(13) NE 'ZBSEG'
  AND wa+1(30) NE 'ZSELP'.
    PERFORM log_msg USING c_msgid 'I' '164'
                          beleg_count satz2_count wa+1(30) space.
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.
  IF (   bbkpf-tcode EQ 'FB01'
      OR bbkpf-tcode EQ 'FBB1'                              "P30K125019
      OR bbkpf-tcode EQ 'FBS1'
      OR bbkpf-tcode EQ 'FBV1'
      OR bbkpf-tcode EQ 'FBCB' )                            "1562986
  AND NOT (    wa+1(30)    EQ 'BBSEG'
            OR wa+1(30)    EQ 'ZBSEG'
            OR wa+1(30)    EQ 'BWITH'
            OR wa+1(30)    EQ 'BBTAX' ).
    PERFORM log_msg USING c_msgid 'I' '165'
                       beleg_count satz2_count wa+1(30) bbkpf-tcode(20).
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    IF wa+1(30) = 'BSELK'.
      bselk = i_bselk.
      bselk = wa.                                           "#EC ENHOK
      PERFORM log_msg USING c_msgid 'I' '017'
                          space space space space.
      PERFORM dump_wa USING 'BSELK'.
    ENDIF.
    IF wa+1(30) = 'BSELP'.
      bselp = i_bselp.
      bselp = wa.                                           "#EC ENHOK
      PERFORM log_msg USING c_msgid 'I' '017'
                          space space space space.
      PERFORM dump_wa USING 'BSELP'.
    ENDIF.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.
*------ Quellensteuer
  IF ( bbkpf-tcode NE 'FB01' AND
       bbkpf-tcode NE 'FBV1' )
       AND wa+1(30) EQ 'BWITH'.
    PERFORM log_msg USING c_msgid 'I' '165'
                       beleg_count satz2_count wa+1(30) bbkpf-tcode(20).
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    bwith = i_bwith.
    bwith = wa.                                             "#EC ENHOK
    PERFORM log_msg USING c_msgid 'I' '017'
                          space space space space.
    PERFORM dump_wa USING 'BWITH'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.
*------ Quellensteuer: Direct Input erst zu 4.0C
*  if wa+1(10) eq 'BWITH' and
*     function = 'D'.
*    message i199 with beleg_count satz2_count wa+1(10).
*    message i016.
*    perform dump_wa using 'BBKPF'.
*    bwith = i_bwith.
*    bwith = wa.
*    message i017.
*    perform dump_wa using 'BWITH'.
*    message a013.
*  endif.

*------- Tabellen in erlaubter Reihenfolge (bei FB05)? -----------------
  IF bbkpf-tcode = 'FB05' or bbkpf-tcode = 'FB05L'. "1527033
    IF wa+1(30) EQ 'BBSEG'.
      IF bselk NE i_bselk
      OR bselp NE i_bselp.
        PERFORM log_msg USING c_msgid 'I' '166'
                              beleg_count space space space.
        PERFORM log_msg USING c_msgid 'I' '016'
                              space space space space.
        PERFORM dump_wa USING 'BBKPF'.
        bbseg = i_bbseg.
        bbseg = wa.                                         "#EC ENHOK
        PERFORM log_msg USING c_msgid 'I' '017'
                              space space space space.
        PERFORM dump_wa USING 'BBSEG'.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.
    ENDIF.
    IF  wa+1(30)   EQ 'BSELP'
    OR  wa+1(30)   EQ 'ZSELP'.
      IF bselk      EQ i_bselk.
        PERFORM log_msg USING c_msgid 'I' '167'
                              beleg_count space space space.
        PERFORM log_msg USING c_msgid 'I' '016'
                              space space space space.
        PERFORM dump_wa USING 'BBKPF'.
        PERFORM log_msg USING c_msgid 'I' '017'
                              space space space space.
        bselp = i_bselp.
        bselp = wa.                                         "#EC ENHOK
        PERFORM dump_wa USING 'BSELP'.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               "datensatz_pruefen

*eject
*-----------------------------------------------------------------------
*        Form  DATENSATZ_TRANSPORTIEREN
*-----------------------------------------------------------------------
*        Datensatz (Typ 2) verarbeiten
*        Falls der Kunde eigene Strukturen verwendet, sind diese
*        bereits in die B-Strukturen ¨¹bertragen worden
*-----------------------------------------------------------------------
FORM datensatz_transportieren.

  DATA: bankdata(1) TYPE c.

  CASE wa+2(09).

*-----------------------------------------------------------------------
*        BBSEG Belegsegment
*-----------------------------------------------------------------------
    WHEN 'BSEG'.
      save_tbnam = 'BBSEG'.

      PERFORM bbseg_erweiterung_pruefen.

*------- Pr¨¹fen und #bertragen der Kontonummer (DUMMYX/NEWKO) ----------
      IF  bbseg-dummyx(1) NE nodata                         "Note 559106
      AND bbseg-dummyx    NE space                          "Note 559106
      AND bbseg-newko(1)  NE nodata
      AND bbseg-newko     NE space
      AND bbseg-dummyx    NE bbseg-newko.                   "Note 559106
        PERFORM log_msg USING c_msgid 'I' '175'
                beleg_count satz2_count bbseg-dummyx space. "Note 559106
        PERFORM log_msg USING c_msgid 'I' '176'
                              bbseg-newko space space space.
        PERFORM log_msg USING c_msgid 'I' '177'
                              space space space space.
        PERFORM log_msg USING c_msgid 'I' '016'
                              space space space space.
        PERFORM dump_wa USING 'BBKPF'.
        PERFORM log_msg USING c_msgid 'I' '017'
                              space space space space.
        PERFORM dump_wa USING 'BBSEG'.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.
      IF  bbseg-dummyx(1) NE nodata                         "Note 559106
      AND bbseg-dummyx    NE space                          "Note 559106
      AND bbseg-newko(1)  NE nodata
      AND bbseg-newko     NE space
      AND bbseg-dummyx    EQ bbseg-newko.                   "Note 559106
        CLEAR bbseg-dummyx.                                 "Note 559106
        bbseg-dummyx = nodata.                              "Note 559106
      ENDIF.
      IF  bbseg-dummyx(1) NE nodata                         "Note 559106
      AND bbseg-dummyx    NE space.                         "Note 559106
        bbseg-newko = bbseg-dummyx.                         "Note 559106
        CLEAR bbseg-dummyx.                                 "Note 559106
        bbseg-dummyx = nodata.                              "Note 559106
      ENDIF.

      IF bbseg-newko    EQ space
      OR bbseg-newko(1)    EQ nodata.
        PERFORM log_msg USING c_msgid 'I' '145'
                              beleg_count satz2_count space space.
        PERFORM log_msg USING c_msgid 'I' '016'
                              space space space space.
        PERFORM dump_wa USING 'BBKPF'.
        PERFORM log_msg USING c_msgid 'I' '017'
                              space space space space.
        PERFORM dump_wa USING 'BBSEG'.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.

* Entweder Finanzposition FIPOS oder FIPEX f¨¹llen.
* Beim gef¨¹lltem FIPOS wird das FIPEX ignoriert.
      IF  bbseg-fipos(1) NE nodata
      AND bbseg-fipos    NE space
      AND bbseg-fipex(1) NE nodata
      AND bbseg-fipex    NE space.
        PERFORM log_msg USING c_msgid 'I' '060'
                              beleg_count satz2_count 'FIPOS' 'FIPEX'.
        PERFORM log_msg USING c_msgid 'I' '061'
                              beleg_count satz2_count 'FIPEX' space.
        PERFORM log_msg USING c_msgid 'I' '899'
                              'BBSEG-FIPOS' '=' bbseg-fipos space.
        PERFORM log_msg USING c_msgid 'I' '899'
                              'BBSEG-FIPEX' '=' bbseg-fipex space.
        CLEAR bbseg-fipex.
        bbseg-fipex = nodata.
      ENDIF.

* Inhalt von FKBER in FKBER_LONG schreiben.
* Falls beide Felder gef¨¹llt sind, wird FKBER ignoriert
      IF bbseg-fkber(1) NE nodata

      AND bbseg-fkber   NE space.
        IF bbseg-fkber_long(1) NE nodata
        AND bbseg-fkber_long NE space.
          PERFORM log_msg USING c_msgid 'I' '060'
                          beleg_count satz2_count 'FKBER' 'FKBER_LONG'.
          PERFORM log_msg USING c_msgid 'I' '061'
                          beleg_count satz2_count 'FKBER' space.
          PERFORM log_msg USING c_msgid 'I' '899'
                          'BBSEG-FKBER' '=' bbseg-fkber space.
          PERFORM log_msg USING c_msgid 'I' '899'
                          'BBSEG-FKBER_LONG' '=' bbseg-fkber_long space.
        ELSE.
          bbseg-fkber_long = bbseg-fkber.
        ENDIF.
        CLEAR bbseg-fkber.
        bbseg-fkber(1) = nodata.
      ENDIF.

      IF  bbseg-kursr(1)   NE nodata
      AND bbseg-kursr      NE space
      AND bbseg-kursr_m(1) NE nodata
      AND bbseg-kursr_m    NE space.
        PERFORM log_msg USING c_msgid 'I' '060'
                              beleg_count satz2_count 'KURSR' 'KURSR_M'.
        PERFORM log_msg USING c_msgid 'I' '016'
                              space space space space.
        PERFORM dump_wa USING 'BBKPF'.
        PERFORM log_msg USING c_msgid 'I' '017'
                              space space space space.
        PERFORM dump_wa USING 'BBSEG'.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.

*---- IBAN -------------------------------------------------------
      IF bbseg-iban(1) NE nodata OR bbseg-valid_from(1) NE nodata.
        CALL FUNCTION 'FUNCTION_EXISTS'
          EXPORTING
            funcname           = 'FI_TECH_ACCNO_CHECK'
          EXCEPTIONS
            function_not_exist = 1
            OTHERS             = 2.

        IF sy-subrc NE 0.
*         IBAN with bank account no.
          IF bbseg-iban(1)       EQ nodata OR
             bbseg-valid_from(1) EQ nodata OR
             bbseg-bankn(1)      EQ nodata OR
             bbseg-bankl(1)      EQ nodata OR
             bbseg-banks(1)      EQ nodata.
            bbseg-iban  = nodata.
            bbseg-valid_from = nodata.
            PERFORM log_msg USING c_msgid 'I' '061'
                    beleg_count satz2_count 'IBAN' space.
            IF bbseg-bankn(1) EQ nodata OR
               bbseg-banks(1) EQ nodata OR
               bbseg-bankl(1) EQ nodata.
              PERFORM log_msg USING 'F8' 'I' '025'
                      space space space space.
            ENDIF.
          ENDIF.
        ELSE.
*         If IBAN has been filled bank data will be ignored
          IF bbseg-iban(1) NE nodata.                          "1520536
            IF bbseg-bankn(1)  NE nodata.                      "1520536
              bbseg-bankn(1) = NODATA.                         "1520536
              PERFORM log_msg USING c_msgid 'I' '061'          "1520536
                      beleg_count satz2_count 'BANKN' space.   "1520536
            ENDIF.                                             "1520536
            IF bbseg-valid_from(1) NE nodata.                  "1520536
              PERFORM log_msg USING c_msgid 'I' '061'          "1520536
                   beleg_count satz2_count 'VALID_FROM' space. "1520536
            ENDIF.                                             "1520536
          ENDIF.
        ENDIF.             "function exists
      ENDIF.               "batch input file contains iban

*------ Kontoart ermitteln
      PERFORM kontoart_ermitteln.
      bbseg_count = bbseg_count + 1.

*------ Quellensteuer: Z#hler inkrementieren (Debitor/Kreditor-Zeilen)
      IF xtbsl-koart = 'D' OR
         xtbsl-koart = 'K'.
        wt_count = wt_count + 1.
      ENDIF.

*begin of insertion note 1293641
*       JVA for the company code active?
      IF prodper_exist is initial.
        select count(*) from dd03l where tabname eq 'BBSEG'
                         and   fieldname eq 'PRODPER'
                         and   AS4LOCAL eq 'A'.
        IF sy-dbcnt > 0.
          prodper_exist = 'Y'.
        ELSE.
          prodper_exist = 'N'.
        ENDIF.
      ENDIF.

      IF prodper_exist = 'Y'.
        CLEAR CHAR.
        CHAR(5)    = 'BBSEG'.
        CHAR+5(1)  = '-'.
        CHAR+6(10) = 'PRODPER'.
        ASSIGN (CHAR) TO <F1>.
        IF <F1>+0(1) NE NODATA.
          IF bbseg-newbk(1) NE nodata AND
             bbseg-newbk NE space.
            bukrs = bbseg-newbk.
          ELSE.
            bukrs = bbkpf-bukrs.
          ENDIF.
          CLEAR xjva.
          LOOP AT xjva WHERE bukrs = bukrs.
            EXIT.
          ENDLOOP.
          IF sy-subrc NE 0.
            SELECT SINGLE bukrs xjvaa INTO CORRESPONDING FIELDS OF xjva
            FROM t001
            WHERE bukrs = bukrs.

            CLEAR xjva-pm_active.
            IF xjva-xjvaa NE space.
              CALL FUNCTION 'FUNCTION_EXISTS'
                EXPORTING
                  FUNCNAME           = 'JV_PM_ACTIVE'
                EXCEPTIONS
                  FUNCTION_NOT_EXIST = 1
                  OTHERS             = 2.

              IF sy-subrc = 0.
                call function 'JV_PM_ACTIVE'                "#EC EXISTS
                 EXPORTING
                   i_bukrs     = bukrs
                 IMPORTING
                   e_pm_active = xjva-pm_active.
              ENDIF.
            ENDIF.
            APPEND xjva.
          ENDIF.
          IF xjva-pm_active IS INITIAL.
            clear <F1>.
            <F1> = NODATA.
            PERFORM log_msg USING c_msgid 'I' '061'
                 beleg_count satz2_count 'PRODPER' space.
          ENDIF.
        ENDIF.
      ENDIF.
*end of insertion note 1293641

      PERFORM fill_ftpost_with_bbseg_data USING bbseg_count.
      PERFORM fill_fttax_from_bbseg.

*-----------------------------------------------------------------------
*        BWITH Quellensteuer
*-----------------------------------------------------------------------
    WHEN 'WITH'.
      IF bwith-witht    EQ space
      OR bwith-witht(1)    EQ nodata.
        PERFORM log_msg USING c_msgid 'I' '145'
                              beleg_count satz2_count space space.
        PERFORM log_msg USING c_msgid 'I' '016'
                              space space space space.
        PERFORM dump_wa USING 'BBKPF'.
        PERFORM log_msg USING c_msgid 'I' '017'
                              space space space space.
        PERFORM dump_wa USING 'BWITH'.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.

      PERFORM fill_ftpost_with_bwith_data USING bbseg_count.

*-----------------------------------------------------------------------
*        BBSEG Belegsteuern
*-----------------------------------------------------------------------
    WHEN 'BTAX'.
      IF ( bbtax-fwbas(1) NE nodata                        "note 692986
      OR   bbtax-hwbas(1) NE nodata                        "note 692986
      OR   bbtax-h2bas(1) NE nodata                        "note 692986
      OR   bbtax-h3bas(1) NE nodata )                      "note 692986
      AND  function NE 'D'.                                "note 692986
        PERFORM log_msg USING c_msgid 'I' '196'            "note 692986
                              'BBTAX-FWBAS' 'BBTAX-HWBAS'  "note 692986
                              'BBTAX-H2BAS' space.         "note 692986
      ENDIF.                                               "note 692986
      IF bbseg_tax = 'X'.
*       Abbruch: Steuern entweder neu oder alt ¨¹bergeben
        PERFORM log_msg USING c_msgid 'I' '178'
                              beleg_count satz2_count space space.
        PERFORM log_msg USING c_msgid 'I' '179'
                              space space space space.
        PERFORM log_msg USING c_msgid 'I' '016'
                              space space space space.
        PERFORM dump_wa USING 'BBKPF'.
        PERFORM log_msg USING c_msgid 'I' '017'
                              space space space space.
        PERFORM dump_wa USING 'BBSEG'.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.
      IF bbkpf-xmwst = 'X'.
*------ Abbruch: Steuern entweder rechnen oder BBTAX ¨¹bergeben -------
        PERFORM log_msg USING c_msgid 'I' '149'
                              beleg_count satz2_count space space.
        PERFORM log_msg USING c_msgid 'I' '016'
                              space space space space.
        PERFORM dump_wa USING 'BBKPF'.
        PERFORM log_msg USING c_msgid 'I' '017'
                              space space space space.
        PERFORM dump_wa USING 'BBTAX'.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.

      PERFORM fill_fttax_with_bbtax_data.

*-----------------------------------------------------------------------
*        BSELK Selektionskopf (FB05)
*-----------------------------------------------------------------------
    WHEN 'SELK'.
      CLEAR xftclear.
      PERFORM move_bselk_to_save_ftclear.
*-------- Selektion mit Avis , Nach Alter sortieren ---------------
      IF bselk-avsid(1) NE nodata.     "Avis
        ftclear = save_ftclear.
        APPEND ftclear.
        CLEAR save_tbnam.
      ELSE.
        xftclear = 'X'.
        save_tbnam = 'BSELK'.
      ENDIF.

*-----------------------------------------------------------------------
*        BSELP Selektionspositionen (FB05)
*-----------------------------------------------------------------------
    WHEN 'SELP'.
      IF save_tbnam NE space.
        CASE save_tbnam.
          WHEN 'BSELP'.
          WHEN 'BSELK'.
          WHEN OTHERS.
*           vor BSELP mu# BSELP oder BSELK kommen!
            PERFORM log_msg USING c_msgid 'I' '146'
                                  beleg_count wa+1(10) space space.
            PERFORM log_msg USING c_msgid 'I' '016'
                              space space space space.
            PERFORM dump_wa USING 'BBKPF'.
            PERFORM log_abort USING c_msgid '013'.
        ENDCASE.
      ENDIF.
      save_tbnam = 'BSELP'.
      PERFORM fill_ftclear_with_bselp_data.
  ENDCASE.
ENDFORM.                               "datensatz_transportieren

*eject
*-----------------------------------------------------------------------
*        Form  DUMP_WA
*-----------------------------------------------------------------------
*        Im Abbruchfall soll der fehlerhafte Satz ausgedumpt werden.
*-----------------------------------------------------------------------
FORM dump_wa USING table.
  CALL FUNCTION 'NAMETAB_GET'
    EXPORTING
      langu          = sy-langu
      tabname        = table
    TABLES
      nametab        = nametab
    EXCEPTIONS
      no_texts_found = 1.
  LOOP AT nametab.
    CLEAR char.
    char(5)    = nametab-tabname.
    char+5(1)  = '-'.
    char+6(10) = nametab-fieldname.
    ASSIGN (char) TO <f1>.
    wert = <f1>.
    PERFORM log_msg USING c_msgid 'I' '014'
                           char wert space space.

  ENDLOOP.
ENDFORM.                               "dump_wa


*eject
*-----------------------------------------------------------------------
*        Form  KOPFSATZ_LESEN
*-----------------------------------------------------------------------
*        Kopfdaten in Workarea lesen
*-----------------------------------------------------------------------
FORM kopfsatz_lesen.
  CLEAR wa.
  READ DATASET ds_name INTO wa.

*------- End of File erreicht ? --> Exit -------------------------------
  IF sy-subrc NE 0.
    xeof = 'X'.
    EXIT.
  ENDIF.

  IF wa(1) NE '1'.
    PERFORM log_msg USING c_msgid 'I' '151'
                          group_count space space space.
    PERFORM log_msg USING c_msgid 'I' '015'
                          space space space space.
    PERFORM dump_wa USING 'BGR00'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.
ENDFORM.                               "kopfsatz_lesen

*eject
*-----------------------------------------------------------------------
*        Form  KOPFSATZ_BEARBEITEN
*-----------------------------------------------------------------------
*        Transportieren und bearbeiten
*        der eingelesenen Belegkopfdaten.
*        Globale BI-Feldtabelle initialisieren .
*        Schalter und Strukturen initialisieren.
*-----------------------------------------------------------------------
FORM kopfsatz_bearbeiten.
* REFRESH FT.
  bbkpf =  i_bbkpf.
  bbseg =  i_bbseg.
  bbtax =  i_bbtax.
  bselk =  i_bselk.
  bselp =  i_bselp.
  bwith =  i_bwith.
  CLEAR: satz2_count, satz2_cnt_akt, wt_count, bbseg_count.
  CLEAR: save_tbnam, fcode, bbseg_tax.
  REFRESH: ftpost, ftclear, fttax.
  REFRESH: t_bbkpf, t_bbseg, t_bbtax, t_bwith.

* Daten werden wegen der Feldl#nge-Erweiterung des Feldes TCODE
* von 4B (<4.0) auf 20B verschoben
  IF ( os_xon = xon ) AND ( error_run NE 'X' ).
    SHIFT wa BY 16 PLACES RIGHT.
    wa(21) = wa+16(5).
  ENDIF.

  bbkpf = wa.                                               "#EC ENHOK

  PERFORM bbkpf_erweiterung_pruefen.

  beleg_count = beleg_count + 1.
  count = count + 1.

*------ Place to set a soft break-point -------------------------------
  IF beleg_count = beleg_break.
    beleg_break = beleg_count.
  ENDIF.

*------- Tcode ¨¹bergeben / Tcode erlaubt ? ----------------------------
  IF bbkpf-tcode(1) EQ nodata
  OR bbkpf-tcode    EQ space.
    PERFORM log_msg USING c_msgid 'I' '161'
                          beleg_count space space space.
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.
  IF  bbkpf-tcode NE 'FB01'
  AND bbkpf-tcode NE 'FBS1'
  AND bbkpf-tcode NE 'FBB1'                                 "P30K125019
  AND bbkpf-tcode NE 'FB05'    "1527033
  AND bbkpf-tcode NE 'FB05L'
  AND bbkpf-tcode NE 'FBV1'
  AND bbkpf-tcode NE 'FBCB'.           "4.0
    PERFORM log_msg USING c_msgid 'I' '154'
                          beleg_count bbkpf-tcode space space.
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

  IF bbkpf-tcode  = 'FB05' and BBKPF-LDGRP(1) ne nodata. "1626148
    bbkpf-tcode = 'FB05L'.                             "1527033
  endif.                                               "1527033
*------- FB05: --> Ausgleichsvorgang auf G¨¹ltigkeit ¨¹berpruefne --------
  IF  bbkpf-tcode  = 'FB05' or bbkpf-tcode = 'FB05L'.
    PERFORM auglv_pruefen.
  ENDIF.

*------- BBKPF-Bukrs ¨¹bergeben / merken ------------------------
  IF bbkpf-bukrs(1) EQ nodata
  OR bbkpf-bukrs    EQ space.
    PERFORM log_msg USING c_msgid 'I' '160'
                          beleg_count space space space.
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

  bukrs = bbkpf-bukrs.

  IF  bbkpf-kursf(1)   NE nodata
  AND bbkpf-kursf      NE space
  AND bbkpf-kursf_m(1) NE nodata
  AND bbkpf-kursf_m    NE space.
    PERFORM log_msg USING c_msgid 'I' '210'
                          beleg_count 'KURSF' 'KURSF_M' space.
    PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
    PERFORM dump_wa USING 'BBKPF'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

  IF bbkpf-tcode = 'FBCB'.                                    "1562986
    IF bbkpf-budat(1) ne nodata.                              "1562986
      bbkpf-budat(1) = nodata.                                "1562986
      PERFORM log_msg USING c_msgid 'I' '061'                 "1562986
                            beleg_count 'BKPF' 'BUDAT' space. "1562986
    ENDIF.                                                    "1562986
    IF bbkpf-monat(1) ne nodata.                              "1562986
      bbkpf-monat(1) = nodata.                                "1562986
      PERFORM log_msg USING c_msgid 'I' '061'                 "1562986
                            beleg_count 'BKPF' 'MONAT' space. "1562986
    ENDIF.                                                    "1562986
  ENDIF.                                                      "1562986

  PERFORM fill_ftpost_with_bbkpf_data.
  bbkpf_ok = 'X'.
ENDFORM.                               "kopfsatz_bearbeiten

*eject
*-----------------------------------------------------------------------
*        Form  MAPPE_OEFFNEN
*-----------------------------------------------------------------------
*        #ffnen der Buchungsschnittstelle
*-----------------------------------------------------------------------
FORM mappe_oeffnen.

  CHECK function NE 'D'.

*-------- Interne Buchungsschnittstelle initialisieren
  CALL FUNCTION 'POSTING_INTERFACE_START'
    EXPORTING
      i_function = function
      i_client   = bgr00-mandt
      i_group    = bgr00-group
      i_xbdcc    = xbdcc
      i_holddate = bgr00-start
      i_keep     = bgr00-xkeep
      i_mode     = anz_mode
      i_update   = update
      i_user     = bgr00-usnam.

  IF function = 'B'.
    PERFORM log_msg USING c_msgid 'I' '007'
                          group_count bgr00-group space space.
  ENDIF.
  group_open = 'X'.
ENDFORM.                               "mappe_oeffnen


*eject
*-----------------------------------------------------------------------
*        Form  MAPPE_PRUEFEN_OEFFNEN
*-----------------------------------------------------------------------
*        Pr¨¹fen/Bearbeiten der Daten im Mappenvorsatz.
*        Sonderzeichen f¨¹r NODATA bestimmen
*        #ffnen der BDC-Queue f¨¹r Datentransfer
*        Initialstrukturen mit NODATA erzeugen
*-----------------------------------------------------------------------
FORM mappe_pruefen_oeffnen.
  CLEAR bgr00.
  bgr00 = wa.                                               "#EC ENHOK
  group_count = group_count + 1.

*------- Mappenname gesetzt ? ------------------------------------------
  IF bgr00-group = space.
    PERFORM log_msg USING c_msgid 'I' '011'
                          group_count space space space.
    PERFORM log_msg USING c_msgid 'I' '015'
                          space space space space.
    PERFORM dump_wa USING 'BGR00'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

*------- Mandant gesetzt / richtig gesetzt? ----------------------------
  IF bgr00-mandt IS INITIAL.
    PERFORM log_msg USING c_msgid 'I' '005'
                          group_count space space space.
    PERFORM log_msg USING c_msgid 'I' '015'
                          space space space space.
    PERFORM dump_wa USING 'BGR00'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.
  IF bgr00-mandt NE sy-mandt.
    PERFORM log_msg USING c_msgid 'I' '006'
                          group_count bgr00-mandt sy-mandt space.
    PERFORM log_msg USING c_msgid 'I' '015'
                          space space space space.
    PERFORM dump_wa USING 'BGR00'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

*------- Username gesetzt ? --------------------------------------------
  IF bgr00-usnam = space.
    PERFORM log_msg USING c_msgid 'I' '009'
                          group_count space space space.
    PERFORM log_msg USING c_msgid 'I' '015'
                          space space space space.
    PERFORM dump_wa USING 'BGR00'.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

*------- Sonderzeichen NODATA pr¨¹fen/¨¹bernehmen -----------------------
  IF bgr00-nodata = space.
    nodata = c_nodata.
  ELSE.
    IF bgr00-nodata BETWEEN '0' AND '9'
    OR bgr00-nodata BETWEEN 'A' AND 'I'
    OR bgr00-nodata BETWEEN 'J' AND 'R'
    OR bgr00-nodata BETWEEN 'S' AND 'Z'
    OR bgr00-nodata BETWEEN 'a' AND 'i'
    OR bgr00-nodata BETWEEN 'j' AND 'r'
    OR bgr00-nodata BETWEEN 's' AND 'z'
    OR bgr00-nodata EQ      '+'        " wegen Zentrale
    OR bgr00-nodata EQ      '*'        " wegen Mehrwertst. rechnen
    OR bgr00-nodata EQ      '='.       " wegen Matchcode
      PERFORM log_msg USING c_msgid 'I' '010'
                            group_count bgr00-nodata space space.
      PERFORM log_msg USING c_msgid 'I' '015'
                            space space space space.
      PERFORM dump_wa USING 'BGR00'.
      PERFORM log_abort USING c_msgid '013'.
    ENDIF.
    nodata = bgr00-nodata.
  ENDIF.
  PERFORM log_msg USING c_msgid 'I' '012'
                        group_count nodata space space.


*------- Mappe #ffnen --------------------------------------------------
  IF  fl_check = space.
    PERFORM mappe_oeffnen.
  ENDIF.

*------- Flags, Z#hler initialisieren ----------------------------------
  CLEAR: xnewg, beleg_count, satz2_count, satz2_cnt_akt, wt_count.

*------- Initialstrukturen erzeugen (NODATA-Sonderzeichen --------------
  IF nodata NE nodata_old.
    PERFORM init_strukturen_erzeugen(rfbibli0) USING nodata.
    PERFORM init_bbkpf(rfbibli0) USING i_bbkpf.
    PERFORM init_bbseg(rfbibli0) USING i_bbseg.
    PERFORM init_bbtax(rfbibli0) USING i_bbtax.
    PERFORM init_bselk(rfbibli0) USING i_bselk.
    PERFORM init_bselp(rfbibli0) USING i_bselp.
    PERFORM init_bwith(rfbibli0) USING i_bwith.
    nodata_old = nodata.
  ENDIF.
ENDFORM.                               "mappe_pruefen_oeffnen

*eject
*-----------------------------------------------------------------------
*        Form  MAPPE_SCHLIESSEN
*-----------------------------------------------------------------------
FORM mappe_schliessen.
  IF fl_check = space.
    IF group_open = 'X'.
      CALL FUNCTION 'POSTING_INTERFACE_END'.
      IF function = 'B'.
        PERFORM log_msg USING c_msgid 'I' '008'
                        group_count bgr00-group space space.
      ENDIF.
      CLEAR group_open.
    ENDIF.
  ELSE.
    IF group_count > 0.
      PERFORM log_msg USING c_msgid 'I' '019'
                      group_count bgr00-group space space.
    ENDIF.
  ENDIF.
ENDFORM.                               "mappe_schliessen

*eject
*-----------------------------------------------------------------------
*        Form  MAPPEN_WECHSEL
*-----------------------------------------------------------------------
*        Neuer Mappenvorsatz wurde gesendet.
*        Aktuelle Mappe wird geschlosssen, neue Mappe ge#ffnet.
*-----------------------------------------------------------------------
FORM mappen_wechsel.
  PERFORM mappe_schliessen.
  PERFORM mappe_pruefen_oeffnen.
ENDFORM.                               "mappen_wechsel

*eject
*-----------------------------------------------------------------------
*        Form  MESSAGE_AUSGEBEN
*-----------------------------------------------------------------------
*        'Call Transaction .. Using ..'
*        Meldung ins Protokoll ausgeben.
*-----------------------------------------------------------------------
FORM message_call_transaction.

*------- neuer Eintrag aus T100 ----------------------------------------
  IF t100-sprsl NE sy-langu
  OR t100-arbgb NE sy-msgid
  OR t100-msgnr NE sy-msgno.
    CLEAR: text, text1, text2, text3, msgvn.
    SELECT SINGLE * FROM t100 WHERE sprsl = sy-langu
                              AND   arbgb = sy-msgid
                              AND   msgnr = sy-msgno.
    IF sy-subrc = 0.
      text = t100-text.
      DO 4 TIMES VARYING msgvn FROM sy-msgv1 NEXT sy-msgv2.
        IF text CA '$'.
          REPLACE '$' WITH msgvn INTO text.
          CONDENSE text.
        ENDIF.
        IF text CA '&'.
          REPLACE '&' WITH msgvn INTO text.
          CONDENSE text.
        ENDIF.
      ENDDO.
      text1 = text(40).
      text2 = text+40(40).
      text3 = text+80(40).
      PERFORM log_msg USING c_msgid 'I' '172'
                      beleg_count text1 text2 text3.
    ELSE.
      PERFORM log_msg USING c_msgid 'I' '173'
                      beleg_count sy-msgno sy-msgv1 sy-msgv2.
    ENDIF.

*------- gleicher Eintrag aus T100 -------------------------------------
  ELSE.
    IF text NE space.
      CLEAR: text, text1, text2, text3, msgvn.
      text = t100-text.
      DO 4 TIMES VARYING msgvn FROM sy-msgv1 NEXT sy-msgv2.
        IF text CA '$'.
          REPLACE '$' WITH msgvn INTO text.
          CONDENSE text.
        ENDIF.
        IF text CA '&'.
          REPLACE '&' WITH msgvn INTO text.
          CONDENSE text.
        ENDIF.
      ENDDO.
      text1 = text(40).
      text2 = text+40(40).
      text3 = text+80(40).
      PERFORM log_msg USING c_msgid 'I' '172'
                      beleg_count text1 text2 text3.
    ELSE.
      PERFORM log_msg USING c_msgid 'I' '173'
                      beleg_count sy-msgno sy-msgv1 sy-msgv2.
    ENDIF.
  ENDIF.
ENDFORM.                               "message_call_transaction

*eject
*-----------------------------------------------------------------------
*        Form  SAVE_DATENSATZ_BEARBEITEN
*-----------------------------------------------------------------------
FORM save_datensatz_bearbeiten.
  satz2_cnt_akt = satz2_count.

ENDFORM.                               "save_datensatz_bearbeiten

*eject
*-----------------------------------------------------------------------
*        Form  KONTOART_ERMITTELN.
*-----------------------------------------------------------------------
FORM kontoart_ermitteln.

  LOOP AT xtbsl WHERE bschl = bbseg-newbs.
    EXIT.
  ENDLOOP.
  IF sy-subrc NE 0.
    SELECT SINGLE * FROM tbsl WHERE bschl = bbseg-newbs.
    IF sy-subrc = 0.
      xtbsl = tbsl.
      APPEND xtbsl.
    ELSE.
      PERFORM log_msg USING c_msgid 'I' '156'
                            beleg_count satz2_cnt_akt bbseg-newbs space.
      PERFORM log_msg USING c_msgid 'I' '016'
                            space space space space.
      PERFORM dump_wa USING 'BBKPF'.
      PERFORM log_msg USING c_msgid 'I' '017'
                            space space space space.
      PERFORM dump_wa USING 'BBSEG'.
      PERFORM log_abort USING c_msgid '013'.
    ENDIF.
  ENDIF.
ENDFORM.                               "kontoart_ermitteln

*eject
*-----------------------------------------------------------------------
*        Form  VBUND_SENDEN
*-----------------------------------------------------------------------
FORM vbund_senden.
* CHECK FL_CHECK = SPACE.
*
* CLEAR FT.
* FT-PROGRAM  = 'SAPLF014'.
* FT-DYNPRO   = '0100'.
* FT-DYNBEGIN = 'X'.
* APPEND FT.
*
* CLEAR FT.
* FT-FNAM = 'RF014-VBUND'.
* FT-FVAL = BBKPF-VBUND.
* APPEND FT.
*
ENDFORM.                               "vbund_senden


*eject
*-----------------------------------------------------------------------
*        Form  MOVE_BSELK_TO_SAVE_FTCLEAR.
*-----------------------------------------------------------------------
*        Selektionskopfdaten in SAVE_FTCLEAR sichern f¨¹r
*        Initialisierung von FTCLEAR
*-----------------------------------------------------------------------
FORM move_bselk_to_save_ftclear.
  CLEAR save_ftclear.
  IF bselk-agkon(1) NE nodata.
    save_ftclear-agkon = bselk-agkon.
  ENDIF.
  IF bselk-agkoa(1) NE nodata.
    save_ftclear-agkoa = bselk-agkoa.
  ENDIF.
  IF bselk-xnops(1) NE nodata.
    save_ftclear-xnops = bselk-xnops.
  ENDIF.
  IF bselk-agbuk(1) NE nodata.
    save_ftclear-agbuk = bselk-agbuk.
  ENDIF.
  IF bselk-agums(1) NE nodata.
    save_ftclear-agums = bselk-agums.
  ENDIF.
  IF bselk-avsid(1) NE nodata.         "Avis
    save_ftclear-avsid = bselk-avsid.  "Avis
  ENDIF.                               "Avis
  IF bselk-xfifo(1) NE nodata.
    save_ftclear-xfifo = bselk-xfifo.
  ENDIF.
ENDFORM.                               "move_bselk_to_save_ftclear


*eject
*-----------------------------------------------------------------------
*        Form  FILL_FTTAX_FROM_BBSEG.
*-----------------------------------------------------------------------
*  Diese Routine hat die Aufgabe die FTTAX mit Daten aus BBSEG zu f¨¹llen
*  Durch das neue Steuerhandling ab 2.2 sind die Steuerdaten in FTTAX
*  zu ¨¹bergeben.
*  Durch diese Routine wird in einfachen F#llen eine Aufw#rts-
*  kompatibilit#t gew#hrleistet
*-----------------------------------------------------------------------
FORM fill_fttax_from_bbseg.
  CLEAR fttax.
  IF       xtbsl-koart  =  'S'
  AND (    bbseg-wmwst(1) NE nodata
        OR bbseg-mwsts(1) NE nodata ).
    IF bbkpf-xmwst  = 'X'.
*     Abbruch: Wenn XMWST ¨¹bergeben,mu# in Steuerfeldern NODATA stehen
      PERFORM log_msg USING c_msgid 'I' '148'
                            beleg_count satz2_count space space.
      PERFORM log_msg USING c_msgid 'I' '899'
                            'BBSEG-WMWST' '=' bbseg-wmwst space.
      PERFORM log_msg USING c_msgid 'I' '899'
                            'BBSEG-MWSTS' '=' bbseg-mwsts space.
      PERFORM dump_wa USING 'BBKPF'.
      PERFORM log_abort USING c_msgid '013'.
    ENDIF.

*------- Steuer wird ¨¹ber BBSEG versorgt ------------------------------
    bbseg_tax = 'X'.

*------- Ausstieg bei Direct Input wg. Performance --------------------
    CHECK function NE 'D'.                                  "30C

    IF bbseg-wmwst = '*' OR bbseg-mwsts = '*'.
      READ TABLE ftpost INDEX 1.
      IF ftpost-fnam NE 'BKPF-XMWST'.
        CLEAR: ftpost.
        ftpost-stype = 'K'.
        ftpost-count = '001'.
        ftpost-fnam = 'BKPF-XMWST'.
        ftpost-fval = 'X'.
        INSERT ftpost INDEX 1.
      ENDIF.
    ELSE.
      IF bbseg-wmwst(1) NE nodata.
        fttax-fwste = bbseg-wmwst.
      ENDIF.
      IF bbseg-mwsts(1) NE nodata.
        fttax-hwste = bbseg-mwsts.
      ENDIF.
      fttax-mwskz = bbseg-mwskz.
      fttax-bschl = bbseg-newbs.
      fttax-txjcd = bbseg-txjcd.                              "N1939681
      APPEND fttax.
    ENDIF.
  ENDIF.
ENDFORM.                               "fill_fttax_from_bbseg

*eject
************************************************************************
*      Include   Generiertes Coding ......
************************************************************************
INCLUDE rfbibl02.

*&---------------------------------------------------------------------*
*&      Form  LOOP_AT_TABLE_TFILE
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM loop_at_table_tfile.
  DATA: counter(5) TYPE n.
  CLEAR group_count .

  PERFORM set_global_variable.

  DO.
    counter = counter + 1.
    IF function NE 'B' AND sy-batch = 'X'.
      jobid_ext+27(5) = counter.
      IMPORT tfile FROM DATABASE tfsave(fi) ID jobid_ext.
      IF sy-subrc <> 0 .
        EXIT.
      ENDIF.
    ELSE.
      IF counter > 1.
        EXIT.
      ENDIF.
    ENDIF.

    LOOP AT tfile.
      wa = tfile-rec.
      IF sy-tabix = 1 AND counter = 1.
*------- erster Satz muss Mappensatz sein ------------------------------
        IF wa(1) NE '0'.
          PERFORM log_msg USING c_msgid 'I' '004'
                                ds_name space space space.
          PERFORM log_abort USING c_msgid '013'.
        ENDIF.
        save_bgr00 = wa.                                    "#EC ENHOK
      ENDIF.

      CASE wa(1).
        WHEN '0'.
*------- neue Mappe ----------------------------------------------------
          PERFORM letzten_beleg_abschliessen.
          PERFORM mappen_wechsel.
        WHEN '1'.

*------- Kopfsatz ------------------------------------------------------
*------- Beleg abschliessen --------------------------------------------
          PERFORM letzten_beleg_abschliessen.
          PERFORM kopfsatz_bearbeiten.
          PERFORM fill_t_bbkpf.
          REFRESH ertab.
          ertab-rec = wa-char1.                             "N1847840
          APPEND ertab.
        WHEN '2'.
*------- Belegsegment --------------------------------------------------
          PERFORM datensatz_pruefen.
          satz2_cnt_akt = satz2_count - 1.
          PERFORM wa_daten_uebertragen.
          PERFORM datensatz_transportieren.
          PERFORM fill_t_bbseg.
          PERFORM fill_t_bwith.
          PERFORM fill_t_bbtax.
          ertab-rec = wa-char1.                             "N1847840
          APPEND ertab.
        WHEN OTHERS.
*------- ung¨¹ltiger Satztyp --------------------------------------------
          satz2_count = satz2_count + 1.
          PERFORM log_msg USING c_msgid 'I' '152'
                          beleg_count satz2_count wa(1) space.
          PERFORM log_msg USING c_msgid 'I' '016'
                          space space space space.
          PERFORM dump_wa USING 'BBKPF'.
          PERFORM log_abort USING c_msgid '013'.
      ENDCASE.
    ENDLOOP.

    REFRESH tfile.
  ENDDO.
  PERFORM letzten_beleg_abschliessen.

  PERFORM mappe_schliessen.
*------- letzter CALL_BI_END_AKT_NUMBER  -------------------------------
  PERFORM call_bi_end_akt_number.
  COMMIT WORK.
  CALL FUNCTION 'DEQUEUE_ALL'.
  CLEAR commit_count.
ENDFORM.                               " LOOP_AT_TABLE_TFILE



*&---------------------------------------------------------------------*
*&      Form  READ_DATASET_INTO_TABLE_TFILE
*&---------------------------------------------------------------------*
*       lesen der Datei und speichers der S#tze in Tabelle TFILE       *
*----------------------------------------------------------------------*
FORM read_dataset_into_table_tfile.
  DATA: new_pak TYPE i.
  DATA: counter(5) TYPE n.
*------- Datei #ffnen -----------------------------------------------

* begin "n1592941
  CALL FUNCTION 'FILE_VALIDATE_NAME'
    EXPORTING
      logical_filename  = gc_filename
      parameter_1       = sy-cprog
    CHANGING
      physical_filename = ds_name
    EXCEPTIONS
      OTHERS            = 1.

  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
* end "n1592941
  IF xnonunic = space.
    OPEN DATASET ds_name IN TEXT MODE
      ENCODING UTF-8
      FOR INPUT
      SKIPPING BYTE-ORDER MARK
      IGNORING CONVERSION ERRORS.
  ELSE.
    OPEN DATASET ds_name IN TEXT MODE ENCODING NON-UNICODE
      FOR INPUT IGNORING CONVERSION ERRORS.
  ENDIF.
  IF sy-subrc NE 0.
    PERFORM log_msg USING c_msgid 'I' '002'
                          ds_name space space space.
    PERFORM log_abort USING c_msgid '013'.
  ENDIF.

*------- Sonderzeichen in Struktur trans definieren-----------------

  CLASS cl_abap_conv_in_ce DEFINITION LOAD.

  trans-x   = cl_abap_conv_in_ce=>uccp( '0000' ).
  trans-soh = cl_abap_conv_in_ce=>uccp( '0001' ).
  trans-stx = cl_abap_conv_in_ce=>uccp( '0002' ).
  trans-etx = cl_abap_conv_in_ce=>uccp( '0003' ).
  trans-eot = cl_abap_conv_in_ce=>uccp( '0004' ).
  trans-enq = cl_abap_conv_in_ce=>uccp( '0005' ).
  trans-ack = cl_abap_conv_in_ce=>uccp( '0006' ).
  trans-bel = cl_abap_conv_in_ce=>uccp( '0007' ).
  trans-bs  = cl_abap_conv_in_ce=>uccp( '0008' ).
  trans-ht  = cl_abap_conv_in_ce=>uccp( '0009' ).
  trans-lf  = cl_abap_conv_in_ce=>uccp( '000A' ).
  trans-vt  = cl_abap_conv_in_ce=>uccp( '000B' ).
  trans-ff  = cl_abap_conv_in_ce=>uccp( '000C' ).
  trans-cr  = cl_abap_conv_in_ce=>uccp( '000D' ).
  trans-so  = cl_abap_conv_in_ce=>uccp( '000E' ).
  trans-si  = cl_abap_conv_in_ce=>uccp( '000F' ).
  trans-dle = cl_abap_conv_in_ce=>uccp( '0010' ).
  trans-dc1 = cl_abap_conv_in_ce=>uccp( '0011' ).
  trans-dc2 = cl_abap_conv_in_ce=>uccp( '0012' ).
  trans-dc3 = cl_abap_conv_in_ce=>uccp( '0013' ).
  trans-dc4 = cl_abap_conv_in_ce=>uccp( '0014' ).
  trans-nak = cl_abap_conv_in_ce=>uccp( '0015' ).
  trans-syn = cl_abap_conv_in_ce=>uccp( '0016' ).
  trans-etb = cl_abap_conv_in_ce=>uccp( '0017' ).
  trans-can = cl_abap_conv_in_ce=>uccp( '0018' ).
  trans-em  = cl_abap_conv_in_ce=>uccp( '0019' ).
  trans-sub = cl_abap_conv_in_ce=>uccp( '001A' ).
  trans-esc = cl_abap_conv_in_ce=>uccp( '001B' ).
  trans-fs  = cl_abap_conv_in_ce=>uccp( '001C' ).
  trans-gs  = cl_abap_conv_in_ce=>uccp( '001D' ).
  trans-rs  = cl_abap_conv_in_ce=>uccp( '001E' ).
  trans-us  = cl_abap_conv_in_ce=>uccp( '001F' ).

*------- Datei lesen   -----------------------------------------------
  DO.

    CLEAR tfile.
    READ DATASET ds_name INTO tfile-rec.                   "N1847840

*------- End of File erreicht ? Exit Do-Schleife -------------------
    IF sy-subrc NE 0.
      EXIT.
    ENDIF.

    TRANSLATE tfile-rec USING trans.                       "N1847840

*------- Satz in Tabelle f¨¹llen, falls ungleich Space ---------------
    IF NOT tfile IS INITIAL.
      PERFORM check_tfile.
      APPEND tfile.
    ENDIF.

*------ beim BI (und evtl. CT und DI, falls diese nicht ueber BMV0
*------ sondern direkt durch RFBIBL00 aufgerufen wurden) existiert
*------ keine eindeutige Job-Id, daher wird die interne Tabelle TFILE
*------ am Stueck und nicht paketweise abgespeichert.
*------ Wenn man CT oder DI ueber BMV0 einplant, so ist SY-BATCH
*------ gesetzt.
    IF function NE 'B' AND sy-batch = 'X'.
      new_pak = sy-tabix MOD pack_size.
      IF new_pak = 0.
        counter = counter + 1.
        jobid_ext+27(5) = counter.
        EXPORT tfile TO DATABASE tfsave(fi) ID jobid_ext.
        REFRESH tfile.
      ENDIF.
    ENDIF.

  ENDDO.
  IF new_pak NE 0.                     "gibt es Zeilen zum Uebertragen?
    counter = counter + 1.
    jobid_ext+27(5) = counter.
    EXPORT tfile TO DATABASE tfsave(fi) ID jobid_ext.
    REFRESH tfile.
  ENDIF.

*------- Datei schliessen -------------------------------------------
  CLOSE DATASET ds_name.
ENDFORM.                               " READ_DATASET_INTO_TABLE_TFILE



*&---------------------------------------------------------------------*
*&      Form  CHECK_TFILE
*&---------------------------------------------------------------------*
*       Pr¨¹fen der Tabelle TFILE                                       *
*----------------------------------------------------------------------*
FORM check_tfile.
  STATICS: bbkpf_cnt TYPE i.
  DATA l_wa(10000) type c.                                 "N1847840

  l_wa = tfile-rec.                                        "N1847840

*------- Plausibilit#tspr¨¹fungen bei Belegk#pfen ----------------------
   IF l_wa+0(1) = '1'.                                      "N1847840
    IF  function CA 'DC'
    AND fl_check IS INITIAL.
      bbkpf_cnt = bbkpf_cnt + 1.
      IF sy-batch NE 'X'
      AND bbkpf_cnt > 50.
        PERFORM log_msg USING c_msgid 'I' '032'
                              space space space space.
        PERFORM log_abort USING c_msgid '013'.
      ENDIF.
    ENDIF.
    IF function = 'D'
    AND ( l_wa+1(4) EQ 'FB05'                              "N1847840
    OR    l_wa+1(4) EQ 'FBS1'
    OR    l_wa+1(4) EQ 'FBCB').                            "1562986
      PERFORM log_msg USING c_msgid 'I' '033'
                              space space space space.
      PERFORM log_abort USING c_msgid '013'.
    ENDIF.
  ENDIF.

ENDFORM.                               " CHECK_TFILE


*&---------------------------------------------------------------------*
*&      Form  ERROR_PROCESSING
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM error_processing.
  CHECK function NE 'B'.
  CHECK fl_check = space.
  REFRESH: efile, tfile.
  IMPORT save_bgr00 efile FROM DATABASE terrd(fi) ID jobid.
  LOOP AT efile.
    tfile = efile.
    APPEND tfile.
  ENDLOOP.
  DESCRIBE TABLE tfile LINES tfill_tfile.

  IF tfill_tfile > 0.
    IF tbist_aktiv NE 'X'.
      DELETE FROM DATABASE terrd(fi) ID jobid.
    ENDIF.
    function = 'B'.
    error_run = 'X'.
    CLEAR: startnum, all_commit, commit_count, numerror,  count.
    tfile-rec = save_bgr00.                                     "#EC ENHOK
    INSERT tfile INDEX 1.
    PERFORM loop_at_table_tfile.
  ENDIF.
ENDFORM.                               " ERROR_PROCESSING

*&---------------------------------------------------------------------*
*&      Form  LETZTEN_BELEG_ABSCHLIESSEN
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM letzten_beleg_abschliessen.

  IF count > startnum.
    IF function = 'D'.
      DESCRIBE TABLE t_bbseg LINES tfill_t_bbseg.
      IF tfill_t_bbseg > 0.
        PERFORM fast_input.
      ENDIF.
    ELSE.
      DESCRIBE TABLE ftpost LINES tfill_ftpost.
      IF tfill_ftpost > 0.
        PERFORM beleg_abschliessen.
      ENDIF.
    ENDIF.
  ENDIF.
  CLEAR: bbkpf_ok.
ENDFORM.                               " LETZTEN_BELEG_ABSCHLIESSEN

*&---------------------------------------------------------------------*
*&      Form  FAST_ENTRY
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM fast_input.
  DATA: bukrs LIKE bkpf-bukrs,
        gjahr LIKE bkpf-gjahr,
        belnr LIKE bkpf-belnr.

  CHECK fl_check = space.
  IF bbkpf-tcode = 'FB01' OR bbkpf-tcode = 'FBB1'.
*  Batch-Input FLAG for Check doc type
    sy-binpt = 'X'.
    CALL FUNCTION 'AC_DOCUMENT_DIRECT_INPUT'
      EXPORTING
        i_nodata      = nodata
        i_grpid       = bgr00-group
      IMPORTING
        e_bukrs       = bukrs
        e_gjahr       = gjahr
        e_belnr       = belnr
      TABLES
        t_bbkpf       = t_bbkpf
        t_bbseg       = t_bbseg
        t_bbtax       = t_bbtax
        t_bwith       = t_bwith
      EXCEPTIONS
        error_message = 01.
    IF sy-subrc IS INITIAL.
      IF pa_xprot = 'X'.
        PERFORM log_msg USING 'F5' 'I' '312'
                        belnr bukrs space space.
      ENDIF.
    ELSE.
      IF sy-msgty = 'A'.
        PERFORM log_msg USING sy-msgid 'I' sy-msgno
                              sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        PERFORM log_abort USING c_msgid '013'.
      ELSE.
        IF sy-batch IS INITIAL.
          PERFORM log_msg USING sy-msgid 'I' sy-msgno
                                sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.
      PERFORM export_error_data.
    ENDIF.
  ELSE.
    MESSAGE w033.
    PERFORM export_error_data.
  ENDIF.

*------- Commit Work? ------------------------------------------------
  commit_count = commit_count + 1.
  IF commit_count = max_commit.
    PERFORM call_bi_end_akt_number.
    COMMIT WORK.
    CALL FUNCTION 'DEQUEUE_ALL'.
    CLEAR commit_count.
  ENDIF.

* Refresh mu# hier erfolgen, da im Fehlerfall nicht im FBS initialisiert
* werden kann
*
  REFRESH: t_bbkpf,
           t_bbseg,
           t_bwith,
           t_bbtax.
  CLEAR:   t_bbkpf,                                         "30C
           t_bbseg,                                         "30C
           t_bwith,
           t_bbtax.                                         "30C
ENDFORM.                               " FAST_ENTRY

*&---------------------------------------------------------------------*
*&      Form  FILL_T_BBKPF
*&---------------------------------------------------------------------*
FORM fill_t_bbkpf.
  CHECK function = 'D'.
  APPEND bbkpf TO t_bbkpf.
ENDFORM.                               " FILL_T_BBKPF

*&---------------------------------------------------------------------*
*&      Form  FILL_T_BBSEG
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM fill_t_bbseg.
  CHECK function = 'D'.
  IF wa+2(9) = 'BSEG'.
*------- falls ZBSEG wurde diese bereits in BBSEG gemoved -------------
*    append bbseg to t_bbseg.
    CLEAR wa_bbseg_di.
    MOVE-CORRESPONDING bbseg TO wa_bbseg_di.
    IF xtbsl-koart = 'D' OR
       xtbsl-koart = 'K'.
      wa_bbseg_di-wt_key = wt_count.
    ENDIF.
    APPEND wa_bbseg_di TO t_bbseg.
  ENDIF.
ENDFORM.                               " FILL_T_BBSEG

*&---------------------------------------------------------------------*
*&      Form  FILL_T_BBTAX
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM fill_t_bbtax.
  CHECK function = 'D'.
  IF wa+2(9) = 'BTAX'.
    APPEND bbtax TO t_bbtax.
  ENDIF.
ENDFORM.                               " FILL_T_BBSEG

*eject
*&---------------------------------------------------------------------*
*&      Form  GET_RESTART_INFO
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM get_restart_info.
  DATA: action.                                             " thk 30F
  DATA: counter(5) TYPE n.

  CHECK function NE 'B'.                                    "30C+
  CHECK fl_check = space.                                   "30C
* Startnummer holen
  IF sy-batch = 'X'.
* THK zu 30F: Aufruf jetzt mit importing-parameter (Periodische Jobs)
*   CALL FUNCTION 'GET_JOB_RUNTIME_INFO'
*        IMPORTING
*             JOBNAME         = JOBNAME
*        EXCEPTIONS
*             NO_RUNTIME_INFO = 01.
*   IF SY-SUBRC NE 0.
*     MESSAGE A051.
*   ENDIF.
    CALL FUNCTION 'BI_GET_STARTING_NUMBER'
      IMPORTING
        jobid              = jobid
        actual_number      = startnum
        action             = action
        lasterrnum         = lasterrnum
        numerrors          = olderror
      EXCEPTIONS
        wrong_status_found = 02
        not_found          = 03.

    IF function NE 'B'.                                     "QHA30C+
      CASE sy-subrc.
        WHEN 0.                                             "QHA30C+
* begin P30K110179
          IF jobid+27(5) NE space.
            PERFORM log_msg USING c_msgid 'I' '209'
                                  jobid '27' space space.
            PERFORM log_abort USING c_msgid '013'.
          ENDIF.
          jobid_ext = jobid.
          CASE action.
            WHEN 'E'.                  " Fehler nachbuchen
              PERFORM log_msg USING c_msgid 'I' '034'
                              space space space space.
              PERFORM log_abort USING c_msgid '013'.
            WHEN ' '.                  " Neustart
              DELETE FROM DATABASE terrd(fi) ID jobid.      "31H
              DO.
                counter = counter + 1.
                jobid_ext+27(5) = counter.
                DELETE FROM DATABASE tfsave(fi) ID jobid_ext.
                IF sy-subrc <> 0 .
                  EXIT.
                ENDIF.
              ENDDO.
              PERFORM execute_bi_end_akt_number.
            WHEN 'R'.                  " Wiederaufsetzen (Restart)
              all_commit = startnum.
              tfsave_fill = 'X'.
              PERFORM log_msg USING c_msgid 'I' '059'
                                    jobid space space space.
          ENDCASE.
* end P30K110179

          tbist_aktiv = 'X'.                                "QHA30C+
        WHEN 2.
          PERFORM log_msg USING c_msgid 'I' '053'
                                space space space space.
          PERFORM log_abort USING c_msgid '013'.
        WHEN 3.
          PERFORM log_msg USING c_msgid 'I' '054'
                                space space space space.
          PERFORM log_abort USING c_msgid '013'.
      ENDCASE.

      IF startnum NE 0.
        PERFORM log_msg USING c_msgid 'I' '055'
                              startnum space space space.
      ENDIF.
    ELSE.
      IF sy-subrc = 0.
        tbist_aktiv = 'X'.
      ENDIF.
    ENDIF.
*   ELSEIF STARTNUM = 0.
*     MESSAGE I899 WITH 'Diese Mappe wird zum ersten Mal angefasst'.
*      "WICHTIG!
*      DELETE ETAB FROM DATABASE ....
*   ELSE.
*     IF IS_ERROR = 'X'.
*      MESSAGE I899 WITH 'File' DS_NAME 'letzter Fehler bei' STARTNUM.
*     ELSE.
*        MESSAGE I899 WITH 'File' DS_NAME 'Fortsetzung bei' STARTNUM.
*     ENDIF.
*   ENDIF.
  ELSE.
    startnum = 0.
*   IS_ERROR = SPACE.
    jobid   = 'RFBIBL00_'.
    jobid+9 = sy-uname.
    DELETE FROM DATABASE terrd(fi) ID jobid.
  ENDIF.

ENDFORM.                               " GET_STARTING_NUMBER

*&---------------------------------------------------------------------*
*&      Form  CALL_BI_END_AKT_NUMBER
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM call_bi_end_akt_number.
* CHECK SY-BATCH = 'X'.
  CHECK fl_check = space.              "QHA->Steinwedel
* CHECK NOT jobid IS INITIAL.
  CHECK function NE 'B'.
  CHECK tbist_aktiv = 'X'.

  all_commit = all_commit + commit_count.
  PERFORM execute_bi_end_akt_number.
  CLEAR commit_count.
  CLEAR numerror.

ENDFORM.                               " CALL_BI_END_AKT_NUMBER


*&---------------------------------------------------------------------*
*&      Form  EXECUTE_BI_END_AKT_NUMBER
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM execute_bi_end_akt_number.

  CALL FUNCTION 'BI_END_AKT_NUMBER'
       EXPORTING
            jobname          = jobid
            actual_number    = all_commit
            number_of_errors = numerror"eine relative Zahl,
               "Anzahl Fehler seit dem letzem(!) COMMIT, wird im FB
                                       "kumuliert.
*     EXTERNAL_NUMBER  = 'interne Nummernvergabe'
       EXCEPTIONS
            internal_error   = 01
            not_found        = 02.

  CASE sy-subrc.
    WHEN 0.
*       MESSAGE I899 WITH 'BI_END_AKT_NUMBER' BELEG_COUNT.     "30Ctest
    WHEN 1.
      ROLLBACK WORK.
      PERFORM log_msg USING c_msgid 'I' '056'
                              space space space space.
      PERFORM log_abort USING c_msgid '013'.
    WHEN 2.
      ROLLBACK WORK.
      PERFORM log_msg USING c_msgid 'I' '054'
                              jobid space space space.
      PERFORM log_abort USING c_msgid '013'.
  ENDCASE.

ENDFORM.                               " EXECUTE_BI_END_AKT_NUMBER



*eject
*&---------------------------------------------------------------------*
*&      Form  EXPORT_ERROR_DATA
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM export_error_data.
  DESCRIBE TABLE ertab LINES tfill_ertab.
  CHECK tfill_ertab > 0.

  IMPORT save_bgr00 efile FROM DATABASE terrd(fi) ID jobid.

  LOOP AT ertab.
    efile = ertab.
    APPEND efile.
  ENDLOOP.

  EXPORT save_bgr00 efile TO DATABASE terrd(fi) ID jobid.
  numerror = numerror + 1.
ENDFORM.                               " EXPORT_ERROR_DATA

*eject
*&---------------------------------------------------------------------*
*&      Form  CALL_BI_CLOSE_ENTRY
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
FORM call_bi_close_entry.
  DATA: counter(5) TYPE n.
  IF tbist_aktiv = 'X' AND sy-batch = 'X'.
    CALL FUNCTION 'BI_CLOSE_ENTRY'
      EXPORTING
        jobname        = jobid
      EXCEPTIONS
        internal_error = 01
        not_found      = 02.

    CASE sy-subrc.
      WHEN 0.
        DELETE FROM DATABASE terrd(fi) ID jobid.
        DO.
          counter = counter + 1.
          jobid_ext+27(5) = counter.
          DELETE FROM DATABASE tfsave(fi) ID jobid_ext.
          IF sy-subrc <> 0 .
            EXIT.
          ENDIF.
        ENDDO.
      WHEN 1.
        PERFORM log_msg USING c_msgid 'I' '057'
                             space space space space.
        PERFORM log_abort USING c_msgid '013'.
      WHEN 2.
        PERFORM log_msg USING c_msgid 'I' '054'
                              jobid space space space.
        PERFORM log_abort USING c_msgid '013'.
    ENDCASE.
  ELSE.
    IF function NE 'B'.
      DELETE FROM DATABASE terrd(fi) ID jobid.
    ENDIF.
  ENDIF.

* delete tfsave also in test run
  IF fl_check EQ 'X' AND function NE 'B' AND sy-batch = 'X'.
    counter = 0.
    DO.
      counter = counter + 1.
      jobid_ext+27(5) = counter.
      DELETE FROM DATABASE tfsave(fi) ID jobid_ext.
      IF sy-subrc <> 0 .
        EXIT.
      ENDIF.
    ENDDO.
  ENDIF.

ENDFORM.                               " CALL_BI_CLOSE_ENTRY
*&---------------------------------------------------------------------*
*&      Form  FILL_T_BWITH
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM fill_t_bwith.
  CHECK function = 'D'.
  IF wa+2(9) = 'WITH'.
*    append bwith to t_bwith.
    CLEAR wa_bwith_di.
    MOVE-CORRESPONDING bwith TO wa_bwith_di.
    wa_bwith_di-wt_key = wt_count.
    APPEND wa_bwith_di TO t_bwith.
  ENDIF.
ENDFORM.                               " FILL_T_BWITH

*eject
*&---------------------------------------------------------------------*
*&      Form  BSELP_FIELD_LENGHT_CONVERT
*&---------------------------------------------------------------------*
*       Die L#nge der Felder BSELP-FELDN, BSELP-SLVON und BSELP-SLBIS
*       wird angepasst                                                 *
*       Feld           L#nge vor 4.0A        L#nge ab 4.0A             *
*       BSELP-FELDN     5                    30
*       BSELP-SLVON    20                    30
*       BSELP-SLBIS    20                    30
*
*  ---> p_wa          aktuelle Zeile mit alten Feldl#ngen
*  <--- p_wa          aktuelle Zeile mit neuen Feldl#ngen
*----------------------------------------------------------------------*
FORM bselp_field_lenght_convert CHANGING p_wa.
  DATA: wa_tmp(10000) TYPE c,           " help work area
        offset_o TYPE i,               " old offset (<4.0A)
        offset_n TYPE i.               " new offset (>= 4.0A)

  CLEAR wa_tmp.
  wa_tmp(31) = p_wa(31).
  offset_n = 31.
  offset_o = 31.
  DO 18 TIMES.
    wa_tmp+offset_n(5) = p_wa+offset_o(5).
    offset_n = offset_n + 30.
    offset_o = offset_o + 5.
    DO 2 TIMES.
      wa_tmp+offset_n(20) = p_wa+offset_o(20).
      offset_n = offset_n + 30.
      offset_o = offset_o + 20.
    ENDDO.
  ENDDO.
  CLEAR p_wa.
  p_wa = wa_tmp.
ENDFORM.                               "bselp_field_lenght_convert

*&---------------------------------------------------------------------*
*&      Form  set_global_variable
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM set_global_variable.

  CHECK function NE 'D'.
* -----  read currency exchange rate prefixes --------------------------
  CALL FUNCTION 'RATE_GET_PREFIXES'
    EXPORTING
      client   = sy-mandt
    IMPORTING
      prefix_p = prefix_p
      prefix_m = prefix_m.


ENDFORM.                               " set_global_variable


*----------------------------------------------------------------------*
*&      Form  LOG_MSG
*&---------------------------------------------------------------------*
*       collects info messages for log or displays pop up
*----------------------------------------------------------------------*
FORM log_msg USING    i_msgid LIKE sy-msgid
                      i_msgty LIKE sy-msgty
                      i_msgno LIKE sy-msgno
                      i_msgv1
                      i_msgv2
                      i_msgv3
                      i_msgv4.

* declaration
  DATA: h_fimsg LIKE fimsg.

  CHECK xinf EQ space.

  IF xlog = 'X'.

* log the message with the message handler
    h_fimsg-msgid = i_msgid.
    h_fimsg-msgty = i_msgty.
    h_fimsg-msgno = i_msgno.
    h_fimsg-msgv1 = i_msgv1. CONDENSE h_fimsg-msgv1.
    h_fimsg-msgv2 = i_msgv2. CONDENSE h_fimsg-msgv2.
    h_fimsg-msgv3 = i_msgv3. CONDENSE h_fimsg-msgv3.
    h_fimsg-msgv4 = i_msgv4. CONDENSE h_fimsg-msgv4.
    CALL FUNCTION 'FI_MESSAGE_COLLECT'
      EXPORTING
        i_fimsg       = h_fimsg
        i_xappn       = 'X'
      EXCEPTIONS
        msgid_missing = 1
        msgno_missing = 2
        msgty_missing = 3
        OTHERS        = 4.

  ELSEIF xpop = 'X'.
* popup
    MESSAGE ID     i_msgid
            TYPE   i_msgty
            NUMBER i_msgno
            WITH   i_msgv1 i_msgv2 i_msgv3 i_msgv4.
  ENDIF.

ENDFORM.                               " LOG_MSG
*&---------------------------------------------------------------------*
*&      Form  log_print
*&---------------------------------------------------------------------*
*       display log
*----------------------------------------------------------------------*
FORM log_print.

  IF xlog = 'X'.
    IF NOT sy-batch IS INITIAL.
      CALL FUNCTION 'FI_MESSAGE_PROTOCOL'
        EXCEPTIONS
          no_message = 1
          not_batch  = 2
          OTHERS     = 3.
    ELSE.
      CALL FUNCTION 'FI_MESSAGE_PRINT'
        EXPORTING
          i_xausn = 'X'
          i_comsg = 0
        EXCEPTIONS
          OTHERS  = 0.
    ENDIF.
  ENDIF.

ENDFORM.                    " log_print

*&---------------------------------------------------------------------*
*&      Form  log_abort
*&---------------------------------------------------------------------*
*       foreground: stop program / background: message aXXX
*----------------------------------------------------------------------*

FORM log_abort USING i_msgid LIKE sy-msgid
                     i_msgno LIKE sy-msgno.

  IF sy-batch IS INITIAL.
    IF xlog = 'X'.
      PERFORM log_msg USING i_msgid 'I' i_msgno
                            space space space space.
    ENDIF.
    PERFORM log_print.
    ROLLBACK WORK.
    IF xpop = 'X'.                                          "Note 559106
      MESSAGE ID i_msgid                                    "Note 559106
              TYPE 'I'                                      "Note 559106
              NUMBER i_msgno.                               "Note 559106
    ELSEIF xlog = 'X' OR xinf = 'X' .                       "Note 559106
      MESSAGE ID i_msgid                                    "Note 559106
      TYPE 'S'                                              "Note 559106
      NUMBER i_msgno.                                       "Note 559106
    ENDIF.                                                  "Note 559106
    STOP.
  ELSE.
    PERFORM log_print.
    MESSAGE ID i_msgid
            TYPE 'A'
            NUMBER i_msgno.
  ENDIF.

ENDFORM.                    " log_abort

*Text symbol text£º

*MSG:Message FB$ issued with variables $ $ $ $
*Selection text£º
*ANZ_MODE:        Display Mode
*DS_NAME:        File Path Name
*FL_CHECK:        Check File Only
*OS_XON:        Structures from Release < 4.0
*UPDATE:        Update Mode
