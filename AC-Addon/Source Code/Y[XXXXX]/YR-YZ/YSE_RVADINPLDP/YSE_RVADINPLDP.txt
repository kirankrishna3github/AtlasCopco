*----------------------------------------------------------------------*
*              Print of an invoice by SAPscript                        *
*----------------------------------------------------------------------*
REPORT yse_rvadinpldp LINE-COUNT 100 MESSAGE-ID vn.

* Report copied from YSE_RVADINPLDP*
* Changes indicated with *YSE*
*----------------------------------------------------------------------*
* MOD. NO.|  DATE    | NAME     |CORRECTION NUMBER| CHANGE REFERENCE # *
*----------------------------------------------------------------------*
* MOD-001 |2007.07.19|Marc Jacobs|CD1K918064 | output to PDF           *
* MOD-002 |2007.11.07|Marc Jacobs|CD1K923158 | prevent zero lines      *
* MOD-003 |2008.02.27|Marc Jacobs|CD1K926750 | prevent print options   *
* MOD-004 |2008.07.24|Marc Jacobs|CD1K942199 | Corrections for AM      *
* MOD-005 |2008.09.11|Marc Jacobs|CD1K943249 | Correction layout       *
* MOD-006 |2008.09.26|Pavan Kaipa|CD1K943679 | Change in Spell Amount. *
* MOD-007 |2010.12.13|Lakshmi R  |CD1K961846 | Change VAT from         *
*                                              22% to 23%              *
* MOD-008 |2015.03.03|Anda Wu    |CD1K984827|Send PDF to customer email*
************************************************************************


***********************************************************************
* Definition of tables                                                *
***********************************************************************

TABLES: komk    ,
        komp    ,
        komvd   ,
        vbco3   ,
        vbdkr   ,
        vbdpr   ,
        vbdre   ,
        conf_out,
        sadr    ,
        tvko    ,
        adrs    ,
        t005    ,
        t001    ,
        t001g   ,
        tvcint  ,
        konh    ,
        tlic    ,
        fpltvb  ,
        bseg    ,
        ser01   ,
        objk    ,
        lips    ,
        adrc    ,
        adr6    ,
        adrt    ,
        tvgrt   ,
        sdaccdpc.

***********************************************************************
* Additional data definitions for Down Payment Poland                 *
***********************************************************************

TYPES: BEGIN OF gtyp_previous_dp_invoices,
        vbeln       TYPE vbeln,
        fkdat       TYPE fkdat,
        gross_value TYPE netwr,
        waerk       TYPE waerk,
      END OF gtyp_previous_dp_invoices.

TYPES: BEGIN OF gtyp_amts_with_tax,
        net_value TYPE netwr,
        tax_rate  TYPE kbetr,
        tax_value TYPE mwsbp,
        gross_value TYPE brtwr_fp,
       END OF gtyp_amts_with_tax.

TYPES: BEGIN OF ltyp_invoices,
        vbeln TYPE vbeln,
        awkey TYPE awkey,
       END OF ltyp_invoices.

TYPES: BEGIN OF ltyp_amt_taxcode,
          mwskz   TYPE mwskz,
          amt     TYPE netwr_fp,
          tax_amt TYPE mwsbp,
       END OF ltyp_amt_taxcode.


TYPES: gtyps_amt_with_tax_t TYPE TABLE OF gtyp_amts_with_tax.
TYPES: gtyp_amt_taxcode_t   TYPE TABLE OF ltyp_amt_taxcode.

DATA gt_prev_dp_inv TYPE TABLE OF gtyp_previous_dp_invoices
                                 WITH HEADER LINE .
DATA gs_prev_dp_inv TYPE gtyp_previous_dp_invoices.
DATA gt_vbap        TYPE TABLE OF vbap WITH HEADER LINE.
DATA gt_vbfa        TYPE TABLE OF vbfa.

DATA gt_left_for_clearing TYPE TABLE OF gtyp_amts_with_tax
                               WITH HEADER LINE.
DATA gt_to_be_paid TYPE TABLE OF gtyp_amts_with_tax
                               WITH HEADER LINE.
DATA gt_dp_clearing TYPE TABLE OF gtyp_amts_with_tax
                               WITH HEADER LINE.

DATA gs_left_for_clearing TYPE gtyp_amts_with_tax.
DATA gs_to_be_paid        TYPE gtyp_amts_with_tax.
DATA gs_dp_clearing       TYPE gtyp_amts_with_tax.
DATA gs_total_amt_tax     TYPE gtyp_amts_with_tax.
DATA gs_spell             TYPE spell.

DATA gv_to_pay           TYPE brtwr_fp.
DATA gv_to_pay_in_words  TYPE gawrd.
DATA gv_to_pay_dec_in_words TYPE gawrd.
DATA gv_dp_invoice       TYPE c.
DATA gv_inv_typ          TYPE c VALUE 'I'.
DATA gv_dp_rcpt_date     TYPE fbuda.
DATA gv_sernr            TYPE gernr.
DATA gv_tdname           TYPE tdobname.
DATA gv_tdline(132)      TYPE c.
DATA : gv_docnr          LIKE bkpf-belnr.
DATA: gv_docnumber       LIKE bkpf-belnr.
DATA: gv_bezei           LIKE tvgrt-bezei.
DATA: gv_stcd1           LIKE kna1-stcd1.
DATA: gv_vkgrp           LIKE vbrp-vkgrp.
DATA gv_tline_tmp TYPE STANDARD TABLE OF tline INITIAL SIZE 0
                                          WITH HEADER LINE.


* Data Declaration for correction invoice - Poland

TYPES: BEGIN OF gtyp_total,
           net_value      TYPE vbrp-netwr,
           gross_value    TYPE vbrp-kzwi2,
           tax_amount     TYPE vbrp-mwsbp,
         END OF gtyp_total.

TYPES: BEGIN OF gtyp_corr_inv,
          doc_num             TYPE   vbrp-vbeln,
          corr_item           TYPE   posnr,
          item_num            TYPE   vbrp-posnr,
          net_value           TYPE   vbrp-netwr,
          material            TYPE   vbrp-matnr,
          gross_value         TYPE   vbrp-kzwi2,
          tax_amt             TYPE   vbrp-mwsbp,
          tax_rate            TYPE   konv-kbetr,
          tax_code            TYPE   konv-mwsk1,
         END OF gtyp_corr_inv.

TYPES: BEGIN OF gtyp_corr_diff,
          item_num      TYPE   vbrp-posnr,
          net_value     TYPE   vbrp-netwr,
          material      TYPE   vbrp-matnr,
          gross_value   TYPE   vbrp-kzwi2,
          tax_amt       TYPE   vbrp-mwsbp,
          tax_rate      TYPE   konv-kbetr,
          tax_code      TYPE   konv-mwsk1,
         END OF gtyp_corr_diff.

TYPES: BEGIN OF gtyp_corr_to_be,
        posnr         TYPE vbrp-posnr,
        fkimg         TYPE vbrp-fkimg,
        meins         TYPE vbrp-meins,
        matnr         TYPE vbrp-matnr,
        arktx         TYPE vbrp-arktx,
        netprl        TYPE vbdpr-netprl,
        netwr         TYPE vbrp-netwr,
        kbetr         TYPE konv-kbetr,
        mwsk1         TYPE konv-mwsk1,
        mwsbp         TYPE vbrp-mwsbp,
        brtwr_vg2     TYPE vbdpr-brtwr_vg2,
        steucl        TYPE vbdpr-steucl,
      END OF gtyp_corr_to_be.

DATA : gs_vbrk TYPE vbrk.

DATA: BEGIN OF corr_tvbdpr OCCURS 100.
        INCLUDE STRUCTURE vbdpr.
DATA: END OF corr_tvbdpr.

DATA: BEGIN OF gv_sernrs OCCURS 50,
        sernr        TYPE objk-sernr,
      END OF gv_sernrs.

DATA: corr_vbco3 TYPE vbco3.
DATA: corr_vbdkr TYPE vbdkr.

DATA: gt_clear_note TYPE TABLE OF gtyp_amts_with_tax WITH HEADER LINE.
DATA: gt_corr_inv TYPE TABLE OF gtyp_corr_inv WITH HEADER LINE.
DATA: gt_corr_diff TYPE TABLE OF gtyp_corr_diff WITH HEADER LINE.
DATA: gt_red_dp_clear TYPE TABLE OF gtyp_corr_diff WITH HEADER LINE.
DATA: gt_corr_to_be TYPE TABLE OF gtyp_corr_to_be WITH HEADER LINE.
DATA: gt_clearing_dp TYPE TABLE OF gtyp_amts_with_tax WITH HEADER LINE.
DATA: gt_after_clearing TYPE TABLE OF gtyp_amts_with_tax WITH HEADER
      LINE.
DATA: corr_vbfa        TYPE TABLE OF vbfa.

DATA: gs_corr_inv     TYPE gtyp_corr_inv.
DATA: gs_corr_diff    TYPE gtyp_corr_diff.
DATA: gs_clear_total  TYPE gtyp_total.
DATA: gs_spell_diff TYPE spell.
DATA: gs_clear_note TYPE gtyp_amts_with_tax.
DATA: gs_red_dp_clear TYPE gtyp_corr_diff.
DATA: gs_corr_to_be   TYPE gtyp_corr_to_be.
DATA: gs_after_clearing TYPE gtyp_amts_with_tax.
DATA: gs_tvfk          TYPE tvfk.
DATA: gs_clearing_dp TYPE gtyp_amts_with_tax.
DATA: gs_corr_print   TYPE gtyp_amts_with_tax.
DATA: gs_diff_print   TYPE gtyp_amts_with_tax.
DATA: gv_diff_pay_in_words TYPE gawrd.
DATA: gt_invoices          TYPE ltyp_invoices.
DATA: gv_dp_total          TYPE netwr.
DATA: gv_to_pay_diff       TYPE brtwr_fp.
DATA: gv_rev_netwr         TYPE netwr.
DATA: gv_rev_mwsbk         TYPE brtwr_fp.
DATA: gv_rev_fkwrt         TYPE fkwrt.

DATA: gt_corr_print TYPE TABLE OF gtyp_amts_with_tax WITH HEADER LINE.
DATA: gt_diff_print TYPE TABLE OF gtyp_amts_with_tax WITH HEADER LINE.

* begin of insertion MOD-001
DATA:
    gv_pdf     TYPE c,                 " PDF needed flag
    gv_res     TYPE itcpp.             " Open Form results
CONSTANTS:
  gc_true    TYPE c VALUE 'X',
  gc_locl(4) TYPE c VALUE 'LOCL'.
* end of insertion MOD-001
********* Correction Invoice - Poland *****************

***********************************************************************
* Additional definitions of tables for general issues                 *
***********************************************************************

INCLUDE rvadtabl.

* Data for printout Slovakia
TABLES: vbrk, bkpf, bset, teurb.

* Data for printout discount information
TABLES: vbdprl, vtopis.


***********************************************************************
* Definition of internal tables                                       *
***********************************************************************

DATA: BEGIN OF tvbdpr OCCURS 100.      "Internal table for items
        INCLUDE STRUCTURE vbdpr.
DATA: END OF tvbdpr.

* begin of insertion MOD-003
TYPES: BEGIN OF tvbdpr2.
        INCLUDE STRUCTURE vbdpr.
TYPES:  matkl2   LIKE      vbap-matkl,
        uepos2   LIKE      vbap-uepos,
        orgpos   LIKE      vbap-posnr,
     END OF tvbdpr2.

DATA: gt_tvbdpr TYPE STANDARD TABLE OF tvbdpr2 WITH HEADER LINE.
DATA : gv_uepos   LIKE vbap-uepos,
       gv_matkl   LIKE vbap-matkl,
       gv_orgpos  LIKE vbap-posnr,
       gv_index   LIKE sy-tabix.
* end of insertion MOD-003

DATA: BEGIN OF tkomv OCCURS 50.
        INCLUDE STRUCTURE komv.
DATA: END OF tkomv.

DATA: BEGIN OF tkomvd OCCURS 50.
        INCLUDE STRUCTURE komvd.
DATA: END OF tkomvd.

DATA: BEGIN OF *tkomvd OCCURS 50.
        INCLUDE STRUCTURE komvd.
DATA: END OF *tkomvd.

DATA: BEGIN OF hkomv OCCURS 50.
        INCLUDE STRUCTURE komv.
DATA: END OF hkomv.

DATA: BEGIN OF hkomvd OCCURS 50.
        INCLUDE STRUCTURE komvd.
DATA: END OF hkomvd.

DATA: BEGIN OF tkomcon OCCURS 50.
        INCLUDE STRUCTURE conf_out.
DATA: END   OF tkomcon.

* Definition of downpayment data

DATA: BEGIN OF ixsdaccdpc OCCURS 0.
        INCLUDE STRUCTURE sdaccdpc.
DATA: END OF ixsdaccdpc.

DATA: BEGIN OF gt_sdaccdpc_doc OCCURS 0,
        vbeln TYPE vbeln,
        posnr TYPE posnr.
DATA: END OF gt_sdaccdpc_doc.

DATA: da_xfilkd LIKE tvfk-xfilkd,
      chara TYPE c VALUE 'A',
      charb TYPE c VALUE 'B'.
DATA: downpay_refresh.

* Definition of billingplan data
DATA:   BEGIN OF xfplt OCCURS 10.
        INCLUDE STRUCTURE fpltvb.
DATA:   END OF xfplt.

DATA:   old_fplnr LIKE vbrp-fplnr.


***********************************************************************
* Definition of internal variables                                    *
***********************************************************************

DATA: retcode   LIKE sy-subrc.         "Returncode
DATA: repeat(1) TYPE c.
DATA: anzal LIKE nast-anzal.           "HUNGARY
DATA: nast_anzal LIKE nast-anzal.      "Number of outputs (Orig. + Cop.)
DATA: nast_tdarmod LIKE nast-tdarmod.  "Archiving only one time
DATA: xscreen(1) TYPE c.               "Output on printer or screen
DATA: xvbeln LIKE vbrk-vbeln.
DATA: xposnr LIKE vbrl-posnr.
DATA: pr_kappl(01)   TYPE c VALUE 'V'. "Application for pricing
DATA: print_mwskz.                     "Mehrwertsteuer-Kz drucken
DATA: ccname(30) TYPE c.               "Card Type

***********************************************************************
* Definition of variables for calling customer subroutines dynamically*
***********************************************************************

DATA : header_userexit       LIKE tnapr-ronam,
       item_userexit         LIKE tnapr-ronam,
       header_print_userexit LIKE tnapr-ronam,
       item_print_userexit   LIKE tnapr-ronam,
       get_data_userexit     LIKE tnapr-ronam.


* country specific entry routines
INCLUDE idbillprint.
* YSE Start modification *
* country specific entry routines (smartform)
INCLUDE yse_idbillprint.
* YSE End modification *

* data for access to central address maintenance
INCLUDE sdzavdat.

********being of MOD-008 INSERT
DATA: it_otf TYPE itcoo OCCURS 0 WITH HEADER LINE,
      gflg_send TYPE char1, " Indicator whether to send mail
      mailto TYPE ad_smtpadr.
********END OF MOD-008 INSERT

***********************************************************************
*                                                                     *
* Standard Routine ENTRY                                              *
*                                                                     *
***********************************************************************

FORM entry USING return_code us_screen.

  CLEAR retcode.
  xscreen = us_screen.
  PERFORM processing USING us_screen.
  CASE retcode.
    WHEN 0.
      return_code = 0.
    WHEN 3.
      return_code = 3.
    WHEN OTHERS.
      return_code = 1.
  ENDCASE.

ENDFORM.                    "entry

***********************************************************************
*                                                                     *
* Standard Routine ENTRY_PROFORMA                                     *
*                                                                     *
***********************************************************************

FORM entry_proforma USING return_code us_screen.

  CLEAR return_code.

ENDFORM.                    "entry_proforma

***********************************************************************
*                                                                     *
* Customer Entry-Routines                                             *
*                                                                     *
***********************************************************************



***********************************************************************
*                                                                     *
* Standard Routine PROCESSING                                         *
*                                                                     *
***********************************************************************

FORM processing USING proc_screen.

**********************************Being of MOD-008
  IMPORT gflg_send TO gflg_send FROM  MEMORY ID 'SEND_MAIL'.
**********************************End of MOD-008
  PERFORM get_data.
  CHECK retcode = 0.
* only print 1 time
*  IF nast-anzal EQ 0.
*    nast_anzal = 1.
*  ELSE.
*    nast_anzal = nast-anzal.
*  ENDIF.
*  nast-anzal = 1.
  nast_anzal = 1.
  DO nast_anzal TIMES.
* In case of repetition only one time archiving
    IF sy-index > 1 AND nast-tdarmod = 3.
      nast_tdarmod = nast-tdarmod.
      nast-tdarmod = 1.
    ENDIF.
    IF sy-index NE 1 AND repeat IS INITIAL.
      repeat = 'X'.
    ENDIF.
    PERFORM form_open USING proc_screen vbdkr-land1.
    CHECK retcode = 0.
    PERFORM get_acc_docnr.
    PERFORM get_vat_number.
    PERFORM get_comp_data.
    PERFORM form_title_print.
    CHECK retcode = 0.
    PERFORM header_consgnee.
    CHECK retcode = 0.
    PERFORM tax_text_print.
    CHECK retcode = 0.
    PERFORM header_data_print.
    CHECK retcode = 0.
    PERFORM header_text_print.
    CHECK retcode = 0.
***********DP POLAND Changes BEGIN*********************************
* Print Previous DP Invoices
*******************************************************************
*    PERFORM previous_dp_invoice_print.
*    CHECK retcode = 0.
    PERFORM form_rec_prep.
    CHECK retcode = 0.
***********DP POLAND Changes END***********************************
    PERFORM item_print.
    CHECK retcode = 0.
    PERFORM end_print.
    CHECK retcode = 0.
    PERFORM form_close.
    CHECK retcode = 0.
    PERFORM refresh_tables.
  ENDDO.
  nast-anzal = nast_anzal.
  nast-tdarmod = nast_tdarmod.
**********************************Being of MOD-009
  EXPORT gflg_send FROM ' ' TO MEMORY ID 'SEND_MAIL'.
**********************************END of MOD-009
ENDFORM.                    "processing

***********************************************************************
*       SAP STANDARD-SUBROUTINES                                      *
***********************************************************************

*---------------------------------------------------------------------*
*       FORM AMOUNT_FOR_CASH_DISCOUNT                                 *
*---------------------------------------------------------------------*
*       This routine prints the amount qualifying for cash discount.  *
*---------------------------------------------------------------------*

FORM amount_for_cash_discount.

  CHECK vbdkr-skfbk NE 0.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'AMOUNT_QUALIFYING_FOR_CASH_DISCOUNT'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "amount_for_cash_discount

*---------------------------------------------------------------------*
*       FORM PAYMENT_SPLIT                                            *
*---------------------------------------------------------------------*
*       This routine prints the payment split                         *
*---------------------------------------------------------------------*
FORM payment_split.

  DATA: h_skfbt LIKE acccr-skfbt.
  DATA: h_fkdat LIKE vbrk-fkdat.
  DATA: h_fkwrt LIKE acccr-wrbtr.
  DATA : BEGIN OF payment_split OCCURS 3.
          INCLUDE STRUCTURE vtopis.
  DATA : END OF payment_split.


  CHECK vbdkr-zterm NE space.

  h_skfbt = vbdkr-skfbk.
  h_fkwrt = komk-fkwrt.
  h_fkdat = vbdkr-fkdat.
  IF vbdkr-valdt NE 0.
    h_fkdat = vbdkr-valdt.
  ENDIF.
  IF vbdkr-valtg NE 0.
    h_fkdat = vbdkr-fkdat + vbdkr-valtg.
  ENDIF.
  CALL FUNCTION 'SD_PRINT_TERMS_OF_PAYMENT_SPLI'
    EXPORTING
      i_country                     = vbdkr-land1
      bldat                         = h_fkdat
      budat                         = h_fkdat
      cpudt                         = h_fkdat
      language                      = vbco3-spras
      terms_of_payment              = vbdkr-zterm
      wert                          = h_fkwrt  "Warenwert + Tax
      waerk                         = vbdkr-waerk
      fkdat                         = vbdkr-fkdat
      skfbt                         = h_skfbt
      i_company_code                = vbdkr-bukrs
    TABLES
      top_text_split                = payment_split
    EXCEPTIONS
      terms_of_payment_not_in_t052  = 01
      terms_of_payment_not_in_t052s = 02.

  LOOP AT payment_split.

    AT FIRST.
      CALL FUNCTION 'CONTROL_FORM'
        EXPORTING
          command = 'PROTECT'.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TERMS_OF_PAYMENT_SPLIT_HEADER'.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    ENDAT.

    vbdkr-text = payment_split-line.
    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'TERMS_OF_PAYMENT_SPLIT'
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    AT LAST.
      CALL FUNCTION 'CONTROL_FORM'
        EXPORTING
          command = 'ENDPROTECT'.
    ENDAT.

  ENDLOOP.

ENDFORM.                    "payment_split

*---------------------------------------------------------------------*
*       FORM CHECK_REPEAT                                             *
*---------------------------------------------------------------------*
*       A text is printed, if it is a repeat print for the document.  *
*---------------------------------------------------------------------*

FORM check_repeat.

  CLEAR repeat.
  CLEAR anzal.
  SELECT * INTO *nast FROM nast WHERE kappl = nast-kappl
                                AND   objky = nast-objky
                                AND   kschl = nast-kschl
                                AND   spras = nast-spras
                                AND   parnr = nast-parnr
                                AND   parvw = nast-parvw
                                AND   nacha BETWEEN '1' AND '4'.
    IF *nast-vstat = '1'.
      anzal = anzal + *nast-anzal.
      repeat = 'X'.
    ENDIF.
  ENDSELECT.

ENDFORM.                    "check_repeat

*---------------------------------------------------------------------*
*       FORM DIFFERENT_CONSIGNEE                                      *
*---------------------------------------------------------------------*
*       If the consignee in the item is different to the header con-  *
*       signee, it is printed by this routine.                        *
*---------------------------------------------------------------------*

FORM different_consignee.

  CHECK vbdkr-name1_we NE vbdpr-name1_we
    OR  vbdkr-name2_we NE vbdpr-name2_we
    OR  vbdkr-name3_we NE vbdpr-name3_we
    OR  vbdkr-name4_we NE vbdpr-name4_we.
  CHECK vbdpr-name1_we NE space
    OR  vbdpr-name2_we NE space
    OR  vbdpr-name3_we NE space
    OR  vbdpr-name4_we NE space.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'ITEM_CONSIGNEE'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "different_consignee

*---------------------------------------------------------------------*
*       FORM DIFFERENT_DELIVERY_NO                                    *
*---------------------------------------------------------------------*
*       If the delivery number is different to number in the header,  *
*       it is printed by this routine.                                *
*---------------------------------------------------------------------*

FORM different_delivery_no.

  CHECK vbdkr-vbtyp CA 'MUN'.
  CHECK vbdpr-vbeln_vl NE vbdpr-vbeln_vauf.
  CHECK vbdkr-vbeln_vl NE vbdpr-vbeln_vl.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'ITEM_DELIVERY_NO'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "different_delivery_no

*---------------------------------------------------------------------*
*       FORM DIFFERENT_ORDER_NO                                       *
*---------------------------------------------------------------------*
*       If the order number is different to number in the header,     *
*       it is printed by this routine.                                *
*---------------------------------------------------------------------*

FORM different_order_no.

  CHECK vbdkr-vbtyp CA 'MUN'.
  CHECK vbdpr-vbeln_vauf NE space.
  CHECK vbdkr-vbeln_vauf NE vbdpr-vbeln_vauf.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'ITEM_ORDER_NO'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "different_order_no

*---------------------------------------------------------------------*
*       FORM DIFFERENT_EXTERN_NO                                      *
*---------------------------------------------------------------------*
*       If the extern number is different to number in the header,    *
*       it is printed by this routine.                                *
*---------------------------------------------------------------------*

FORM different_extern_no.

  CHECK vbdkr-vbtyp CA 'MUN'.
  CHECK vbdkr-vbeln_vauf EQ space.
  CHECK vbdkr-vbeln_vl   EQ space.
  CHECK vbdpr-vbeln_vauf EQ space.
  CHECK vbdpr-vbeln_vl   EQ space.
  CHECK vbdkr-vgbel NE vbdpr-vgbel.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'ITEM_EXTERN_NO'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "different_extern_no
*---------------------------------------------------------------------*
*       FORM DIFFERENT_PURCHASE_ORDER_NO                              *
*---------------------------------------------------------------------*
*       If the purchase order number is different to number in the    *
*       header, it is printed by this routine.                        *
*---------------------------------------------------------------------*

FORM different_purchase_order_no.

  CHECK vbdkr-vbtyp CA 'MUN'.
  CHECK vbdpr-bstnk NE space.
  CHECK vbdkr-bstnk NE vbdpr-bstnk
    OR  vbdkr-bstdk NE vbdpr-bstdk.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'ITEM_PURCHASE_ORDER_NO'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "different_purchase_order_no

*---------------------------------------------------------------------*
*       FORM END_PRINT                                                *
*---------------------------------------------------------------------*
*                                                                     *
*---------------------------------------------------------------------*

FORM end_print.

  CALL FUNCTION 'CONTROL_FORM'
    EXPORTING
      command = 'PROTECT'.
*****DP Poland changes **********************************************
*  the text element END_VALUES is called after sub routine
* header_price_print in the standard print program RVADIN01

* next call deleted MJ 20070704
*  IF gv_inv_typ = 'D'.
*    CALL FUNCTION 'WRITE_FORM'
*      EXPORTING
*        element = 'DP_SPECIFICATION'
*      EXCEPTIONS
*        element = 1
*        window  = 2.
*    IF sy-subrc NE 0.
*      PERFORM protocol_update.
*    ENDIF.
*
*  ENDIF.
* To print the negative value for clearing note reversal

  IF gv_inv_typ =  'N'.
    gv_rev_netwr = vbdkr-netwr * ( -1 ).
    gv_rev_mwsbk = vbdkr-mwsbk * ( -1 ).
    gv_rev_fkwrt =  komk-fkwrt * ( -1 ).
  ENDIF.
* begin of change MOD-004
  IF gv_inv_typ <> 'D' OR
  ( vbdkr-fkart <> 'FAF' AND vbdkr-fkart <> 'FAFS' ).
* end of change MOD-004
    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'END_VALUES'.

    PERFORM header_price_print.

    IF gv_inv_typ NE 'P'.

      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'U_LINE_SHORT'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    ENDIF.
  ENDIF.
*******************************************************************
***********DP POLAND Changes BEGIN*********************************
* Print Previous DP Invoices
*******************************************************************
*  PERFORM previous_dp_invoice_print.
*  CHECK retcode = 0.
***********DP POLAND Changes END***********************************
  PERFORM downpayment_value.
  PERFORM paymentcard_values.
  PERFORM amount_for_cash_discount.
  CALL FUNCTION 'CONTROL_FORM'
    EXPORTING
      command = 'ENDPROTECT'.

********DP POLAND Changes For Correction Invoices************

  IF gv_inv_typ = 'E'.
    PERFORM corr_invoice.
  ELSEIF gv_inv_typ = 'P'.
    PERFORM corr_partial_invoice.
  ELSEIF gv_inv_typ = 'N'.
    PERFORM clearing_note_rev.
  ENDIF.

* DP Poland changes for Correction Invoices
*******************************************************************
***********DP POLAND Changes BEGIN**********************************
* Print down payment clearing amounts only if it is not a DP Invoice
********************************************************************
*  IF gv_inv_typ NE 'D'.
* begin of change MOD-004
  IF gv_inv_typ NE 'D' OR
    ( vbdkr-fkart <> 'FAF' AND vbdkr-fkart <> 'FAFS' ).
* end of change MOD-004
    PERFORM dp_amts_totals_print.
    CHECK retcode = 0.
  ENDIF.
***********DP POLAND Changes END***********************************
  PERFORM payment_split.
  PERFORM downpayments.
  PERFORM get_salesgroup_desc.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'SUPPLEMENT_TEXT'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "end_print

*---------------------------------------------------------------------*
*       FORM FORM_CLOSE                                               *
*---------------------------------------------------------------------*
*       End of printing the form                                      *
*---------------------------------------------------------------------*

FORM form_close.

  DATA: i_itcpp LIKE itcpp.
  DATA:
    t_itcoo      TYPE itcoo OCCURS 1,
    lv_fname     TYPE string.                 " PDF filename

* OTF-Output, wenn Browser-Druck
*
* Define Internal table for OTF-Data
  DATA: otf_data LIKE itcoo OCCURS 0 WITH HEADER LINE.
*******BEGIN OF MOD-008  INSERT
  IF gflg_send IS NOT INITIAL.
    CALL FUNCTION 'CLOSE_FORM'
      IMPORTING
        RESULT  = i_itcpp
      TABLES
        otfdata = otf_data
      EXCEPTIONS
        OTHERS  = 1.
  ELSE.
*******END OF MOD-008  INSERT
    IF nast-sort1 = 'EBPP'.
      CALL FUNCTION 'CLOSE_FORM'
        IMPORTING
          RESULT  = i_itcpp
        TABLES
          otfdata = otf_data
        EXCEPTIONS
          OTHERS  = 1.

    ELSE.

      CALL FUNCTION 'CLOSE_FORM'
        IMPORTING
          RESULT  = i_itcpp
        TABLES
          otfdata = t_itcoo
        EXCEPTIONS
          OTHERS  = 1.

    ENDIF.
*******BEGIN OF MOD-008  INSERT
  ENDIF.
*******END OF MOD-008  INSERT

  IF sy-subrc NE 0.
    retcode = sy-subrc.
    PERFORM protocol_update.
*******BEGIN OF MOD-008  INSERT
  ELSEIF gflg_send IS NOT INITIAL.
    it_otf[] = otf_data[].
    PERFORM send_mail.
*******END OF MOD-008  INSERT
  ENDIF.

* begin of insertion MOD-001
  IF gv_pdf = gc_true.

    CONCATENATE 'Downpayment_'
                gv_docnr
                '.pdf'
           INTO lv_fname.

    CALL FUNCTION 'YSE_PRINT_PDF2'
      EXPORTING
        pv_fname = lv_fname
      TABLES
        it_otf   = t_itcoo.
  ENDIF.
* end of insertion MOD-001

* insert note 508569 {
  IF nast-sort1 = 'EBPP'.
    CALL FUNCTION 'SAVE_OTF_TO_MEMORY'
      EXPORTING
        memory_key = nast-objky
      TABLES
        otf        = otf_data.
  ENDIF.
* } end note 508569

  IF i_itcpp-tdspoolid NE space.
    PERFORM protocol_update_spool USING '342' i_itcpp-tdspoolid
                                              space space space.
  ENDIF.

  SET COUNTRY space.

* reset data for CTCV
  CALL FUNCTION 'CTCV_INIT_USER_DATA'.

* update number of printed pages in VBRK for Argentina
  CALL FUNCTION 'J_1A_SD_UPD_NUM_OF_PAGES'
    EXPORTING
      pages = i_itcpp-tdpages
      vbeln = vbdkr-vbeln
      bukrs = vbdkr-bukrs.


ENDFORM.                    "form_close

*---------------------------------------------------------------------*
*       FORM FORM_OPEN                                                *
*---------------------------------------------------------------------*
*       Start of printing the form                                    *
*---------------------------------------------------------------------*
*  -->  US_SCREEN  Output on screen                                   *
*                  ' ' = Printer                                      *
*                  'X' = Screen                                       *
*  -->  US_COUNTRY County for telecommunication and SET COUNTRY       *
*---------------------------------------------------------------------*

FORM form_open USING us_screen us_country.

* begin of deletion MOD-001
*  INCLUDE rvadopfo.
* end of deletion MOD-001

* begin of insertion MOD-001
  DATA: lvs_itcpo         TYPE   itcpo,
        lvf_device(30)    TYPE   c,
        lvf_dialog(1)     TYPE   c   VALUE ' ',
        lvs_recipient     LIKE   swotobjid,
        lvs_sender        LIKE   swotobjid,
        lvs_snast         TYPE   snast,
        lvf_program       LIKE   sy-repid,
        lvs_comm_type     TYPE   ad_comm,
        lvs_comm_values   TYPE   szadr_comm_values.

* reset return code
  retcode = 0.

* if there is a communication strategy used ...
  IF NOT nast-tcode IS INITIAL AND nast-nacha EQ '5'.

*   ... use stratagy to get communication type
    CALL FUNCTION 'ADDR_GET_NEXT_COMM_TYPE'
         EXPORTING
              strategy           = nast-tcode
*             ADDRESS_TYPE       =
*             ADDRESS_NUMBER     = VBDKA-ADRNR
*             PERSON_NUMBER      = VBDKA-ADRNP
              address_number     = addr_key-addrnumber
              person_number      = addr_key-persnumber
         IMPORTING
              comm_type          = lvs_comm_type
              comm_values        = lvs_comm_values
*        TABLES
*             STRATEGY_TABLE     =
         EXCEPTIONS
              address_not_exist  = 1
              person_not_exist   = 2
              no_comm_type_found = 3
              internal_error     = 4
              parameter_error    = 5
              OTHERS             = 6.
    IF sy-subrc <> 0.
      retcode = sy-subrc.
      syst-msgty = 'E'.
      PERFORM protocol_update.
    ENDIF.

  ENDIF.


* convert communication data
  MOVE-CORRESPONDING nast TO lvs_snast.
  MOVE sy-repid           TO lvf_program.
  CALL FUNCTION 'CONVERT_COMM_TYPE_DATA'
       EXPORTING
            pi_comm_type              = lvs_comm_type
            pi_comm_values            = lvs_comm_values
            pi_screen                 = us_screen
*           PI_NEWID                  =
            pi_country                = us_country
            pi_repid                  = lvf_program
            pi_snast                  = lvs_snast
       IMPORTING
            pe_itcpo                  = lvs_itcpo
            pe_device                 = lvf_device
            pe_mail_recipient         = lvs_recipient
            pe_mail_sender            = lvs_sender
       EXCEPTIONS
            comm_type_not_supported   = 1
            recipient_creation_failed = 2
            sender_creation_failed    = 3
            OTHERS                    = 4.
  IF sy-subrc <> 0.
    retcode = sy-subrc.
    syst-msgty = 'E'.
    PERFORM protocol_update.
  ENDIF.

  CHECK retcode EQ 0.

* if there is no communication type
  IF  lvs_comm_type IS INITIAL.
*   set device
    CASE nast-nacha.
      WHEN '1'.
        lvf_device = 'PRINTER'.
      WHEN '2'.
        lvf_device = 'TELEFAX'.
        lvs_itcpo-tdtelenum = nast-telfx.
        IF nast-tland IS INITIAL.
          lvs_itcpo-tdteleland = us_country.
        ELSE.
          lvs_itcpo-tdteleland = nast-tland.
        ENDIF.
        lvs_itcpo-tdsenddate = nast-vsdat.
        lvs_itcpo-tdsendtime = nast-vsura.
        lvs_itcpo-tdfaxuser  = nast-usnam.
      WHEN '3'.
        lvf_device = 'TELETEX'.
        lvs_itcpo-tdtelenum = nast-teltx.
        IF nast-tland IS INITIAL.
          lvs_itcpo-tdteleland = us_country.
        ELSE.
          lvs_itcpo-tdteleland = nast-tland.
        ENDIF.
        lvs_itcpo-tdsenddate = nast-vsdat.
        lvs_itcpo-tdsendtime = nast-vsura.
      WHEN '4'.
        lvf_device = 'TELEX'.
        lvs_itcpo-tdtelenum = nast-telx1.
        IF nast-tland IS INITIAL.
          lvs_itcpo-tdteleland = us_country.
        ELSE.
          lvs_itcpo-tdteleland = nast-tland.
        ENDIF.
        lvs_itcpo-tdsenddate = nast-vsdat.
        lvs_itcpo-tdsendtime = nast-vsura.
      WHEN OTHERS.
        lvf_device = 'PRINTER'.
    ENDCASE.
  ENDIF.

* fill structure itcpo
  itcpo = lvs_itcpo.

* OTF-Output, wenn Browser-Druck
  IF nast-sort1 = 'EBPP'.
    lvs_itcpo-tdgetotf = 'X'.
  ENDIF.

*... Now determine what device based on destination type.
  PERFORM determine_device USING itcpo lvf_device.
* Check PDF table if a PDF file is requested.
  PERFORM determine_pdf.
*******begin of mod-008 insert
  IF gflg_send IS NOT INITIAL.
    itcpo-tdcopies = 1.                " Number of copies
    itcpo-tdnoprev = gc_true.          " No print preview
    itcpo-tdgetotf = 'X'.
    itcpo-tdnoprint = 'X'.
    itcpo-tdarmod = '1'.

    CALL FUNCTION 'OPEN_FORM'
      EXPORTING
        archive_index  = toa_dara
        archive_params = arc_params
        device         = lvf_device
        dialog         = ' '
        form           = tnapr-fonam
        language       = nast-spras
        OPTIONS        = itcpo
        mail_sender    = lvs_sender
        mail_recipient = lvs_recipient
      IMPORTING
        RESULT         = gv_res.
  ENDIF.
*******end of mod-008 insert
*******begin of mod-008 insert
  IF gflg_send IS INITIAL.
*******end of mod-008 insert

    IF gv_pdf = gc_true.

      itcpo-tdcopies = 1.                " Number of copies
      itcpo-tdnoprev = gc_true.          " No print preview
      itcpo-tdgetotf = gc_true.          " Return of OTF table
* next line deleted to prevent # in PDF
****    itcpo-tddest   = gc_locl.          " Spool: Output device

      CALL FUNCTION 'OPEN_FORM'
        EXPORTING
          archive_index  = toa_dara
          archive_params = arc_params
          device         = lvf_device
          dialog         = ' '
          form           = tnapr-fonam
          language       = nast-spras
          OPTIONS        = itcpo
          mail_sender    = lvs_sender
          mail_recipient = lvs_recipient
        IMPORTING
          RESULT         = gv_res.

    ELSE.
* open sapscript form
      CALL FUNCTION 'OPEN_FORM'
        EXPORTING
          archive_index  = toa_dara
          archive_params = arc_params
          device         = lvf_device
          dialog         = ' '
          form           = tnapr-fonam
          language       = nast-spras
          OPTIONS        = itcpo
          mail_sender    = lvs_sender
          mail_recipient = lvs_recipient.
    ENDIF.
*******begin of mod-008 insert
  ENDIF.
*******end of mod-008 insert

  SET COUNTRY us_country.
* end of insertion MOD-001

ENDFORM.                    "form_open

*---------------------------------------------------------------------*
*       FORM FORM_TITLE_PRINT                                         *
*---------------------------------------------------------------------*
*       Printing of the form title depending of the field VBTYP       *
*---------------------------------------------------------------------*

FORM form_title_print.

  CASE vbdkr-vbtyp.
    WHEN 'M'.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TITLE_M'
          window  = 'TITLE'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    WHEN 'N'.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TITLE_N'
          window  = 'TITLE'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    WHEN 'O'.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TITLE_O'
          window  = 'TITLE'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    WHEN 'P'.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TITLE_P'
          window  = 'TITLE'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    WHEN 'S'.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TITLE_S'
          window  = 'TITLE'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    WHEN 'U'.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TITLE_U'
          window  = 'TITLE'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    WHEN OTHERS.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TITLE_M'
          window  = 'TITLE'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
  ENDCASE.
*  IF repeat NE space.
*    CALL FUNCTION 'WRITE_FORM'
*      EXPORTING
*        element = 'KOPIA'
*        window  = 'REPEAT'
*      EXCEPTIONS
*        element = 1
*        window  = 2.
*    IF sy-subrc NE 0.
*      PERFORM protocol_update.
*    ENDIF.
*  ELSE.
*    CALL FUNCTION 'WRITE_FORM'
*      EXPORTING
*        element = 'ORYGINAL'
*        window  = 'REPEAT'
*      EXCEPTIONS
*        element = 1
*        window  = 2.
*    IF sy-subrc NE 0.
*      PERFORM protocol_update.
*    ENDIF.
*  ENDIF.

ENDFORM.                    "form_title_print
*---------------------------------------------------------------------*
*       FORM GET_DATA                                                 *
*---------------------------------------------------------------------*
*       General provision of data for the form                        *
*---------------------------------------------------------------------*

FORM get_data.

  CALL FUNCTION 'RV_PRICE_PRINT_REFRESH'
    TABLES
      tkomv = tkomv.
  CLEAR komk.
  CLEAR komp.
  CLEAR nast_anzal.      "Clear aux. variable for number of outputs
  CLEAR   sdaccdpc.
  REFRESH ixsdaccdpc.
  CLEAR downpay_refresh.


  IF nast-objky+10(6) NE space.
    vbco3-vbeln = nast-objky+16(10).
  ELSE.
    vbco3-vbeln = nast-objky.
  ENDIF.

  vbco3-mandt = sy-mandt.
  vbco3-spras = nast-spras.
  vbco3-kunde = nast-parnr.
  vbco3-parvw = nast-parvw.

* DP Poland Correction Invoice

  SELECT SINGLE * FROM vbrk INTO gs_vbrk
  WHERE vbeln = vbco3-vbeln.

  CALL FUNCTION 'RV_BILLING_PRINT_VIEW'
    EXPORTING
      comwa                        = vbco3
    IMPORTING
      kopf                         = vbdkr
    TABLES
      pos                          = tvbdpr
    EXCEPTIONS
      terms_of_payment_not_in_t052 = 1
      error_message                = 5
      OTHERS                       = 4.
  IF NOT sy-subrc IS INITIAL.
    IF sy-subrc = 1.
      syst-msgty = 'I'.
      PERFORM protocol_update.
    ENDIF.
  ENDIF.

* DP Poland Correction Invoice

  IF gs_vbrk-vbtyp = 'O'.
    corr_tvbdpr[] = tvbdpr[].
    corr_vbco3 = vbco3.
    IF gs_vbrk-vbeln NE gs_vbrk-xblnr.
      corr_vbco3-vbeln = gs_vbrk-xblnr.
    ELSE.
      corr_vbco3-vbeln = gs_vbrk-zuonr.
    ENDIF.
    REFRESH tvbdpr.

    CALL FUNCTION 'RV_BILLING_PRINT_VIEW'
      EXPORTING
        comwa                        = corr_vbco3
      IMPORTING
        kopf                         = corr_vbdkr
      TABLES
        pos                          = tvbdpr
      EXCEPTIONS
        terms_of_payment_not_in_t052 = 1
        error_message                = 5
        OTHERS                       = 4.

  ENDIF.

* fill address key --> necessary for emails
  addr_key-addrnumber = vbdkr-adrnr.
  addr_key-persnumber = vbdkr-adrnp.
  addr_key-addr_type  = vbdkr-address_type.

  PERFORM sender.
  PERFORM check_repeat.
  PERFORM get_header_prices.
* Calling customer subroutine dynamically for additional data transfer
  IF NOT get_data_userexit IS INITIAL.
    PERFORM (get_data_userexit) IN PROGRAM rvadin01 IF FOUND.
  ENDIF.
  PERFORM down_payment_poland.
ENDFORM.                    "get_data


*---------------------------------------------------------------------*
*       FORM GET_ITEM_CHARACTERISTICS                                 *
*---------------------------------------------------------------------*
*       In this routine the configuration data item is fetched from   *
*       the database.                                                 *
*---------------------------------------------------------------------*

FORM get_item_characteristics.

  DATA da_t_cabn LIKE cabn OCCURS 10 WITH HEADER LINE.
  DATA: BEGIN OF da_key,
          mandt LIKE cabn-mandt,
          atinn LIKE cabn-atinn,
        END   OF da_key.

  REFRESH tkomcon.
  CHECK NOT vbdpr-cuobj IS INITIAL.

  CALL FUNCTION 'VC_I_GET_CONFIGURATION'
    EXPORTING
      instance      = vbdpr-cuobj
      language      = nast-spras
      print_sales   = 'X'
    TABLES
      configuration = tkomcon
    EXCEPTIONS
      OTHERS        = 4.

  RANGES : da_in_cabn FOR da_t_cabn-atinn.
* Beschreibung der Merkmale wegen Objektmerkmalen auf sdcom-vkond holen
  CLEAR da_in_cabn. REFRESH da_in_cabn.
  LOOP AT tkomcon.
    da_in_cabn-option = 'EQ'.
    da_in_cabn-sign   = 'I'.
    da_in_cabn-low    = tkomcon-atinn.
    APPEND da_in_cabn.
  ENDLOOP.

  CLEAR da_t_cabn. REFRESH da_t_cabn.
  CALL FUNCTION 'CLSE_SELECT_CABN'
*    EXPORTING
*         KEY_DATE                     = SY-DATUM
*         BYPASSING_BUFFER             = ' '
*         WITH_PREPARED_PATTERN        = ' '
*         I_AENNR                      = ' '
*    IMPORTING
*         AMBIGUOUS_OBJ_CHARACTERISTIC =
     TABLES
          in_cabn                      = da_in_cabn
          t_cabn                       = da_t_cabn
     EXCEPTIONS
          no_entry_found               = 1
          OTHERS                       = 2.

* Preisfindungsmerkmale und Merkmale auf vcsd_update herausnehmen
  SORT da_t_cabn.
  LOOP AT tkomcon.
    da_key-mandt = sy-mandt.
    da_key-atinn = tkomcon-atinn.
    READ TABLE da_t_cabn WITH KEY da_key BINARY SEARCH.
    IF sy-subrc <> 0 OR
         ( ( da_t_cabn-attab = 'SDCOM' AND
            da_t_cabn-atfel = 'VKOND'       ) OR
          ( da_t_cabn-attab = 'VCSD_UPDATE' ) ) .
      DELETE tkomcon.
    ENDIF.
  ENDLOOP.

ENDFORM.                    "get_item_characteristics

*---------------------------------------------------------------------*
*       FORM GET_ITEM_PRICES                                          *
*---------------------------------------------------------------------*
*       In this routine the price data for the item is fetched from   *
*       the database.                                                 *
*---------------------------------------------------------------------*

FORM get_item_prices.

  CLEAR: komp,
         tkomv.

  IF komk-knumv NE vbdkr-knumv.
    CLEAR komk.
    komk-mandt = sy-mandt.
    komk-kalsm = vbdkr-kalsm.
    komk-fkart = vbdkr-fkart.
    komk-kappl = pr_kappl.
    IF vbdkr-kappl NE space.
      komk-kappl = vbdkr-kappl.
    ENDIF.
    komk-waerk = vbdkr-waerk.
    komk-knumv = vbdkr-knumv.
    komk-vbtyp = vbdkr-vbtyp.
    komk-bukrs = vbdkr-bukrs.
    komk-land1 = vbdkr-lland.
    komk-vkorg = vbdkr-vkorg.
    komk-vtweg = vbdkr-vtweg.
    komk-spart = vbdkr-spart.
    komk-hwaer = vbdkr-waers.
    komk-prsdt = vbdkr-erdat.
    komk-kurst = vbdkr-kurst.
    komk-kurrf = vbdkr-kurrf.
    komk-kurrf_dat = vbdkr-kurrf_dat.
  ENDIF.
  komp-kposn = vbdpr-posnr.
  komp-kursk = vbdpr-kursk.
  komp-kursk_dat = vbdpr-kursk_dat.
  IF vbdkr-vbtyp CA 'HKNOT6'.
    IF  vbdpr-shkzg CA ' A'.
      komp-shkzg = 'X'.
    ENDIF.
  ELSE.
    IF  vbdpr-shkzg CA 'BX'.
      komp-shkzg = 'X'.
    ENDIF.
  ENDIF.

  CALL FUNCTION 'RV_PRICE_PRINT_ITEM'
    EXPORTING
      comm_head_i = komk
      comm_item_i = komp
      language    = nast-spras
    IMPORTING
      comm_head_e = komk
      comm_item_e = komp
    TABLES
      tkomv       = tkomv
      tkomvd      = tkomvd.

*Begin of insert MOD-007
*Retrieve the VAT% for each line item
  DATA: wa_komv TYPE komv,
        lv_tax  TYPE kbetr.

  CLEAR: lv_tax,
         wa_komv.
  IF vbdkr-fkart EQ 'ZF6' OR vbdkr-fkart EQ 'ZF2D'.
    READ TABLE tkomv INTO wa_komv WITH KEY kposn = vbdpr-posnr
                                           kschl = 'MWST'.
    IF sy-subrc EQ 0.
      lv_tax       = wa_komv-kbetr / 10.
      vbdpr-kbetrl = lv_tax.
    ENDIF.
  ELSEIF vbdkr-fkart EQ 'FAF' OR vbdkr-fkart EQ 'FAFS'.
    READ TABLE tkomv INTO wa_komv WITH KEY kposn = vbdpr-posnr
                                           kschl = 'MWIG'.
    IF sy-subrc EQ 0.
      lv_tax       = wa_komv-kbetr / 10.
      vbdpr-kbetrl = lv_tax.
    ENDIF.
  ENDIF.
*End of insert MOD-007

* Calling customer subroutine dynamically for handling item prices
  IF NOT item_userexit IS INITIAL.
    PERFORM (item_userexit) IN PROGRAM rvadin01 IF FOUND.
  ENDIF.

ENDFORM.                    "get_item_prices

*---------------------------------------------------------------------*
*       FORM GET_HEADER_PRICES                                        *
*---------------------------------------------------------------------*
*       In this routine the price data for the header is fetched from *
*       the database.                                                 *
*---------------------------------------------------------------------*

FORM get_header_prices.

  IF komk-knumv NE vbdkr-knumv.
    CLEAR komk.
    komk-mandt = sy-mandt.
    komk-kalsm = vbdkr-kalsm.
    komk-fkart = vbdkr-fkart.
    komk-kappl = pr_kappl.
    IF vbdkr-kappl NE space.
      komk-kappl = vbdkr-kappl.
    ENDIF.
    komk-waerk = vbdkr-waerk.
    komk-knumv = vbdkr-knumv.
    komk-vbtyp = vbdkr-vbtyp.
    komk-knuma = vbdkr-knuma.
    komk-bukrs = vbdkr-bukrs.
    komk-land1 = vbdkr-lland.
    komk-vkorg = vbdkr-vkorg.
    komk-vtweg = vbdkr-vtweg.
    komk-spart = vbdkr-spart.
    komk-hwaer = vbdkr-waers.
    komk-prsdt = vbdkr-erdat.
    komk-kurst = vbdkr-kurst.
    komk-kurrf = vbdkr-kurrf.
    komk-kurrf_dat = vbdkr-kurrf_dat.
  ENDIF.
  CALL FUNCTION 'RV_PRICE_PRINT_HEAD'
    EXPORTING
      comm_head_i = komk
      language    = nast-spras
    IMPORTING
      comm_head_e = komk
      comm_mwskz  = print_mwskz
    TABLES
      tkomv       = tkomv
      tkomvd      = hkomvd.
* begin of insertion MOD-004
  IF hkomvd[] IS INITIAL.
    LOOP AT tkomv.
      IF tkomv-kschl = 'MWST'.
        MOVE-CORRESPONDING tkomv TO hkomvd.
        APPEND hkomvd.
        CLEAR hkomvd.
      ENDIF.
    ENDLOOP.
    LOOP AT hkomvd.
      IF hkomvd-kbetr > 100.
        hkomvd-kbetr = hkomvd-kbetr / 10.
      ENDIF.
      MODIFY hkomvd.
    ENDLOOP.
  ENDIF.
* end of insertion MOD-004
* Calling customer subroutine dynamically for handling header prices
  IF NOT header_userexit IS INITIAL.
    PERFORM (header_userexit) IN PROGRAM rvadin01 IF FOUND.
  ENDIF.

ENDFORM.                    "get_header_prices

*---------------------------------------------------------------------*
*       FORM HEADER_PRICE_PRINT                                       *
*---------------------------------------------------------------------*
*       Printout of the header prices                                 *
*---------------------------------------------------------------------*

FORM header_price_print.

  LOOP AT hkomvd.

    AT FIRST.
      IF komk-supos NE 0.
        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            element = 'ITEM_SUM'.
      ELSE.
        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            element = 'UNDER_LINE'
          EXCEPTIONS
            element = 1
            window  = 2.
        IF sy-subrc NE 0.
          PERFORM protocol_update.
        ENDIF.
      ENDIF.
    ENDAT.

    komvd = hkomvd.

* For clearing note reversal to print negative values
* of netprice and tax amount.

    IF gv_inv_typ = 'N'.
      komvd-kawrt = komvd-kawrt * ( -1 ).
      komvd-kwert = komvd-kwert * ( -1 ).
    ENDIF.

    IF print_mwskz = space.
      CLEAR komvd-mwskz.
    ENDIF.
    IF komvd-koaid = 'D'.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TAX_LINE'.
    ELSE.
      IF NOT komvd-kntyp EQ 'f'.
        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            element = 'SUM_LINE'.
      ENDIF.
    ENDIF.
  ENDLOOP.
  DESCRIBE TABLE hkomvd LINES sy-tfill.
  IF sy-tfill = 0.
    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'UNDER_LINE'
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.
  ENDIF.
* Calling customer subroutine dynamically for handling header price
* printing
  IF NOT header_print_userexit IS INITIAL.
    PERFORM (header_print_userexit) IN PROGRAM rvadin01 IF FOUND.
  ENDIF.

ENDFORM.                    "header_price_print

*---------------------------------------------------------------------*
*       FORM HEADER_TEXT_PRINT                                        *
*---------------------------------------------------------------------*
*       Printout of the headertexts                                   *
*---------------------------------------------------------------------*

FORM header_text_print.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'HEADER_TEXT'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "header_text_print

*---------------------------------------------------------------------*
*       FORM ITEM_CHARACERISTICS_PRINT                                *
*---------------------------------------------------------------------*
*       Printout of the item characteristics -> configuration         *
*---------------------------------------------------------------------*

FORM item_characteristics_print.

  LOOP AT tkomcon.
    conf_out = tkomcon.
    IF sy-tabix = 1.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'ITEM_LINE_CONFIGURATION_HEADER'
        EXCEPTIONS
          OTHERS  = 1.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    ELSE.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'ITEM_LINE_CONFIGURATION'
        EXCEPTIONS
          OTHERS  = 1.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    "item_characteristics_print

*---------------------------------------------------------------------*
*       FORM ITEM_PRICE_PRINT                                         *
*---------------------------------------------------------------------*
*       Printout of the item prices                                   *
*---------------------------------------------------------------------*

FORM item_price_print.
* begin of insertion mj 20070712
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'ITEM_LINE_PRICE_TEXT'.
* end of insertion mj 20070712
* begin of deletion mj 20070712

**  LOOP AT tkomvd.
**    komvd = tkomvd.
****Adjust for DP Poland DP Invoice**********
**    IF NOT gv_dp_invoice IS INITIAL.
**      IF komvd-koaid = 'D'.
**        CLEAR gt_vbap.
**        READ TABLE gt_vbap WITH KEY posnr = vbdpr-posnr_vauf.
**        komvd-kwert = gt_vbap-mwsbp.
**      ENDIF.
**    ENDIF.
*****end DP POLAND**************************
**    IF print_mwskz EQ space.
**      CLEAR komvd-mwskz.
**    ENDIF.
**    IF sy-tabix = 1.
**      IF komvd-koaid = 'B' OR komvd-kschl IS INITIAL.
**        CALL FUNCTION 'WRITE_FORM'
**          EXPORTING
**            element = 'ITEM_LINE_PRICE_QUANTITY'.
**      ELSE.
**        CALL FUNCTION 'WRITE_FORM'
**          EXPORTING
**            element = 'ITEM_LINE_PRICE_TEXT'.
**      ENDIF.
**    ELSE.
**      IF komvd-kntyp NE 'f'.
**        CALL FUNCTION 'WRITE_FORM'
**          EXPORTING
**            element = 'ITEM_LINE_PRICE_TEXT'.
**      ELSE.
**        CALL FUNCTION 'WRITE_FORM'
**          EXPORTING
**            element = 'ITEM_LINE_REBATE_IN_KIND'.
**      ENDIF.
**    ENDIF.
**   ENDLOOP.
* Calling customer subroutine dynamically for handling item price
* printing
  IF NOT item_print_userexit IS INITIAL.
    PERFORM (item_print_userexit) IN PROGRAM rvadin01 IF FOUND.
  ENDIF.

ENDFORM.                    "item_price_print

*---------------------------------------------------------------------*
*       FORM ITEM_PRINT                                               *
*---------------------------------------------------------------------*
*       Printout of the items                                         *
*---------------------------------------------------------------------*

FORM item_print.

  DATA: da_ganf(1) TYPE c,      "Print flag for billing correction
        da_lanf(1) TYPE c.      "Print flag for billing correction

  CALL FUNCTION 'WRITE_FORM'           "First header
       EXPORTING  element = 'ITEM_HEADER'
       EXCEPTIONS OTHERS  = 1.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.
  CALL FUNCTION 'WRITE_FORM'           "Activate header
       EXPORTING  element = 'ITEM_HEADER'
                  type    = 'TOP'
       EXCEPTIONS OTHERS  = 1.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

* begin of insertion MOD-003
* collect lines with options to machine line
  IF nast-kschl = 'ZDP1'.
* copy internal table and add extra info
    REFRESH gt_tvbdpr.
    CLEAR gt_tvbdpr.
    LOOP AT tvbdpr.
      CLEAR: gv_matkl, gv_uepos.
      MOVE-CORRESPONDING tvbdpr TO gt_tvbdpr.
      SELECT SINGLE uepos matkl INTO (gv_uepos, gv_matkl)
          FROM vbap WHERE vbeln = vbdkr-vbeln_vauf
                      AND posnr = gt_tvbdpr-posnr.
      gt_tvbdpr-matkl2 = gv_matkl.
      gt_tvbdpr-uepos2 = gv_uepos.
      APPEND gt_tvbdpr.
      CLEAR gt_tvbdpr.
    ENDLOOP.
* sort gt_tvbdpr
**    sort gt_tvbdpr by matkl2 uepos2.
    SORT gt_tvbdpr BY uepos2 matkl2.
    CLEAR: gv_uepos, gv_orgpos.
    LOOP AT gt_tvbdpr.
      IF NOT gt_tvbdpr-uepos2 IS INITIAL AND
         gt_tvbdpr-uepos2 <> gv_uepos.
        gv_uepos = gt_tvbdpr-uepos2.
        gv_orgpos = gt_tvbdpr-posnr.
      ENDIF.
      IF NOT gt_tvbdpr-uepos2 IS INITIAL AND
             gt_tvbdpr-matkl2 = '03'.
        gt_tvbdpr-orgpos = gv_orgpos.
      ENDIF.
      MODIFY gt_tvbdpr.
    ENDLOOP.
* update the correct record in table tvbdpr.
    LOOP AT gt_tvbdpr.
      IF NOT gt_tvbdpr-orgpos IS INITIAL.
* update record with header machine
        READ TABLE tvbdpr WITH KEY posnr = gt_tvbdpr-orgpos
                          BINARY SEARCH.
        IF sy-subrc = 0.
          gv_index = sy-tabix.
          tvbdpr-netwr = tvbdpr-netwr + gt_tvbdpr-netwr.
          tvbdpr-mwsbp = tvbdpr-mwsbp + gt_tvbdpr-mwsbp.
          tvbdpr-netprl = tvbdpr-netprl + gt_tvbdpr-netprl.
          tvbdpr-brtwr = tvbdpr-brtwr + gt_tvbdpr-brtwr.
          MODIFY tvbdpr INDEX gv_index.
        ENDIF.
* delete record with option
        READ TABLE tvbdpr WITH KEY posnr = gt_tvbdpr-posnr
                          BINARY SEARCH.
        IF sy-subrc = 0.
          gv_index = sy-tabix.
          DELETE tvbdpr INDEX gv_index.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.
* end of insertion MOD-003

  LOOP AT tvbdpr.

    vbdpr = tvbdpr.
* Bei Fakturen, die keine Anzahlungsanforderungen darstellen, werden
* die Verrechnungspositionen nicht gedruckt

* mj skip item category 'ZP1'
    IF vbdpr-pstyv <> 'ZP1'.

      IF ( vbdkr-fktyp EQ 'P'  )       OR
         ( vbdkr-fktyp NE 'P' AND vbdpr-fareg NA '45' ).
        PERFORM item_billing_correction_header USING da_ganf da_lanf.
        IF tvbdpr-uecha EQ vbdpr-posnr OR
           tvbdpr-uecha IS INITIAL.
          PERFORM get_item_prices.
          PERFORM get_item_characteristics.
          CALL FUNCTION 'CONTROL_FORM'
            EXPORTING
              command = 'PROTECT'.
          CALL FUNCTION 'WRITE_FORM'
            EXPORTING
              element = 'ITEM_LINE'.
          IF tvbdpr-charg NE space.
            CALL FUNCTION 'WRITE_FORM'
              EXPORTING
                element = 'ITEM_LINE_BATCH'
              EXCEPTIONS
                OTHERS  = 1.
            IF sy-subrc NE 0.
              PERFORM protocol_update.
            ENDIF.
          ENDIF.
          PERFORM item_price_print.
          PERFORM item_characteristics_print.
          PERFORM item_reference_billing.
          CALL FUNCTION 'CONTROL_FORM'
            EXPORTING
              command = 'ENDPROTECT'.
          PERFORM item_text_print.
          PERFORM different_consignee.
          PERFORM different_order_no.
* begin of deletion mj20070718
*          PERFORM different_delivery_no.
* end of deletion mj20070718
          PERFORM different_extern_no.
          PERFORM different_purchase_order_no.
          PERFORM different_reference_no.
        ELSE.
          IF NOT tvbdpr-fkimg IS INITIAL.
            PERFORM get_item_prices.
            CALL FUNCTION 'WRITE_FORM'
              EXPORTING
                element = 'ITEM_LINE_BATCH'
              EXCEPTIONS
                OTHERS  = 1.
            IF sy-subrc NE 0.
              PERFORM protocol_update.
            ENDIF.
            PERFORM item_price_print.
          ENDIF.
        ENDIF.
*   IF NOT VBDPR-PREFE IS INITIAL.
*     CALL FUNCTION 'WRITE_FORM'
*          EXPORTING
*               ELEMENT = 'PREFERENCE_TEXT'
*          EXCEPTIONS
*               OTHERS  = 1.
*     IF SY-SUBRC NE 0.
*       PERFORM PROTOCOL_UPDATE.
*     ENDIF.
*   ENDIF.
      ENDIF.
      IF vbdkr-fktyp NE 'P'.
        IF vbdpr-fareg CA '45'.
          PERFORM get_downpayment_data.
        ENDIF.
      ENDIF.

* Billingplan 14

      IF NOT vbdpr-fplnr IS INITIAL.
        PERFORM get_billingplan_data.
      ENDIF.
*  print serial numbers
      REFRESH: gv_sernrs.

      IF NOT tvbdpr-vbeln_vl IS INITIAL.
        SELECT * FROM ser01 WHERE lief_nr = tvbdpr-vbeln_vl
                              AND posnr  = tvbdpr-posnr_vl.
          IF sy-subrc = 0.
            SELECT * FROM objk WHERE obknr = ser01-obknr.
              IF sy-subrc = 0.
                MOVE objk-sernr TO gv_sernrs-sernr.
                APPEND gv_sernrs.
                CLEAR gv_sernrs.
              ENDIF.
            ENDSELECT.
          ENDIF.
        ENDSELECT.
      ELSE.
        SELECT * FROM lips WHERE vgbel = tvbdpr-vbeln_vauf
                             AND vgpos = tvbdpr-posnr_vauf.
          IF sy-subrc = 0.
            SELECT * FROM ser01 WHERE lief_nr = lips-vbeln
                                   AND posnr  = lips-posnr.
              IF sy-subrc = 0.
                SELECT * FROM objk WHERE obknr = ser01-obknr.
                  IF sy-subrc = 0.
                    MOVE objk-sernr TO gv_sernrs-sernr.
                    APPEND gv_sernrs.
                    CLEAR gv_sernrs.
                  ENDIF.
                ENDSELECT.
              ENDIF.
            ENDSELECT.

          ENDIF.
        ENDSELECT.
      ENDIF.

      IF NOT gv_sernrs[] IS INITIAL.
        CLEAR : gv_sernr.
        LOOP AT gv_sernrs.
          MOVE gv_sernrs-sernr TO gv_sernr.
          CALL FUNCTION 'WRITE_FORM'
            EXPORTING
              element = 'SERIAL_NUMBER'
            EXCEPTIONS
              element = 1
              window  = 2.
          IF sy-subrc NE 0.
            PERFORM protocol_update.
          ENDIF.
        ENDLOOP.
      ENDIF.

* print frame text

      CONCATENATE tvbdpr-vbeln_vauf tvbdpr-posnr_vauf
         INTO gv_tdname.
      REFRESH gv_tline_tmp.

      CALL FUNCTION 'READ_TEXT'
        EXPORTING
          id                      = 'SL01'
          language                = t001-spras
          name                    = gv_tdname
          object                  = 'VBBP'
        TABLES
          lines                   = gv_tline_tmp
        EXCEPTIONS
          id                      = 1
          language                = 2
          name                    = 3
          not_found               = 4
          object                  = 5
          reference_check         = 6
          wrong_access_to_archive = 7
          OTHERS                  = 8.
      IF sy-subrc = 0.
        LOOP AT gv_tline_tmp.
          MOVE gv_tline_tmp-tdline TO gv_tdline.
          CALL FUNCTION 'WRITE_FORM'
            EXPORTING
              element = 'FRAME_TEXT'
            EXCEPTIONS
              element = 1
              window  = 2.
          IF sy-subrc NE 0.
            PERFORM protocol_update.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDLOOP.

  CALL FUNCTION 'WRITE_FORM'           "Deactivate Header
       EXPORTING  element  = 'ITEM_HEADER'
                  function = 'DELETE'
                  type     = 'TOP'
       EXCEPTIONS OTHERS   = 1.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "item_print

*---------------------------------------------------------------------*
*       FORM ITEM_TEXT_PRINT                                          *
*---------------------------------------------------------------------*
*       Printout of the item texts                                    *
*---------------------------------------------------------------------*

FORM item_text_print.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'ITEM_TEXT'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "item_text_print

*---------------------------------------------------------------------*
*       FORM PROTOCOL_UPDATE                                          *
*---------------------------------------------------------------------*
*       The messages are collected for the processing protocol.       *
*---------------------------------------------------------------------*

FORM protocol_update.

  CHECK xscreen = space.
  CALL FUNCTION 'NAST_PROTOCOL_UPDATE'
    EXPORTING
      msg_arbgb = syst-msgid
      msg_nr    = syst-msgno
      msg_ty    = syst-msgty
      msg_v1    = syst-msgv1
      msg_v2    = syst-msgv2
      msg_v3    = syst-msgv3
      msg_v4    = syst-msgv4
    EXCEPTIONS
      OTHERS    = 1.

ENDFORM.                    "protocol_update
*---------------------------------------------------------------------*
*       FORM PROTOCOL_UPDATE_SPOOL                                    *
*---------------------------------------------------------------------*
*       The messages are collected for the processing protocol.       *
*---------------------------------------------------------------------*

FORM protocol_update_spool USING syst-msgno h_i_itcpp-tdspoolid
                                 syst-msgv2 syst-msgv3 syst-msgv4.
  syst-msgid = 'VN'.
  syst-msgv1 = h_i_itcpp-tdspoolid.
  CONDENSE syst-msgv1.
  CHECK xscreen = space.
  CALL FUNCTION 'NAST_PROTOCOL_UPDATE'
    EXPORTING
      msg_arbgb = syst-msgid
      msg_nr    = syst-msgno
      msg_ty    = syst-msgty
      msg_v1    = syst-msgv1
      msg_v2    = syst-msgv2
      msg_v3    = syst-msgv3
      msg_v4    = syst-msgv4
    EXCEPTIONS
      OTHERS    = 1.

ENDFORM.                    "protocol_update_spool

*---------------------------------------------------------------------*
*       FORM SENDER                                                   *
*---------------------------------------------------------------------*
*       This routine determines the address of the sender (Table VKO) *
*---------------------------------------------------------------------*

FORM sender.

*  SELECT SINGLE * FROM tvko  WHERE vkorg = vbdkr-vkorg.
*  IF sy-subrc NE 0.
*    syst-msgid = 'VN'.
*    syst-msgno = '203'.
*    syst-msgty = 'E'.
*    syst-msgv1 = 'TVKO'.
*    syst-msgv2 = syst-subrc.
*    PERFORM protocol_update.
*    EXIT.
*  ENDIF.
  SELECT SINGLE * FROM t001  WHERE bukrs = vbdkr-bukrs.
  IF sy-subrc NE 0.
    EXIT.
  ENDIF.

  CLEAR gv_fb_addr_get_selection.
*  gv_fb_addr_get_selection-addrnumber = tvko-adrnr.
  gv_fb_addr_get_selection-addrnumber = t001-adrnr.

  CALL FUNCTION 'ADDR_GET'
    EXPORTING
      address_selection = gv_fb_addr_get_selection
      address_group     = 'CA01'
    IMPORTING
      sadr              = sadr
    EXCEPTIONS
      OTHERS            = 01.                               "SADR40A
  IF sy-subrc NE 0.
    CLEAR sadr.
  ENDIF.

  vbdkr-sland = sadr-land1.

  IF sy-subrc NE 0.
    syst-msgid = 'VN'.
    syst-msgno = '203'.
    syst-msgty = 'E'.
    syst-msgv1 = 'SADR'.
    syst-msgv2 = syst-subrc.
    PERFORM protocol_update.
  ENDIF.

* Interne Verrechnung: Adresse des Buchungskreises lesen
  IF vbdkr-vbtyp CA '56'.
    CLEAR t001g.
    SELECT SINGLE * FROM t001g WHERE bukrs = vbdkr-bukrs
                                 AND programm EQ sy-repid
                                 AND txtid EQ 'SD'.
  ENDIF.

ENDFORM.                    "sender

*&---------------------------------------------------------------------*
*&      Form  HEADER_CONSGNEE
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM header_consgnee.

  IF vbdkr-name1 NE vbdkr-name1_we OR
     vbdkr-name2 NE vbdkr-name2_we OR
     vbdkr-name3 NE vbdkr-name3_we OR
     vbdkr-name4 NE vbdkr-name4_we   .
    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'HEADER_CONSGNEE'
        window  = 'CONSGNEE'
      EXCEPTIONS
        element = 1
        window  = 2.
    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'HEADER_CONSGNEE'
        window  = 'INFO1'
      EXCEPTIONS
        element = 1
        window  = 2.
  ENDIF.
ENDFORM.                               " HEADER_CONSGNEE
*&---------------------------------------------------------------------*
*&      Form  DIFFERENT_REFERENCE_NO
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM different_reference_no.

  CHECK vbdkr-vbtyp CA 'OP'.
  CHECK vbdkr-vbeln_vg2 NE vbdpr-vbeln_vg2.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'ITEM_REFERENCE_NO'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                               " DIFFERENT_REFERENCE_NO
*&---------------------------------------------------------------------*
*&      Form  HEADER_DATA_PRINT
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM header_data_print.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'HEADER_DATA'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                               " HEADER_DATA_PRINT
*&---------------------------------------------------------------------*
*&      Form  START_FORM
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM start_form.

  DATA : startseite(8) VALUE 'FIRSTBSR'.
  DATA : sprache LIKE sy-langu.

  IF vbdre-verfa = '04' OR vbdre-verfa = '08'.

    CALL FUNCTION 'START_FORM'
      EXPORTING
        archive_index = toa_dara
        startpage     = startseite
      IMPORTING
        language      = sprache
      EXCEPTIONS
        form          = 1
        format        = 2
        unended       = 3
        unopened      = 4
        unused        = 5
        OTHERS        = 6.
    IF sy-subrc NE 0.
      retcode = sy-subrc.
      PERFORM protocol_update.
    ENDIF.

  ENDIF.

ENDFORM.                               " START_OPEN
*&---------------------------------------------------------------------*
*&      Form  TAX_TEXT_PRINT
*&---------------------------------------------------------------------*
*       text                                                           *
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM tax_text_print.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'TAX_TEXT'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                               " TAX_TEXT_PRINT

***********************************************************************
*       CUSTOMER SUBROUTINES                                          *
***********************************************************************
*&---------------------------------------------------------------------*
*&      Form  ITEM_BILLING_CORRECTION_HEADER
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_DA_GANF  text                                              *
*      -->P_DA_LANF  text                                              *
*----------------------------------------------------------------------*
FORM item_billing_correction_header USING    us_ganf
                                             us_lanf.
  CHECK : vbdkr-knuma IS INITIAL.
  IF vbdpr-autyp = 'K'.
*   Gutschriftsanforderung
    IF vbdpr-shkzg = 'X'.
      IF us_ganf IS INITIAL.
        MOVE 'X'   TO us_ganf.
        MOVE space TO us_lanf.

        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            element = 'CORRECTION_TEXT_K'
          EXCEPTIONS
            element = 1
            window  = 2.
        IF sy-subrc NE 0.
          PERFORM protocol_update.
        ENDIF.
      ENDIF.
    ELSE.
      IF us_lanf IS INITIAL.
        MOVE 'X'   TO us_lanf.
        MOVE space TO us_ganf.

        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            element = 'CORRECTION_TEXT_L'
          EXCEPTIONS
            element = 1
            window  = 2.
        IF sy-subrc NE 0.
          PERFORM protocol_update.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  IF vbdpr-autyp = 'L'.
*   Lastschriftsanforderung
    IF vbdpr-shkzg = space.
      IF us_lanf IS INITIAL.
        MOVE 'X'   TO us_lanf.
        MOVE space TO us_ganf.

        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            element = 'CORRECTION_TEXT_L'
          EXCEPTIONS
            element = 1
            window  = 2.
        IF sy-subrc NE 0.
          PERFORM protocol_update.
        ENDIF.
      ENDIF.
    ELSE.
      IF us_ganf IS INITIAL.
        MOVE 'X'   TO us_ganf.
        MOVE space TO us_lanf.

        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            element = 'CORRECTION_TEXT_K'
          EXCEPTIONS
            element = 1
            window  = 2.
        IF sy-subrc NE 0.
          PERFORM protocol_update.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                               " ITEM_BILLING_CORRECTION_HEADER
*&---------------------------------------------------------------------*
*&      Form  ITEM_REFERENCE_BILLING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM item_reference_billing.

  CHECK vbdpr-vbklt EQ 'D'.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'ITEM_REFERENCE_BILLING'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                               " ITEM_REFERENCE_BILLING
*&---------------------------------------------------------------------*
*&      Form  DOWNPAYMENT_INFO
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM downpayment_value.
  CHECK NOT vbdkr-dpval IS INITIAL.
  vbdkr-dpend = komk-fkwrt.
  SUBTRACT vbdkr-dpval FROM vbdkr-dpend.
  vbdkr-dpmws_end = vbdkr-mwsbk - vbdkr-dpmws.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'DOWNPAYMENT_VALUE'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.
ENDFORM.                               " DOWNPAYMENT_INFO

*&---------------------------------------------------------------------*
*&      Form  PAYMENTCARD_VALUES
*&---------------------------------------------------------------------*
*       Print Payment Cards
*----------------------------------------------------------------------*
*  -->  VBDKR Header
*----------------------------------------------------------------------*
FORM paymentcard_values.

  DATA: da_xfplt LIKE fpltvb OCCURS 2 WITH HEADER LINE. " Cards

  IF NOT vbdkr-rplnr IS INITIAL.
* Read from the Database
    CALL FUNCTION 'BILLING_SCHEDULE_READ'
      EXPORTING
        fplnr         = vbdkr-rplnr
      TABLES
        zfplt         = da_xfplt
      EXCEPTIONS
        error_message = 0
        OTHERS        = 0.
* Loop at Cards
    LOOP AT da_xfplt.
      MOVE-CORRESPONDING da_xfplt TO fpltvb.
* Get text
      IF da_xfplt-ccins NE tvcint-ccins.
        SELECT SINGLE * FROM tvcint
               WHERE spras = vbco3-spras
               AND   ccins = da_xfplt-ccins.
        IF sy-subrc =  0.
          ccname = tvcint-vtext.
        ELSE.
          ccname = da_xfplt-ccins.
        ENDIF.
      ENDIF.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'PAYMENTCARDS'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
      ADD da_xfplt-fakwr TO vbdkr-ccval.
    ENDLOOP.
    IF da_xfplt-fakwr NE vbdkr-ccval.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'PAYMENTCARD_SUM'
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               " PAYMENTCARD_VALUES

*---------------------------------------------------------------------*
*       FORM GET_DOWNPAYMENT_DATA                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM get_downpayment_data .
*     Lesen der fr die Kundenfaktura zu verrechnenden Anzahlung.

*     Can there be a head office?
  CASE vbdkr-xfilkd.
*       Ordering party
    WHEN chara.
      IF vbdkr-knkli IS INITIAL OR
         vbdkr-knkli EQ vbdkr-kunag.
        da_xfilkd = vbdkr-xfilkd.
      ENDIF.
*       Payer
    WHEN charb.
      da_xfilkd = vbdkr-xfilkd.
  ENDCASE.

*     Setzen der Belegnummer
  IF NOT vbdpr-vbelv IS INITIAL.
    gt_sdaccdpc_doc-vbeln = vbdpr-vbelv.
    gt_sdaccdpc_doc-posnr = vbdpr-posnv.
  ELSE.
    gt_sdaccdpc_doc-vbeln = vbdpr-vbeln_vauf.
    gt_sdaccdpc_doc-posnr = vbdpr-posnr_vauf.
  ENDIF.
  APPEND gt_sdaccdpc_doc.

  CALL FUNCTION 'SD_DOWNPAYMENT_READ'
    EXPORTING
      i_waerk           = vbdkr-waerk
      i_bukrs           = vbdkr-bukrs
      i_kunnr           = vbdkr-kunrg
      i_vbel2           = gt_sdaccdpc_doc-vbeln
      i_vbeln           = vbdkr-vbeln
      i_sfakn           = vbdkr-sfakn
      i_xfilkd          = da_xfilkd
      i_gesanz          = 'X'
      i_item_with_rrdp  = 'X'
    TABLES
      t_sdaccdpc        = ixsdaccdpc
    CHANGING
      c_downpay_refresh = downpay_refresh
    EXCEPTIONS
      no_downpayments   = 1
      in_downpayments   = 2
      OTHERS            = 3.


ENDFORM.                               " GET_DOWNPAYMENT_DATA

*&---------------------------------------------------------------------*
*&      Form  DOWNPAYMENTS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM downpayments .

  SORT gt_sdaccdpc_doc BY vbeln posnr.
  DELETE ADJACENT DUPLICATES FROM gt_sdaccdpc_doc.

  LOOP AT ixsdaccdpc.
    READ TABLE gt_sdaccdpc_doc WITH KEY vbeln = ixsdaccdpc-vgbel
                                        posnr = ixsdaccdpc-vgpos
                                        BINARY SEARCH.
    IF NOT sy-subrc IS INITIAL.
      DELETE ixsdaccdpc.
    ENDIF.
  ENDLOOP.

  LOOP AT ixsdaccdpc.
    sdaccdpc = ixsdaccdpc.

    AT FIRST.
      CALL FUNCTION 'CONTROL_FORM'
        EXPORTING
          command = 'PROTECT'.
      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'TERMS_OF_DOWNPAYMENT_HEADER'.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    ENDAT.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'TERMS_OF_DOWNPAYMENTS'
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    AT LAST.
      CALL FUNCTION 'CONTROL_FORM'
        EXPORTING
          command = 'ENDPROTECT'.
    ENDAT.

  ENDLOOP.



ENDFORM.                               " DOWNPAYMENTS
*&---------------------------------------------------------------------*
*&      Form  get_billingplan_data
*&---------------------------------------------------------------------*
*       14
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_billingplan_data.

  IF vbdpr-fplnr NE old_fplnr.
* Read from the Database
    CALL FUNCTION 'BILLING_SCHEDULE_READ'
      EXPORTING
        fplnr         = vbdpr-fplnr
      TABLES
        zfplt         = xfplt
      EXCEPTIONS
        error_message = 0
        OTHERS        = 0.
  ENDIF.

  old_fplnr = vbdpr-fplnr.

  READ TABLE xfplt WITH KEY fplnr = vbdpr-fplnr
                            fpltr = vbdpr-fpltr
                            BINARY SEARCH.

  MOVE-CORRESPONDING xfplt TO fpltvb.
  fpltvb-afdat = xfplt-afdat.
  fpltvb-fkdat = xfplt-fkdat.
  fpltvb-nfdat = xfplt-nfdat.


  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'TERMS_OF_BILLINGPLAN'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    " get_billingplan_data

*&---------------------------------------------------------------------*
*&      Form  previous_dp_invoice_print
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM previous_dp_invoice_print.

  DATA: lv_lines TYPE i.

  DESCRIBE TABLE gt_prev_dp_inv LINES lv_lines.

*  IF lv_lines NE 0.
*    CALL FUNCTION 'WRITE_FORM'
*      EXPORTING
*        element = 'PREVIOUS_DP_INVOICES_HD'
*      EXCEPTIONS
*        OTHERS  = 1.
*    IF sy-subrc NE 0.
*      PERFORM protocol_update.
*    ENDIF.
*  ENDIF.


  LOOP AT gt_prev_dp_inv.

    gs_prev_dp_inv = gt_prev_dp_inv.

    CLEAR: gv_docnumber.

    SELECT * FROM bkpf WHERE awtyp = 'VBRK'
                         AND awkey = gs_prev_dp_inv-vbeln.
    ENDSELECT.
    IF sy-subrc = 0.
      MOVE bkpf-belnr TO gv_docnumber.
    ELSE.
      MOVE vbdkr-vbeln TO gv_docnumber.
    ENDIF.


    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'PREVIOUS_DP_INVOICES'
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.
  ENDLOOP.

  REFRESH gt_prev_dp_inv.

ENDFORM.                    " previous_dp_invoice_print
*&---------------------------------------------------------------------*
*&      Form  down_payment_poland
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM down_payment_poland.

  PERFORM get_downpayment_amts.
  PERFORM adjust_print_lines_dp_invoice.

* DP Poland Correction Invoice
  PERFORM corr_and_partial_invoice.
  PERFORM adjust_print_lines_corr_invoic.

ENDFORM.                    " down_payment_poland
*&---------------------------------------------------------------------*
*&      Form  adjust_print_lines_dp_invoice
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM adjust_print_lines_dp_invoice.

  DATA lv_base_value TYPE kawrt.
  DATA ls_tvfk       TYPE tvfk.
  DATA ls_vbap       TYPE vbap.
  DATA ls_vbak_key   TYPE sales_key.

  DATA lt_vbap       TYPE TABLE OF vbap.
  DATA lt_vbak_key   TYPE TABLE OF sales_key.


  SELECT SINGLE * FROM tvfk INTO ls_tvfk WHERE fkart = vbdkr-fkart.

* check if it is a down payment invoice.
* the SD documenent category(VBTYP) is invoice and transaction group
* (trvog) is proforma invoice for a DP invoice.

  CHECK vbdkr-vbtyp = 'M' AND ls_tvfk-trvog = '8'.

  gv_dp_invoice = 'X'.
  gv_inv_typ    = 'D'.

*if the condition type is 'H'-Percentage included, subtract the
*tax value from the base value for correct printing in the tax lines
  LOOP AT hkomvd.
    IF hkomvd-krech = 'H'.
      SUBTRACT hkomvd-kwert FROM hkomvd-kawrt.
      MODIFY hkomvd.
    ENDIF.
  ENDLOOP.

  ls_vbak_key-vbeln = vbdkr-vbeln_vauf.
  APPEND ls_vbak_key TO lt_vbak_key.

  CALL FUNCTION 'SD_VBAP_ARRAY_READ_VBELN'
* EXPORTING
*   I_BYPASSING_BUFFER          = ' '
*   I_REFRESH_BUFFER            =
    TABLES
      it_vbak_key                 = lt_vbak_key
*   ET_VBAPVB                   =
      et_vbap                     = gt_vbap
  EXCEPTIONS
    records_not_found           = 1
    records_not_requested       = 2
    OTHERS                      = 3
            .
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

  CLEAR ls_vbap.
  LOOP AT tvbdpr.

    READ TABLE gt_vbap INTO ls_vbap WITH KEY vbeln = tvbdpr-vbeln_vauf
                                             posnr = tvbdpr-posnr_vauf.
    IF sy-subrc = 0.
      tvbdpr-netprl = ls_vbap-netpr.
      tvbdpr-netwr  = ls_vbap-netwr.
      tvbdpr-brtwr  = ls_vbap-netwr + ls_vbap-mwsbp.
      tvbdpr-mwsbp  = ls_vbap-mwsbp.
      MODIFY tvbdpr.
    ENDIF.

* Down payment acquistion date is got from FBUDA at item level
    IF gv_dp_rcpt_date IS INITIAL.
      gv_dp_rcpt_date = tvbdpr-fbuda.
    ENDIF.

  ENDLOOP.

  CLEAR  : gt_to_be_paid, gt_left_for_clearing, gt_dp_clearing.
  REFRESH: gt_to_be_paid, gt_left_for_clearing, gt_dp_clearing.

  gv_to_pay = vbdkr-netwr + vbdkr-mwsbk.

  PERFORM get_amt_in_words.


ENDFORM.                    " adjust_print_lines_dp_invoice
*&---------------------------------------------------------------------*
*&      Form  get_downpayment_amts
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_downpayment_amts.

  DATA ls_vbfa          TYPE vbfa.
  DATA lv_lines         TYPE i.
  DATA lt_vbrp_items    TYPE TABLE OF vbrp.
  DATA lt_vbrk_header   TYPE TABLE OF vbrk.
  DATA lt_konv          TYPE TABLE OF konv.
  DATA ls_vbrk_temp     TYPE vbrk.
  DATA ls_vbrp_temp     TYPE vbrp.
  DATA ls_konv_temp     TYPE konv.
  DATA ls_vbfa_temp     TYPE vbfa.
  DATA lv_diff          TYPE netwr_fp.
  DATA ls_konv          TYPE konv.
  DATA ls_amts_with_tax TYPE gtyp_amts_with_tax.
  DATA ls_spell         TYPE spell.
*  DATA lt_bkpf          TYPE TABLE OF bkpf.
  DATA lt_bkpf          TYPE TABLE OF bkpf WITH HEADER LINE.
  DATA lv_diff_tax      TYPE netwr_fp.


  DATA ls_invoices      TYPE ltyp_invoices.
  DATA ls_amt_taxcode   TYPE ltyp_amt_taxcode.
  DATA ls_dp_amt        TYPE ltyp_amt_taxcode.
  DATA ls_invoice_amt   TYPE ltyp_amt_taxcode.
  DATA ls_dp_amt_wa     TYPE ltyp_amt_taxcode.
  DATA ls_clearing_amt  TYPE ltyp_amt_taxcode.
  DATA ls_curr_inv_amt  TYPE ltyp_amt_taxcode.
  DATA ls_curr_inv_bkpf TYPE bkpf.
  DATA lv_awkey         TYPE awkey.
  DATA ls_bkpf          TYPE bkpf.
  DATA ls_prev_dp_inv   TYPE gtyp_previous_dp_invoices.
  DATA ls_tvfk          TYPE tvfk.
*
  DATA lt_dp_amt       TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA lt_invoice_amt  TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA lt_clearing_amt TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA lt_curr_inv_amt TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA lt_left_for_clearing
                       TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA lt_to_be_paid   TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA lt_invoices     TYPE TABLE OF ltyp_invoices    WITH HEADER LINE.

* DP Poland Correction Invoice
  DATA lt_partial_amt  TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA ls_partial_amt        TYPE ltyp_amt_taxcode.
  DATA lt_red_dp_clear  TYPE TABLE OF gtyp_corr_inv WITH HEADER LINE.
  DATA ls_red_dp_clear  TYPE gtyp_corr_inv.

  CALL FUNCTION 'SD_VBFA_READ_WITH_VBELV'
    EXPORTING
      i_vbelv                  = vbdkr-vbeln_vauf
*   I_BYPASSING_BUFFER       = ' '
*   I_REFRESH_BUFFER         =
    TABLES
*   ET_VBFAVB                =
      et_vbfa                  = gt_vbfa
   EXCEPTIONS
      record_not_found         = 1
      OTHERS                   = 2.

*---get all invoices-----------------------
  LOOP AT gt_vbfa INTO ls_vbfa WHERE vbtyp_n = 'M'.

    MOVE ls_vbfa-vbeln TO ls_invoices-vbeln.

    READ TABLE lt_invoices WITH KEY vbeln = ls_vbfa-vbeln
    TRANSPORTING NO FIELDS.

    IF sy-subrc NE 0.
      MOVE ls_vbfa-vbeln TO ls_invoices-vbeln.
      MOVE ls_vbfa-vbeln TO ls_invoices-awkey.
      APPEND ls_invoices TO lt_invoices.
    ENDIF.

  ENDLOOP.

* DP Poland Correction Invoices
  IF gs_vbrk-vbtyp NE 'O'.
    IF vbdkr-vbeln_vl NE '0'.
      PERFORM get_corr_invoices TABLES lt_invoices[].
    ENDIF.
  ENDIF.
  SORT lt_invoices BY vbeln.

  DESCRIBE TABLE lt_invoices LINES lv_lines.

  IF lv_lines NE 0.

    SELECT * FROM vbrp
    INTO TABLE lt_vbrp_items
    FOR ALL ENTRIES IN  lt_invoices
    WHERE vbeln = lt_invoices-vbeln.

    SELECT * FROM vbrk
    INTO TABLE lt_vbrk_header
    FOR ALL ENTRIES IN lt_invoices
    WHERE vbeln = lt_invoices-vbeln.

    SELECT * FROM konv
    INTO TABLE lt_konv
    FOR ALL ENTRIES IN lt_vbrk_header
    WHERE knumv = lt_vbrk_header-knumv.

    SELECT * FROM bkpf
    INTO TABLE lt_bkpf
    FOR ALL ENTRIES IN lt_invoices
    WHERE awtyp = 'VBRK'
    AND   awkey = lt_invoices-awkey.

* DP Poland Correction Invoices
*  ENDIF.

* fill gv_dp_rcpt_date with first booking date.

    LOOP AT lt_bkpf.
      IF gv_dp_rcpt_date IS INITIAL.
        MOVE lt_bkpf-budat TO gv_dp_rcpt_date.
      ENDIF.
      IF bkpf-budat < gv_dp_rcpt_date.
        MOVE lt_bkpf-budat TO gv_dp_rcpt_date.
      ENDIF.
    ENDLOOP.

    MOVE vbdkr-vbeln TO lv_awkey.
    READ TABLE lt_bkpf INTO ls_curr_inv_bkpf
                       WITH KEY awtyp = 'VBRK'
                                awkey = lv_awkey.


* sort the billing documents by billing date to get the correct sequence
* of DP invoices and final invoices
    SORT lt_vbrk_header BY erdat erzet.

    LOOP AT lt_vbrk_header INTO ls_vbrk_temp.
      IF ls_vbrk_temp-fkdat LE vbdkr-fkdat
                        AND ls_vbrk_temp-vbeln NE vbdkr-vbeln.
*---must be a an invoice(M)
*---billing document must not be cancelled
*---must have been transferred to accounting

*      IF ls_vbrk_temp-vbtyp = 'M'      AND

* DP Poland Correction Invoices
* To consider corr invoice and along with DP invoice

        IF ls_vbrk_temp-vbtyp CA 'MO'    AND
         ls_vbrk_temp-fksto IS INITIAL AND
         ls_vbrk_temp-rfbsk = 'C'.

          MOVE ls_vbrk_temp-vbeln TO lv_awkey.

          READ TABLE lt_bkpf INTO ls_bkpf
                             WITH KEY awtyp = 'VBRK'
                                      awkey = lv_awkey.
* begin of deletion mj 20070711
*          IF ls_bkpf-cpudt LE ls_curr_inv_bkpf-cpudt AND
*              ls_bkpf-cputm LE ls_curr_inv_bkpf-cputm.
* end of deletion mj 20070711
* begin of insertion mj 20070711
          IF ls_bkpf-cpudt LT ls_curr_inv_bkpf-cpudt OR
          ( ls_bkpf-cpudt EQ ls_curr_inv_bkpf-cpudt AND
              ls_bkpf-cputm LE ls_curr_inv_bkpf-cputm ) .
* end of insertion mj 20070711

            LOOP AT lt_vbrp_items INTO ls_vbrp_temp
                 WHERE vbeln = ls_vbrk_temp-vbeln.

              READ TABLE lt_konv INTO ls_konv_temp
                   WITH KEY knumv = ls_vbrk_temp-knumv
                            kposn = ls_vbrp_temp-posnr
                            koaid = 'D'.

              MOVE ls_konv_temp-mwsk1 TO ls_amt_taxcode-mwskz.
              MOVE ls_vbrp_temp-netwr TO ls_amt_taxcode-amt.
              MOVE ls_vbrp_temp-mwsbp TO ls_amt_taxcode-tax_amt.

              READ TABLE gt_vbfa INTO ls_vbfa_temp
                   WITH KEY vbeln = ls_vbrk_temp-vbeln.
*            IF  ls_vbfa_temp-fktyp = 'A'.

              CLEAR ls_tvfk.

              SELECT SINGLE *
              FROM tvfk
              INTO ls_tvfk
              WHERE fkart = ls_vbrk_temp-fkart.
* the Sd document type should be invoice 'M' and transaction group
* should be proforma invoice '8' for a downpayment invoice
              IF ls_tvfk-vbtyp = 'M' AND ls_tvfk-trvog = '8'.
* store all previous DP invoices for printing
                ls_prev_dp_inv-vbeln = ls_vbrk_temp-vbeln.
                ls_prev_dp_inv-fkdat = ls_vbrk_temp-fkdat.
                ls_prev_dp_inv-waerk = ls_vbrk_temp-waerk.
                ls_prev_dp_inv-gross_value = ls_vbrk_temp-netwr +
                                             ls_vbrk_temp-mwsbk.
                APPEND ls_prev_dp_inv TO gt_prev_dp_inv.
*              ENDIF.

                COLLECT ls_amt_taxcode INTO lt_dp_amt.

* DP Poland - correction Invoice
*                ELSE.
              ELSEIF ls_tvfk-vbtyp = 'O' AND ls_tvfk-trvog = '8'.
                READ TABLE    lt_dp_amt
                     WITH KEY ls_amt_taxcode-mwskz INTO ls_dp_amt.
                CLEAR lv_diff.
                IF ls_vbrp_temp-shkzg = 'X'.
                  ls_dp_amt-amt     = ls_dp_amt-amt - ls_amt_taxcode-amt.
                  ls_dp_amt-tax_amt = ls_dp_amt-tax_amt - ls_amt_taxcode-tax_amt.
                ELSE.
                  lv_diff     = ls_dp_amt-amt + ABS( ls_amt_taxcode-amt ).
                  lv_diff_tax =  ls_dp_amt-tax_amt + ABS( ls_amt_taxcode-tax_amt ).
                  IF lv_diff < 0.
                    ls_dp_amt-amt     = 0.
                    ls_dp_amt-tax_amt = 0.
                  ELSE.
                    ls_dp_amt-amt     = lv_diff.
                    ls_dp_amt-tax_amt = lv_diff_tax.
                  ENDIF.
                ENDIF.
                MODIFY lt_dp_amt FROM ls_dp_amt TRANSPORTING amt tax_amt
                                      WHERE mwskz = ls_amt_taxcode-mwskz.
                COLLECT ls_amt_taxcode INTO lt_invoice_amt.

                ls_prev_dp_inv-vbeln = ls_vbrk_temp-vbeln.
                ls_prev_dp_inv-fkdat = ls_vbrk_temp-fkdat.
                ls_prev_dp_inv-waerk = ls_vbrk_temp-waerk.
                ls_prev_dp_inv-gross_value = ( ls_vbrk_temp-netwr +
                                           ls_vbrk_temp-mwsbk ) * -1.
                APPEND ls_prev_dp_inv TO gt_prev_dp_inv.
                CLEAR lv_diff.
                CLEAR lv_diff_tax.

* DP Poland - Correction for partial or Final invoice

              ELSEIF ls_tvfk-vbtyp = 'O' AND ls_tvfk-trvog = '7'.
                READ TABLE    lt_dp_amt
                WITH KEY ls_amt_taxcode-mwskz INTO ls_dp_amt.

                IF ls_vbrp_temp-shkzg = 'X'.
                  READ TABLE   lt_red_dp_clear INTO ls_red_dp_clear
                  WITH KEY  doc_num  = ls_vbrk_temp-xblnr
                            tax_code = ls_amt_taxcode-mwskz.

                  lv_diff     = ls_amt_taxcode-amt - ls_red_dp_clear-net_value.
                  lv_diff_tax = ls_amt_taxcode-tax_amt - ls_red_dp_clear-tax_amt.
                  IF lv_diff GE 0.
                    ls_dp_amt-amt      = ls_red_dp_clear-net_value.
                    ls_dp_amt-tax_amt  = ls_red_dp_clear-tax_amt.
                  ELSE.
                    ls_dp_amt-amt      = ls_amt_taxcode-amt.
                    ls_dp_amt-tax_amt  = ls_amt_taxcode-tax_amt.
                  ENDIF.
                ELSE.
                  lv_diff     = ls_dp_amt-amt - ABS( ls_amt_taxcode-amt ).
                  lv_diff_tax = ls_dp_amt-tax_amt - ABS( ls_amt_taxcode-tax_amt ).
                  IF lv_diff GE 0.
                    ls_dp_amt-amt      = lv_diff.
                    ls_dp_amt-tax_amt  = lv_diff_tax.
                  ELSE.
                    ls_dp_amt-amt      = 0.
                    ls_dp_amt-tax_amt  = 0.
                  ENDIF.
                ENDIF.
                MODIFY lt_dp_amt FROM ls_dp_amt TRANSPORTING amt tax_amt
                                      WHERE mwskz = ls_amt_taxcode-mwskz.

* DP Poland - For partial & final Invoice
              ELSEIF ls_tvfk-vbtyp = 'M' AND ls_tvfk-trvog = '7'.
                READ TABLE    lt_dp_amt
                       WITH KEY ls_amt_taxcode-mwskz INTO ls_dp_amt.
                IF ls_vbrk_temp-vbeln LT vbdkr-vbeln.
                  ls_red_dp_clear-doc_num   = ls_vbrp_temp-vbeln.
                  ls_red_dp_clear-item_num  = ls_vbrp_temp-posnr.
                  ls_red_dp_clear-material  = ls_vbrp_temp-matnr.
                  ls_red_dp_clear-net_value = ls_dp_amt-amt.
                  ls_red_dp_clear-tax_amt   = ls_dp_amt-tax_amt.
                  ls_red_dp_clear-tax_rate  = ls_konv-kbetr / 10.
                  ls_red_dp_clear-tax_code  = ls_dp_amt-mwskz.
                  APPEND ls_red_dp_clear TO lt_red_dp_clear.
                  CLEAR  ls_red_dp_clear.

                  lv_diff     = ls_dp_amt-amt - ls_amt_taxcode-amt.
                  lv_diff_tax =  ls_dp_amt-tax_amt - ls_amt_taxcode-tax_amt.
                  IF lv_diff < 0.
                    ls_dp_amt-amt     = 0.
                    ls_dp_amt-tax_amt = 0.
                  ELSE.
                    ls_dp_amt-amt     = lv_diff.
                    ls_dp_amt-tax_amt = lv_diff_tax.
                  ENDIF.
                  MODIFY lt_dp_amt FROM ls_dp_amt TRANSPORTING amt tax_amt
                       WHERE mwskz = ls_amt_taxcode-mwskz.
                ENDIF.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

    SORT gt_prev_dp_inv BY vbeln.
    DELETE ADJACENT DUPLICATES FROM gt_prev_dp_inv COMPARING vbeln.

* begin of insertion MOD-005
    LOOP AT lt_dp_amt.
      IF lt_dp_amt-amt = 0.
        DELETE lt_dp_amt.
      ENDIF.
    ENDLOOP.

    IF lt_dp_amt[] IS INITIAL.
      CLEAR gv_to_pay.
      LOOP AT tvbdpr.
        gv_to_pay = gv_to_pay + tvbdpr-skfbp.
      ENDLOOP.
    ENDIF.
* end of insertion MOD-005

    LOOP AT tvbdpr.

      CLEAR ls_amt_taxcode.

      READ TABLE lt_konv INTO ls_konv WITH KEY
                  knumv = vbdkr-knumv
                  kposn = tvbdpr-posnr
                  koaid = 'D'.

      MOVE ls_konv-mwsk1 TO ls_amt_taxcode-mwskz.
      MOVE tvbdpr-netwr  TO ls_amt_taxcode-amt.
      MOVE tvbdpr-mwsbp  TO ls_amt_taxcode-tax_amt.

      COLLECT ls_amt_taxcode INTO lt_curr_inv_amt.

    ENDLOOP.

    CLEAR ls_dp_amt_wa.

* DP Poland - correction Invoice
    IF gs_vbrk-vbtyp NE 'N'.

      LOOP AT lt_dp_amt INTO ls_dp_amt_wa.

        READ TABLE lt_curr_inv_amt INTO ls_curr_inv_amt
                   WITH KEY mwskz = ls_dp_amt_wa-mwskz.

        MOVE ls_dp_amt_wa-mwskz TO ls_clearing_amt-mwskz.

        lv_diff = ls_dp_amt_wa-amt - ls_curr_inv_amt-amt.

        IF lv_diff GE 0.
          ls_clearing_amt-amt     = ls_dp_amt_wa-amt - ls_curr_inv_amt-amt.
          ls_clearing_amt-tax_amt = ls_dp_amt_wa-tax_amt -
                                              ls_curr_inv_amt-tax_amt.
          COLLECT ls_clearing_amt INTO lt_left_for_clearing.
        ELSE.
          ls_clearing_amt-amt     = ls_curr_inv_amt-amt - ls_dp_amt_wa-amt.
          ls_clearing_amt-tax_amt = ls_curr_inv_amt-tax_amt -
                                                 ls_dp_amt_wa-tax_amt.

          COLLECT ls_clearing_amt INTO lt_to_be_paid.

        ENDIF.
      ENDLOOP.
* begin of insert MOD-002
* delete records with only zero-values
      LOOP AT lt_dp_amt.
        IF lt_dp_amt-amt = 0 AND lt_dp_amt-tax_amt = 0.
          DELETE lt_dp_amt.
        ENDIF.
      ENDLOOP.
      LOOP AT lt_to_be_paid.
        IF lt_to_be_paid-amt = 0 AND lt_to_be_paid-tax_amt = 0.
          DELETE lt_to_be_paid.
        ENDIF.
      ENDLOOP.
      LOOP AT lt_left_for_clearing.
        IF lt_left_for_clearing-amt = 0
         AND lt_left_for_clearing-tax_amt = 0.
          DELETE lt_left_for_clearing.
        ENDIF.
      ENDLOOP.
* end of insert MOD-002

      PERFORM print_line_format USING lt_dp_amt[]
                                      lt_konv
                                CHANGING gt_dp_clearing[].
      PERFORM print_line_format USING lt_to_be_paid[]
                                      lt_konv
                                CHANGING gt_to_be_paid[].
      PERFORM print_line_format USING lt_left_for_clearing[]
                                      lt_konv
                                CHANGING gt_left_for_clearing[].

      LOOP AT gt_dp_clearing.
        MULTIPLY gt_dp_clearing-net_value BY -1.
        MULTIPLY gt_dp_clearing-tax_value BY -1.
        MULTIPLY gt_dp_clearing-gross_value BY -1.
        MODIFY gt_dp_clearing.
      ENDLOOP.


* get the total value to be paid.
      LOOP AT gt_to_be_paid.
        ADD gt_to_be_paid-gross_value TO gv_to_pay.
      ENDLOOP.

      IF gv_to_pay IS INITIAL.
        gv_to_pay = 0.
        gv_inv_typ = 'C'.
      ENDIF.

      PERFORM get_amt_in_words.

* DP Poland -  Clearing Note reversal

    ELSE.
      PERFORM clearing_note_reversal USING lt_dp_amt[]
                                           lt_konv
                                           lt_curr_inv_amt[]
                              CHANGING gt_clear_note[].

    ENDIF.
  ENDIF.
ENDFORM.                    "get_downpayment_amts

*&---------------------------------------------------------------------*
*&      Form  print_line_format
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_DP_AMT  text
*      <--P_GT_DP_CLEARING  text
*----------------------------------------------------------------------*
FORM print_line_format USING    ut_dp_amt TYPE gtyp_amt_taxcode_t
                                ut_konv   TYPE me_konv
                   CHANGING ct_amts_with_tax TYPE gtyps_amt_with_tax_t.

  DATA ls_dp_amt        TYPE ltyp_amt_taxcode.
  DATA ls_amts_with_tax TYPE  gtyp_amts_with_tax.
  DATA ls_konv          TYPE konv.

  LOOP AT ut_dp_amt INTO ls_dp_amt.

    ls_amts_with_tax-net_value = ls_dp_amt-amt.
    ls_amts_with_tax-tax_value = ls_dp_amt-tax_amt.
    ls_amts_with_tax-gross_value = ls_dp_amt-amt + ls_dp_amt-tax_amt.
    READ TABLE ut_konv INTO ls_konv WITH KEY
                                    knumv = vbdkr-knumv
                                    koaid = 'D'
                                    mwsk1 = ls_dp_amt-mwskz.
    ls_amts_with_tax-tax_rate = ls_konv-kbetr / 10.
    APPEND ls_amts_with_tax TO ct_amts_with_tax.
  ENDLOOP.

ENDFORM.                    " print_line_format
*&---------------------------------------------------------------------*
*&      Form  dp_amts_totals_print
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM dp_amts_totals_print.

  DATA lv_lines TYPE i.
  DATA ls_total TYPE gtyp_amts_with_tax.

  PERFORM print_dp_lines USING 'DP_CLEARING'.
  PERFORM print_dp_lines USING 'LEFT_FOR_CLEARING'.
  PERFORM print_dp_lines USING 'TO_BE_PAID'.

  CALL FUNCTION 'CONTROL_FORM'
    EXPORTING
      command = 'PROTECT'.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'IN_WORDS'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

  CALL FUNCTION 'CONTROL_FORM'
    EXPORTING
      command = 'ENDPROTECT'.

ENDFORM.                    " dp_amts_totals_print
*&---------------------------------------------------------------------*
*&      Form  get_amt_in_words
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_amt_in_words.

* get amount to be paid in words
  IF gv_to_pay GT 0.

    CALL FUNCTION 'SPELL_AMOUNT'
      EXPORTING
        amount          = gv_to_pay
        currency        = vbdkr-waerk
*   FILLER          = ' '
*        language        = sy-langu  "nast-spras
      language        = nast-spras

      IMPORTING
        in_words        = gs_spell
      EXCEPTIONS
        not_found       = 1
        too_large       = 2
        OTHERS          = 3
              .
    IF sy-subrc <> 0.
      PERFORM protocol_update.
    ENDIF.

    gv_to_pay_in_words = gs_spell-word.
    gv_to_pay_dec_in_words = gs_spell-decword.


*Begin of change MOD-006.
  ELSEIF gv_to_pay EQ '0.00'.

    CALL FUNCTION 'SPELL_AMOUNT'
      EXPORTING
        amount    = gv_to_pay
        currency  = vbdkr-waerk
        language  = nast-spras
      IMPORTING
        in_words  = gs_spell
      EXCEPTIONS
        not_found = 1
        too_large = 2
        OTHERS    = 3.

    IF sy-subrc <> 0.
      PERFORM protocol_update.
    ENDIF.

    gv_to_pay_in_words = gs_spell-word.
    gv_to_pay_dec_in_words = gs_spell-decword.
*End of change MOD-006.
  ENDIF.

ENDFORM.                    " get_amt_in_words
*&---------------------------------------------------------------------*
*&      Form  print_dp_lines
*&---------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM print_dp_lines USING  uv_line_type TYPE string.

  DATA lv_lines TYPE i.
  DATA ls_total TYPE gtyp_amts_with_tax.
  DATA lt_table TYPE TABLE OF gtyp_amts_with_tax WITH HEADER LINE.

  DATA lv_head  TYPE string.
  DATA lv_total TYPE string.

  FIELD-SYMBOLS <print_line> TYPE gtyp_amts_with_tax.

  IF uv_line_type = 'DP_CLEARING'.
    ASSIGN gs_dp_clearing TO <print_line>.
    lt_table[] = gt_dp_clearing[].
  ENDIF.

  IF uv_line_type = 'LEFT_FOR_CLEARING'.
    ASSIGN gs_left_for_clearing TO <print_line>.
    lt_table[] = gt_left_for_clearing[].
  ENDIF.

  IF uv_line_type = 'TO_BE_PAID'.
    ASSIGN gs_to_be_paid TO <print_line>.
    lt_table[] = gt_to_be_paid[].
  ENDIF.

  DESCRIBE TABLE lt_table LINES lv_lines.

  IF lv_lines NE 0.

    CONCATENATE uv_line_type '_HD'    INTO lv_head.
    CONCATENATE uv_line_type '_TOTAL' INTO lv_total.

    CALL FUNCTION 'CONTROL_FORM'
      EXPORTING
        command = 'PROTECT'.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = lv_head
      EXCEPTIONS
        OTHERS  = 1.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

* print list of previous dp invoices
    PERFORM previous_dp_invoice_print.

    CLEAR ls_total.

    LOOP AT lt_table INTO ls_total.
      SUM.
    ENDLOOP.

    <print_line> = ls_total.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = lv_total
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    LOOP AT lt_table.

      <print_line> = lt_table.

      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = uv_line_type
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.

    ENDLOOP.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'U_LINE_SHORT'
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    CALL FUNCTION 'CONTROL_FORM'
      EXPORTING
        command = 'ENDPROTECT'.
  ENDIF.

ENDFORM.                    " print_dp_lines
*&---------------------------------------------------------------------*
*&      Form  GET_CORR_INVOICES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_INVOICES  text
*----------------------------------------------------------------------*
FORM get_corr_invoices TABLES   p_lt_invoices STRUCTURE gt_invoices.

  DATA ls_vbfa          TYPE vbfa.
  DATA ls_invoices      TYPE ltyp_invoices.

*---to get the DP correction invoices ------------------------

  LOOP AT gt_vbfa INTO ls_vbfa WHERE vbtyp_n CA 'NO'.

    MOVE ls_vbfa-vbeln TO ls_invoices-vbeln.

    READ TABLE p_lt_invoices WITH KEY vbeln = ls_vbfa-vbeln
    TRANSPORTING NO FIELDS.

    IF sy-subrc NE 0.
      IF ls_vbfa-vbeln LE vbdkr-vbeln.
        MOVE ls_vbfa-vbeln TO ls_invoices-vbeln.
        MOVE ls_vbfa-vbeln TO ls_invoices-awkey.
        APPEND ls_invoices TO p_lt_invoices.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " GET_CORR_INVOICES
*&---------------------------------------------------------------------*
*&      Form  clearing_note_reversal
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_DP_AMT[]  text
*      -->P_LT_KONV  text
*      -->P_LT_CURR_INV_AMT  text
*      <--P_GT_CLEAR_NOTE[]  text
*----------------------------------------------------------------------*
FORM clearing_note_reversal USING ut_dp_amt TYPE gtyp_amt_taxcode_t
                                  ut_konv   TYPE me_konv
                            ut_curr_inv_amt TYPE gtyp_amt_taxcode_t
                    CHANGING ct_amts_with_tax TYPE gtyps_amt_with_tax_t.

  DATA ls_dp_amt        TYPE ltyp_amt_taxcode.
  DATA ls_amts_with_tax TYPE  gtyp_amts_with_tax.
  DATA ls_konv          TYPE konv.
  DATA ls_curr_inv_amt  TYPE ltyp_amt_taxcode.

  IF gs_vbrk-vbtyp = 'N'.

    gv_inv_typ = 'N'.

    LOOP AT ut_dp_amt INTO ls_dp_amt.
      READ TABLE ut_konv INTO ls_konv WITH KEY
                                  knumv = vbdkr-knumv
                                  koaid = 'D'
                                  mwsk1 = ls_dp_amt-mwskz.
      gs_clear_note-tax_rate    = ls_konv-kbetr / 10.
      gs_clear_note-net_value   = ls_dp_amt-amt.
      gs_clear_note-tax_value   = ls_dp_amt-tax_amt.
      gs_clear_note-gross_value = ls_dp_amt-amt + ls_dp_amt-tax_amt.
      APPEND gs_clear_note TO gt_clear_note.
      CLEAR gs_clear_note.
    ENDLOOP.

* To get the total of the reversal of clearing note

    LOOP AT gt_clear_note.
      ADD gt_clear_note-net_value    TO gs_clear_total-net_value.
      ADD gt_clear_note-gross_value  TO gs_clear_total-gross_value.
      ADD gt_clear_note-tax_value    TO gs_clear_total-tax_amount.
    ENDLOOP.

* Previous DP Invoices not to be printed
* if it is reversal of clearing note

    REFRESH gt_prev_dp_inv.

  ENDIF.

ENDFORM.                    " clearing_note_reversal
*&---------------------------------------------------------------------*
*&      Form  clearing_note_rev
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM clearing_note_rev.

  DATA: lv_lines_clear TYPE i.

  DESCRIBE TABLE gt_clear_note LINES lv_lines_clear.

  IF lv_lines_clear NE 0.

    CALL FUNCTION 'CONTROL_FORM'
      EXPORTING
        command = 'PROTECT'.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'REMAINING_DP_AMOUNT_HEADING'
      EXCEPTIONS
        element = 1.

    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    LOOP AT gt_clear_note.

      gs_clear_note = gt_clear_note.

      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'REMAINING_DP_AMOUNT'
        EXCEPTIONS
          element = 1.

      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.

      CALL FUNCTION 'CONTROL_FORM'
        EXPORTING
          command = 'ENDPROTECT'.
    ENDLOOP.
  ENDIF.

ENDFORM.                    " clearing_note_rev
*&---------------------------------------------------------------------*
*&      Form  corr_and_partial_invoice
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM corr_and_partial_invoice.

  IF gs_vbrk-vbtyp = 'O'.

* To get the sales flow of the document

    CALL FUNCTION 'SD_VBFA_READ_WITH_VBELV'
      EXPORTING
        i_vbelv                  = corr_vbdkr-vbeln_vauf
*   I_BYPASSING_BUFFER       = ' '
*   I_REFRESH_BUFFER         =
      TABLES
*   ET_VBFAVB                =
        et_vbfa                  = corr_vbfa
     EXCEPTIONS
        record_not_found         = 1
        OTHERS                   = 2.

    CLEAR gs_tvfk.
    SELECT SINGLE * FROM tvfk
    INTO gs_tvfk WHERE fkart = vbdkr-fkart.

* DP Correction Invoice

    IF gs_tvfk-vbtyp = 'O' AND gs_tvfk-trvog = '8'.
      PERFORM correction_invoice.

* For correction of partial invoice.

    ELSEIF gs_tvfk-vbtyp = 'O' AND gs_tvfk-trvog = '7'.
      PERFORM correction_partial_invoice.
    ENDIF.
  ENDIF.
ENDFORM.                    " corr_and_partial_invoice
*&---------------------------------------------------------------------*
*&      Form  correction_Invoice
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM correction_invoice.

  DATA: wa_tvbdpr         LIKE LINE OF tvbdpr.
  DATA: wa_corr_inv       LIKE LINE OF gt_corr_inv.
  DATA: lt_konv_corr      TYPE TABLE OF konv.
  DATA: ls_konv_corr      TYPE konv.
  DATA: ls_vbfa_corr      TYPE vbfa.
  DATA: lt_invoices_corr  TYPE TABLE OF ltyp_invoices WITH HEADER LINE.
  DATA: ls_invoices_corr  TYPE ltyp_invoices.
  DATA: lt_vbrk_corr      TYPE TABLE OF vbrk.
  DATA: ls_vbrk_corr      TYPE vbrk.
  DATA: lt_tvfk_corr      TYPE TABLE OF tvfk.
  DATA: ls_tvfk_corr      TYPE tvfk.
  DATA: lt_bkpf_corr      TYPE TABLE OF bkpf.
  DATA: ls_bkpf_corr      TYPE bkpf.
  DATA: ls_prev_dp_inv    TYPE gtyp_previous_dp_invoices.
  DATA: lv_lines_corr     TYPE i.
  DATA: lv_awkey_corr     TYPE awkey.
  DATA: ls_corr_inv_bkpf  TYPE bkpf.

*   To ensure no multiple lines are printed

  REFRESH gt_corr_inv.
  REFRESH gt_corr_diff.
  REFRESH gt_corr_print.
  REFRESH gt_diff_print.

*---To get the DP previous correction invoices---------

  gv_inv_typ = 'E'.
  gv_dp_invoice = 'X'.

  LOOP AT corr_vbfa INTO ls_vbfa_corr WHERE vbtyp_n CA 'MO'.
    MOVE ls_vbfa_corr-vbeln TO ls_invoices_corr-vbeln.
    READ TABLE lt_invoices_corr WITH KEY vbeln = ls_vbfa_corr-vbeln
    TRANSPORTING NO FIELDS.
    IF sy-subrc NE 0.
      IF ls_vbfa_corr-vbeln LT vbdkr-vbeln.
        MOVE ls_vbfa_corr-vbeln TO ls_invoices_corr-vbeln.
        MOVE ls_vbfa_corr-vbeln TO ls_invoices_corr-awkey.
        APPEND ls_invoices_corr TO lt_invoices_corr.
      ENDIF.
    ENDIF.
  ENDLOOP.

  SORT lt_invoices_corr BY vbeln.

  DESCRIBE TABLE lt_invoices_corr LINES lv_lines_corr.

  IF lv_lines_corr NE 0.

    SELECT * FROM vbrk
    INTO TABLE lt_vbrk_corr
    FOR ALL ENTRIES IN lt_invoices_corr
    WHERE vbeln = lt_invoices_corr-vbeln.

    SELECT * FROM tvfk
    INTO TABLE lt_tvfk_corr
    FOR ALL ENTRIES IN lt_vbrk_corr
    WHERE fkart = lt_vbrk_corr-fkart.

    SELECT * FROM bkpf
    INTO TABLE lt_bkpf_corr
    FOR ALL ENTRIES IN lt_invoices_corr
    WHERE awtyp = 'VBRK'
    AND   awkey = lt_invoices_corr-awkey.

    MOVE vbdkr-vbeln TO lv_awkey_corr.

    READ TABLE lt_bkpf_corr INTO ls_corr_inv_bkpf
                       WITH KEY awtyp = 'VBRK'
                                awkey = lv_awkey_corr.


    LOOP AT lt_vbrk_corr INTO ls_vbrk_corr
      WHERE fksto IS INITIAL AND
          rfbsk = 'C'.

      READ TABLE lt_bkpf_corr INTO ls_bkpf_corr
               WITH KEY awtyp = 'VBRK'
                        awkey = lv_awkey_corr.

      IF ls_bkpf_corr-cpudt LE ls_corr_inv_bkpf-cpudt AND
         ls_bkpf_corr-cputm LE ls_corr_inv_bkpf-cputm.


        READ TABLE lt_tvfk_corr INTO ls_tvfk_corr
             WITH KEY fkart = ls_vbrk_corr-fkart.

        IF ls_tvfk_corr-vbtyp = 'M' AND ls_tvfk_corr-trvog = '8'.

          ls_prev_dp_inv-vbeln = ls_vbrk_corr-vbeln.
          ls_prev_dp_inv-fkdat = ls_vbrk_corr-fkdat.
          ls_prev_dp_inv-waerk = ls_vbrk_corr-waerk.
          ls_prev_dp_inv-gross_value = ls_vbrk_corr-netwr +
                                     ls_vbrk_corr-mwsbk.
          APPEND ls_prev_dp_inv TO gt_prev_dp_inv.

        ELSEIF ls_tvfk_corr-vbtyp = 'O' AND ls_tvfk_corr-trvog = '8'.

          ls_prev_dp_inv-vbeln = ls_vbrk_corr-vbeln.
          ls_prev_dp_inv-fkdat = ls_vbrk_corr-fkdat.
          ls_prev_dp_inv-waerk = ls_vbrk_corr-waerk.
          ls_prev_dp_inv-gross_value = ( ls_vbrk_corr-netwr +
                                     ls_vbrk_corr-mwsbk ) * -1.
          APPEND ls_prev_dp_inv TO gt_prev_dp_inv.
        ENDIF.
      ENDIF.
      CLEAR ls_vbrk_corr.
      CLEAR ls_bkpf_corr.
      CLEAR ls_tvfk_corr.
    ENDLOOP.
  ENDIF.

  SORT gt_prev_dp_inv BY vbeln.
  DELETE ADJACENT DUPLICATES FROM gt_prev_dp_inv COMPARING vbeln.

* Check if invoice is corection invoice - credit Memo or Debit Memo

  SELECT * FROM konv
  INTO TABLE lt_konv_corr
  WHERE knumv = vbdkr-knumv.


  LOOP AT corr_tvbdpr INTO wa_tvbdpr WHERE shkzg NE 'X'.

    wa_corr_inv-item_num       = wa_tvbdpr-posnr.
    wa_corr_inv-corr_item      = wa_tvbdpr-posnr_vg2.
    wa_corr_inv-net_value      = ABS( wa_tvbdpr-netwr ).
    wa_corr_inv-material       = wa_tvbdpr-matnr.
    wa_corr_inv-gross_value    = ABS( wa_tvbdpr-brtwr ).
    wa_corr_inv-tax_amt        = ABS( wa_tvbdpr-mwsbp ).

    LOOP AT lt_konv_corr INTO ls_konv_corr
    WHERE kposn = wa_tvbdpr-posnr AND
    kntyp = 'D'.
      IF sy-subrc = 0.
        IF wa_corr_inv-tax_code IS INITIAL.
          wa_corr_inv-tax_rate = ls_konv_corr-kbetr / 10.
          wa_corr_inv-tax_code = ls_konv_corr-mwsk1.
        ENDIF.
      ELSE.
        CONTINUE.
      ENDIF.
    ENDLOOP.

    APPEND wa_corr_inv TO gt_corr_inv.
    CLEAR wa_tvbdpr.
    CLEAR wa_corr_inv.
  ENDLOOP.

  DELETE ADJACENT DUPLICATES FROM gt_corr_inv COMPARING doc_num item_num.
  CLEAR sy-subrc.

* Get the difference amount = DP amount - Corr Inv amount

  LOOP AT tvbdpr INTO wa_tvbdpr.

    LOOP AT gt_corr_inv INTO wa_corr_inv WHERE
    corr_item = wa_tvbdpr-posnr AND material = wa_tvbdpr-matnr.

      gt_corr_diff-net_value   = wa_corr_inv-net_value - wa_tvbdpr-netwr.
      gt_corr_diff-material    = wa_tvbdpr-matnr.
      gt_corr_diff-gross_value   = wa_corr_inv-gross_value - wa_tvbdpr-kzwi5.
      gt_corr_diff-tax_amt     = wa_corr_inv-tax_amt - wa_tvbdpr-mwsbp.
      gt_corr_diff-tax_rate    = wa_corr_inv-tax_rate.
      gt_corr_diff-tax_code    = wa_corr_inv-tax_code.
      APPEND gt_corr_diff.

      LOOP AT hkomvd WHERE mwskz = wa_corr_inv-tax_code.
        IF sy-subrc = 0.
          hkomvd-kawrt = wa_tvbdpr-kzwi5.
          hkomvd-kwert = wa_tvbdpr-mwsbp.
          MODIFY hkomvd.
        ENDIF.
      ENDLOOP.

      CLEAR wa_corr_inv.
    ENDLOOP.
  ENDLOOP.

  LOOP AT gt_corr_inv.
    gt_corr_print-net_value   = gt_corr_inv-net_value.
    gt_corr_print-tax_rate    = gt_corr_inv-tax_rate.
    gt_corr_print-tax_value   = gt_corr_inv-tax_amt.
    gt_corr_print-gross_value = gt_corr_inv-gross_value.
    APPEND gt_corr_print.
  ENDLOOP.

  CLEAR gv_to_pay_diff.

  LOOP AT gt_corr_diff.
    gt_diff_print-net_value    = gt_corr_diff-net_value.
    gt_diff_print-tax_rate     = gt_corr_diff-tax_rate.
    gt_diff_print-tax_value    = gt_corr_diff-tax_amt.
    gt_diff_print-gross_value  = gt_corr_diff-gross_value.
    APPEND gt_diff_print.
    ADD gt_corr_diff-gross_value TO gv_to_pay_diff.
  ENDLOOP.

  PERFORM get_amt_in_words_diff.

ENDFORM.                    " correction_Invoice
*&---------------------------------------------------------------------*
*&      Form  corr_invoice
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM corr_invoice.

  PERFORM print_corr_line USING 'DP_AMOUNT_AFTER_CORRECTION'.
  PERFORM print_corr_line USING 'DIFFERENCE'.

  CALL FUNCTION 'CONTROL_FORM'
    EXPORTING
      command = 'PROTECT'.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'IN_WORDS_DIFF'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

  CALL FUNCTION 'CONTROL_FORM'
    EXPORTING
      command = 'ENDPROTECT'.

ENDFORM.                    " corr_invoice
*&---------------------------------------------------------------------*
*&      Form  correction_partial_invoice
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM correction_partial_invoice.

  DATA ls_vbfa_corr      TYPE vbfa.
  DATA lt_invoices_corr  TYPE TABLE OF ltyp_invoices WITH HEADER LINE.
  DATA ls_invoices_corr  TYPE ltyp_invoices.
  DATA lv_lines_corr     TYPE i.
  DATA lt_vbrp_corr      TYPE TABLE OF vbrp.
  DATA lt_vbrk_corr      TYPE TABLE OF vbrk.
  DATA lt_konv_corr      TYPE TABLE OF konv.
  DATA lt_bkpf_corr      TYPE TABLE OF bkpf.
  DATA lv_awkey_corr     TYPE awkey.
  DATA ls_vbrp_corr      TYPE vbrp.
  DATA ls_vbrk_corr      TYPE vbrk.
  DATA ls_bkpf_corr      TYPE bkpf.
  DATA ls_corr_inv_bkpf  TYPE bkpf.
  DATA ls_konv_corr      TYPE konv.
  DATA ls_tvfk_corr      TYPE tvfk.
  DATA lt_corr_amt       TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA lt_corr_var       TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA ls_corr_amt       TYPE ltyp_amt_taxcode.
  DATA ls_corr_var       TYPE ltyp_amt_taxcode.
  DATA ls_corr_taxcode   TYPE ltyp_amt_taxcode.
  DATA lv_diff_corr      TYPE netwr_fp.
  DATA lv_diff_tax_corr  TYPE netwr_fp.
  DATA ls_prev_dp_inv    TYPE gtyp_previous_dp_invoices.
  DATA lt_corr_inv_amt   TYPE TABLE OF ltyp_amt_taxcode WITH HEADER LINE.
  DATA wa_tvbdpr LIKE LINE OF tvbdpr.
  DATA wa_corr_tvbdpr LIKE LINE OF corr_tvbdpr.
  DATA lt_red_dp_clear  TYPE TABLE OF gtyp_corr_inv WITH HEADER LINE.
  DATA ls_red_dp_clear  TYPE gtyp_corr_inv.

* To ensure no multiple lines are printed

  REFRESH gt_red_dp_clear.
  REFRESH gt_clearing_dp.
  REFRESH gt_corr_to_be.
  REFRESH gt_after_clearing.

*-----get all the DP, DP correction & partial invoices---------

  gv_inv_typ = 'P'.

  LOOP AT corr_vbfa INTO ls_vbfa_corr WHERE vbtyp_n CA 'MO'.
    MOVE ls_vbfa_corr-vbeln TO ls_invoices_corr-vbeln.
    READ TABLE lt_invoices_corr WITH KEY vbeln = ls_vbfa_corr-vbeln
    TRANSPORTING NO FIELDS.
    IF sy-subrc NE 0.
      IF ls_vbfa_corr-vbeln LE vbdkr-vbeln.
        MOVE ls_vbfa_corr-vbeln TO ls_invoices_corr-vbeln.
        MOVE ls_vbfa_corr-vbeln TO ls_invoices_corr-awkey.
        APPEND ls_invoices_corr TO lt_invoices_corr.
      ENDIF.
    ENDIF.
  ENDLOOP.

  SORT lt_invoices_corr BY vbeln.

  DESCRIBE TABLE lt_invoices_corr LINES lv_lines_corr.

  IF lv_lines_corr NE 0.

    SELECT * FROM vbrp
    INTO TABLE lt_vbrp_corr
    FOR ALL ENTRIES IN  lt_invoices_corr
    WHERE vbeln = lt_invoices_corr-vbeln.

    SELECT * FROM vbrk
    INTO TABLE lt_vbrk_corr
    FOR ALL ENTRIES IN lt_invoices_corr
    WHERE vbeln = lt_invoices_corr-vbeln.

    SELECT * FROM konv
    INTO TABLE lt_konv_corr
    FOR ALL ENTRIES IN lt_vbrk_corr
    WHERE knumv = lt_vbrk_corr-knumv.

    SELECT * FROM bkpf
    INTO TABLE lt_bkpf_corr
    FOR ALL ENTRIES IN lt_invoices_corr
    WHERE awtyp = 'VBRK'
    AND   awkey = lt_invoices_corr-awkey.

    MOVE vbdkr-vbeln TO lv_awkey_corr.
    READ TABLE lt_bkpf_corr INTO ls_corr_inv_bkpf
                       WITH KEY awtyp = 'VBRK'
                                awkey = lv_awkey_corr.

    SORT lt_vbrk_corr BY erdat erzet.

    LOOP AT lt_vbrk_corr INTO ls_vbrk_corr.
      IF ls_vbrk_corr-fkdat LE vbdkr-fkdat
                        AND ls_vbrk_corr-vbeln LT vbdkr-vbeln.

        IF ls_vbrk_corr-vbtyp CA 'MO'    AND
           ls_vbrk_corr-fksto IS INITIAL AND
           ls_vbrk_corr-rfbsk = 'C'.

          MOVE ls_vbrk_corr-vbeln TO lv_awkey_corr.

          READ TABLE lt_bkpf_corr INTO ls_bkpf_corr
                             WITH KEY awtyp = 'VBRK'
                                      awkey = lv_awkey_corr.

          IF ls_bkpf_corr-cpudt LE ls_corr_inv_bkpf-cpudt AND
             ls_bkpf_corr-cputm LE ls_corr_inv_bkpf-cputm.

            LOOP AT lt_vbrp_corr INTO ls_vbrp_corr
            WHERE vbeln = ls_vbrk_corr-vbeln.

              READ TABLE lt_konv_corr INTO ls_konv_corr
                   WITH KEY knumv = ls_vbrk_corr-knumv
                            kposn = ls_vbrp_corr-posnr
                            koaid = 'D'.

              ls_corr_taxcode-mwskz   = ls_konv_corr-mwsk1.
              ls_corr_taxcode-amt     = ABS( ls_vbrp_corr-netwr ).
              ls_corr_taxcode-tax_amt = ABS( ls_vbrp_corr-mwsbp ).

              READ TABLE corr_vbfa INTO ls_vbfa_corr
                   WITH KEY vbeln = ls_vbrk_corr-vbeln.

              CLEAR ls_tvfk_corr.

              SELECT SINGLE *
              FROM tvfk
              INTO ls_tvfk_corr
              WHERE fkart = ls_vbrk_corr-fkart.

              IF ls_tvfk_corr-vbtyp = 'M' AND ls_tvfk_corr-trvog = '8'.
                ls_prev_dp_inv-vbeln = ls_vbrk_corr-vbeln.
                ls_prev_dp_inv-fkdat = ls_vbrk_corr-fkdat.
                ls_prev_dp_inv-waerk = ls_vbrk_corr-waerk.
                ls_prev_dp_inv-gross_value = ls_vbrk_corr-netwr +
                                             ls_vbrk_corr-mwsbk.
                APPEND ls_prev_dp_inv TO gt_prev_dp_inv.
                COLLECT ls_corr_taxcode INTO lt_corr_amt.

              ELSEIF ls_tvfk_corr-vbtyp = 'O' AND ls_tvfk_corr-trvog = '8'.
                READ TABLE    lt_corr_amt
                     WITH KEY ls_corr_taxcode-mwskz INTO ls_corr_amt.
                IF ls_vbrp_corr-shkzg = 'X'.
                  ls_corr_amt-amt     = ls_corr_amt-amt - ls_corr_taxcode-amt.
                  ls_corr_amt-tax_amt = ls_corr_amt-tax_amt - ls_corr_taxcode-tax_amt.
                ELSE.
                  lv_diff_corr     = ls_corr_amt-amt + ls_corr_taxcode-amt.
                  lv_diff_tax_corr = ls_corr_amt-tax_amt + ls_corr_taxcode-tax_amt.
                  IF lv_diff_corr < 0.
                    ls_corr_amt-amt     = 0.
                    ls_corr_amt-tax_amt = 0.
                  ELSE.
                    ls_corr_amt-amt     = lv_diff_corr.
                    ls_corr_amt-tax_amt = lv_diff_tax_corr.
                  ENDIF.
                ENDIF.
                MODIFY lt_corr_amt FROM ls_corr_amt TRANSPORTING amt tax_amt
                                         WHERE mwskz = ls_corr_taxcode-mwskz.
                ls_prev_dp_inv-vbeln = ls_vbrk_corr-vbeln.
                ls_prev_dp_inv-fkdat = ls_vbrk_corr-fkdat.
                ls_prev_dp_inv-waerk = ls_vbrk_corr-waerk.
                ls_prev_dp_inv-gross_value = ( ls_vbrk_corr-netwr +
                                           ls_vbrk_corr-mwsbk ) * -1.
                APPEND ls_prev_dp_inv TO gt_prev_dp_inv.
                CLEAR lv_diff_corr.
                CLEAR lv_diff_tax_corr.

              ELSEIF ls_tvfk_corr-vbtyp = 'M' AND ls_tvfk_corr-trvog = '7'.
                IF ls_vbrk_corr-vbeln LT vbdkr-vbeln.
                  READ TABLE    lt_corr_amt
                  WITH KEY ls_corr_taxcode-mwskz INTO ls_corr_amt.
                  ls_red_dp_clear-doc_num   = ls_vbrp_corr-vbeln.
                  ls_red_dp_clear-item_num  = ls_vbrp_corr-posnr.
                  ls_red_dp_clear-material  = ls_vbrp_corr-matnr.
                  ls_red_dp_clear-net_value = ls_corr_amt-amt.
                  ls_red_dp_clear-tax_amt   = ls_corr_amt-tax_amt.
                  ls_red_dp_clear-tax_rate  = ls_konv_corr-kbetr / 10.
                  ls_red_dp_clear-tax_code  = ls_corr_amt-mwskz.
                  APPEND ls_red_dp_clear TO lt_red_dp_clear.
                  CLEAR  ls_red_dp_clear.
                  lv_diff_corr     = ls_corr_amt-amt - ls_corr_taxcode-amt.
                  lv_diff_tax_corr = ls_corr_amt-tax_amt - ls_corr_taxcode-tax_amt.
                  IF lv_diff_corr < 0.
                    ls_corr_amt-amt         = 0.
                    ls_corr_amt-tax_amt     = 0.
                  ELSE.
                    ls_corr_amt-amt         = lv_diff_corr.
                    ls_corr_amt-tax_amt     = lv_diff_tax_corr.
                  ENDIF.
                  MODIFY lt_corr_amt FROM ls_corr_amt TRANSPORTING amt tax_amt
                                           WHERE mwskz = ls_corr_taxcode-mwskz.
                  CLEAR   lv_diff_corr.
                  CLEAR   lv_diff_tax_corr.
                ENDIF.

              ELSEIF ls_tvfk_corr-vbtyp = 'O' AND ls_tvfk_corr-trvog = '7'.
                READ TABLE    lt_corr_amt
                    WITH KEY ls_corr_taxcode-mwskz INTO ls_corr_amt.

                IF ls_vbrp_corr-shkzg = 'X'.

                  READ TABLE   lt_red_dp_clear INTO ls_red_dp_clear
                       WITH KEY  doc_num  = ls_vbrk_corr-xblnr
                                 tax_code = ls_corr_taxcode-mwskz.
                  lv_diff_corr     = ls_corr_taxcode-amt - ls_red_dp_clear-net_value.
                  lv_diff_tax_corr = ls_corr_taxcode-tax_amt - ls_red_dp_clear-tax_amt.
                  IF lv_diff_corr GE 0.
                    ls_corr_amt-amt      = ls_red_dp_clear-net_value.
                    ls_corr_amt-tax_amt  = ls_red_dp_clear-tax_amt.
                  ELSE.
                    ls_corr_amt-amt      = ls_corr_taxcode-amt.
                    ls_corr_amt-tax_amt  = ls_corr_taxcode-tax_amt.
                  ENDIF.
                ELSE.
                  lv_diff_corr     = ls_corr_amt-amt - ABS( ls_corr_taxcode-amt ).
                  lv_diff_tax_corr = ls_corr_amt-tax_amt - ABS( ls_corr_taxcode-tax_amt ).
                  IF lv_diff_corr GE 0.
                    ls_corr_amt-amt      = lv_diff_corr.
                    ls_corr_amt-tax_amt  = lv_diff_tax_corr.
                  ELSE.
                    ls_corr_amt-amt      = 0.
                    ls_corr_amt-tax_amt  = 0.
                  ENDIF.
                ENDIF.
                MODIFY lt_corr_amt FROM ls_corr_amt TRANSPORTING amt tax_amt
                                         WHERE mwskz = ls_corr_taxcode-mwskz.
                CLEAR   lv_diff_corr.
                CLEAR   lv_diff_tax_corr.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

    SORT gt_prev_dp_inv BY vbeln.
    DELETE ADJACENT DUPLICATES FROM gt_prev_dp_inv COMPARING vbeln.
  ENDIF.

* Reduction of DP clearing

  SORT lt_red_dp_clear BY doc_num item_num.
  DELETE ADJACENT DUPLICATES FROM lt_red_dp_clear COMPARING doc_num
 item_num.

  LOOP AT tvbdpr INTO wa_tvbdpr.

    gs_red_dp_clear-material = wa_tvbdpr-matnr.

    READ TABLE lt_red_dp_clear INTO ls_red_dp_clear WITH KEY
               doc_num  = vbdkr-vbeln_vg2
               item_num = wa_tvbdpr-posnr.

    gs_red_dp_clear-tax_rate = ls_red_dp_clear-tax_rate.
    gs_red_dp_clear-tax_code = ls_red_dp_clear-tax_code.

    CLEAR lv_diff_corr.

    lv_diff_corr = wa_tvbdpr-netwr - ls_red_dp_clear-net_value.
    IF lv_diff_corr GE 0.
      gs_red_dp_clear-net_value = ls_red_dp_clear-net_value.
      gs_red_dp_clear-tax_amt   = ls_red_dp_clear-tax_amt.
      gs_red_dp_clear-gross_value = ls_red_dp_clear-net_value
                                    + ls_red_dp_clear-tax_amt.
    ELSE.
      gs_red_dp_clear-net_value   = wa_tvbdpr-netwr.
      gs_red_dp_clear-tax_amt     = wa_tvbdpr-mwsbp.
      gs_red_dp_clear-gross_value = wa_tvbdpr-netwr + wa_tvbdpr-mwsbp.
    ENDIF.
    APPEND gs_red_dp_clear TO gt_red_dp_clear.
    CLEAR wa_tvbdpr.
    CLEAR ls_red_dp_clear.
    CLEAR gs_red_dp_clear.

  ENDLOOP.

  SORT gt_red_dp_clear BY item_num.
  DELETE ADJACENT DUPLICATES FROM gt_red_dp_clear COMPARING item_num.

* SHOULD BE

  LOOP AT lt_vbrp_corr INTO ls_vbrp_corr WHERE
  vbeln = vbdkr-vbeln AND shkzg NE 'X'.

    READ TABLE corr_tvbdpr INTO wa_corr_tvbdpr
    WITH KEY posnr = ls_vbrp_corr-posnr.

    IF wa_corr_tvbdpr-netprl IS INITIAL.
      gs_corr_to_be-netprl    = ABS( wa_corr_tvbdpr-netpr_vg2 ).
    ELSE.
      gs_corr_to_be-netprl    = ABS( wa_corr_tvbdpr-netprl ).
    ENDIF.
    gs_corr_to_be-kbetr     = wa_corr_tvbdpr-mwspr_vg2.
    gs_corr_to_be-posnr     = ls_vbrp_corr-posnr.
    gs_corr_to_be-matnr     = ls_vbrp_corr-matnr.
    gs_corr_to_be-arktx     = ls_vbrp_corr-arktx.
    gs_corr_to_be-fkimg     = ls_vbrp_corr-fkimg.
    gs_corr_to_be-meins     = ls_vbrp_corr-meins.
    gs_corr_to_be-netwr     = ABS( ls_vbrp_corr-netwr ).
    gs_corr_to_be-mwsbp     = ABS( ls_vbrp_corr-mwsbp ).
    gs_corr_to_be-brtwr_vg2   = gs_corr_to_be-netwr + gs_corr_to_be-mwsbp.
    gs_corr_to_be-steucl    = wa_corr_tvbdpr-steucl.

    READ TABLE lt_konv_corr INTO ls_konv_corr
      WITH KEY knumv = vbdkr-knumv
               kposn = wa_corr_tvbdpr-posnr
               koaid = 'D'.
    gs_corr_to_be-kbetr     = ls_konv_corr-kbetr / 10.
    gs_corr_to_be-mwsk1     = ls_konv_corr-mwsk1.

* Clearing of DP
    IF wa_corr_tvbdpr-fkimg NE '0'.
      READ TABLE gt_red_dp_clear INTO gs_red_dp_clear
      WITH KEY tax_code = ls_konv_corr-mwsk1.

      gt_clearing_dp-tax_rate  = gs_corr_to_be-kbetr.
      CLEAR lv_diff_corr.
      lv_diff_corr = gs_corr_to_be-netwr - gs_red_dp_clear-net_value.
      IF lv_diff_corr GE 0.
        gt_clearing_dp-net_value   = gs_red_dp_clear-net_value * -1.
        gt_clearing_dp-tax_value   = gs_red_dp_clear-tax_amt * -1.
        gt_clearing_dp-gross_value = gt_clearing_dp-net_value +
                                     gt_clearing_dp-tax_value.
      ELSE.
        gt_clearing_dp-net_value   = gs_corr_to_be-netwr * -1.
        gt_clearing_dp-tax_value   = gs_corr_to_be-mwsbp * -1.
        gt_clearing_dp-gross_value = gt_clearing_dp-net_value +
        gt_clearing_dp-tax_value.
      ENDIF.
      APPEND gt_clearing_dp.
    ENDIF.
    APPEND gs_corr_to_be TO gt_corr_to_be.
    CLEAR ls_vbrp_corr.
    CLEAR wa_corr_tvbdpr.
    CLEAR gs_red_dp_clear.
    CLEAR gs_corr_to_be.
    CLEAR ls_konv_corr.
    CLEAR ls_corr_amt.
  ENDLOOP.

  SORT gt_corr_to_be BY posnr.
  DELETE ADJACENT DUPLICATES FROM gt_corr_to_be COMPARING posnr.

* After Clearing

  LOOP AT tvbdpr INTO wa_tvbdpr.

    READ TABLE lt_konv_corr INTO ls_konv_corr
        WITH KEY knumv = vbdkr-knumv
                 kposn = wa_tvbdpr-posnr
                 koaid = 'D'.

    gs_after_clearing-tax_rate = ls_konv_corr-kbetr / 10.

    LOOP AT gt_red_dp_clear INTO gs_red_dp_clear
     WHERE tax_code = ls_konv_corr-mwsk1.

      CLEAR lv_diff_corr.

      READ TABLE gt_corr_to_be INTO gs_corr_to_be
       WITH KEY  mwsk1 = gs_red_dp_clear-tax_code.

      lv_diff_corr = gs_corr_to_be-netwr - gs_red_dp_clear-net_value.

      IF lv_diff_corr GE 0.
        gs_after_clearing-net_value   = gs_corr_to_be-netwr - wa_tvbdpr-netwr.
        gs_after_clearing-tax_value   = gs_corr_to_be-mwsbp - wa_tvbdpr-mwsbp.
        gs_after_clearing-gross_value = gs_after_clearing-net_value +
                                        gs_after_clearing-tax_value.
      ELSE.
        gs_after_clearing-net_value   = gs_red_dp_clear-net_value -
                                        wa_tvbdpr-netwr.
        gs_after_clearing-tax_value   = gs_red_dp_clear-tax_amt -
                                        wa_tvbdpr-mwsbp.
        gs_after_clearing-gross_value = gs_after_clearing-net_value +
                                        gs_after_clearing-tax_value.
      ENDIF.
      APPEND gs_after_clearing TO gt_after_clearing.
      CLEAR wa_tvbdpr.
      CLEAR ls_konv_corr.
      CLEAR gs_corr_to_be.
      CLEAR gs_after_clearing.
      CLEAR gs_red_dp_clear.
    ENDLOOP.
  ENDLOOP.

* Amount to be paid/Return

  CLEAR gv_to_pay_diff.

  LOOP AT gt_after_clearing.
    ADD gt_after_clearing-gross_value TO gv_to_pay_diff.
  ENDLOOP.

  PERFORM get_amt_in_words_diff.

ENDFORM.                    " correction_partial_invoice
*&---------------------------------------------------------------------*
*&      Form  ADJUST_PRINT_LINES_CORR_INVOIC
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM adjust_print_lines_corr_invoic.

  DATA ls_vbak_key   TYPE sales_key.
  DATA ls_vbap       TYPE vbap.
  DATA lt_vbap       TYPE TABLE OF vbap.
  DATA lt_vbak_key   TYPE TABLE OF sales_key.

* Check if the invoice is credit invoice or correction to DP invoice

  IF gs_vbrk-vbtyp = 'O'.

    IF gs_tvfk-trvog = '8'.

      gv_inv_typ    = 'E'.

*if the condition type is 'H'-Percentage included, subtract the
*tax value from the base value for correct printing in the tax lines

      LOOP AT hkomvd.
        IF hkomvd-krech = 'H'.
          SUBTRACT hkomvd-kwert FROM hkomvd-kawrt.
          MODIFY hkomvd.
        ENDIF.
      ENDLOOP.

      ls_vbak_key-vbeln = corr_vbdkr-vbeln_vauf.
      APPEND ls_vbak_key TO lt_vbak_key.

      CALL FUNCTION 'SD_VBAP_ARRAY_READ_VBELN'
* EXPORTING
*   I_BYPASSING_BUFFER          = ' '
*   I_REFRESH_BUFFER            =
        TABLES
          it_vbak_key                 = lt_vbak_key
*   ET_VBAPVB                   =
          et_vbap                     = gt_vbap
      EXCEPTIONS
        records_not_found           = 1
        records_not_requested       = 2
        OTHERS                      = 3
                .
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.

      CLEAR ls_vbap.

      LOOP AT tvbdpr.
        READ TABLE gt_vbap INTO ls_vbap WITH KEY vbeln = tvbdpr-vbeln_vauf
                                                 posnr = tvbdpr-posnr_vauf.
        IF sy-subrc = 0.
          tvbdpr-netprl = ls_vbap-netpr.
          tvbdpr-netwr  = ls_vbap-netwr.
          tvbdpr-brtwr  = ls_vbap-netwr + ls_vbap-mwsbp.
          tvbdpr-mwsbp  = ls_vbap-mwsbp.
          MODIFY tvbdpr.
        ENDIF.

* Down payment acquistion date is got from FBUDA at item level

        IF gv_dp_rcpt_date IS INITIAL.
          gv_dp_rcpt_date = tvbdpr-fbuda.
        ENDIF.
      ENDLOOP.

* total amount before correction

      gv_dp_total = corr_vbdkr-netwr + corr_vbdkr-mwsbk.

    ENDIF.
  ENDIF.

ENDFORM.                    " ADJUST_PRINT_LINES_CORR_INVOIC
*&---------------------------------------------------------------------*
*&      Form  corr_partial_invoice
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM corr_partial_invoice.

  DATA: lv_lines TYPE i.

  DESCRIBE TABLE gt_red_dp_clear LINES lv_lines.

  IF lv_lines NE 0.

    CLEAR gs_red_dp_clear.

    LOOP AT gt_red_dp_clear.
      ADD gt_red_dp_clear-net_value TO gs_red_dp_clear-net_value.
      ADD gt_red_dp_clear-gross_value TO gs_red_dp_clear-gross_value.
      ADD gt_red_dp_clear-tax_amt  TO gs_red_dp_clear-tax_amt.
    ENDLOOP.

* For Reduction of DP Clearing

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'REDUCTION_OF_DP_HEA'
      EXCEPTIONS
        element = 1.

    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    LOOP AT gt_red_dp_clear.

      gs_red_dp_clear = gt_red_dp_clear.

      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'REDUCTION_OF_DP'
        EXCEPTIONS
          element = 1.

      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    ENDLOOP.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'U_LINE_SHORT'
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

* To Print Should be data

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'SHOULD_BE_HEA'
      EXCEPTIONS
        element = 1.

    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    LOOP AT gt_corr_to_be.

      CALL FUNCTION 'CONTROL_FORM'
        EXPORTING
          command = 'PROTECT'.

      gs_corr_to_be  = gt_corr_to_be.

      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'SHOULD_BE_DP'
        EXCEPTIONS
          element = 1.

      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.

      CALL FUNCTION 'CONTROL_FORM'
        EXPORTING
          command = 'ENDPROTECT'.

      PERFORM item_text_print.
    ENDLOOP.

* To print Clearing of DP

    PERFORM partial_amts_totals_print.
  ENDIF.

ENDFORM.                    " corr_partial_invoice
*&---------------------------------------------------------------------*
*&      Form  partial_amts_totals_print
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM partial_amts_totals_print.

  PERFORM print_corr_lines USING 'CLEARING_OF_DP'.
  PERFORM print_corr_lines USING 'AFTER_CLEARING'.

  CALL FUNCTION 'CONTROL_FORM'
    EXPORTING
      command = 'PROTECT'.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      element = 'IN_WORDS_DIFF'
    EXCEPTIONS
      element = 1
      window  = 2.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

  CALL FUNCTION 'CONTROL_FORM'
    EXPORTING
      command = 'ENDPROTECT'.


ENDFORM.                    " partial_amts_totals_print
*&---------------------------------------------------------------------*
*&      Form  print_corr_lines
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM print_corr_lines USING    uv_line_type TYPE string.

  DATA lt_table_corr TYPE TABLE OF gtyp_amts_with_tax WITH HEADER LINE.
  DATA lv_lines TYPE i.
  DATA ls_total_corr TYPE gtyp_amts_with_tax.
  DATA lv_head_corr  TYPE string.
  DATA lv_total_corr TYPE string.

  FIELD-SYMBOLS <print_lines> TYPE gtyp_amts_with_tax.


  IF uv_line_type = 'CLEARING_OF_DP'.
    ASSIGN gs_clearing_dp TO <print_lines>.
    lt_table_corr[] = gt_clearing_dp[].
  ENDIF.

  IF uv_line_type = 'AFTER_CLEARING'.
    ASSIGN gs_after_clearing TO <print_lines>.
    lt_table_corr[] = gt_after_clearing[].
  ENDIF.


  DESCRIBE TABLE lt_table_corr LINES lv_lines.

  IF lv_lines NE 0.

    CONCATENATE uv_line_type '_HEA'    INTO lv_head_corr.
    CONCATENATE uv_line_type '_TOTAL' INTO lv_total_corr.

    CALL FUNCTION 'CONTROL_FORM'
      EXPORTING
        command = 'PROTECT'.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = lv_head_corr
      EXCEPTIONS
        OTHERS  = 1.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    CLEAR ls_total_corr.

    LOOP AT lt_table_corr INTO ls_total_corr.
      SUM.
    ENDLOOP.

    <print_lines> = ls_total_corr.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = lv_total_corr
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    LOOP AT lt_table_corr.

      <print_lines> = lt_table_corr.

      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = uv_line_type
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.

    ENDLOOP.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'U_LINE_SHORT'
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    CALL FUNCTION 'CONTROL_FORM'
      EXPORTING
        command = 'ENDPROTECT'.
  ENDIF.

ENDFORM.                    " print_corr_lines
*&---------------------------------------------------------------------*
*&      Form  print_corr_line
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM print_corr_line USING    uv_line_type TYPE string.

  DATA lt_table_corr TYPE TABLE OF gtyp_amts_with_tax WITH HEADER LINE.
  DATA lv_lines TYPE i.
  DATA ls_total_corr TYPE gtyp_amts_with_tax.
  DATA lv_head_corr  TYPE string.
  DATA lv_total_corr TYPE string.

  CLEAR gs_corr_print.
  CLEAR gs_diff_print.

  FIELD-SYMBOLS <print_linec> TYPE gtyp_amts_with_tax.

  IF uv_line_type = 'DP_AMOUNT_AFTER_CORRECTION'.
    ASSIGN gs_corr_print TO <print_linec>.
    lt_table_corr[] = gt_corr_print[].
  ENDIF.

  IF uv_line_type = 'DIFFERENCE'.
    ASSIGN gs_diff_print TO <print_linec>.
    lt_table_corr[] = gt_diff_print[].
  ENDIF.

  DESCRIBE TABLE lt_table_corr LINES lv_lines.

  IF lv_lines NE 0.

    CONCATENATE uv_line_type '_HEA' INTO lv_head_corr.
    CONCATENATE uv_line_type '_TOT' INTO lv_total_corr.

    CALL FUNCTION 'CONTROL_FORM'
      EXPORTING
        command = 'PROTECT'.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = lv_head_corr
      EXCEPTIONS
        OTHERS  = 1.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    CLEAR ls_total_corr.

    LOOP AT lt_table_corr INTO ls_total_corr.
      SUM.
    ENDLOOP.


    <print_linec> = ls_total_corr.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = lv_total_corr
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    LOOP AT lt_table_corr.

      <print_linec> = lt_table_corr.

      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = uv_line_type
        EXCEPTIONS
          element = 1
          window  = 2.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.

    ENDLOOP.

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'U_LINE_SHORT'
      EXCEPTIONS
        element = 1
        window  = 2.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    CALL FUNCTION 'CONTROL_FORM'
      EXPORTING
        command = 'ENDPROTECT'.
  ENDIF.


ENDFORM.                    " print_corr_line
*&---------------------------------------------------------------------*
*&      Form  get_amt_in_words_diff
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_amt_in_words_diff.

  IF gv_to_pay_diff NE 0.

    CALL FUNCTION 'SPELL_AMOUNT'
      EXPORTING
        amount          = gv_to_pay_diff
        currency        = vbdkr-waerk
*   FILLER          = ' '
*        language        = sy-langu  "nast-spras
         language        = nast-spras
      IMPORTING
        in_words        = gs_spell
      EXCEPTIONS
        not_found       = 1
        too_large       = 2
        OTHERS          = 3
              .
    IF sy-subrc <> 0.
      PERFORM protocol_update.
    ENDIF.

    gv_to_pay_in_words = gs_spell-word.
    gv_to_pay_dec_in_words = gs_spell-decword.
  ENDIF.

ENDFORM.                    " get_amt_in_words_diff
*&---------------------------------------------------------------------*
*&      Form  form_rec_prep
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM form_rec_prep.
* begin of change MOD-004
  IF ( gv_inv_typ = 'D' AND vbdkr-fkart = 'FAF' ) OR
     ( gv_inv_typ = 'D' AND vbdkr-fkart = 'FAFS' ).
* end of change MOD-004
    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        element = 'RECEIVED_PREPAYMENT'
      EXCEPTIONS
        OTHERS  = 1.
    IF sy-subrc NE 0.
      PERFORM protocol_update.
    ENDIF.

    LOOP AT hkomvd.
      komvd = hkomvd.
      CHECK komvd-kwert NE 0.
      IF komvd-koaid = 'D'.
        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            element = 'TAX_LINE'.
      ENDIF.
    ENDLOOP.

* print amount in words
    IF komp-kzwi6 NE 0.
      CALL FUNCTION 'SPELL_AMOUNT'
        EXPORTING
          amount    = komp-kzwi6
          currency  = vbdkr-waerk
          language  = nast-spras
        IMPORTING
          in_words  = gs_spell
        EXCEPTIONS
          not_found = 1
          too_large = 2
          OTHERS    = 3.
      IF sy-subrc <> 0.
        PERFORM protocol_update.
      ENDIF.

      gv_to_pay_in_words = gs_spell-word.
      gv_to_pay_dec_in_words = gs_spell-decword.

      CALL FUNCTION 'WRITE_FORM'
        EXPORTING
          element = 'SLOWNIE'
        EXCEPTIONS
          OTHERS  = 1.
      IF sy-subrc NE 0.
        PERFORM protocol_update.
      ENDIF.
    ENDIF.

  ENDIF.

ENDFORM.                    "form_rec_prep
*&---------------------------------------------------------------------*
*&      Form  get_acc_docnr
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_acc_docnr.

  CLEAR: gv_docnr.

  SELECT * FROM bkpf WHERE awtyp = 'VBRK'
                       AND awkey = vbdkr-vbeln.
  ENDSELECT.
  IF sy-subrc = 0.
    MOVE bkpf-belnr TO gv_docnr.
  ELSE.
    MOVE vbdkr-vbeln TO gv_docnr.
  ENDIF.

ENDFORM.                    "get_acc_docnr
*&---------------------------------------------------------------------*
*&      Form  get_comp_data
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_comp_data.

  CLEAR t001-stceg.
  SELECT SINGLE * FROM t001 WHERE bukrs = vbdkr-bukrs.
  IF sy-subrc = 0.
    SELECT SINGLE * FROM adrc WHERE addrnumber = t001-adrnr.
    IF sy-subrc = 0.
      SELECT SINGLE * FROM adr6 WHERE addrnumber = t001-adrnr.
      SELECT SINGLE * FROM adrt WHERE addrnumber = t001-adrnr
                                  AND comm_type = 'INT'.
    ENDIF.
  ENDIF.


ENDFORM.                    "get_comp_data
*&---------------------------------------------------------------------*
*&      Form  refresh_tables
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM refresh_tables.

  REFRESH : gt_to_be_paid,
            gt_dp_clearing,
            gt_left_for_clearing.
  CLEAR : gv_to_pay,
          gv_to_pay_in_words,
          gv_to_pay_dec_in_words.

ENDFORM.                    "refresh_tables
* begin of insertion MOD-001
*&---------------------------------------------------------------------*
*&      Form  DETERMINE_PDF
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM determine_pdf .

  CLEAR gv_pdf.
* pdf is only possible when the medium = 8 (special)
  IF nast-nacha = '8'.
    IF NOT itcpo-tdpreview = gc_true.
      SELECT SINGLE pdf
          INTO gv_pdf
          FROM yse_pmpl_pdf
*        WHERE pm_paper EQ t390-workpaper.
* begin of change MOD-003
*           WHERE pm_paper EQ 'ZDPL'.
            WHERE pm_paper EQ nast-kschl.
* end of change MOD-003
    ENDIF.
  ENDIF.

ENDFORM.                    " DETERMINE_PDF
*---------------------------------------------------------------------*
*       FORM DETERMINE_DEVICE                                         *
*---------------------------------------------------------------------*
*  -->  ITCPO                                                         *
*  -->  RET_DEVICE                                                    *
*---------------------------------------------------------------------*
FORM determine_device USING itcpo STRUCTURE itcpo
                            ret_device TYPE clike. "ITCPP-TDDEVICE
  CALL FUNCTION 'PM_DETERMINE_OUTPUT_DEVICE'
    EXPORTING
      in_itcpo   = itcpo
    IMPORTING
      out_device = ret_device.
ENDFORM.                    "DETERMINE_DEVICE

*&---------------------------------------------------------------------*
*&      Form  get_salesgroup_desc
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_salesgroup_desc.

  CLEAR: gv_vkgrp,
         gv_bezei.

  SELECT vkgrp INTO gv_vkgrp FROM vbrp UP TO 1 ROWS
   WHERE vbeln = vbdkr-vbeln.  "insert AIR22296 on 12/10/2007.
  ENDSELECT.

  SELECT SINGLE bezei INTO gv_bezei FROM
      tvgrt WHERE vkgrp = gv_vkgrp
            AND spras = nast-spras.


ENDFORM.                    "get_salesgroup_desc
*&---------------------------------------------------------------------*
*&      Form  get_vat_number
*&---------------------------------------------------------------------*
*       Get vat number from KNA1
*----------------------------------------------------------------------*
FORM get_vat_number.

  CLEAR gv_stcd1.

  SELECT SINGLE stcd1 INTO gv_stcd1 FROM kna1
   WHERE kunnr = vbdkr-kunre.

ENDFORM.                    "get_vat_number
*****BEGIN OF MOD-008 INSERT
*&---------------------------------------------------------------------*
*&      Form  SEND_MAIL
*&---------------------------------------------------------------------*
*       Send mail attach the pdf
*----------------------------------------------------------------------*
FORM send_mail .

  DATA: send_request   TYPE REF TO cl_bcs,
        i_sender       TYPE REF TO if_sender_bcs,
        document       TYPE REF TO cl_document_bcs,
        recipient      TYPE REF TO if_recipient_bcs,
        bcs_exception  TYPE REF TO cx_bcs,
        main_text      TYPE bcsy_text,
        binary_content TYPE solix_tab,
        size           TYPE so_obj_len,
        sent_to_all    TYPE os_boolean,
        lv_docnr       TYPE so_obj_des,
        lv_subject  TYPE so_obj_des,
        it_documents TYPE TABLE OF acc_doc WITH HEADER LINE,
        it_data TYPE solix_tab,
*       Internal table to hold the data from the FM CONVERT_OTF
        t_pdf_tab LIKE tline OCCURS 0 WITH HEADER LINE,
        w_bin_filesize TYPE i, " Binary File Size
        lt_pdf TYPE TABLE OF tline,
        ls_pdf TYPE tline,
        lv_kunnr_st TYPE vbpa-kunnr,
        lv_content  TYPE xstring.
  FIELD-SYMBOLS <fs_x> TYPE x.

  CLEAR : mailto.
  SELECT COUNT(*)
    FROM yse_soldto
    WHERE kunnr = vbdkr-kunag.
  IF sy-subrc = 0.
    SELECT SINGLE kunnr
      FROM vbpa
      INTO lv_kunnr_st
      WHERE vbeln = vbdkr-vbeln
        AND posnr = '000000'
        AND parvw EQ 'WE'.
    IF  sy-subrc = 0.
*     Get bill to email
      SELECT SINGLE adr6~smtp_addr
        INTO mailto
        FROM kna1
          INNER JOIN adr6
          ON kna1~adrnr = adr6~addrnumber
        WHERE kna1~kunnr = lv_kunnr_st.
    ENDIF.
  ENDIF.
  IF mailto IS INITIAL.
*   Get bill to email
    SELECT SINGLE adr6~smtp_addr
      INTO mailto
      FROM kna1
        INNER JOIN adr6
        ON kna1~adrnr = adr6~addrnumber
      WHERE kna1~kunnr = vbdkr-kunag.
  ENDIF.


** Get bill to email
*  SELECT SINGLE adr6~smtp_addr
*    INTO mailto
*    FROM kna1
*      INNER JOIN adr6
*      ON kna1~adrnr = adr6~addrnumber
*    WHERE kna1~kunnr = vbdkr-kunag.

**Get the FI number of the SD invoice
*  CALL FUNCTION 'FI_DOCUMENT_RECORD'
*    EXPORTING
*      i_awtyp     = 'VBRK'
*      i_awref     = wa_vbrk-vbeln
*      i_bukrs     = wa_vbrk-bukrs
*    TABLES
*      t_documents = it_documents.
*
*  READ TABLE it_documents INDEX 1.
  lv_docnr = gv_docnr.

*  Function Module CONVERT_OTF is used to convert the OTF format to PDF
  CALL FUNCTION 'CONVERT_OTF'
    EXPORTING
      format = 'PDF'
      max_linewidth = 132
    IMPORTING
      bin_filesize = w_bin_filesize
*     BIN_FILE =
    TABLES
      otf = it_otf
      lines = t_pdf_tab
    EXCEPTIONS
      err_max_linewidth = 1
      err_format = 2
      err_conv_not_possible = 3
      err_bad_otf = 4
      OTHERS = 5.

  APPEND LINES OF t_pdf_tab TO lt_pdf.
*     convert pdf to xstring string
  LOOP AT lt_pdf INTO ls_pdf.
    ASSIGN ls_pdf TO <fs_x> CASTING.
    CONCATENATE lv_content <fs_x> INTO lv_content IN BYTE MODE.
  ENDLOOP.

* Convert xstring to binary table to pass to the LOAD_DATA method
  CALL FUNCTION 'SCMS_XSTRING_TO_BINARY'
    EXPORTING
      buffer     = lv_content
    TABLES
      binary_tab = it_data.

  TRY.

*     -------- create persistent send request ------------------------
      send_request = cl_bcs=>create_persistent( ).

*     create document object from internal table with text
      APPEND 'Szanowni Pastwo,'(071)
        TO main_text.                                       "#EC NOTEXT
      APPEND INITIAL LINE TO  main_text.
      APPEND 'w za##czeniu przesy#amy faktur# elektroniczn# odno#nie Pastwa zamwienia.'(010)
        TO main_text.                                       "#EC NOTEXT
      APPEND INITIAL LINE TO  main_text.
      APPEND 'Prosimy sprawdzi#, czy wszystkie dane s# prawid#owe. W razie potrzeby'(092)
        TO main_text.                                       "#EC NOTEXT
      APPEND INITIAL LINE TO  main_text.
      APPEND 'prosimy o kontakt z osob# wystawiaj#c# faktur# lub osob# odpowiedzialn# za zamwienie,'(093)
        TO main_text.                                       "#EC NOTEXT
      APPEND INITIAL LINE TO  main_text.
      APPEND 'ktrego ta faktura dotyczy.'(094)
        TO main_text.                                       "#EC NOTEXT
      APPEND INITIAL LINE TO  main_text.
      APPEND 'Prosimy o podanie pe#nego numeru faktury w tytule p#atno#ci.'(095)
        TO main_text.                                       "#EC NOTEXT
      APPEND INITIAL LINE TO  main_text.
      APPEND INITIAL LINE TO  main_text.
      APPEND 'Z powa#aniem,'(072)
        TO main_text.                                       "#EC NOTEXT
      APPEND 'Atlas Copco Polska Sp. z o.o.'(073)
        TO main_text.                                       "#EC NOTEXT
      APPEND INITIAL LINE TO  main_text.
      APPEND INITIAL LINE TO  main_text.
      APPEND 'Ta wiadomo## mo#e zawiera# informacje o charakterze zastrze#onym i poufnym. W razie stwierdzenia, #e odbiorc#'(096)
        TO main_text.                                       "#EC NOTEXT
      APPEND 'mia#a by# inna osoba, prosimy poinformowa# nadawc# oraz niezw#ocznie usun## wiadomo##. Kopiowanie lub'(097)
        TO main_text.                                       "#EC NOTEXT
      APPEND 'jakiekolwiek wykorzystanie zawartych w niej informacji, jak rwnie# ujawnienie ich osobom trzecim, jest'(098)
        TO main_text.                                       "#EC NOTEXT
      APPEND 'zabronione.'(099)
        TO main_text. "#EC NOTEXT                                     "#EC NOTEXT

      CONCATENATE 'Faktura nr'(015) '-' lv_docnr '(Atlas Copco Polska)'(020)
        INTO lv_subject SEPARATED BY space.
      document = cl_document_bcs=>create_document(
        i_type    = 'RAW'
        i_text    = main_text
        i_subject = lv_subject ).                           "#EC NOTEXT

*     add the spread sheet as attachment to document object
      document->add_attachment(
        i_attachment_type    = 'PDF'                        "#EC NOTEXT
        i_attachment_subject = lv_docnr                     "#EC NOTEXT
        i_attachment_size    = size
        i_att_content_hex    = it_data ).

*     add document object to send request
      send_request->set_document( document ).

*     --------- add recipient (e-mail address) -----------------------
*     create recipient object
      recipient = cl_cam_address_bcs=>create_internet_address( mailto ).

*     add recipient object to send request
      send_request->add_recipient( recipient ).
******************set sender******************************************
      IF sy-uname = 'SSCEXTCWU'.
        i_sender = cl_cam_address_bcs=>create_internet_address( 'Allen.Cao@cn.atlascopco.com' ).
        send_request->set_sender( i_sender  ).
      ENDIF.

******************set sender******************************************

*     ---------- send document ---------------------------------------
      sent_to_all = send_request->send( i_with_error_screen = 'X' ).

*      COMMIT WORK.

      IF sent_to_all IS INITIAL.
        MESSAGE i500(sbcoms) WITH mailto.
      ELSE.
        MESSAGE s022(so).
      ENDIF.

*     ------------ exception handling ----------------------------------
*     replace this rudimentary exception handling with your own one !!!
    CATCH cx_bcs INTO bcs_exception.
      MESSAGE i865(so) WITH bcs_exception->error_type.
  ENDTRY.
ENDFORM.                    " SEND_MAIL

********End of MOD-008 INSERT
*Text symbol text
*010:w za##czeniu przesy#amy faktur# elektroniczn# odno#nie Pastwa zamwienia.
*015:Faktura nr
*020:(Atlas Copco Polska)
*071:Szanowni Pastwo,
*072:Z powa#aniem,
*073:Atlas Copco Polska Sp. z o.o.
*092:Prosimy sprawdzi#, czy wszystkie dane s# prawid#owe. W razie potrzeby
*093:prosimy o kontakt z osob# wystawiaj#c# faktur# lub osob# odpowiedzialn# za zamwienie,
*094:ktrego ta faktura dotyczy.
*095:Prosimy o podanie pe#nego numeru faktury w tytule p#atno#ci.
*096:Ta wiadomo## mo#e zawiera# informacje o charakterze zastrze#onym i poufnym. W razie stwierdzenia, #e odbiorc#
*097:mia#a by# inna osoba, prosimy poinformowa# nadawc# oraz niezw#ocznie usun## wiadomo##. Kopiowanie lub
*098:jakiekolwiek wykorzystanie zawartych w niej informacji, jak rwnie# ujawnienie ich osobom trzecim, jest
*099:zabronione.
