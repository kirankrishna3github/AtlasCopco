*&---------------------------------------------------------------------*
*&  Include           YSE_SD_CPL_DEL_AVAIL_FORMS                       *
*&---------------------------------------------------------------------*
*----------------------------------------------------------------------*
* CHANGE HISTORY LOG                                                   *
*----------------------------------------------------------------------*
* MOD. NO.|  DATE    | NAME     |CORRECTION NUMBER| CHANGE REFERENCE # *
*----------------------------------------------------------------------*
* MOD-002 |17.03.2011|Lakshmi R |CD1K963789       |CR1995              *
************************************************************************
* MOD-003 |05.05.2011|Deplancke |CD1K964854       |CR2047              *
************************************************************************
* MOD-003 |20.06.2011|L. Mertens  USG Innotiv  |CD1K965783|CR2047      *
*----------------------------------------------------------------------*
************************************************************************
* MOD-005 |19 06.2012| Pratap Mada             |CD1K972246|CR2480      *
*----------------------------------------------------------------------*
* MOD-007 |14 02.2013| Raghavendra D.V.S       |CD1K975097|CR2727      *
*         Addition of Open_qty and Scheduled qty in the output program *
*----------------------------------------------------------------------*
* MOD-008 |14.10.2013|Anda Wu                  |CD1K977819|CR2923      *
*          New YSE_AVAIL availability report enhancement               *
*----------------------------------------------------------------------*
* MOD-009 |19.05.2014|Raghavendra D.V.S.       |CD1K981562|CR2480      *
*          Logic for Conf. and requested delivery date                 *
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  GET_ARBID
*&---------------------------------------------------------------------*
FORM get_arbid TABLES arbid_tab STRUCTURE arbid_tab_n
                          arbpl STRUCTURE so_arbpl
                          arbid STRUCTURE arbid_n.

* read internal number of a work center -------------------------------*
  SELECT objid arbpl FROM crhd INTO TABLE arbid_tab
    FOR ALL ENTRIES IN it_werks
    WHERE arbpl IN arbpl
      AND werks EQ it_werks-werks.

*-- no work center found ----------------------------------------------*
  DESCRIBE TABLE arbid_tab LINES sy-tabix.
  IF sy-tabix IS INITIAL.
    MESSAGE s047(ih).
    STOP.
  ENDIF.

*-- too many work centers for select-----------------------------------*
*    IF sy-tabix > 255.
*      MESSAGE i103(ih).
*      STOP.
*    ENDIF.

*-- fill range for selection ------------------------------------------*
  arbid-option = 'EQ'.
  arbid-sign = 'I'.
  LOOP AT arbid_tab.
    arbid-low = arbid_tab-arbid.
    APPEND arbid.
  ENDLOOP.
  SORT arbid_tab.

ENDFORM.                               " GET_ARBID

*&---------------------------------------------------------------------*
*&      Form  SELECT_DATA
*&---------------------------------------------------------------------*
FORM select_data .

  DATA: BEGIN OF lt_vbeln OCCURS 0,
          vbeln TYPE vbeln,
        END OF lt_vbeln,

        BEGIN OF lt_kunnr OCCURS 0,
          kunnr TYPE kunnr,
        END OF lt_kunnr,

        BEGIN OF lt_aufnr OCCURS 0,
          aufnr      TYPE aufnr,
        END OF lt_aufnr.

  DATA: BEGIN OF t_lt_vbeln OCCURS 0,
          vbeln LIKE vbak-vbeln,
        END OF t_lt_vbeln.

*  Insert MOD-008 Begin
  DATA: lr_autlf TYPE RANGE OF vbak-autlf,
        ls_autlf LIKE LINE OF lr_autlf.
  IF p_autlf IS INITIAL.
    REFRESH: lr_autlf.
  ELSE.
    ls_autlf-sign = 'I'.
    ls_autlf-option = 'EQ'.
    ls_autlf-low  = p_autlf.
    APPEND ls_autlf TO lr_autlf.
  ENDIF.
*  Insert MOD-008 End

*---------------------------------------------------------------------
* Preselect plants for selection of workcenters
  SELECT DISTINCT werks
    FROM tvkwz
    INTO it_werks
    WHERE vkorg EQ p_vkorg.

    APPEND it_werks.
  ENDSELECT.

  IF rb_sbas = 'X'.
    r_auart-low    = 'ZO01'.
    r_auart-sign   = 'I'.
    r_auart-option = 'EQ'.
    CLEAR r_auart-high.
    APPEND r_auart.

*.. Order lines
    SELECT vbeln
         INTO CORRESPONDING FIELDS OF TABLE it_vbap
         FROM vbak
        WHERE vbeln IN so_vbeln
          AND vkorg EQ p_vkorg
          AND auart IN r_auart.
  ELSE.
*.. Get VBEP data with the delivery date first as this is the most selective criteria.
*.. This makes the total data to select later on much less (IT_VBAK)
    SELECT DISTINCT vbeln
         FROM vbep
         INTO t_lt_vbeln
         WHERE edatu IN so_edatu    "requested delivery date
           AND wadat IN so_wadat.   "goods issue date

      APPEND t_lt_vbeln.
    ENDSELECT.

*.. Don't continue if nothing found
    CHECK sy-subrc EQ 0.
    SORT t_lt_vbeln BY vbeln.

    REFRESH r_auart.
    r_auart-low    = 'ZO03'.
    r_auart-sign   = 'I'.
    r_auart-option = 'EQ'.
    CLEAR r_auart-high.
    APPEND r_auart.
    r_auart-low    = 'ZOR '.
    r_auart-sign   = 'I'.
    r_auart-option = 'EQ'.
    CLEAR r_auart-high.
    APPEND r_auart.

**    Begin of mod-009
**    Begin of mod-005
*    r_auart-low    = 'ZKB '.
*    r_auart-sign   = 'I'.
*    r_auart-option = 'EQ'.
*    CLEAR r_auart-high.
*    APPEND r_auart.
**    end of mod-005
    r_auart-low    = 'ZKB '.
    r_auart-sign   = 'I'.
    r_auart-option = 'EQ'.
    CLEAR r_auart-high.
    APPEND r_auart.
**    end of mod-009
*.. Order lines
*    SELECT vbak~vbeln vbap~posnr vbak~auart vbak~vkorg vbak~vtweg vbak~spart                      "comment MOD-002
    SELECT vbak~vbeln vbap~posnr vbak~auart vbak~erdat vbak~vkorg vbak~vtweg vbak~spart            "insert  MOD-002
*         vbap~werks vbap~matnr vbak~aufnr vbap~arktx marc~dismm mvke~mtpos mvke~mvgr4             "comment MOD-008
         vbap~werks vbap~matnr vbak~aufnr vbap~arktx vbap~ernam marc~dismm mvke~mtpos mvke~mvgr4   "insert  MOD-008
         mvke~prodh kwmeng AS menge vbak~vkbur vbak~vkgrp vbak~kunnr vbak~vgbel vbak~qmnum
         vbak~vsbed vbak~kvgr4 vbak~autlf vbuk~cmgst vbuk~lsstk
         INTO CORRESPONDING FIELDS OF TABLE it_vbap
         FROM vbak
         JOIN vbuk
           ON vbak~vbeln EQ vbuk~vbeln
         JOIN vbap
           ON vbak~vbeln EQ vbap~vbeln
         JOIN vbup
           ON vbap~vbeln EQ vbup~vbeln
          AND vbap~posnr EQ vbup~posnr
         JOIN marc
           ON vbap~matnr EQ marc~matnr
          AND vbap~werks EQ marc~werks
         JOIN mvke
           ON vbap~matnr EQ mvke~matnr
          AND vbak~vkorg EQ mvke~vkorg
          AND vbak~vtweg EQ mvke~vtweg
        FOR ALL entries IN t_lt_vbeln
        WHERE ( vbak~vbeln EQ t_lt_vbeln-vbeln AND
                vbak~vbeln IN so_vbeln )
          AND vbak~vkorg EQ p_vkorg
          AND vbak~aufnr IN so_aufnr
          AND vbak~vsbed IN so_vsbed
          AND vbak~kvgr4 IN so_kvgr4
*          AND vbak~autlf EQ p_autlf                            "Comment MOD-008
          AND vbak~autlf IN lr_autlf                            "Insert  MOD-008
          AND vbak~vtweg IN so_vtweg
          AND vbak~spart IN so_spart
          AND vbak~vkbur IN so_vkbur
          AND vbak~vkgrp IN so_vkgrp
          AND vbak~kunnr IN so_soldt
          AND vbak~auart IN r_auart
          AND vbap~werks IN so_werks
          AND vbap~matnr IN so_matnr
          AND vbap~abgru EQ  '  '
          AND vbak~vbtyp EQ 'C'
          AND vbuk~lfstk NE 'C'
          AND vbup~lfsta NE 'C'.
  ENDIF.

* Don't continue selection if no result returned
  CHECK sy-subrc EQ 0.

  IF rb_sbas = 'X'.
*.. Get ASSO's linked to selected service sales orders
    IF NOT it_vbap[] IS INITIAL.
      SELECT vbeln
         INTO TABLE it_asso
         FROM vbfa
         FOR ALL ENTRIES IN it_vbap
         WHERE vbelv   EQ it_vbap-vbeln
           AND vbtyp_n EQ 'C'
           AND vbtyp_v EQ 'C'.

*.... Don't continue selection if no result returned
      CHECK sy-subrc EQ 0.

*.... Order lines
      REFRESH it_vbap.

*      SELECT vbak~vbeln vbap~posnr vbak~auart vbak~vkorg vbak~vtweg vbak~spart                     "comment MOD-002
      SELECT vbak~vbeln vbap~posnr vbak~auart vbak~erdat vbak~vkorg vbak~vtweg vbak~spart           "insert  MOD-002
*             vbap~werks vbap~matnr vbak~aufnr vbap~arktx marc~dismm mvke~mtpos mvke~mvgr4          "comment MOD-008
             vbap~werks vbap~matnr vbak~aufnr vbap~arktx vbap~ernam marc~dismm mvke~mtpos mvke~mvgr4"insert  MOD-008
             mvke~prodh vbap~kwmeng vbak~vkbur vbak~vkgrp vbak~kunnr vbak~vgbel vbak~qmnum
             vbak~vsbed vbak~kvgr4 vbak~autlf vbuk~cmgst vbuk~lsstk
           INTO CORRESPONDING FIELDS OF TABLE it_vbap
           FROM vbak
           JOIN vbuk
             ON vbak~vbeln EQ vbuk~vbeln
           JOIN vbap
             ON vbak~vbeln EQ vbap~vbeln
           JOIN vbup
             ON vbap~vbeln EQ vbup~vbeln
            AND vbap~posnr EQ vbup~posnr
           JOIN marc
             ON vbap~matnr EQ marc~matnr
            AND vbap~werks EQ marc~werks
           JOIN mvke
             ON vbap~matnr EQ mvke~matnr
            AND vbak~vkorg EQ mvke~vkorg
            AND vbak~vtweg EQ mvke~vtweg
          FOR ALL entries IN it_asso
          WHERE vbak~vbeln EQ it_asso-vbeln
            AND vbak~vkorg EQ p_vkorg
            AND vbak~aufnr IN so_aufnr
            AND vbak~vsbed IN so_vsbed
            AND vbak~kvgr4 IN so_kvgr4
*            AND vbak~autlf EQ p_autlf                           "Comment MOD-008
            AND vbak~autlf IN lr_autlf                           "Insert  MOD-008
            AND vbak~vtweg IN so_vtweg
            AND vbak~spart IN so_spart
            AND vbak~vkbur IN so_vkbur
            AND vbak~vkgrp IN so_vkgrp
            AND vbak~kunnr IN so_soldt
            AND vbap~werks IN so_werks
            AND vbap~matnr IN so_matnr
            AND vbap~abgru EQ  '  '
            AND vbuk~lfstk NE 'C'
            AND vbup~lfsta NE 'C'.
    ENDIF.
  ENDIF.

* Don't continue selection if no result returned
  CHECK sy-subrc EQ 0.

  SORT it_vbap BY vbeln posnr.

* Create lists of unique material numbers and SO numbers found in IT_VBAP
  LOOP AT it_vbap.
    lt_vbeln-vbeln = it_vbap-vbeln.
    APPEND lt_vbeln.
    IF NOT it_vbap-aufnr IS INITIAL.
      lt_aufnr-aufnr  = it_vbap-aufnr.
      APPEND lt_aufnr.
    ENDIF.
    lt_kunnr-kunnr = it_vbap-kunnr.
    APPEND lt_kunnr.
  ENDLOOP.

  SORT lt_vbeln BY vbeln.
  DELETE ADJACENT DUPLICATES FROM lt_vbeln COMPARING vbeln.

  SORT lt_aufnr BY aufnr.
  DELETE ADJACENT DUPLICATES FROM lt_aufnr COMPARING aufnr.

  SORT lt_kunnr BY kunnr.
  DELETE ADJACENT DUPLICATES FROM lt_kunnr COMPARING kunnr.

* Get schedule lines
* logic for confirmed delievery date
  SELECT vbeln posnr etenr ettyp edatu wadat
         INTO TABLE it_vbep
         FROM vbep
         FOR ALL ENTRIES IN lt_vbeln
         WHERE vbeln = lt_vbeln-vbeln
         AND bmeng NE space.                      " Changed by EXTRRS aginst CR-2689

* logic for Requested delivery date.
*  Begin of MOD-009
  SELECT vbeln posnr etenr ettyp edatu wadat
         INTO TABLE it_vbep1
         FROM vbep
         FOR ALL ENTRIES IN lt_vbeln
         WHERE vbeln = lt_vbeln-vbeln
         AND etenr EQ c_001.
  SORT it_vbep1 BY vbeln posnr etenr.
*  End of MOD-009.

  SORT it_vbep BY vbeln posnr etenr.

* Eliminate schedule lines
*   - which are not the first ones for a specific item
*   - which are not according to req. del date from selection screen
*   - which are not according to goods issue date from selection screen
  DELETE ADJACENT DUPLICATES FROM it_vbep COMPARING vbeln posnr.
  DELETE it_vbep WHERE edatu NOT IN so_edatu
                    OR wadat NOT IN so_wadat.

* Get ship-to parties
  SELECT vbeln kunnr
         INTO TABLE it_vbpa
         FROM vbpa
         FOR ALL ENTRIES IN lt_vbeln
         WHERE vbeln EQ lt_vbeln-vbeln
           AND parvw EQ 'WE'.

  SORT it_vbpa BY vbeln.

* Eliminate ship-to parties
*   - which are not according to ship-to party from selection screen
  DELETE it_vbpa WHERE kunnr NOT IN so_shipt.

* Get customer names
  SELECT kunnr name1
         INTO TABLE it_kna1
         FROM kna1
         FOR ALL ENTRIES IN lt_kunnr
         WHERE kunnr EQ lt_kunnr-kunnr.

  SELECT kunnr name1
         APPENDING TABLE it_kna1
         FROM kna1
         FOR ALL ENTRIES IN it_vbpa
         WHERE kunnr EQ it_vbpa-kunnr.

  SORT it_kna1 BY kunnr.
  DELETE ADJACENT DUPLICATES FROM it_kna1 COMPARING kunnr.

* Get sales districts and payment terms
  SELECT vbeln posnr bzirk zterm bstkd " mod-005
         INTO TABLE it_vbkd
         FROM vbkd
         FOR ALL ENTRIES IN lt_vbeln
         WHERE vbeln EQ lt_vbeln-vbeln.

  SORT it_vbkd BY vbeln posnr.

* Eliminate sales districts
*   - which are not according to sales district from selection screen
  DELETE it_vbkd WHERE bzirk NOT IN so_bzirk.

* Eliminate payment terms
*   - which are not according to payment conditions from selection screen
  DELETE it_vbkd WHERE zterm NOT IN so_zterm.

* Get planner groups/main work centers/notifications
  IF NOT lt_aufnr[] IS INITIAL.
    SELECT aufnr ingpr gewrk qmnum
         INTO TABLE it_afih
         FROM afih
         FOR ALL ENTRIES IN lt_aufnr
         WHERE aufnr EQ lt_aufnr-aufnr.

    SORT it_afih BY aufnr.

*.. Eliminate planner groups
*..   - which are not according to planner group from selection screen
    DELETE it_afih WHERE ingpr NOT IN so_ingpr.
  ENDIF.

* Get main work centers
  IF NOT lt_aufnr[] IS INITIAL.
    PERFORM get_arbid TABLES arbid_tab_n so_arbpl arbid_n.

*.. Eliminate main work centers
*..   - which are not according to main work center from selection screen
    DELETE arbid_tab_n WHERE arbid NOT IN arbid_n.
  ENDIF.

* Get PO number
  SELECT vbelv posnv vbeln posnn
       INTO TABLE it_vbfa
       FROM vbfa
       FOR ALL ENTRIES IN lt_vbeln
       WHERE vbfa~vbelv   EQ lt_vbeln-vbeln
         AND vbfa~vbtyp_n EQ 'V'
         AND vbfa~vbtyp_v EQ 'C'.

  SORT it_vbfa BY vbelv posnv.

  REFRESH: it_ebeln, "mod-004
           it_ekbe.  "mod-004


  LOOP AT it_vbfa.
    SELECT SINGLE loekz INTO ekpo-loekz
      FROM ekpo WHERE ebeln = it_vbfa-vbeln
                  AND ebelp = it_vbfa-posnn
                  AND loekz = ' '.

    IF sy-subrc <> 0.
      DELETE it_vbfa.
*      Begin of mod-004
    ELSE.
      wa_ebeln-ebeln = it_vbfa-vbeln.
      wa_ebeln-ebelp = it_vbfa-posnn+1(5).
      wa_ebeln-vbeln = it_vbfa-vbelv.
      wa_ebeln-posnr = it_vbfa-posnv.
      APPEND wa_ebeln TO it_ebeln.
      CLEAR wa_ebeln.
*     end of mod-004
    ENDIF.
  ENDLOOP.

*  begin of mod-004
  SORT it_ebeln BY vbeln posnr.
  IF it_ebeln[] IS NOT INITIAL.
    SELECT ebeln
           ebelp
           zekkn
           vgabe
           gjahr
           belnr
           buzei
           bwart
           budat
           FROM ekbe
           INTO TABLE it_ekbe
           FOR ALL ENTRIES IN it_ebeln
           WHERE ebeln EQ it_ebeln-ebeln
           AND ebelp EQ it_ebeln-ebelp
           AND bwart EQ '101'.

    SORT it_ekbe BY  ebeln ebelp
                     gjahr  belnr budat.
    DELETE ADJACENT DUPLICATES FROM it_ekbe
                           COMPARING ebeln ebelp.
    SORT it_ekbe BY ebeln ebelp.
  ENDIF.
*  end of mod--04

ENDFORM.                    " SELECT_DATA

*&---------------------------------------------------------------------*
*&      Form  PROCESS_DATA
*&---------------------------------------------------------------------*
FORM process_data .

* First determine the items to be displayed
  PERFORM build_out_table.

* For those items, determine the availability
  PERFORM determine_avl.
*Begin of MOD-007.
*  For adding new columns to the final table.
  PERFORM add_column.
*End of MOD-007.
*Begin of CR3439.
*  For adding new columns to the final table CR3439
  PERFORM add_column_2.
*End of CR3439

ENDFORM.                    " PROCESS_DATA

*&---------------------------------------------------------------------*
*&      Form  DISPLAY_DATA
*&---------------------------------------------------------------------*
FORM display_data .
* Begin of Mod-001.
* Check if run in batch mode
  IF sy-batch <> 'X'.
* End of Mod-001.
    CALL SCREEN '0100'.

* Begin of Mod-001.
* If run in background mode call the list display
  ELSE.
*   Set parameters regarding layout, etc.
    gv_variant-report = sy-cprog.
    gs_layout-zebra      = 'X'.
    gs_layout-colwidth_optimize = 'X'.

*   Clear the field catalog table
    REFRESH: it_fieldcat.

*   Fetch the field catalog for structure
    IF rb_hlev = 'X'.
      gs_structure = 'YSE_SD_CPL_DEL_OUT_HDR'.
*.... Keep only one line per sales order
      DELETE ADJACENT DUPLICATES FROM it_out COMPARING vbeln.
    ELSE.
      gs_structure =  'YSE_SD_CPL_DEL_OUT_ITM'.
    ENDIF.

    gv_variant-variant = p_var.               "insert MOD-002
    CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
     EXPORTING
       i_callback_program             = sy-repid
*     I_CALLBACK_PF_STATUS_SET       = ' '
*     I_CALLBACK_USER_COMMAND        = ' '
       i_structure_name               = gs_structure
       is_layout                      = gs_layout
*     IT_FIELDCAT                    =  IT_FIELDCAT
*     I_DEFAULT                      = 'X'
       i_save                         = 'A'
       is_variant                     = gv_variant
*     IT_EVENTS                      =
*   IMPORTING
*     E_EXIT_CAUSED_BY_CALLER        =
*     ES_EXIT_CAUSED_BY_USER         =
      TABLES
        t_outtab                       =    it_out[]
     EXCEPTIONS
       program_error                  = 1
       OTHERS                         = 2
              .
  ENDIF.
* End of Mod-001.

ENDFORM.                    " DISPLAY_DATA

*&---------------------------------------------------------------------*
*&      Form  BUILD_OUT_TABLE
*&---------------------------------------------------------------------*
FORM build_out_table .

* Process the item lines
  LOOP AT it_vbap.

*   Clear output structure
    CLEAR it_out.

*   Move fields with same name
    MOVE-CORRESPONDING it_vbap TO it_out.

*   Skip Generic machines
    IF it_vbap-matnr = 'GMACH'.
      CONTINUE.
    ENDIF.

*   Map PGC
    IF it_vbap-prodh+4(4) NOT IN so_pgc.
*     Skip the item line
      CONTINUE.
    ENDIF.
    it_out-pgc = it_vbap-prodh+4(4).

*   Map ordered quantity
    it_out-kwmeng = it_vbap-menge.

*   Map sales district and payment conditions
    READ TABLE it_vbkd WITH KEY vbeln = it_out-vbeln
                                posnr = it_out-posnr
                       BINARY SEARCH.

    IF sy-subrc = 0.
      it_out-bzirk = it_vbkd-bzirk.
      it_out-bstkd = it_vbkd-bstkd. "mod-005
*      it_out-zterm = it_vbkd-zterm.                 "comment MOD-002
* begin of insert MOD-003
      IF it_vbap-auart = 'ZOR'.
        it_out-zterm = it_vbkd-zterm.
      ENDIF.
* end of insert MOD-003
    ELSE.
      READ TABLE it_vbkd WITH KEY vbeln = it_out-vbeln
                                  posnr = '000000'
                         BINARY SEARCH.
      IF sy-subrc = 0.
        it_out-bzirk = it_vbkd-bzirk.
        it_out-bstkd = it_vbkd-bstkd. "mod-005
*        it_out-zterm = it_vbkd-zterm.               "comment MOD-002
* begin of insert MOD-003
        IF it_vbap-auart = 'ZOR'.
          it_out-zterm = it_vbkd-zterm.
        ENDIF.
* end of insert MOD-003
      ELSE.
        CONTINUE.
      ENDIF.
    ENDIF.

*   Map customers and names
    it_out-kunag = it_vbap-kunnr.
    READ TABLE it_kna1 WITH KEY kunnr = it_out-kunag
                       BINARY SEARCH.

    IF sy-subrc = 0.
      it_out-name1_ag = it_kna1-name1.
    ENDIF.

    READ TABLE it_vbpa WITH KEY vbeln = it_out-vbeln
                       BINARY SEARCH.
    IF sy-subrc = 0.
      it_out-kunwe = it_vbpa-kunnr.
    ELSE.
      CONTINUE.
    ENDIF.

    READ TABLE it_kna1 WITH KEY kunnr = it_out-kunwe
                       BINARY SEARCH.

    IF sy-subrc = 0.
      it_out-name1_we = it_kna1-name1.
    ENDIF.

*   Map stock policy
    IF it_vbap-dismm EQ 'Z5' OR it_vbap-dismm EQ 'Z9' OR it_vbap-dismm EQ 'PD'.
      it_out-stockpol = 'ST'.
    ELSEIF it_vbap-dismm EQ 'ND' OR it_vbap-dismm EQ 'Z6' OR it_vbap-dismm EQ 'Z7'.
      it_out-stockpol = 'NS'.
    ENDIF.

*   Map Distribution mode
    IF it_vbap-mtpos = 'ZDTC'.
      it_out-distri_mode = 'DTC'.
    ELSEIF it_vbap-mtpos = 'NORM' AND it_vbap-mvgr4 = space.
      it_out-distri_mode = 'NDTC'.
    ELSEIF it_vbap-mtpos = 'NORM' AND it_vbap-mvgr4 = 'LCL'.
      it_out-distri_mode = 'LCL'.
    ENDIF.

*   Get schedule line
*   logic for confirmed delevery date.
    READ TABLE it_vbep WITH KEY vbeln = it_out-vbeln
                                posnr = it_out-posnr
                       BINARY SEARCH.

*   If schedule line of the item not found (didn't meet date condition)
    IF sy-subrc NE 0.
*     Skip the item line
*      CONTINUE.          " Commented by EXTRRS --- CR 2689  --Some items are missing in YSE_AVAIL repo - bugs from CR2689
*   If schedule line found
    ELSE.
*     Fill "requested delivery date"
*   Begin of MOD-009.
*      it_out-edatu = it_vbep-edatu.
      it_out-conf_date = it_vbep-edatu.   " loigic for Conrfirmed del. date
*   logic for requested delevery date.
      CLEAR wa_vbep1.
      READ TABLE it_vbep1 INTO wa_vbep1
                          WITH KEY vbeln = it_out-vbeln
                                  posnr = it_out-posnr
                          BINARY SEARCH
                          TRANSPORTING edatu.
      it_out-edatu = wa_vbep1-edatu.      " loigic for requested del. date
*    End of MOD-009.
*     Fill "planned issue date"
      it_out-wadat = it_vbep-wadat.

*     Fill "confirmed quantity"
      SELECT SUM( bmeng )
         FROM vbep
         INTO it_out-bmeng
         WHERE vbeln = it_out-vbeln
           AND posnr = it_out-posnr.

*     Set DTC/SFS depending on schedule line type
      IF it_vbep-ettyp = 'ZB' OR it_vbep-ettyp = 'Z4' OR it_vbep-ettyp = 'Z5'.
        it_out-dtc_sfs = 'DTC'.
      ELSEIF it_vbep-ettyp = 'ZS'.
        it_out-dtc_sfs = 'DIE'.
      ELSE.
        it_out-dtc_sfs = 'SFS'.
      ENDIF.
    ENDIF.

*   Set block flags
    IF it_vbap-cmgst EQ 'B' OR it_vbap-cmgst EQ 'C'.
      it_out-cre_block = 'X'.
    ENDIF.
    IF it_vbap-lsstk EQ 'B' OR it_vbap-lsstk EQ 'C'.
      it_out-del_block = 'X'.
    ENDIF.

*   Get PO number
    IF it_out-dtc_sfs = 'DTC' OR it_out-dtc_sfs = 'DIE'.
      READ TABLE it_vbfa WITH KEY vbelv = it_out-vbeln
                                  posnv = it_out-posnr
                         BINARY SEARCH.

      IF sy-subrc = 0.
        it_out-ebeln = it_vbfa-vbeln.
        it_out-posnn = it_vbfa-posnn.                     "Insert MOD-008
      ENDIF.
    ENDIF.

*   Map Service Order Number
    it_out-aufnr = it_vbap-aufnr+2(10).

*   Map Service Sales Order
    it_out-ssord = it_vbap-vgbel.

*   Get planner group/notification number
    IF NOT it_vbap-aufnr IS INITIAL.
      READ TABLE it_afih WITH KEY aufnr = it_vbap-aufnr
                       BINARY SEARCH.
      IF sy-subrc = 0.
        it_out-ingpr = it_afih-ingpr.
        it_out-qmnum = it_afih-qmnum.

*...... Get main work center
        READ TABLE arbid_tab_n WITH KEY arbid = it_afih-gewrk
                       BINARY SEARCH.
        IF sy-subrc = 0.
          it_out-arbpl = arbid_tab_n-arbpl.
        ELSE.
          CONTINUE.
        ENDIF.
      ELSE.
        CONTINUE.
      ENDIF.
    ELSE.
      IF NOT ( so_ingpr[] IS INITIAL AND
               so_arbpl[] IS INITIAL ).
        CONTINUE.
      ENDIF.
    ENDIF.

*    begin of mod-004
    CLEAR wa_ebeln.
    READ TABLE it_ebeln INTO wa_ebeln
                    WITH KEY vbeln = it_out-vbeln
                             posnr = it_out-posnr
                     BINARY SEARCH.
    IF sy-subrc EQ 0.
      CLEAR wa_ekbe.
      READ TABLE it_ekbe INTO wa_ekbe
                    WITH KEY ebeln =  wa_ebeln-ebeln
                             ebelp =  wa_ebeln-ebelp
                     BINARY SEARCH.
      IF sy-subrc EQ 0.
        it_out-lewed = wa_ekbe-budat.
      ENDIF.
    ENDIF.
*   end of mod-004

    APPEND it_out.

  ENDLOOP.

*Begin of insert MOD-002
  REFRESH: it_ssozterms.
  IF NOT it_out[] IS INITIAL.
*Get Payment terms of Service Sales orders from VBKD table
    SELECT vbeln
           posnr
           zterm
    FROM   vbkd
    INTO   TABLE it_ssozterms
    FOR    ALL ENTRIES IN it_out
    WHERE  vbeln EQ it_out-ssord
    AND    posnr EQ '00000'.

* begin of insert MOD-003
* Get sales group of Service Sales orders from VBAK table
    SELECT vbeln
           vkgrp
    FROM   vbak
    INTO   TABLE it_ssovkgrps
    FOR    ALL ENTRIES IN it_out
    WHERE  vbeln EQ it_out-ssord.
* end of insert MOD-003
  ENDIF.

* begin of change MOD-003
*  LOOP AT it_out.
  LOOP AT it_out WHERE auart = 'ZO03'.
* end of change MOD-003
    CLEAR: wa_ssozterms.
    READ TABLE it_ssozterms INTO wa_ssozterms WITH KEY vbeln = it_out-ssord.
    IF sy-subrc EQ 0.
      it_out-zterm = wa_ssozterms-zterm.
    ENDIF.

* begin of insert MOD-003
    CLEAR: wa_ssovkgrps.
    READ TABLE it_ssovkgrps INTO wa_ssovkgrps WITH KEY vbeln = it_out-ssord.
    IF sy-subrc EQ 0.
      it_out-vkgrp = wa_ssovkgrps-vkgrp.
    ENDIF.
* end of insert MOD-003

    MODIFY it_out.
  ENDLOOP.

  REFRESH: it_tvzbt,
           it_tvgrt.
  IF NOT it_out[] IS INITIAL.
*Get Sales groups description
    SELECT spras
           vkgrp
           bezei
    FROM   tvgrt
    INTO   TABLE it_tvgrt
    FOR    ALL ENTRIES IN it_out
    WHERE  vkgrp EQ it_out-vkgrp
    AND    spras EQ 'E'.
*Get Payment terms description
    SELECT spras
           zterm
           vtext
    FROM   tvzbt
    INTO   TABLE it_tvzbt
    FOR    ALL ENTRIES IN it_out
    WHERE  zterm EQ it_out-zterm
    AND    spras EQ 'E'.
  ENDIF.

  LOOP AT it_out.
    CLEAR: wa_tvgrt,
           wa_tvzbt.
    READ TABLE it_tvgrt INTO wa_tvgrt WITH KEY vkgrp = it_out-vkgrp.
    IF sy-subrc EQ 0.
      it_out-bezei = wa_tvgrt-bezei.
    ENDIF.

    READ TABLE it_tvzbt INTO wa_tvzbt WITH KEY zterm = it_out-zterm.
    IF sy-subrc EQ 0.
      it_out-vtext = wa_tvzbt-vtext.
    ENDIF.
    MODIFY it_out.
  ENDLOOP.
*End of insert MOD-002

ENDFORM.                    " BUILD_OUT_TABLE

*&---------------------------------------------------------------------*
*&      Form  DETERMINE_AVL
*&---------------------------------------------------------------------*
FORM determine_avl.

  DATA:
     BEGIN OF lt_mara OCCURS 0,
       matnr LIKE marc-matnr,
     END OF lt_mara,

     BEGIN OF lt_marc OCCURS 0,
       matnr LIKE marc-matnr,
       werks LIKE marc-werks,
     END OF lt_marc,

     BEGIN OF lt_mard OCCURS 0,
       matnr LIKE mard-matnr,
       werks LIKE mard-werks,
       lgort LIKE mard-lgort,
       labst LIKE mard-labst,
     END OF lt_mard,

     BEGIN OF it_ekes OCCURS 0,
       ebeln   LIKE ekes-ebeln,
       ebelp   LIKE ekes-ebelp,
     END OF it_ekes,

     BEGIN OF lt_vbfa OCCURS 0,
       vbelv   LIKE vbfa-vbelv,
       posnv   LIKE vbfa-posnv,
       vbeln   LIKE vbfa-vbeln,
       posnn   LIKE vbfa-posnn,
       vbtyp_n LIKE vbfa-vbtyp_n,
     END OF lt_vbfa,

     BEGIN OF lt_lips OCCURS 0,
       matnr TYPE lips-matnr,    "insert MOD-002
       werks TYPE lips-werks,    "insert MOD-002
       vbeln LIKE lips-vbeln,
       posnr LIKE lips-posnr,
       vgbel TYPE lips-vgbel,    "insert MOD-002
       lfimg LIKE lips-lfimg,
       wbstk LIKE vbuk-wbstk,
     END OF lt_lips,

*Begin of insert MOD-002
     BEGIN OF lt_outdel OCCURS 0,
       matnr TYPE lips-matnr,
       werks TYPE lips-werks,
       lfimg TYPE lips-lfimg,
     END OF lt_outdel,
*End of insert MOD-002

  BEGIN OF lt_mard_aggr OCCURS 0,
    matnr LIKE mard-matnr,
    werks LIKE mard-werks,
    labst LIKE mard-labst,
  END OF lt_mard_aggr,

  BEGIN OF lt_vbap_all OCCURS 0,
    vbeln       LIKE vbap-vbeln,
    posnr       LIKE vbap-posnr,
    matnr       LIKE vbap-matnr,
    werks       LIKE vbap-werks,
    lgort       LIKE vbap-lgort,
    lprio       LIKE vbap-lprio,
    kwmeng      LIKE vbap-kwmeng,
    kwmeng_open LIKE vbap-kwmeng,
    edatu       LIKE vbep-edatu,
    available   TYPE c,
  END OF lt_vbap_all,

  BEGIN OF lt_vbep_all OCCURS 0,
    vbeln LIKE vbep-vbeln,
    posnr LIKE vbep-posnr,
    etenr LIKE vbep-etenr,
    edatu LIKE vbep-edatu,
  END OF lt_vbep_all,

  ls_vbep_all LIKE LINE OF lt_vbep_all.

  DATA: lv_vbtyp            TYPE vbtyp,
        lv_kalab            TYPE labst,
        lv_cnt(3)           TYPE n,
        lv_cnt_c(3)         TYPE c,
        lv_tot_cnt(3)       TYPE n,
        lv_tot_cnt_c(3)     TYPE c,
        lv_avail(1)         TYPE c,
        wa_out_available(3) TYPE c.

  RANGES: lr_lgort FOR mard-lgort.

* First build table of unique materials and plant materials based on output table
  LOOP AT it_out.
    lt_mara-matnr = it_out-matnr.
    APPEND lt_mara.
    lt_marc-matnr = it_out-matnr.
    lt_marc-werks = it_out-werks.
    APPEND lt_marc.
  ENDLOOP.

  SORT lt_mara BY matnr.
  SORT lt_marc BY matnr werks.

  DELETE ADJACENT DUPLICATES FROM lt_marc COMPARING ALL FIELDS.
  DELETE ADJACENT DUPLICATES FROM lt_mara COMPARING matnr.

* If no materials found in the order lines, leave them all to "not available"
  CHECK:
    NOT lt_mara[] IS INITIAL,
    NOT lt_marc[] IS INITIAL.

* Read EKES for the order items to check if inbound delivery exists
  SELECT ebeln ebelp
         INTO TABLE it_ekes
         FROM ekes
         FOR ALL ENTRIES IN it_out
        WHERE ebeln EQ it_out-ebeln
          AND ebtyp EQ 'LA'.

  SORT it_ekes BY ebeln ebelp.

* Select unrestricted stock
* First add storage location 1000 and '    '
  lr_lgort-sign   = 'I'.
  lr_lgort-option = 'EQ'.
  lr_lgort-low    = '1000'.
  APPEND lr_lgort.
  lr_lgort-sign   = 'I'.
  lr_lgort-option = 'EQ'.
  lr_lgort-low    = '    '.
  APPEND lr_lgort.

* Then get stock
  SELECT matnr werks lgort labst
         INTO TABLE lt_mard
         FROM mard
         FOR ALL ENTRIES IN lt_mara
         WHERE matnr EQ lt_mara-matnr
           AND lgort IN lr_lgort.

* Aggregate the stock to plant level
  LOOP AT lt_mard.
    READ TABLE lt_marc WITH KEY matnr = lt_mard-matnr
                                werks = lt_mard-werks
                       BINARY SEARCH.
    IF sy-subrc EQ 0.
      MOVE-CORRESPONDING lt_mard TO lt_mard_aggr.
      COLLECT lt_mard_aggr.
    ENDIF.
  ENDLOOP.

* If no stock found, leave all items to "not available"
*  CHECK NOT lt_mard_aggr[] IS INITIAL.

* Get all order items with any of the previously selected materials
  SELECT vapma~vbeln vapma~posnr vapma~matnr vapma~werks lgort lprio kwmeng kwmeng AS kwmeng_open
         INTO TABLE lt_vbap_all
         FROM vapma
         JOIN vbap
           ON vapma~vbeln EQ vbap~vbeln
          AND vapma~posnr EQ vbap~posnr
         JOIN vbak
           ON vbap~vbeln EQ vbak~vbeln
         JOIN vbup
           ON vbap~vbeln EQ vbup~vbeln
          AND vbap~posnr EQ vbup~posnr
          FOR ALL entries IN lt_mara
        WHERE vapma~matnr EQ lt_mara-matnr
          AND vbak~vbtyp  = 'C'
          AND vbap~abgru  = '  '
*          AND ( vbup~gbsta = 'A' OR vbup~gbsta = 'B' )   "CR2047
          AND ( vbup~lfsta = 'A' OR vbup~lfsta = 'B' )  "CR2047: switch to Delivery related check
          AND ( vbap~pstyv = 'ZTAN' OR vbap~pstyv = 'ZAS1' ).

* There should always be lines (at least those which were already selected to be output)

* Eliminate records for which no match in LT_MARC (now including WERKS)
*                   or where StLoc conflicts with selection
  LOOP AT lt_vbap_all.
*   Check storage location of the order line
    IF NOT lt_vbap_all-lgort IN lr_lgort.
      DELETE lt_vbap_all.
      CONTINUE.
    ENDIF.

*   Check plant of the order line
    READ TABLE lt_marc WITH KEY matnr = lt_vbap_all-matnr
                                werks = lt_vbap_all-werks
                       BINARY SEARCH.
    IF sy-subrc NE 0.
      DELETE lt_vbap_all.
    ENDIF.
  ENDLOOP.

* Get schedule lines for the remaining orders
  IF NOT lt_vbap_all[] IS INITIAL.
    SELECT vbeln posnr etenr edatu
      INTO TABLE lt_vbep_all
      FROM vbep
      FOR ALL ENTRIES IN lt_vbap_all
      WHERE vbeln = lt_vbap_all-vbeln.

*.. Eliminate schedule lines which are not the first ones for a specific item
*.. <! - which are not according to req. del date from selection screen >
    SORT lt_vbep_all BY vbeln posnr etenr.

    DELETE ADJACENT DUPLICATES FROM lt_vbep_all
                               COMPARING vbeln posnr.
  ENDIF.

* Add requested delivery date to LT_VBAP_ALL
  LOOP AT lt_vbap_all.
    READ TABLE lt_vbep_all WITH KEY vbeln = lt_vbap_all-vbeln
                                    posnr = lt_vbap_all-posnr
                          BINARY SEARCH.
    IF sy-subrc EQ 0.
      lt_vbap_all-edatu = lt_vbep_all-edatu.
      MODIFY lt_vbap_all.
    ELSE.
      DELETE lt_vbap_all.
    ENDIF.
  ENDLOOP.
*Begin of comment MOD-002
** Read VBFA for the order items to find delivered qty's
*  IF NOT lt_vbap_all[] IS INITIAL.
*    SELECT vbelv posnv vbeln posnn vbtyp_n
*           INTO TABLE lt_vbfa
*           FROM vbfa
*            FOR ALL ENTRIES IN lt_vbap_all
*          WHERE vbelv   EQ lt_vbap_all-vbeln
*            AND posnv   EQ lt_vbap_all-posnr
*            AND vbtyp_n EQ 'J'.
*  ENDIF.
*
** Document flow table can be empty, processing needs to continue (i.e. determine the
** orders which can be delivered)
*  IF NOT lt_vbfa[] IS INITIAL.
**   Get delivered quantities and delivery status for doc flow entries
*    SELECT lips~vbeln posnr lfimg vbuk~wbstk
*           INTO TABLE lt_lips
*           FROM lips
*           JOIN vbuk
*             ON vbuk~vbeln EQ lips~vbeln
*            FOR ALL entries IN lt_vbfa
*          WHERE lips~vbeln EQ lt_vbfa-vbeln
*            AND lips~posnr EQ lt_vbfa-posnn.
*  ENDIF.
*End of comment MOD-002
  SORT:
    lt_vbfa     BY vbeln posnn,
    lt_vbap_all BY vbeln posnr.

*Begin of insert MOD-002
*Get out bound deliveries from LIPS table for all Materials
  REFRESH: lt_lips.
  SELECT lips~matnr
         lips~werks
         lips~vbeln
         lips~posnr
         lips~vgbel
         lips~lfimg
         vbuk~wbstk
  INTO   TABLE lt_lips
  FROM   lips
  INNER  JOIN vbuk
  ON     lips~vbeln EQ vbuk~vbeln
  FOR    ALL entries IN lt_marc
  WHERE  lips~matnr EQ lt_marc-matnr
  AND    lips~werks EQ lt_marc-werks
  AND    lips~vgtyp EQ 'C'
  AND    vbuk~wbstk EQ 'A'.

  REFRESH:lt_outdel.
  LOOP AT lt_lips.
    MOVE-CORRESPONDING lt_lips TO lt_outdel.
    COLLECT lt_outdel.
  ENDLOOP.

*Subtract outbound delivery stoc from total Material Stock
  LOOP AT lt_mard_aggr.
    READ TABLE lt_outdel WITH KEY matnr = lt_mard_aggr-matnr
                                  werks = lt_mard_aggr-werks.
    IF sy-subrc EQ 0.
      lt_mard_aggr-labst = lt_mard_aggr-labst - lt_outdel-lfimg.
      MODIFY lt_mard_aggr.
    ENDIF.
  ENDLOOP.

*Subtract SO outbound delivery from SO stock,if the SO has outbound delivery
  LOOP AT lt_vbap_all.
    LOOP AT lt_lips WHERE vgbel = lt_vbap_all-vbeln.
      lt_vbap_all-kwmeng_open = lt_vbap_all-kwmeng_open - lt_lips-lfimg.
      MODIFY lt_vbap_all.
    ENDLOOP.
  ENDLOOP.
*End of insert MOD-002

*Begin of comment MOD-002
** Subtract delivered qty's from the order items' open qty's
*  LOOP AT lt_lips.
**   Don't consider the qty if the dlvry doc's "Total Goods Mvt Stat" = C ~ Completely processed
*    CHECK lt_lips-wbstk = 'C'.
**   Get preceding order item number
*    READ TABLE lt_vbfa WITH KEY vbeln = lt_lips-vbeln
*                                posnn = lt_lips-posnr
*                       BINARY SEARCH.
**   When found
*    IF sy-subrc EQ 0.
**     Get the order line
*      READ TABLE lt_vbap_all WITH KEY vbeln = lt_vbfa-vbelv
*                                      posnr = lt_vbfa-posnv
*                             BINARY SEARCH.
**     When found
*      IF sy-subrc EQ 0.
*        lt_vbap_all-kwmeng_open = lt_vbap_all-kwmeng_open - lt_lips-lfimg.
*        MODIFY lt_vbap_all INDEX sy-tabix.
*      ENDIF.
*
*    ENDIF.
*
*  ENDLOOP.
*End of comment MOD-002

  IF rb_psort = 'X'.   " delivery priority
    SORT lt_vbap_all BY matnr werks lprio edatu vbeln posnr.
  ELSE.                " requested delivery date
    SORT lt_vbap_all BY matnr werks edatu lprio vbeln posnr.
  ENDIF.

* Subtract open order qty's from stock and set avly flag appropriately for each order line
  LOOP AT lt_vbap_all.

*   If item is fully delivered
    IF lt_vbap_all-kwmeng_open LE 0.
*     It should be marked available
      lt_vbap_all-available = '1'.
    ELSE.
*     Get the stock
      READ TABLE lt_mard_aggr WITH KEY matnr = lt_vbap_all-matnr
                                       werks = lt_vbap_all-werks
                            BINARY SEARCH.
*     When stock found
      IF sy-subrc EQ 0.
*       If stock is enough for current order item
        IF lt_mard_aggr-labst GE lt_vbap_all-kwmeng_open.
          lt_vbap_all-available = '1'.

*         Subtract order open qty from stock
          lt_mard_aggr-labst = lt_mard_aggr-labst - lt_vbap_all-kwmeng_open.
        ELSE.
*         Leave available mark empty
        ENDIF.
        MODIFY lt_mard_aggr INDEX sy-tabix.
*     When stock NOT found
      ELSE.
*       Leave available mark empty
      ENDIF.
    ENDIF.
    MODIFY lt_vbap_all.
  ENDLOOP.

  SORT lt_vbap_all BY vbeln posnr.

* Update the lines being output with appropriate available mark
  LOOP AT it_out.
    IF it_out-dtc_sfs = 'SFS'.
*.... Get the corresponding line in LT_VBAP_ALL
      READ TABLE lt_vbap_all WITH KEY vbeln = it_out-vbeln
                                      posnr = it_out-posnr
                             BINARY SEARCH.
      IF sy-subrc EQ 0.
        IF lt_vbap_all-available IS INITIAL.
          it_out-available = 'N'.
        ELSE.
          it_out-available = 'Y'.
        ENDIF.
      ELSE.
        it_out-available = 'N'.
      ENDIF.
    ELSE.
*.... Check ordered quantity with sales order stock
      CLEAR lv_kalab.
      SELECT SUM( kalab )
         FROM mska
         INTO lv_kalab
         WHERE vbeln = it_out-vbeln
           AND posnr = it_out-posnr.

      IF sy-subrc EQ 0 AND lv_kalab > 0.
        IF lv_kalab <> it_out-kwmeng.
*........ Check if inbound delivery exists
          READ TABLE it_vbfa WITH KEY vbelv = it_out-vbeln
                                      posnv = it_out-posnr
                             BINARY SEARCH.
          IF sy-subrc = 0.
            READ TABLE it_ekes WITH KEY ebeln = it_vbfa-vbeln
                                        ebelp = it_vbfa-posnn
                               BINARY SEARCH.
            IF sy-subrc = 0.
              it_out-available = 'GIT'.
            ELSE.
              it_out-available = 'N'.
            ENDIF.
          ELSE.
            it_out-available = 'N'.
          ENDIF.
        ELSE.
          it_out-available = 'Y'.
        ENDIF.
      ELSE.
*...... Check if inbound delivery exists
        READ TABLE it_vbfa WITH KEY vbelv = it_out-vbeln
                                    posnv = it_out-posnr
                           BINARY SEARCH.

        IF sy-subrc = 0.
          READ TABLE it_ekes WITH KEY ebeln = it_vbfa-vbeln
                                      ebelp = it_vbfa-posnn
                             BINARY SEARCH.
          IF sy-subrc = 0.
            it_out-available = 'GIT'.
          ELSE.
            it_out-available = 'N'.
          ENDIF.
        ELSE.
          it_out-available = 'N'.
        ENDIF.
      ENDIF.
      it_out-kalab = lv_kalab.                                  " Insert MOD-008
    ENDIF.
    MODIFY it_out.
  ENDLOOP.

  SORT it_out BY vbeln posnr.

* Update the lines being output with appropriate 'all_available'
* and 'available vs total lines'
* But, do not show the values for these fields when there was
* a selection made for PGC or material number
  IF so_pgc IS INITIAL AND so_matnr IS INITIAL.
    REFRESH it_save.

    LOOP AT it_out.
      wa_out_available = it_out-available.

      AT NEW vbeln.
        lv_avail = 'X'.
        lv_cnt = 0.
        lv_tot_cnt = 0.
      ENDAT.

      ADD 1 TO lv_tot_cnt.
      IF wa_out_available = 'N' OR wa_out_available = 'GIT'.
        CLEAR lv_avail.
      ELSE.
        ADD 1 TO lv_cnt.
      ENDIF.

      AT END OF vbeln.
        WRITE lv_cnt TO lv_cnt_c NO-ZERO.
        IF lv_cnt_c IS INITIAL.
          lv_cnt_c = '  0'.
        ENDIF.
        WRITE lv_tot_cnt TO lv_tot_cnt_c NO-ZERO.
        SHIFT lv_cnt_c LEFT DELETING LEADING ' '.
        SHIFT lv_tot_cnt_c LEFT DELETING LEADING ' '.

        CONCATENATE lv_cnt_c '/' lv_tot_cnt_c INTO it_save-avail_vs_totlin.

        IF lv_avail = 'X'.
          it_save-all_available = 'Y'.
        ELSE.
          it_save-all_available = 'N'.
        ENDIF.
        it_save-vbeln = it_out-vbeln.
        COLLECT it_save.
      ENDAT.
    ENDLOOP.

    LOOP AT it_out.
      READ TABLE it_save WITH KEY vbeln = it_out-vbeln
                        BINARY SEARCH.
      IF sy-subrc = 0.
        it_out-all_available = it_save-all_available.
        it_out-avail_vs_totlin = it_save-avail_vs_totlin.
        MODIFY it_out TRANSPORTING all_available avail_vs_totlin.
      ENDIF.
    ENDLOOP.
  ENDIF.

* In case the selection of 'All available only' is checked, only the sales orders
* for which all lines available are shown
  IF cb_avail = 'X'.
    LOOP AT it_out.
      IF it_out-all_available = 'N'.
        DELETE it_out.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                    " DETERMINE_AVL
*&---------------------------------------------------------------------*
*&      Form  ADD_COLUMN
*&---------------------------------------------------------------------*
*       Adding new columns to the final internal table.
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM add_column .
*  Begin of MOD-007
* Adding up of Open Qty and Scheduled Quantity to the final output table
  TYPES: BEGIN OF ty_lips_new,
            vbeln	TYPE vbeln_vl,    " Delivery
            posnr	TYPE posnr_vl,    " Delivery Item
            matnr	TYPE matnr,       "	Material Number
            lfimg	TYPE lfimg,       "	Actual quantity delivered (in sales units)
            meins	TYPE meins,	      " Base Unit of Measure
            vgbel	TYPE vgbel,       " Document number of the reference document
            vgpos	TYPE vgpos,       " Item number of the reference item
          END OF ty_lips_new.
  TYPES:  BEGIN OF ty_vbep_new,
            vbeln TYPE vbeln_va,    "	Sales Document
            posnr	TYPE posnr_va,    "	Sales Document Item
            etenr	TYPE etenr,       "	Delivery Schedule Line Number
            bmeng	TYPE bmeng,       " Confirmed Quantity
          END OF ty_vbep_new.
  DATA: it_lips_new TYPE STANDARD TABLE OF ty_lips_new,
        wa_lips_new TYPE ty_lips_new,
        it_vbep_new TYPE STANDARD TABLE OF ty_vbep_new,
        wa_vbep_new TYPE ty_vbep_new.
  DATA: flag TYPE lfimg,
        flag1 TYPE bmeng.
  IF it_out[] IS NOT INITIAL.
    SELECT
      vbeln posnr matnr lfimg meins vgbel vgpos
      FROM lips INTO TABLE it_lips_new
      FOR ALL ENTRIES IN it_out
      WHERE vgbel = it_out-vbeln
      AND   vgpos = it_out-posnr.
    SELECT
      vbeln posnr etenr bmeng
      FROM vbep INTO TABLE it_vbep_new
      FOR ALL ENTRIES IN it_out
      WHERE vbeln = it_out-vbeln
      AND   posnr = it_out-posnr.

    LOOP AT it_out.
      CLEAR: wa_lips_new, wa_vbep_new, it_out-open_qty, it_out-schd_qty, flag, flag1.
      LOOP AT it_lips_new INTO wa_lips_new WHERE vgbel = it_out-vbeln AND vgpos = it_out-posnr.
        flag  = flag  + wa_lips_new-lfimg.
        CLEAR wa_lips_new.
      ENDLOOP.
      LOOP AT it_vbep_new INTO wa_vbep_new WHERE vbeln = it_out-vbeln AND posnr = it_out-posnr.
        flag1 = flag1 + wa_vbep_new-bmeng.
        CLEAR wa_vbep_new.
      ENDLOOP.
      it_out-open_qty = ( it_out-kwmeng - flag ).
      it_out-schd_qty = ( flag1 - flag ).
      MODIFY it_out.
    ENDLOOP.
  ENDIF.
*  End of MOD-007
ENDFORM.                    " ADD_COLUMN
*&---------------------------------------------------------------------*
*&      Form  ADD_COLUMN_2
*&---------------------------------------------------------------------*
*       For adding new columns to the final table CR3439
*----------------------------------------------------------------------*
FORM add_column_2 .
  TYPES:  BEGIN OF ty_out_ekpo,
            ebeln TYPE ekpo-ebeln,
            ebelp TYPE ekpo-ebelp,
          END OF ty_out_ekpo,
          BEGIN OF ty_cdpos_index,
            objectclas TYPE cdpos-objectclas,
            objectid   TYPE cdpos-objectid,
            tabname    TYPE cdpos-tabname,
            tabkey     TYPE cdpos-tabkey,
            fname      TYPE cdpos-fname,
          END OF ty_cdpos_index.
  DATA: lt_out_ekpo TYPE STANDARD TABLE OF ty_out_ekpo,
        ls_out_ekpo TYPE ty_out_ekpo,
        lv_ebelp    TYPE ekpo-ebelp,
        lt_cdpos_index TYPE STANDARD TABLE OF ty_cdpos_index,
        ls_cdpos_index TYPE ty_cdpos_index,
        lt_vbup     TYPE STANDARD TABLE OF vbup,
        ls_vbup     TYPE vbup,
        lt_cdpos    TYPE STANDARD TABLE OF cdpos,
        ls_cdpos    TYPE STANDARD TABLE OF cdpos,
        lt_lips     TYPE STANDARD TABLE OF lips,
        ls_lips     TYPE lips,
        lt_vbep     LIKE TABLE OF it_vbep,
        ls_vbep     LIKE LINE OF it_vbep,
        lt_ekes     TYPE STANDARD TABLE OF ekes,
        lt_vbfa     TYPE STANDARD TABLE OF vbfa,
        lv_qty_a    TYPE vbfa-rfmng,
        lv_qty_b    TYPE vbfa-rfmng,
        lv_qty_c    TYPE vbfa-rfmng,
        lv_lfimg    TYPE lips-lfimg,
        ls_vbfa     TYPE vbfa,
        ls_ekes     TYPE ekes,
        lflag_a     TYPE char1,
        lflag_b     TYPE char1,
        lflag_c     TYPE char1.
  DATA: flag TYPE lfimg,
        flag1 TYPE bmeng.
  IF it_out[] IS NOT INITIAL.
    SELECT vbeln posnr etenr ettyp edatu wadat
      INTO TABLE lt_vbep
      FROM vbep
      FOR ALL ENTRIES IN it_out[]
      WHERE vbeln = it_out-vbeln
        AND posnr = it_out-posnr.
*        AND etenr EQ c_001.
    LOOP AT it_out.
      ls_out_ekpo-ebeln = it_out-ebeln.
      ls_out_ekpo-ebelp = it_out-posnn.
      APPEND ls_out_ekpo TO lt_out_ekpo.

      LOOP at lt_vbep INTO ls_vbep
                  WHERE  vbeln = it_out-vbeln
                    AND  posnr = it_out-posnr.
        ls_cdpos_index-objectclas = 'VERKBELEG'.
        ls_cdpos_index-objectid   =  it_out-vbeln.
        ls_cdpos_index-tabname    =  'VBEP'.
        CONCATENATE sy-mandt it_out-vbeln it_out-posnr ls_vbep-etenr
          INTO ls_cdpos_index-tabkey.
        ls_cdpos_index-fname      = 'EDATU'.
        APPEND ls_cdpos_index TO lt_cdpos_index.
      ENDLOOP.
    ENDLOOP.
    DELETE ADJACENT DUPLICATES FROM lt_out_ekpo.
    SELECT *
      FROM ekes
      INTO TABLE lt_ekes
      FOR ALL ENTRIES IN lt_out_ekpo
      WHERE ebeln = lt_out_ekpo-ebeln
        AND ebelp = lt_out_ekpo-ebelp
        AND ebtyp = 'LA'.
    IF lt_ekes IS NOT INITIAL.
      SELECT *
        FROM vbup
        INTO TABLE lt_vbup
        FOR ALL ENTRIES IN lt_ekes
        WHERE vbeln = lt_ekes-vbeln
          AND posnr = lt_ekes-vbelp.
      SELECT *
        FROM vbfa
        INTO TABLE lt_vbfa
        FOR ALL ENTRIES IN lt_ekes
        WHERE vbelv = lt_ekes-vbeln
          AND posnv = lt_ekes-vbelp
          AND vbtyp_n = 'R'.
      SELECT *
        FROM lips
        INTO TABLE lt_lips
        FOR ALL ENTRIES IN lt_ekes
        WHERE vbeln = lt_ekes-vbeln
          AND posnr = lt_ekes-vbelp.
    ENDIF.

    IF lt_cdpos_index IS NOT INITIAL.
      SELECT *
        FROM cdpos
        INTO TABLE lt_cdpos
        FOR ALL ENTRIES IN lt_cdpos_index
        WHERE objectclas = lt_cdpos_index-objectclas
          AND objectid   = lt_cdpos_index-objectid
          AND tabname    = lt_cdpos_index-tabname
          AND tabkey     = lt_cdpos_index-tabkey
          AND fname      = lt_cdpos_index-fname.
    ENDIF.

    LOOP AT it_out.
      CLEAR: lflag_a, lflag_b,lflag_c,
             lv_qty_a, lv_qty_b,lv_qty_c,lv_lfimg,ls_cdpos_index.
      lv_ebelp = it_out-posnn.
      IF    it_out-dtc_sfs = 'DTC'
        AND it_out-ebeln IS NOT INITIAL.
        LOOP AT lt_ekes INTO ls_ekes
            WHERE ebeln = it_out-ebeln
              AND ebelp = lv_ebelp.
          READ TABLE lt_vbup TRANSPORTING NO FIELDS
            WITH KEY vbeln = ls_ekes-vbeln
                     posnr = ls_ekes-vbelp
                     wbsta = 'A'.
          IF sy-subrc = 0.
            lflag_a = 'X'.
            CLEAR: ls_lips.
            READ TABLE lt_lips INTO ls_lips
              WITH KEY  vbeln = ls_ekes-vbeln
                        posnr = ls_ekes-vbelp.
            IF sy-subrc = 0.
              lv_qty_a = lv_qty_a + ls_lips-lfimg.
            ENDIF.
          ENDIF.
          READ TABLE lt_vbup TRANSPORTING NO FIELDS
            WITH KEY vbeln = ls_ekes-vbeln
                     posnr = ls_ekes-vbelp
                     wbsta = 'B'.
          IF sy-subrc = 0.
            lflag_b = 'X'.
            CLEAR: ls_lips.
            READ TABLE lt_lips INTO ls_lips
              WITH KEY  vbeln = ls_ekes-vbeln
                        posnr = ls_ekes-vbelp.
            IF sy-subrc = 0.
              lv_qty_b = lv_qty_b + ls_lips-lfimg.
            ENDIF.

          ENDIF.
          READ TABLE lt_vbup TRANSPORTING NO FIELDS
            WITH KEY vbeln = ls_ekes-vbeln
                     posnr = ls_ekes-vbelp
                     wbsta = 'C'.
          IF sy-subrc = 0.
            lflag_c = 'X'.
            CLEAR: ls_vbfa.
            READ TABLE lt_lips INTO ls_lips
              WITH KEY  vbeln = ls_ekes-vbeln
                        posnr = ls_ekes-vbelp.
            IF sy-subrc = 0.
              lv_qty_c = lv_qty_c + ls_lips-lfimg.
            ENDIF.
          ENDIF.
          CLEAR: ls_lips.
          READ TABLE lt_lips INTO ls_lips
            WITH KEY  vbeln = ls_ekes-vbeln
                      posnr = ls_ekes-vbelp.
          IF sy-subrc = 0.
            lv_lfimg = ls_lips-lfimg + lv_lfimg.
          ENDIF.
        ENDLOOP.
        IF lflag_b IS INITIAL AND  lflag_a = 'X' AND lflag_c IS INITIAL.
          it_out-git_qty = lv_lfimg.
        ELSEIF lflag_b IS INITIAL AND  lflag_a = 'X' AND lflag_c = 'X'.
          it_out-git_qty = lv_qty_a.
        ELSEIF lflag_b = 'X' AND  lflag_a IS INITIAL.
          it_out-git_qty = lv_lfimg.
        ELSEIF lflag_b = 'X' AND  lflag_a = 'X' AND lflag_c IS INITIAL.
          it_out-git_qty = lv_qty_a + lv_qty_b.
        ENDIF.
      ENDIF.
      it_out-chg_date = 'N'.
      LOOP AT lt_vbep INTO ls_vbep
                      WHERE vbeln = it_out-vbeln
                        AND posnr = it_out-posnr.
        ls_cdpos_index-objectid   =  it_out-vbeln.
        CONCATENATE sy-mandt it_out-vbeln it_out-posnr ls_vbep-etenr
          INTO ls_cdpos_index-tabkey.
        READ TABLE lt_cdpos TRANSPORTING NO FIELDS
          WITH KEY objectid = ls_cdpos_index-objectid
                   tabkey   = ls_cdpos_index-tabkey
                   chngind  = 'U'.
        IF sy-subrc = 0.
          it_out-chg_date = 'Y'.
        ENDIF.
      ENDLOOP.
      MODIFY it_out.
    ENDLOOP.
  ENDIF.
ENDFORM.                    " ADD_COLUMN_2
