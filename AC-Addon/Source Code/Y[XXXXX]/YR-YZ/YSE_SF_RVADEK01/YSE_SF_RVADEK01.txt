**********************************************************************

* Program ID        : YSE_SF_RVADEK01                                 *
* Project           : YSE_PO                                          *
* Author            : Pieter Jespers                                  *
* Date              : 29/02/2007                                      *
* Functional spec   : SEED   D058-Smartforms SDMM Picking list        *
* Printprogram for smartform YSE_SF_RVADEK01
**********************************************************************
*----------------------------------------------------------------------------*
* MOD.NR. | DATE       | NAME               | CORRECTION NR. | CHANGE REF. # *
*----------------------------------------------------------------------------*
* MOD-001 | 11.11.2016 | Dashmantha         | CD1K990096     | CR3825        *
* Call new smartform for dangerous goods for CN06                           *
*----------------------------------------------------------------------------*
* MOD-001 CR3825
*----------------------------------------------------------------------*
* Print of pickinglist for one single delivery note with Smart Form
*----------------------------------------------------------------------*
REPORT /bpr3pf/rvadek01 LINE-COUNT 100 MESSAGE-ID vn.

types: begin of t_lips,
  vbeln like lips-vbeln,
  posnr like lips-posnr,
  pstyv like lips-pstyv,
  matnr like lips-matnr,
  arktx like lips-arktx,
  lgpbe like lips-lgpbe,
  vtweg LIKE lips-vtweg,
  sernr like objk-sernr,
  lfimg like lips-lfimg,
  vrkme like lips-vrkme,
  vbelv LIKE lips-vbelv,
  vgbel LIKE lips-vgbel,
  vgpos like lips-vgpos,
  werks LIKE lips-werks,
  lgort LIKE lips-lgort,
  aufnr like lips-aufnr,
  posnr_char like lips-posnr,
  flow(7) type c,
  caseorbin(17) type c.
types: end of t_lips.

TABLES: vbco3,                         "Communicationarea for view
        vblkk,                         "Headerview
        vblkp,                         "Itemview
        ltak,                          "Transportauftrag
        adrs,                          "Communicationarea for Address
        riserls,                       "Serialnumbers
        komser,                        "Communicationarea Serialnumbers
        tvst, tvstt,                   "Shipping point
        vbkok, vbpok.

TABLES: nast,                          "Messages
        *nast,                         "Messages
        tnapr,                         "Programs & Forms
        itcpo,                         "Communicationarea for Spool
        arc_params,                    "Archive parameters
        toa_dara,                      "Archive parameters
        addr_key.                      "Adressnumber for ADDRESS

TYPE-POOLS szadr.

* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

DATA: retcode     LIKE sy-subrc,       "Returncode
      xvbeln      LIKE likp-vbeln,
      xkomau      LIKE likp-vbeln,
      xscreen(1)  TYPE c.              "Output on printer or screen

DATA: BEGIN OF tvblkp OCCURS 0.        "Internal table for items
        INCLUDE STRUCTURE vblkp.
DATA: END OF tvblkp.

DATA: BEGIN OF tsernr OCCURS 0.        "Internal table for serialnumbers
        INCLUDE STRUCTURE riserls.
DATA: END OF tsernr.

DATA: BEGIN OF tsernr_print OCCURS 0.
        INCLUDE STRUCTURE komser.
DATA: END   OF tsernr_print.

DATA:  BEGIN OF tltap OCCURS 50.       "TA-Positionen
        INCLUDE STRUCTURE ltap.
        INCLUDE STRUCTURE ltap1.
DATA:  END OF tltap.

DATA: BEGIN OF svblkp.
        INCLUDE STRUCTURE vblkp.
DATA: END OF svblkp.
DATA: ls_ebeln TYPE ebeln,
      ls_sobkz TYPE sobkz,
      ls_aufnr TYPE aufnr,
      wa_likp LIKE likp.
DATA: it_lips TYPE TABLE OF lips,
      wa_lips TYPE lips,
      l_name_soldto TYPE ad_name1.
DATA: it_outtab3 TYPE TABLE OF t_lips.

* IMP RU Begin of insert
DATA: BEGIN OF gt_messtab OCCURS 0,
   tcode TYPE bdc_tcode,
   dyname TYPE bdc_module,
   dynumb TYPE bdc_dynnr,
   msgtyp TYPE bdc_mart,
   msgspra TYPE bdc_spras,
   msgid TYPE bdc_mid,
   msgnr TYPE bdc_mnr,
   msgv1 TYPE bdc_vtext1,
   msgv2 TYPE bdc_vtext1,
   msgv3 TYPE bdc_vtext1,
   msgv4 TYPE bdc_vtext1,
   env TYPE   bdc_akt,
   fldname TYPE fnam_____4,
   vbeln TYPE LIPS-vbeln,
   posnr TYPE LIPS-posnr,
 END OF gt_messtab.

DATA: lv_mode VALUE 'N'.
DATA: gt_msgtab TYPE TABLE OF bdcmsgcoll WITH HEADER LINE.

DATA : i_bdcdata LIKE bdcdata OCCURS 0 WITH HEADER LINE,
      struct_bdcdata TYPE bdcdata.

CONSTANTS c_trans VALUE 'VL02N'.
* IMP RU End of insert
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

INCLUDE yse_vblpdata.
*include vblpdata.
INCLUDE yse_vbfadata.
*include vbfadata.
INCLUDE yse_vbukdata.
*include vbukdata.
INCLUDE yse_vbupdata.
*include vbupdata.
INCLUDE yse_vbbddata.
*include vbbddata.
INCLUDE yse_vbpadata.
*include vbpadata.
INCLUDE yse_sadrdata.
*include sadrdata.
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

*---------------------------------------------------------------------*
*       FORM ENTRY                                                    *
*---------------------------------------------------------------------*
*       Steuerung des Drucks                                          *
*---------------------------------------------------------------------*
FORM entry USING return_code us_screen.

  CLEAR retcode.
  xscreen = us_screen.

  PERFORM processing USING us_screen.
  IF retcode NE 0.
    return_code = 1.
  ELSE.
* Kommimengen an Lieferungen zur¨¹ckgeben, aber nicht bei Druckansicht
    IF xscreen = ' '.
      PERFORM delivery_update.
    ENDIF.
    return_code = 0.
  ENDIF.

ENDFORM.                    "entry

*---------------------------------------------------------------------*
*       FORM PROCESSING                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  PROC_SCREEN                                                   *
*---------------------------------------------------------------------*
FORM processing USING proc_screen.

  REFRESH: xlips,
           xvbfa,
           xvbuk,
           xvbup,
           yvbfa,
           yvbuk,
           yvbup.

  PERFORM get_data.
  CHECK retcode = 0.
  PERFORM get_comm USING proc_screen tvst-aland.
  CHECK retcode = 0.
  PERFORM user_exit1.
  PERFORM smartform_print.
  CHECK retcode = 0.


ENDFORM.                    "processing

***********************************************************************
*       S U B R O U T I N E S                                         *
***********************************************************************

*---------------------------------------------------------------------*
*       FORM DELIVERY_UPDATE                                          *
*---------------------------------------------------------------------*
*       Erg#nzen Lieferung um Kommissionierinformation                *
*---------------------------------------------------------------------*

* Erg#nzen der Lieferungen um Kommissionierinformation
FORM delivery_update.

  DATA: BEGIN OF hvbpok OCCURS 10.     "Lieferpositionen Kommiss.
          INCLUDE STRUCTURE vbpok.
  DATA: END OF hvbpok.

  DATA: BEGIN OF sav_nast.
          INCLUDE STRUCTURE nast.
  DATA: END OF sav_nast.

* DATA: SYNC_FLAG TYPE C.             "synchrone Verbuchung?


*>>>AIR22296 only change the loading point 20/02
  PERFORM update_lstel.
*<<<AIR22296


* F¨¹llen Lieferkopfdaten f¨¹r Kommi-Update
  vbkok-vbeln_vl = xvbeln.
  vbkok-vbeln = vblkk-komau.

* F¨¹llen Positionsdaten zu Liefernr.
  LOOP AT tvblkp.
    hvbpok-vbeln_vl = tvblkp-vbeln.
    hvbpok-posnr_vl = tvblkp-posnr.
    hvbpok-posnn = tvblkp-posnr.
    hvbpok-vbeln = vblkk-komau.
    hvbpok-vbtyp_n = 'Q'.
    hvbpok-pikmg = tvblkp-komng.
    hvbpok-meins = tvblkp-meins.
    hvbpok-ndifm = 0.
    hvbpok-taqui = ' '.
    hvbpok-charg = tvblkp-charg.
    hvbpok-matnr = tvblkp-matnr.
    hvbpok-brgew = tvblkp-brgew.
    hvbpok-gewei = tvblkp-gewei.
    hvbpok-volum = tvblkp-volum.
    hvbpok-voleh = tvblkp-voleh.
    hvbpok-orpos = 0.
    APPEND hvbpok.
  ENDLOOP.

* IF NAST-VSZTP <> 4.
*    SYNC_FLAG = 'X'.
* ELSE.
*    SYNC_FLAG = ' '.
* ENDIF.

  sav_nast = nast.
  CALL FUNCTION 'SD_DELIVERY_UPDATE_PICKING'
    EXPORTING
      synchron =  ' '
*{   REPLACE        CD2K940300                                        1
*\      nicht_sperren = 'X'
      nicht_sperren = 'Y'
*}   REPLACE
      vbkok_wa      = vbkok
      aufrufer_t    = 'X'
    TABLES
      vbpok_tab     = hvbpok.

  nast = sav_nast.

* IMP RU Begin of insert
* BDC update pick flag PIKMG
*
*
*  PERFORM bdc_filldata.
*  REFRESH gt_msgtab.
*  call transaction c_trans using i_bdcdata MODE lv_mode
*  MESSAGES INTO gt_msgtab.
*  IF sy-subrc NE 0.
*    LOOP AT gt_msgtab.
*      MOVE-CORRESPONDING gt_msgtab TO gt_messtab.
*      MOVE hvbpok-vbeln_vl TO gt_messtab-vbeln.
*      MOVE hvbpok-posnr_vl TO gt_messtab-posnr.
*      APPEND gt_messtab.
*      CLEAR gt_messtab.
*    ENDLOOP.
*  ENDIF.

* IMP RU End of insert

* IMP RU Begin of insert
* Freigabe an Datenbank
* COMMIT WORK.
* IMP RU End of insert






ENDFORM.                    "delivery_update

* IMP RU Begin of insert
*FORM bdc_filldata.
** first screen - fill in outbound delivery number
*  PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                     USING: 'SAPMV50A' '0100' 'X' ' ' ' '
*                     CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
*
*   PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                      USING: '' '' '' 'BDC_CURSOR' tvblkp-VBELN
*                      CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
*
*  PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                      USING: '' '' '' 'BDC_OKCODE' '/00'
*                      CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
*



* loop per outbound delivery line
*LOOP at tvblkp.
*  PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                     USING: 'SAPMV50A' '1000' 'X' ' ' ' '
*                     CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
*
*   PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                      USING: '' '' '' 'BDC_CURSOR' 'RV50A-CHMULT(teller)'
*                      CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
*
*  PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                      USING: '' '' '' 'BDC_OKCODE' '=CHPL_T01'
*                      CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
*
*  PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                      USING: '' '' '' 'BKPF-BELNR' wa_selec-BELNR
*                      CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
*
*  PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                      USING: '' '' '' 'BKPF-BUKRS' wa_selec-BUKRS
*                      CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
*
*  PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                      USING: '' '' '' 'BKPF-GJAHR' wa_selec-GJAHR
*                      CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
*
*  PERFORM fill_bdcdata IN PROGRAM yam_common_routines
*                      USING: '' '' '' 'RF05A-CPSTO' 'X'
*                      CHANGING struct_bdcdata.
*
*  APPEND struct_bdcdata TO i_bdcdata.
*  CLEAR  struct_bdcdata.
* endloop.

*ENDFORM.

* IMP RU End of insert

*---------------------------------------------------------------------*
*       FORM get_comm                                               *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*  -->  US_SCREEN  Output on screen                                   *
*                  ' ' = printer                                      *
*                  'X' = screen                                       *
*  -->  US_COUNTRY County for telecommunication and SET COUNTRY       *
*---------------------------------------------------------------------*

FORM get_comm USING us_screen us_country.
  DATA: lvs_itcpo         TYPE   itcpo,
        lvf_device(30)    TYPE   c,
        lvf_dialog(1)     TYPE   c   VALUE ' ',
        lvs_recipient     LIKE   swotobjid,
        lvs_sender        LIKE   swotobjid,
        lvs_snast         TYPE   snast,
        lvf_program       LIKE   sy-repid,
        lvs_comm_type     TYPE   ad_comm,
        lvs_comm_values   TYPE   szadr_comm_values.


* reset return code
  retcode = 0.


* if there is a communication strategy used ...
  IF NOT nast-tcode IS INITIAL.

*   ... use stratagy to get communication type
    CALL FUNCTION 'ADDR_GET_NEXT_COMM_TYPE'
         EXPORTING
              strategy           = nast-tcode
*             ADDRESS_TYPE       =
*             ADDRESS_NUMBER     = VBDKA-ADRNR
*             PERSON_NUMBER      = VBDKA-ADRNP
              address_number     = addr_key-addrnumber
              person_number      = addr_key-persnumber
         IMPORTING
              comm_type          = lvs_comm_type
              comm_values        = lvs_comm_values
*        TABLES
*             STRATEGY_TABLE     =
         EXCEPTIONS
              address_not_exist  = 1
              person_not_exist   = 2
              no_comm_type_found = 3
              internal_error     = 4
              parameter_error    = 5
              OTHERS             = 6.
    IF sy-subrc <> 0.
      retcode = sy-subrc.
      syst-msgty = 'E'.
      PERFORM protocol_update.
    ENDIF.

  ENDIF.


* convert communication data
  MOVE-CORRESPONDING nast TO lvs_snast.
  MOVE sy-repid           TO lvf_program.
  CALL FUNCTION 'CONVERT_COMM_TYPE_DATA'
       EXPORTING
            pi_comm_type              = lvs_comm_type
            pi_comm_values            = lvs_comm_values
            pi_screen                 = us_screen
*           PI_NEWID                  =
            pi_country                = us_country
            pi_repid                  = lvf_program
            pi_snast                  = lvs_snast
       IMPORTING
            pe_itcpo                  = lvs_itcpo
            pe_device                 = lvf_device
            pe_mail_recipient         = lvs_recipient
            pe_mail_sender            = lvs_sender
       EXCEPTIONS
            comm_type_not_supported   = 1
            recipient_creation_failed = 2
            sender_creation_failed    = 3
            OTHERS                    = 4.
  IF sy-subrc <> 0.
    retcode = sy-subrc.
    syst-msgty = 'E'.
    PERFORM protocol_update.
  ENDIF.

  CHECK retcode EQ 0.

* if there is no communication type
  IF  lvs_comm_type IS INITIAL.
*   set device
    CASE nast-nacha.
      WHEN '1'.
        lvf_device = 'PRINTER'.
      WHEN '2'.
        lvf_device = 'TELEFAX'.
        lvs_itcpo-tdtelenum = nast-telfx.
        IF nast-tland IS INITIAL.
          lvs_itcpo-tdteleland = us_country.
        ELSE.
          lvs_itcpo-tdteleland = nast-tland.
        ENDIF.
        lvs_itcpo-tdsenddate = nast-vsdat.
        lvs_itcpo-tdsendtime = nast-vsura.
        lvs_itcpo-tdfaxuser  = nast-usnam.
      WHEN '3'.
        lvf_device = 'TELETEX'.
        lvs_itcpo-tdtelenum = nast-teltx.
        IF nast-tland IS INITIAL.
          lvs_itcpo-tdteleland = us_country.
        ELSE.
          lvs_itcpo-tdteleland = nast-tland.
        ENDIF.
        lvs_itcpo-tdsenddate = nast-vsdat.
        lvs_itcpo-tdsendtime = nast-vsura.
      WHEN '4'.
        lvf_device = 'TELEX'.
        lvs_itcpo-tdtelenum = nast-telx1.
        IF nast-tland IS INITIAL.
          lvs_itcpo-tdteleland = us_country.
        ELSE.
          lvs_itcpo-tdteleland = nast-tland.
        ENDIF.
        lvs_itcpo-tdsenddate = nast-vsdat.
        lvs_itcpo-tdsendtime = nast-vsura.
      WHEN OTHERS.
        lvf_device = 'PRINTER'.
    ENDCASE.
  ENDIF.

* fill structure itcpo
  itcpo = lvs_itcpo.
  SET COUNTRY us_country.
*  include rvadopfo.

ENDFORM.                    "get_comm


*---------------------------------------------------------------------*
*       FORM GET_DATA                                                 *
*---------------------------------------------------------------------*
*       General provision of data for the form                        *
*---------------------------------------------------------------------*

FORM get_data.

  DATA: vblkp_lines      TYPE p.

* Beschaffen View
  xvbeln = nast-objky.
  CALL FUNCTION 'RV_DELIVERY_PICK_VIEW'
    EXPORTING
      vbeln     = xvbeln
      zweck     = 'D'
      spras     = nast-spras
    IMPORTING
      vblkk_wa  = vblkk
    TABLES
      vblkp_tab = tvblkp
    EXCEPTIONS
      OTHERS    = 1.
  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

* gibt es zu kommissionierende Positionen, ggf. sortieren
  DESCRIBE TABLE tvblkp LINES vblkp_lines.
  IF vblkp_lines GT 0.

* Nummernvergabe Kommissionierauftrag
    CLEAR vblkk-komau.
    CALL FUNCTION 'NUMBER_GET_NEXT'
      EXPORTING
        nr_range_nr = '01'
        object      = 'SD_PICKING'
      IMPORTING
        number      = vblkk-komau
      EXCEPTIONS
        OTHERS      = 1.
    IF sy-subrc NE 0.
    ENDIF.

    IF vblkk-komau IS INITIAL.
      vblkk-komau = sy-datum+2.
      vblkk-komau+6(4) = sy-uzeit(4).
    ENDIF.

    PERFORM sort_pick_list.
    retcode = 0.
  ELSE.
    retcode = 4.
    syst-msgid = 'VN'.
    syst-msgno = '202'.
    syst-msgty = 'E'.
    syst-msgv1 = vblkk-vbeln.
    PERFORM protocol_update.
    CHECK 1 = 2.
  ENDIF.

* Lesen Versandstelle
  IF vblkk-vstel EQ space.
    CLEAR: tvst, tvstt.
  ELSE.
    SELECT SINGLE * FROM tvst WHERE vstel EQ vblkk-vstel.
    IF sy-subrc NE 0.
      CLEAR tvst.
      syst-msgid = 'VN'.
      syst-msgno = '203'.
      syst-msgty = 'E'.
      syst-msgv1 = 'TVST'.
      syst-msgv2 = syst-subrc.
      PERFORM protocol_update.
    ENDIF.
    SELECT SINGLE * FROM tvstt WHERE spras EQ nast-spras
                                 AND vstel EQ vblkk-vstel.
    IF sy-subrc NE 0.
      CLEAR tvstt.
      syst-msgid = 'VN'.
      syst-msgno = '203'.
      syst-msgty = 'E'.
      syst-msgv1 = 'TVSTT'.
      syst-msgv2 = syst-subrc.
      PERFORM protocol_update.
    ENDIF.
  ENDIF.
  PERFORM get_po.
*  PERFORM get_po2.
  PERFORM get_soldto_name.
ENDFORM.                    "get_data

*---------------------------------------------------------------------*
*       FORM GET_SERIAL_NO                                            *
*---------------------------------------------------------------------*
*       In this routine the serialnumbers are fetched from the        *
*       database.                                                     *
*---------------------------------------------------------------------*

FORM get_serial_no.

  REFRESH tsernr.
  REFRESH tsernr_print.
  CHECK vblkp-anzsn > 0.
* Read the Serialnumbers of a Position.
  CALL FUNCTION 'SERIAL_LS_PRINT'
    EXPORTING
      vbeln  = vblkp-vbeln
      posnr  = vblkp-posnr
    TABLES
      iserls = tsernr.

* Process the stringtable for Printing.
  CALL FUNCTION 'PROCESS_SERIALS_FOR_PRINT'
    EXPORTING
      i_boundary_left             = '(_'
      i_boundary_right            = '_)'
      i_sep_char_strings          = ',_'
      i_sep_char_interval         = '_-_'
      i_use_interval              = 'X'
      i_boundary_method           = 'C'
      i_line_length               = 50
      i_no_zero                   = 'X'
      i_alphabet                  = sy-abcde
      i_digits                    = '0123456789'
      i_special_chars             = '-'
      i_with_second_digit         = ' '
    TABLES
      serials                     = tsernr
      serials_print               = tsernr_print
    EXCEPTIONS
      boundary_missing            = 01
      interval_separation_missing = 02
      length_to_small             = 03
      internal_error              = 04
      wrong_method                = 05
      wrong_serial                = 06
      two_equal_serials           = 07
      serial_with_wrong_char      = 08
      serial_separation_missing   = 09.

  IF sy-subrc NE 0.
    PERFORM protocol_update.
  ENDIF.

ENDFORM.                    "get_serial_no
*---------------------------------------------------------------------*
*       FORM SMARTFORM_PRINT
*---------------------------------------------------------------------*

FORM smartform_print.

  DATA: e_werks LIKE tvblkp-werks VALUE ' ',
        e_lgort LIKE tvblkp-lgort VALUE ' ',
        e_lgnum LIKE tvblkp-lgnum VALUE ' ',
        e_mbdat LIKE tvblkp-mbdat VALUE IS INITIAL.
  DATA: lf_fm_name            TYPE rs38l_fnam.
  DATA: ls_control_param      TYPE ssfctrlop.
  DATA: ls_composer_param     TYPE ssfcompop.
  DATA: ls_recipient          TYPE swotobjid.
  DATA: ls_sender             TYPE swotobjid.
  DATA: lf_formname           TYPE tdsfname.
  DATA: ls_addr_key           LIKE addr_key.

  CLEAR retcode.
*  nast_key = objky.



  PERFORM set_print_param USING      ls_addr_key
                          CHANGING ls_control_param
                                   ls_composer_param
                                   ls_recipient
                                   ls_sender
                                   retcode.
*Get the Smart Form name.
  IF NOT tnapr-sform IS INITIAL.
    lf_formname = tnapr-sform.
  ELSE.
    MESSAGE e001(/smb40/ssfcomposer).
  ENDIF.

*>>> getting other smartforms for other countries.
  DATA: l_sform TYPE tdsfname,
       l_land1 TYPE land1_gp,
       l_bukrs TYPE bukrs.


  CLEAR l_bukrs.
  SELECT SINGLE t001k~bukrs INTO l_bukrs FROM lips
  INNER JOIN t001k ON bwkey = lips~werks
              WHERE lips~vbeln = nast-objky.

  CLEAR l_land1.
  SELECT SINGLE land1 INTO l_land1 FROM  t001
         WHERE  bukrs  = l_bukrs.


  CALL FUNCTION 'YSE_LAY_GET_FNAME'
    EXPORTING
      tnapr = tnapr
      land1 = l_land1
    IMPORTING
      sform = l_sform.

  IF NOT l_sform IS INITIAL.
    lf_formname = l_sform.
  ELSE.
    lf_formname = tnapr-sform.
  ENDIF.
*<<<
* Begin of insertion by MOD-001.
  DATA: lv_vkorg TYPE vkorg,
        lv_vkorg1 TYPE vkorg.

  SELECT SINGLE vkorg INTO lv_vkorg
                      FROM likp
                      WHERE vbeln = vblkk-vbeln.
    IF sy-subrc = 0.
      SELECT SINGLE vkorg INTO lv_vkorg1
                          FROM YSE_DG_VKORG
                          WHERE vkorg = lv_vkorg.
        IF  sy-subrc = 0.
          lf_formname = 'YSE_SD_PICKING_LIST_DG'.
        ENDIF.
    ENDIF.


* End of insertion by MOD-001.

* determine smartform function module for invoice
  CALL FUNCTION 'SSF_FUNCTION_MODULE_NAME'
       EXPORTING  formname           = lf_formname
*                 variant            = ' '
*                 direct_call        = ' '
       IMPORTING  fm_name            = lf_fm_name
       EXCEPTIONS no_form            = 1
                  no_function_module = 2
                  OTHERS             = 3.
  IF sy-subrc <> 0.
*   error handling
    retcode = sy-subrc.
    IF sy-subrc = 1.
      MESSAGE e001(/smb40/ssfcomposer).
    ENDIF.
    IF sy-subrc = 2.
      MESSAGE e002(/smb40/ssfcomposer) WITH lf_fm_name .
    ENDIF.
    PERFORM protocol_update.
  ENDIF.


  CALL FUNCTION lf_fm_name
    EXPORTING
       archive_index            = toa_dara
*   ARCHIVE_INDEX_TAB          =
       archive_parameters       = arc_params
       control_parameters       = ls_control_param
*   MAIL_APPL_OBJ              =
       mail_recipient           = ls_recipient
       mail_sender              = ls_sender
       output_options           = ls_composer_param
       user_settings            = ' '
       vblkk                    = vblkk
       ebeln                    = ls_ebeln
       se_order                 = ls_aufnr
       se_sobkz                 = ls_sobkz
       is_nast                  = nast
       se_name_soldto           = l_name_soldto
 TABLES
       tvblkp                   = tvblkp
       lt_lips                  = it_lips

EXCEPTIONS
 formatting_error           = 1
 internal_error             = 2
 send_error                 = 3
 user_canceled              = 4
 OTHERS                     = 5
            .
  IF sy-subrc <> 0.
    retcode = sy-subrc.
    PERFORM protocol_update.
* get SmartForm protocoll and store it in the NAST protocoll
    PERFORM add_smfrm_prot.
  ENDIF.
ENDFORM.                    "smartform_print


*---------------------------------------------------------------------*
*       FORM PROTOCOL_UPDATE                                          *
*---------------------------------------------------------------------*
*       The messages are collected for the processing protocol.       *
*---------------------------------------------------------------------*

FORM protocol_update.

  CHECK xscreen = space.
  CALL FUNCTION 'NAST_PROTOCOL_UPDATE'
    EXPORTING
      msg_arbgb = syst-msgid
      msg_nr    = syst-msgno
      msg_ty    = syst-msgty
      msg_v1    = syst-msgv1
      msg_v2    = syst-msgv2
      msg_v3    = syst-msgv3
      msg_v4    = syst-msgv4
    EXCEPTIONS
      OTHERS    = 1.

ENDFORM.                    "protocol_update

*---------------------------------------------------------------------*
*       FORM SENDER                                                   *
*---------------------------------------------------------------------*
*       This routine determines the address of the sender (Table VBUR)*
*---------------------------------------------------------------------*

FORM user_exit1.

ENDFORM.                                                    "user_exit1
INCLUDE yse_mv50bfz1.
*include mv50bfz1.
*&---------------------------------------------------------------------*
*&      Form  set_print_param
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_ADDR_KEY  text
*      <--P_LS_CONTROL_PARAM  text
*      <--P_LS_COMPOSER_PARAM  text
*      <--P_LS_RECIPIENT  text
*      <--P_LS_SENDER  text
*      <--P_RETCO  text
*----------------------------------------------------------------------*
FORM set_print_param USING    is_addr_key LIKE addr_key
                     CHANGING cs_control_param TYPE ssfctrlop
                              cs_composer_param TYPE ssfcompop
                              cs_recipient TYPE  swotobjid
                              cs_sender TYPE  swotobjid
                              cf_retcode TYPE sy-subrc.

  DATA: ls_itcpo     TYPE itcpo.
  DATA: lf_repid     TYPE sy-repid.
  DATA: lf_device    TYPE tddevice.
  DATA: ls_recipient TYPE swotobjid.
  DATA: ls_sender    TYPE swotobjid.

  lf_repid = sy-repid.
  IF itcpo IS INITIAL.
    CALL FUNCTION 'WFMC_PREPARE_SMART_FORM'
      EXPORTING
        pi_nast       = nast
        pi_addr_key   = is_addr_key
        pi_repid      = lf_repid
      IMPORTING
        pe_returncode = cf_retcode
        pe_itcpo      = ls_itcpo
        pe_device     = lf_device
        pe_recipient  = cs_recipient
        pe_sender     = cs_sender.

    IF cf_retcode = 0.
      MOVE-CORRESPONDING ls_itcpo TO cs_composer_param.
*   CS_CONTROL_PARAM-NO_OPEN
*   CS_CONTROL_PARAM-NO_CLOSE
      cs_control_param-device      = lf_device.
      cs_control_param-no_dialog   = 'X'.
      cs_control_param-preview     = xscreen.
      cs_control_param-getotf      = ls_itcpo-tdgetotf.
      cs_control_param-langu       = nast-spras.
*   CS_CONTROL_PARAM-REPLANGU1
*   CS_CONTROL_PARAM-REPLANGU2
*   CS_CONTROL_PARAM-REPLANGU3
*   CS_CONTROL_PARAM-STARTPAGE
    ENDIF.
  ELSE.
    MOVE-CORRESPONDING itcpo TO cs_composer_param.
*   CS_CONTROL_PARAM-NO_OPEN
*   CS_CONTROL_PARAM-NO_CLOSE
    cs_control_param-device      = lf_device.
    cs_control_param-no_dialog   = 'X'.
    cs_control_param-preview     = xscreen.
    cs_control_param-getotf      = itcpo-tdgetotf.
    cs_control_param-langu       = nast-spras.
*   CS_CONTROL_PARAM-REPLANGU1
*   CS_CONTROL_PARAM-REPLANGU2
*   CS_CONTROL_PARAM-REPLANGU3
*   CS_CONTROL_PARAM-STARTPAGE

  ENDIF.

ENDFORM.                               " set_print_param
**&---------------------------------------------------------------------
*
**&      Form  protocol_update_i
**&---------------------------------------------------------------------
*
**       text
**----------------------------------------------------------------------
*
**  -->  p1        text
**  <--  p2        text
**----------------------------------------------------------------------
*
*form protocol_update_i.
*  check xscreen = space.
*  call function 'NAST_PROTOCOL_UPDATE'
*       exporting
*            msg_arbgb = syst-msgid
*            msg_nr    = syst-msgno
*            msg_ty    = syst-msgty
*            msg_v1    = syst-msgv1
*            msg_v2    = syst-msgv2
*            msg_v3    = syst-msgv3
*            msg_v4    = syst-msgv4
*       exceptions
*            others    = 1.
*
*endform.                               " protocol_update_i
*&---------------------------------------------------------------------*
*&      Form  add_smfrm_prot
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM add_smfrm_prot.
  DATA: lt_errortab             TYPE tsferror.
  DATA: lf_msgnr                TYPE sy-msgno.
  DATA:  l_s_log                TYPE bal_s_log,
         p_loghandle            TYPE balloghndl,
         l_s_msg                TYPE bal_s_msg.

  FIELD-SYMBOLS: <fs_errortab>  TYPE LINE OF tsferror.

* get smart form protocoll
  CALL FUNCTION 'SSF_READ_ERRORS'
    IMPORTING
      errortab = lt_errortab.

* add smartform protocoll to nast protocoll
  LOOP AT lt_errortab ASSIGNING <fs_errortab>.
    CLEAR lf_msgnr.
    lf_msgnr = <fs_errortab>-errnumber.
    CALL FUNCTION 'NAST_PROTOCOL_UPDATE'
      EXPORTING
        msg_arbgb = <fs_errortab>-msgid
        msg_nr    = lf_msgnr
        msg_ty    = <fs_errortab>-msgty
        msg_v1    = <fs_errortab>-msgv1
        msg_v2    = <fs_errortab>-msgv2
        msg_v3    = <fs_errortab>-msgv3
        msg_v4    = <fs_errortab>-msgv4
      EXCEPTIONS
        OTHERS    = 1.
  ENDLOOP.
* open the application log
  l_s_log-extnumber    = sy-uname.

  CALL FUNCTION 'BAL_LOG_CREATE'
    EXPORTING
      i_s_log      = l_s_log
    IMPORTING
      e_log_handle = p_loghandle
    EXCEPTIONS
      OTHERS       = 1.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  LOOP AT lt_errortab ASSIGNING <fs_errortab>.
    MOVE-CORRESPONDING <fs_errortab> TO l_s_msg.
    CALL FUNCTION 'BAL_LOG_MSG_ADD'
      EXPORTING
        i_log_handle = p_loghandle
        i_s_msg      = l_s_msg
      EXCEPTIONS
        OTHERS       = 1.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDLOOP.

  CALL FUNCTION 'BAL_DSP_LOG_DISPLAY'.
*  IF sy-subrc <> 0.
*    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*  ENDIF.

ENDFORM.                               " add_smfrm_prot
*&---------------------------------------------------------------------*
*&      Form  update_lstel
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*Whenever output type ZPIC is being processed, a standard routine is
*executed that is setting the picked quantity in the delivery equal
*to the delivered quantity. Just before this standard routine is called,
*a special routine should be executed that is setting the loading point
*in the outbound delivery (LIKP-LSTEL) according to the following rule:
*#  If the material group (MARA-MATKL) = 02 for all items in the
* delivery => LIKP-LSTEL = Z1
*#  If the material group differs from 02 for at least one item in the
* delivery => LIKP-LSTEL = Z2
*Before calling this special routine, a check should be performed to
*see whether for the shipping point in the delivery (LIKP-VSTEL),
*entries Z1 and Z2 exist in table TVLA (field LSTEL). If they do not
*exist, the routine should not be executed.

*----------------------------------------------------------------------*
FORM update_lstel .

  DATA: BEGIN OF it_matkl OCCURS 0,
     matkl TYPE matkl.
  DATA: END OF it_matkl.

  DATA: l_matkl TYPE matkl,
        l_lstel LIKE likp-lstel,
                it_vtrdi TYPE STANDARD TABLE OF vtrdi WITH HEADER LINE.

*get the data from likp
  CLEAR: wa_likp.
  SELECT SINGLE * FROM likp INTO wa_likp WHERE vbeln = xvbeln.
  CHECK sy-subrc = 0.

*get the data from vtrdi, it could be more than one entry
  REFRESH it_vtrdi.
  SELECT  * FROM  vtrdi INTO TABLE it_vtrdi
         WHERE vstel  = wa_likp-vstel
         AND   vbeln  = xvbeln.

*determine lstel.
  CLEAR: l_matkl, l_lstel.
  SELECT matkl INTO TABLE it_matkl FROM mara
  FOR ALL ENTRIES IN tvblkp
  WHERE matnr = tvblkp-matnr.

  LOOP AT it_matkl WHERE matkl <> '02'.
  ENDLOOP.
  IF sy-subrc = 0.
    l_lstel = 'Z2'.
  ELSE.
    l_lstel = 'Z1'.
  ENDIF.

*check if the entry can be entered.
  SELECT SINGLE COUNT(*) FROM tvla
      WHERE vstel = wa_likp-vstel
        AND lstel = l_lstel.
  IF sy-subrc NE 0.
    EXIT.
  ENDIF.


  wa_likp-lstel = l_lstel.

  LOOP AT it_vtrdi.
    it_vtrdi-lstel = l_lstel.
    MODIFY it_vtrdi.
  ENDLOOP.

*update likp
  MODIFY likp FROM wa_likp.

*update vtrdi
  DESCRIBE TABLE  it_vtrdi.
  IF sy-tfill > 0.
    MODIFY vtrdi FROM TABLE it_vtrdi.
  ENDIF.


ENDFORM.                    " update_lstel
*&---------------------------------------------------------------------*
*&      Form  get_po
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_po .

  DATA: l_vbelv TYPE srrelroles-objkey,
        l_auart TYPE auart,
        l_pstyv TYPE pstyv.

  DATA: BEGIN OF it_vbeln OCCURS 0,
    aufnr TYPE aufnr.
  DATA: END OF it_vbeln.


  CLEAR: ls_aufnr, l_vbelv, it_vbeln, ls_ebeln.
  REFRESH: it_vbeln.
*firs get the advanced shipment order:
* Get the service order number:
*  "select an earlier document for wich you find a notification.

  SELECT SINGLE vbfa~vbelv
     INTO l_vbelv FROM vbfa
    INNER JOIN vbak ON vbak~vbeln = vbfa~vbelv
    WHERE vbfa~vbeln = vblkk-vbeln
      AND vbfa~vbtyp_v = 'C'
      AND vbak~auart = 'ZO03'.

*for PO: if zas2 item --> po
  IF sy-subrc = 0.
    CALL FUNCTION 'YSE_GET_EXISTING_SEO'
      EXPORTING
        objectkey_imp       = l_vbelv
        auart_imp           = 'ZO03'
      TABLES
        vbeln_exp           = it_vbeln
* EXCEPTIONS
*   NONSENSE            = 1
*   OTHERS              = 2
              .
    IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.

    READ TABLE it_vbeln INDEX 1.
    IF sy-subrc = 0.
      ls_aufnr = it_vbeln-aufnr.
    ENDIF.

*code below is not needed any more, we will use the lips-pstyv
**special stock indicator (when E, orders on hand --> semi DTC /
*    service)
*    CLEAR  ls_sobkz.
*    SELECT SINGLE resb~sobkz INTO ls_sobkz
*      FROM resb
*      INNER JOIN rsdbs ON rsdbs~rsnum = resb~rsnum
*                      AND rsdbs~rspos = resb~rspos
*      WHERE resb~aufnr = ls_aufnr
*        AND resb~sobkz NE space .

    SELECT * FROM lips INTO TABLE it_lips
        WHERE vbeln = vblkk-vbeln.

    READ TABLE it_lips INTO wa_lips WITH KEY pstyv = 'ZAS2'.
    IF sy-subrc = 0.
**in this case we don't have a po:
**ZAS1 items on an ASO are delivered from normal stock, which is
*mormaly purchased via replenishment PO that is not relanted to any
*service.
**ZAS2 items on an ASO are delivered from normal advance shipment sales
*order stock, which is mormaly purchased via PO linked to a service
*sales order.
      CLEAR ls_ebeln.
      SELECT SINGLE rsdbs~ebeln INTO ls_ebeln
      FROM resb
      INNER JOIN rsdbs ON rsdbs~rsnum = resb~rsnum
                      AND rsdbs~rspos = resb~rspos
      WHERE resb~aufnr = ls_aufnr
        AND rsdbs~ebeln NE space.
    ENDIF.
  ELSE.
** If we are not dealing with AM.  get the po from the flow.
*    "first get the sales order

    SELECT SINGLE vbfa~vbelv
   INTO l_vbelv FROM vbfa
  WHERE vbfa~vbeln = vblkk-vbeln
    AND vbfa~vbtyp_v = 'C'.

    IF sy-subrc = 0.
      "then get the po
      SELECT SINGLE vbfa~vbeln
     INTO ls_ebeln FROM vbfa
    WHERE vbfa~vbelv = l_vbelv
      AND vbfa~vbtyp_n = 'V'.
    ENDIF.

  ENDIF.
ENDFORM.                    " get_po
*&---------------------------------------------------------------------*
*&      Form  get_soldto_name
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM get_soldto_name .

  DATA: l_adrnr TYPE adrnr.

* Get the address number
  SELECT SINGLE adrnr
    INTO l_adrnr
    FROM vbpa
    WHERE vbeln EQ vblkk-vbeln
    AND   parvw EQ 'AG'.

  CLEAR l_name_soldto.
  SELECT SINGLE name1 INTO l_name_soldto FROM adrc
    WHERE addrnumber = l_adrnr.

ENDFORM.                    " get_soldto_name
*&---------------------------------------------------------------------*
*&      Form  GET_PO2
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM GET_PO2 .

  DATA: wa_vblkp TYPE vblkp,
        l_tabix like sy-tabix,
        l_obknr TYPE objknr,
        i_sernr TYPE TABLE OF objk,
        wa_outtab TYPE t_lips,
        wa_outtab2 TYPE t_lips,
        it_outtab2 TYPE TABLE OF t_lips,
        wa_lips TYPE t_lips,
        it_lips TYPE TABLE OF t_lips,
        salesorders type text30,
        serviceorders type text30,
        gv_count_salo TYPE i,
        sv_vgbel TYPE vgbel,
        gv_count TYPE i,
        gv_vgbel type vgbel,
        gv_aufnr TYPE aufnr,
        gv_lfart TYPE lfart,
        l_ettyp LIKE vbep-ettyp,
        gv_dtc TYPE text10,
        gv_aeskd TYPE aeskd,
        gv_lgpbe TYPE lgpbe.

  READ TABLE tvblkp INTO wa_vblkp INDEX 1.

  SELECT * FROM lips
  INTO CORRESPONDING FIELDS OF TABLE it_lips
  WHERE vbeln = wa_vblkp-vbeln.

  SORT tvblkp BY lgpbe.

  LOOP AT it_lips INTO wa_lips WHERE NOT vgbel IS INITIAL.
    EXIT.
  ENDLOOP.

  LOOP AT it_lips INTO wa_lips.
*Do not show GMACH lines when VBAP-PSTYV for LIPS-MATNR = ZP1, ZP2, ZP3
*or ZP4 or ZOFM
    l_tabix = sy-tabix.

    IF wa_lips-pstyv = 'ZP1'
    OR wa_lips-pstyv = 'ZP2'
    OR wa_lips-pstyv = 'ZP3'
    OR wa_lips-pstyv = 'ZP4'
    OR wa_lips-pstyv = 'ZOFM'.
      DELETE it_lips INDEX l_tabix.
      CONTINUE.
    ENDIF.


    SELECT SINGLE obknr INTO l_obknr
    FROM ser01
    WHERE lief_nr = wa_lips-vbeln
        AND posnr = wa_lips-posnr.
    IF sy-subrc EQ 0.
*    REFRESH: i_sernr.
      SELECT *
      FROM objk
      INTO TABLE i_sernr
      WHERE obknr EQ l_obknr.
    ENDIF.

    CLEAR wa_outtab2.
    wa_outtab2 = wa_lips.

*for the qty open:
    CLEAR wa_vblkp.
    READ TABLE tvblkp
      INTO wa_vblkp
      WITH KEY posnr = wa_lips-posnr.
* If entry does not exit, there is nothing left to pick
    IF sy-subrc <> 0.
      wa_outtab2-lfimg = 0.
    ELSE.
      wa_outtab2-lfimg = wa_vblkp-komng.
    ENDIF.

    IF NOT wa_outtab2 IS INITIAL.
      APPEND wa_outtab2 TO it_outtab2.
    ENDIF.
  ENDLOOP.

  READ TABLE it_outtab2 INTO wa_outtab2 INDEX 1.

  SELECT SINGLE *
    INTO wa_likp
    FROM likp
    WHERE vbeln EQ wa_outtab2-vbeln.


* check if there is more then 1 salesorder/serviceorder
  clear : salesorders,
          serviceorders,
          gv_count_salo.
  sort it_outtab2 by vgbel vgpos.
  loop at it_outtab2 into wa_outtab2.
    if wa_outtab2-vgbel <> sv_vgbel.
      gv_count_salo = gv_count_salo + 1.
      sv_vgbel = wa_outtab2-vgbel.
    endif.
  endloop.

  if gv_count_salo = 1.
    if WA_LIPS-VTWEG = '01'.
      salesorders = wa_lips-vgbel.
      SHIFT salesorders LEFT DELETING LEADING '0'.
    else.
      select single aufnr into serviceorders from vbak
          where vbeln = wa_lips-vgbel
            and aufnr <> ' '.
      SHIFT serviceorders LEFT DELETING LEADING '0'.
    endif.
  endif.

  if gv_count_salo > 1.
    if wa_lips-vtweg = '01'.
      clear: sv_vgbel,
             gv_count.
      loop at it_outtab2 into wa_outtab2.
        if wa_outtab2-vgbel <> sv_vgbel.
          move wa_outtab2-vgbel to gv_vgbel.
          SHIFT gv_vgbel LEFT DELETING LEADING '0'.
          add 1 to gv_count.
          if gv_count = 1.
            move gv_vgbel to salesorders.
          else.
            concatenate salesorders gv_vgbel into
            salesorders separated by space.
          endif.
          sv_vgbel = wa_outtab2-vgbel.
        endif.
* not more then 4 ordernumbers
        if gv_count = 4.
          exit.
        endif.
      endloop.
    endif.
* for service orders
    if wa_lips-vtweg = '11'.
      clear: sv_vgbel,
             gv_count.
      sort it_outtab2 by vgbel posnr.
      loop at it_outtab2 into wa_outtab2.
        if wa_outtab2-vgbel <> sv_vgbel.
          select single aufnr into gv_aufnr
            from vbak where vbeln = wa_outtab2-vgbel.
          SHIFT gv_aufnr LEFT DELETING LEADING '0'.
          add 1 to gv_count.
          if gv_count = 1.
            move gv_aufnr to serviceorders.
          else.
            concatenate serviceorders gv_aufnr into
            serviceorders separated by space.
          endif.
          sv_vgbel = wa_outtab2-vgbel.
        endif.
* not more then 3 salesordernumbers
        if gv_count = 3.
          exit.
        endif.
      endloop.
    endif.
  endif.

* determine flow per detailline
  loop at it_outtab2 into wa_outtab2.
    clear gv_lfart.
    select single lfart into gv_lfart from likp
       where vbeln = wa_outtab2-vbeln.
    CASE gv_lfart.
      WHEN 'NLCC' OR 'ZNLC'.
        wa_outtab2-flow = 'ST TRF'.
      WHEN 'NL'.
        wa_outtab2-flow = 'ST TRF'.
      WHEN 'ZRL'.
        wa_outtab2-flow = 'RET'.
      WHEN 'ZKT'.
        wa_outtab2-flow = 'KIT'.
      WHEN OTHERS.
        CLEAR l_ettyp.
        SELECT SINGLE ettyp INTO l_ettyp FROM vbep
        WHERE vbeln = wa_outtab2-vgbel
          AND posnr = wa_outtab2-vgpos.
        CASE wa_outtab2-vtweg.
          WHEN '01'.
            IF l_ettyp = 'ZB'.
              wa_outtab2-flow = 'SDTC SA'.
            ELSE.
              wa_outtab2-flow = 'SFS SA'.
            ENDIF.
          WHEN '11'.
**in this case we don't have a po:
**ZAS1 items on an ASO are delivered from normal stock, which is
*mormaly purchased via replenishment PO that is not relanted to any
*service.
**ZAS2 items on an ASO are delivered from normal advance shipment sales
*order stock, which is mormaly purchased via PO linked to a service
*sales order.

*           IF l_ettyp = 'Z2'.
            READ TABLE it_lips INTO wa_lips
            WITH KEY vbeln = wa_outtab2-vbeln
                     posnr = wa_outtab2-posnr
                     pstyv = 'ZAS2'.
            IF sy-subrc = 0.
              wa_outtab2-flow = 'SDTC SE'.
            ELSE.
              wa_outtab2-flow = 'SFS SE'.
            ENDIF.
*            ENDIF.
          WHEN '21'.
            wa_outtab2-flow = wa_lips-vgbel.
        ENDCASE.
    ENDCASE.

    modify it_outtab2 from wa_outtab2.
  endloop.
********************************************************************
  DATA: wa_ekkn TYPE ekkn,
          it_ekes TYPE TABLE OF ekes,
          wa_vbfa TYPE vbfa,
          wa_ekes TYPE ekes,
          wa_vbap TYPE vbap,
          wa_rsdbs TYPE rsdbs,
          v_traid TYPE likp-traid,
          v_LGPBE like lips-LGPBE,
          v_count TYPE lfimg,
          v_po TYPE TEXT60.

  CLEAR it_outtab3.

* fill field caseorbin in it_outtab
  loop at it_outtab2 into wa_outtab2.

    gv_dtc = wa_outtab2-flow+0(4).
    CLEAR wa_vbfa.


    IF  wa_outtab2-flow NE 'SDTC SA' AND wa_outtab2-flow NE 'SDTC SE'. "1371 ENDIF
      wa_outtab2-caseorbin = wa_outtab2-lgpbe.
      APPEND wa_outtab2 to it_outtab3.
    ELSE." SDTC**************************************

      IF wa_outtab2-flow = 'SDTC SE'.
***************** CHECK SERVICE ORDER

        DATA: gv_ebeln   TYPE ebeln,
        gv_ebelp   TYPE ebelp,
        gv_vbeln   TYPE vbeln_vl,
        gv_vbelp   TYPE posnr_vl,
        gv_zz_aso_rsnum TYPE rsnum,
        gv_zz_aso_rspos TYPE rspos.

        CLEAR: gv_ebeln,
               gv_ebelp,
               gv_vbeln,
               gv_vbelp,
               gv_zz_aso_rsnum,
               gv_zz_aso_rspos.

* get vbap
        SELECT SINGLE zz_aso_rsnum zz_aso_rspos INTO
          (gv_zz_aso_rsnum, gv_zz_aso_rspos) FROM vbap
          WHERE vbeln = wa_outtab2-vbelv
            AND posnr = wa_outtab2-vgpos
            AND vbelv = wa_outtab2-vbelv
            AND posnv = wa_outtab2-vgpos.
* get rsdbs
        IF NOT gv_zz_aso_rsnum IS INITIAL.
          SELECT SINGLE ebeln ebelp INTO (gv_ebeln, gv_ebelp) FROM rsdbs
            WHERE rsnum = gv_zz_aso_rsnum
              AND rspos = gv_zz_aso_rspos
              and ebeln <> ' '.
* get ekkn
        ELSE.
          SELECT SINGLE ebeln ebelp INTO (gv_ebeln, gv_ebelp) FROM ekkn " get PO
            WHERE vbeln = wa_outtab2-vbelv
              AND vbelp = wa_outtab2-vbelv.
        ENDIF.


*************************************************
      ELSE.
        clear wa_ekkn.
        SELECT SINGLE * FROM ekkn INTO wa_ekkn
          WHERE vbeln = wa_outtab2-vgbel " SO or SEO
          AND vbelp = wa_outtab2-vgpos.
        IF sy-subrc NE 0.
          SELECT * FROM vbfa INTO wa_vbfa
            WHERE vbeln = wa_outtab2-vgbel " SEO
            AND posnn = wa_outtab2-vgpos.
          ENDSELECT.
          IF sy-subrc NE 0.
            SELECT SINGLE * FROM ekkn INTO wa_ekkn
              WHERE vbeln = wa_vbfa-vbelv " SO
              AND vbelp = wa_vbfa-posnv.
          ENDIF.
        ENDIF.
        gv_ebeln = wa_ekkn-ebeln. " PO
        gv_ebelp = wa_ekkn-ebelp.
      ENDIF.
      CONCATENATE v_po gv_ebeln INTO v_po SEPARATED BY space.

      SELECT * FROM ekes INTO TABLE it_ekes
          WHERE ebeln = gv_ebeln     " PO
          AND ebelp = gv_ebelp
          AND ebtyp = 'LA'.

      SORT it_ekes BY vbeln DESCENDING.

      CLEAR v_count.

      LOOP AT it_ekes INTO wa_ekes. " IBDLV
* Check if the inbounddelivery is registered in warehouse, otherwise it couldn't be picked
        SELECT SINGLE * FROM vbfa INTO wa_vbfa
          WHERE vbelv = wa_ekes-vbeln
            AND posnv = wa_ekes-vbelp.
        IF sy-subrc EQ 0 " IBDLV is registered in warehouse
          AND ( wa_ekes-menge NE '0.00' OR wa_ekes-menge NE '' ).
          v_count = v_count + wa_ekes-menge.
          MOVE-CORRESPONDING wa_outtab2 TO wa_outtab.

          IF v_count <= wa_outtab2-lfimg.

            SELECT SINGLE traid FROM likp INTO v_traid
            WHERE vbeln = wa_ekes-vbeln.

            wa_outtab-caseorbin = v_traid.
            wa_outtab-lfimg = wa_ekes-menge.
*****
            APPEND wa_outtab to it_outtab3.
            IF v_count = wa_outtab2-lfimg.
              EXIT.
            ENDIF.
          ELSE.
* Add only 1 line without case numbers
            DELETE it_outtab3 WHERE posnr = wa_outtab-posnr.
*****
            APPEND wa_outtab to it_outtab3.
          ENDIF.

        ENDIF.
      ENDLOOP.

    ENDIF.
  endloop.
* new sorting by flow , caseorbin , posnr
  SORT it_outtab3 BY flow caseorbin posnr.

ENDFORM.                                                    " GET_PO2
