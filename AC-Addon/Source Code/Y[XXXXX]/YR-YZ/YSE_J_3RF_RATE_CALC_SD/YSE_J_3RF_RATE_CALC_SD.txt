*&---------------------------------------------------------------------*
*& Report  YSE_J_3RF_RATE_CALC_SD
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  yse_j_3rf_rate_calc_sd MESSAGE-ID /ccis/ficlr.

TYPE-POOLS rsds.

TABLES: vbak.

INCLUDE j_3rcaltop.
INCLUDE j_3rf_rate_calc_top.
INCLUDE YSE_J_RF_RATE_CALC_SEL_SD.
*INCLUDE j_3rcalf00.
INCLUDE j_3rf_rate_calc_class.  "CR3854 ADD
INCLUDE YSE_J_3RF_RATE_CALC_FORMS_SD.
INCLUDE mrm_const_mrm.

INITIALIZATION.

  SET TITLEBAR '100' OF PROGRAM gc_main_func.
  PERFORM j3rf_rate_calc_init.

START-OF-SELECTION.

  CLEAR g_bkgrnd.
*  IF NOT sy-BATCH IS INITIAL OR
*     NOT sy-BINPT IS INITIAL.
*    g_bkgrnd = 'X'.
*  ENDIF.

*  PERFORM check_job.
  PERFORM start_selection CHANGING g_data_ok.

END-OF-SELECTION.

  IF NOT g_data_ok IS INITIAL.
    " show grid
    PERFORM end_selection CHANGING g_data_back.
  ENDIF.

*&---------------------------------------------------------------------*
*&      Form  SHOW_SELECTION
*&---------------------------------------------------------------------*
*       show popup screen to select down payments
* Returns p_sel_ok = 'X' - user clicked Execute
*         p_sel_ok = ' ' - user clicked Cancel or Back
*----------------------------------------------------------------------*
FORM show_selection
  CHANGING p_sel_ok TYPE c.

  CLEAR p_sel_ok.
****REMOVE CR3854 ADD
* Default the reference key 2 to the sales order related to the invoice
* which we are creating
  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      INPUT         = vbak-vbeln
    IMPORTING
      OUTPUT        = p_xref2.
****REMOVE CR3854 ADD
**ADD CR3854 BEGIN


*****begin of mod cr3854
* Default the document type with 'RU'
  move 'RU' to p_blart.

* call selection screen
  CALL FUNCTION 'YSE_J3RF_RATE_CALC_SEL_SD'
    TABLES
      f_p_budat    = p_budat[]
      f_p_umskz    = p_umskz[]
      f_p_belnr    = p_belnr[]
      f_p_bldat    = p_bldat[]
    CHANGING
      f_p_bukrs    = p_bukrs
      f_p_rb_lif   = p_rb_lif
      f_p_lifnr    = p_lifnr
      f_p_rb_kun   = p_rb_kun
      f_p_kunnr    = p_kunnr
      f_p_modpay   = p_modpay
      f_p_modclr   = p_modclr
      f_p_zuonr    = p_zuonr
      f_p_gsber    = p_gsber
      f_p_pwaers   = p_pwaers
      f_p_vari     = p_vari
      f_p_amount   = p_amount
      f_p_waers    = p_waers
      f_p_invdat   = p_invdat
      f_p_clcdat   = p_clcdat
      f_p_invrat   = p_invrat
      f_p_clcrat   = p_clcrat
      f_p_blart    = p_blart
      f_p_xref2    = p_xref2
      f_p_clear    = p_clear
*      f_x_call     = x_call
*      f_b_input    = b_input
*      f_b_name     = b_name
       f_b_inv      = b_inv
       f_b_gjahr    = b_gjahr
       f_b_bldat    = b_bldat
*      f_b_budat    = b_budat
*      f_b_bupem    = b_bupem
*      f_b_blart    = b_blart
*      f_b_rstgr    = b_rstgr
*      f_b_remin    = pa_remin
*      f_b_prpay    = pa_prpay
       f_automode   = automode
    EXCEPTIONS
      ex_cancelled = 1.

  IF sy-subrc IS INITIAL.
    p_sel_ok = 'X'.
    " initiate variant
    PERFORM check_selection_screen.
  ELSEIF sy-ucomm = 'CCAN' or
         sy-ucomm = 'CEND' or
         sy-ucomm = 'CBAC'.
*   IF automode CA gc_auto_mode_sel.
      " Cancel is clicked - abort processing
      MESSAGE e342(F5).
*   ENDIF.
  ENDIF.
ENDFORM.                    "SHOW_SELECTION

*&---------------------------------------------------------------------*
*&      Form  SHOW_SELECTION_2
*&---------------------------------------------------------------------*
*       show popup screen Exchange Rate Input
* Returns p_sel_ok = 'X' - user clicked Execute
*         p_sel_ok = ' ' - user clicked Cancel or Back
*----------------------------------------------------------------------*
FORM show_selection_2

  CHANGING p_sel_ok TYPE c.

  CLEAR p_sel_ok.

  p_clcdat = sy-datum.

* call selection screen
  CALL FUNCTION 'YSE_J3RF_RATE_CALC_SEL'
    CHANGING
      f_p_invdat   = p_invdat
      f_p_clcdat   = p_clcdat
      f_p_invrat   = p_invrat
      f_p_clcrat   = p_clcrat
    EXCEPTIONS
      ex_cancelled = 1.

  IF sy-subrc IS INITIAL.
    p_sel_ok = 'X'.
*   " initiate variant
*    PERFORM check_selection_screen.
  ELSEIF sy-ucomm = 'CCAN' or
         sy-ucomm = 'CEND' or
         sy-ucomm = 'CBAC'.
*    IF automode CA gc_auto_mode_sel.
    " Cancel is clicked - abort processing
    MESSAGE e342(F5).
*    ENDIF.
  ENDIF.

ENDFORM.                    "SHOW_SELECTION_2

*&---------------------------------------------------------------------*
*&      Form  START_SELECTION
*&---------------------------------------------------------------------*
*   event START-OF-SELECTION
*   validate selection parameters
*----------------------------------------------------------------------*
FORM start_selection
  CHANGING p_data_ok TYPE c.

  DATA: l_subrc TYPE sy-subrc.

  " check the data
  TRY.
      CLEAR p_data_ok.

*     check company code - need for performance
      IF p_bukrs IS INITIAL.
        MESSAGE s110(/ccis/ficlr).
        EXIT.
      ENDIF.

      PERFORM acount_info_fill.
      IF it_rc_t001 IS INITIAL.
        MESSAGE s111(/ccis/ficlr) WITH p_bukrs.
        EXIT.
      ENDIF.

*     if vendor is selected then the vendor must be specified
      IF p_rb_lif = 'X' AND p_lifnr IS INITIAL.
        MESSAGE s101(/ccis/ficlr).
        EXIT.
      ENDIF.

*     if customer is selected then the customer must be specified
      IF p_rb_kun = 'X' AND p_kunnr IS INITIAL.
        MESSAGE s102(/ccis/ficlr).
        EXIT.
      ENDIF.

*     only vendor or customer can be selected for get_downpayments
      IF p_rb_lif = 'X'.
        CLEAR p_kunnr.
      ELSE.
        CLEAR p_lifnr.
      ENDIF.

*     check if the customer is locked
      PERFORM down_payments_locked
        USING
           p_lifnr
           p_kunnr
        CHANGING
           g_locked
           p_amount
           p_waers
           g_uname
      .

      IF ( p_clear = 'X' OR p_modclr = 'X' ) AND automode NA gc_auto_mode_sel.
*       validate clearing rules
        IF g_locked NE 'X'.
          MESSAGE s107(/ccis/ficlr).
          IF g_bkgrnd EQ 'X'.
            MESSAGE s107(/ccis/ficlr) INTO g_msg .
            WRITE: / g_msg.
          ENDIF.
          EXIT.
        ENDIF.

        IF b_inv IS INITIAL.
          MESSAGE s106(/ccis/ficlr).
          IF g_bkgrnd EQ 'X'.
            MESSAGE s106(/ccis/ficlr) INTO g_msg .
            WRITE: / g_msg.
          ENDIF.
          EXIT.
        ENDIF.

        IF b_gjahr IS INITIAL.
          MESSAGE s116(/ccis/ficlr).
          IF g_bkgrnd EQ 'X'.
            MESSAGE s116(/ccis/ficlr) INTO g_msg .
            WRITE: / g_msg.
          ENDIF.
          EXIT.
        ENDIF.

*       override invoice amount and currency
        PERFORM read_invoice
          USING    p_bukrs
                   b_inv
                   b_gjahr
                   p_kunnr
                   p_lifnr
          CHANGING p_amount
                   p_waers
                   p_clcdat
                   p_clcrat
                   l_subrc.

        CASE l_subrc.
          WHEN 1. MESSAGE s114(/ccis/ficlr) WITH b_inv.
                  IF g_bkgrnd EQ 'X'.
                    MESSAGE s114(/ccis/ficlr) WITH b_inv INTO g_msg .
                    WRITE: / g_msg.
                  ENDIF.
                  EXIT.
          WHEN 2. MESSAGE s117(/ccis/ficlr) WITH b_inv.
                  IF g_bkgrnd EQ 'X'.
                    MESSAGE s117(/ccis/ficlr) WITH b_inv INTO g_msg .
                    WRITE: / g_msg.
                  ENDIF.
                  EXIT.
        ENDCASE.

        "N1384274 - we should re-init currency rates
        PERFORM init_currency
          USING g_kurstyp
                p_clcdat
                p_waers
                it_rc_t001-waers
                g_dp_rate.

      ELSEIF g_locked EQ 'X'.

*        IF NOT p_lifnr IS INITIAL.
*          MESSAGE s104(/ccis/ficlr) WITH p_lifnr.
*        ENDIF.
*        IF NOT p_kunnr IS INITIAL.
*          MESSAGE s104(/ccis/ficlr) WITH p_kunnr.
*        ENDIF.

      ELSE.
        IF p_amount IS INITIAL.
          MESSAGE s105(/ccis/ficlr).
          EXIT.
        ENDIF.
        IF p_waers IS INITIAL.
          MESSAGE s112(/ccis/ficlr).
          EXIT.
        ENDIF.
      ENDIF.

      IF p_invdat = 'X' OR p_clear = 'X'. " if rate is calculated by invoice date
        CLEAR p_clcrat.                   " then clear rate
      ELSE.
        rateequation-conv_date = p_clcdat." save date
        CLEAR p_clcdat.  " otherwise clear date
      ENDIF.

*     get list of down payments
      PERFORM get_down_payments
        TABLES p_belnr
               p_budat
               p_bldat
               p_umskz
        USING  p_bukrs
               p_lifnr
               p_kunnr
               p_zuonr
               p_gsber
               p_waers
               p_pwaers
               p_blart
               p_xref2
      .

      IF LINES( it_j_3rf_downpay ) EQ 0.
*       MESSAGE s103(/ccis/ficlr).
        EXIT.
      ENDIF.

**     validate clearing amount
*      IF ( p_clear = 'X' OR p_modclr = 'X' ) AND automode NA gc_auto_mode_sel.
*        PERFORM calc_down_payments USING p_amount p_clcdat p_clcrat.
*      ENDIF.

      p_data_ok = 'X'.

    CATCH cx_root INTO g_err_ex.

      g_err_str = g_err_ex->get_longtext( ).
      WRITE: / g_err_str.

*     clear array
      REFRESH: it_j_3rf_invoice, it_j_3rf_downpay.
      EXIT.
  ENDTRY.

ENDFORM.                    "START_SELECTION

*&---------------------------------------------------------------------*
*&      Form  START_SELECTION_2
*&---------------------------------------------------------------------*
*   event START-OF-SELECTION
*   validate selection parameters
*----------------------------------------------------------------------*
FORM start_selection_2
  CHANGING p_data_ok TYPE c.

  DATA: l_subrc TYPE sy-subrc.

  " check the data
  TRY.
      CLEAR p_data_ok.

      PERFORM acount_info_fill.

      IF p_invdat = 'X'.                  " if rate is calculated by invoice date
        PERFORM get_invoice_rate.
*        CLEAR p_clcrat.                   " then clear rate
      ELSE.
        rateequation-conv_date = p_clcdat." save date
*        CLEAR p_clcdat.                   " otherwise clear date
      ENDIF.

      p_data_ok = 'X'.

    CATCH cx_root INTO g_err_ex.

      g_err_str = g_err_ex->get_longtext( ).
      WRITE: / g_err_str.

*     clear array
      REFRESH: it_j_3rf_invoice.
      EXIT.
  ENDTRY.

ENDFORM.                    "START_SELECTION_2

*&---------------------------------------------------------------------*
*&      Form  END_SELECTION
*&---------------------------------------------------------------------*
*   event END-OF-SELECTION
*   show down payments list or clear invoice with down payments
*----------------------------------------------------------------------*
FORM end_selection CHANGING p_back TYPE c.

  TRY.
      CLEAR p_back.
*     get account info
      PERFORM acount_info_fill.

**     clear the down payments
*      IF p_modclr = 'X'.
*        PERFORM clear_invoice USING space.
*        EXIT.
*      ENDIF.

      g_loop = 'X'.
      WHILE g_loop = 'X'.
        CLEAR g_loop.
        PERFORM alv_grid CHANGING p_back.
      ENDWHILE.

    CATCH cx_root INTO g_err_ex.
      g_err_str = g_err_ex->get_longtext( ).
      WRITE: / g_err_str.
  ENDTRY.
ENDFORM.                    "END_SELECTION

*&---------------------------------------------------------------------*
*&      Form  END_SELECTION_2
*&---------------------------------------------------------------------*
*   event END-OF-SELECTION
*----------------------------------------------------------------------*
FORM end_selection_2 CHANGING p_back TYPE c.

  DATA:
  it_inv    TYPE STANDARD TABLE OF j_3rfin_rate_clc WITH HEADER LINE,
  l_dat(10) TYPE c.

* save to the database
  CLEAR it_inv.

  " create invoice
  IF it_inv IS INITIAL.
    it_inv-mandt     = sy-mandt.
    it_inv-lifnr     = p_lifnr.
    it_inv-kunnr     = p_kunnr.
    it_inv-usnam     = sy-uname.
    if not p_invdat is initial.
      it_inv-rate_inv  = g_dp_rate.
      it_inv-dmbtr_inv = g_dp_rate * p_amount.
    else.
      it_inv-rate_inv  = p_clcrat.
      it_inv-dmbtr_inv = p_clcrat * p_amount.
    endif.
    it_inv-wrbtr_inv = p_amount.
    it_inv-waers_inv = p_waers.
*    it_inv-awkey_inv = g_awkey_inv.
*    it_inv-rate_clr  = g_cl_rate.
    IF p_clcdat IS INITIAL.
      p_clcdat = sy-datum.
    ENDIF.
    WRITE p_clcdat TO l_dat MM/DD/YYYY.
    it_inv-gjahr_inv = l_dat+6(4). " extract year
    it_inv-bukrs_inv = p_bukrs.
    APPEND it_inv.
  ENDIF.

  CHECK LINES( it_inv ) > 0.

  REFRESH: it_j_3rf_invoice.
  LOOP AT it_inv.
    MOVE-CORRESPONDING it_inv TO it_j_3rf_invoice.          "#EC ENHOK
    APPEND it_j_3rf_invoice.
  ENDLOOP.

* clear memory
  REFRESH: it_inv.

ENDFORM.                    "END_SELECTION_2


*&---------------------------------------------------------------------*
*&      Form  refresh_grid
*&---------------------------------------------------------------------*
*       reload ALV grid
*----------------------------------------------------------------------*
FORM refresh_grid USING rs_selfield TYPE slis_selfield.
  DATA: l_amount TYPE j_3rfin_rate_clc-wrbtr_inv,
        l_waers  TYPE j_3rfin_rate_clc-waers_inv.

* reselect data
  PERFORM get_down_payments
    TABLES p_belnr
           p_budat
           p_bldat
           p_umskz
    USING  p_bukrs
           p_lifnr
           p_kunnr
           p_zuonr
           p_gsber
           p_waers
           p_pwaers
           p_blart
           p_xref2
  .

  rs_selfield-exit = 'X'. " regenerate the grid
  g_loop           = 'X'.

*  update g_locked flag
  PERFORM down_payments_locked
    USING
       p_lifnr
       p_kunnr
    CHANGING
       g_locked
       l_amount
       l_waers
       g_uname
  .
ENDFORM.                    "refresh_grid

*&---------------------------------------------------------------------*
*&      Form  alv_grid
*&---------------------------------------------------------------------*
*       show grid
*----------------------------------------------------------------------*
FORM alv_grid CHANGING p_back TYPE c.

  DATA: gt_fieldcat TYPE slis_t_fieldcat_alv,
        gt_events   TYPE slis_t_event,
        gt_sort     TYPE slis_t_sortinfo_alv,
        ls_layout   TYPE slis_layout_alv,
        ls_print    TYPE slis_print_alv,
        i_exit(1)   TYPE c,
        is_exit     TYPE slis_exit_by_user.

* if there are selected downpayments then grid cannot be changed
  CLEAR: g_locked, p_back.
*  READ TABLE it_j_3rf_downpay WITH KEY chk_sel = 'X'.
*  IF sy-subrc EQ 0.
*    g_locked = 'X'.
*  ENDIF.

  CLEAR ls_print.
  ls_print-reserve_lines      = '2'.
  ls_print-no_print_listinfos = 'X'. "No print info
  ls_print-no_print_selinfos  = 'X'. "No sel info

  PERFORM rc_make_fieldcatalog USING g_locked CHANGING gt_fieldcat.
  PERFORM rc_alv_events_make   CHANGING gt_events.
  PERFORM rc_layout_build      CHANGING ls_layout.

  CALL FUNCTION 'REUSE_ALV_VARIANT_SELECT'
    EXPORTING
      i_dialog            = ' '
      it_default_fieldcat = gt_fieldcat[]
      i_layout            = ls_layout
    IMPORTING
      et_sort             = gt_sort[]  "info about sort,filters...
    CHANGING
      cs_variant          = gx_variant
    EXCEPTIONS
      wrong_input         = 1
      fc_not_complete     = 2
      not_found           = 3
      program_error       = 4
      OTHERS              = 5.

  CALL FUNCTION 'REUSE_ALV_LIST_DISPLAY'
    EXPORTING
      i_buffer_active          = space
      i_callback_program       = sy-repid
      i_callback_pf_status_set = 'RC_SET_PF_STATUS'
      i_callback_user_command  = 'RC_USER_COMMAND'
      it_fieldcat              = gt_fieldcat
      i_default                = 'X'
      i_save                   = 'A'
      it_events                = gt_events
      is_variant               = g_variant          "ALV variant
      is_layout                = ls_layout
      is_print                 = ls_print
      it_sort                  = gt_sort[]
    IMPORTING
      e_exit_caused_by_caller  = i_exit
      es_exit_caused_by_user   = is_exit
    TABLES
      t_outtab                 = it_j_3rf_downpay[]
    EXCEPTIONS
      program_error            = 1
      OTHERS                   = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
  IF is_exit-back = 'X'.
    p_back = 'X'.
  ELSEIF is_exit-cancel = 'X'.
    IF automode CA gc_auto_mode_sel.
      " Cancel is clicked - abort processing
      MESSAGE e342(F5).
    ENDIF.
  ENDIF.
ENDFORM.                    "alv_grid

*&---------------------------------------------------------------------*
*&      Form  RC_MAKE_FIELDCATALOG
*&---------------------------------------------------------------------*
FORM rc_make_fieldcatalog
  USING    pa_locked   TYPE c
  CHANGING pa_fieldcat TYPE slis_t_fieldcat_alv.

  DATA         : fn TYPE string.
  FIELD-SYMBOLS: <fs> LIKE LINE OF pa_fieldcat.

*  get J_3RFPM_RATE_CLC field catalog
  CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
    EXPORTING
      i_program_name         = sy-repid
      i_structure_name       = 'J_3RF_RATE_CALC_ALV'
    CHANGING
      ct_fieldcat            = pa_fieldcat[]
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.
  IF sy-subrc <> 0.
    MESSAGE a011(msitem).
  ENDIF.

* by default show only the following fields
  LOOP AT pa_fieldcat ASSIGNING <fs>.
    CONCATENATE ',' <fs>-fieldname ',' INTO fn.

    <fs>-no_out = 'X'.
    IF ',CHK_SEL,CHK_PART,BELNR,BLART,BLDAT,' CS fn  OR
       ',UMSKZ,BUZEI,GSBER,DMBTR,HWAER,'      CS fn  OR
       ',WRBTR_INV,WAERS_INV,RATE_PAY,ZUONR,' CS fn.
      <fs>-no_out = ' '.
    ENDIF.

    IF <fs>-fieldname EQ 'CHK_SEL' OR <fs>-fieldname EQ 'CHK_PART'.
      IF pa_locked IS INITIAL.
        <fs>-input     = 'X'.
      ENDIF.
      <fs>-checkbox  = 'X'.
      <fs>-just      = 'C'.
      IF <fs>-fieldname EQ 'CHK_SEL'.
        <fs>-ddictxt   = 'M'.
      ENDIF.
    ENDIF.

  ENDLOOP.

ENDFORM.                               " RC_MAKE_FIELDCATALOG

*&---------------------------------------------------------------------*
*&      Form  RC_ALV_EVENTS_MAKE
*&---------------------------------------------------------------------*
FORM rc_alv_events_make CHANGING t_events TYPE slis_t_event.
  DATA: wa_event TYPE slis_alv_event.

  CALL FUNCTION 'REUSE_ALV_EVENTS_GET'
    EXPORTING
      i_list_type     = 0
    IMPORTING
      et_events       = t_events
    EXCEPTIONS
      list_type_wrong = 1
      OTHERS          = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  READ TABLE t_events WITH KEY name = slis_ev_top_of_page
                      INTO wa_event.
  IF sy-subrc = 0.
    MOVE 'RC_TOP_OF_PAGE' TO wa_event-form.
    MODIFY t_events FROM wa_event INDEX sy-tabix.
  ENDIF.
  READ TABLE t_events WITH KEY name = slis_ev_top_of_list
                      INTO wa_event.
  IF sy-subrc = 0.
    MOVE 'RC_TOP_OF_LIST' TO wa_event-form.
    MODIFY t_events FROM wa_event INDEX sy-tabix.
  ENDIF.

*...delete all unneeded events:
  DELETE t_events WHERE form IS INITIAL.

ENDFORM.                               " RC_ALV_EVENTS_MAKE

*&---------------------------------------------------------------------*
*&      Form  rc_layout_build
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->LS_LAYOUT  text
*----------------------------------------------------------------------*
FORM rc_layout_build USING ls_layout TYPE slis_layout_alv.
  CLEAR ls_layout.
ENDFORM.                                               "e05_layout_build

*&---------------------------------------------------------------------*
*&      Form  acount_info_fill
*&---------------------------------------------------------------------*
*       read company information
*----------------------------------------------------------------------*
FORM acount_info_fill.

  IF it_rc_t001-bukrs NE p_bukrs.
    SELECT * FROM t001 INTO TABLE it_rc_t001 WHERE bukrs = p_bukrs.
    READ TABLE it_rc_t001 INTO it_rc_t001 INDEX 1.
    IF NOT sy-subrc IS INITIAL.
      CLEAR it_rc_t001.
    ENDIF.
  ENDIF.

* N1363895: read conversion factors
  IF g_kurstyp IS INITIAL.
    g_kurstyp = 'M'.
  endif.

  IF it_rc_t001-waers NE p_waers.
    IF rateequation-fcurrp    NE p_waers          OR
       rateequation-tcurrp    NE it_rc_t001-waers OR
       rateequation-fcurrm    NE p_waers          OR
       rateequation-tcurrm    NE it_rc_t001-waers OR
       rateequation-kurstyp   NE g_kurstyp        OR
       rateequation-conv_date NE p_clcdat.

      PERFORM init_currency
        USING g_kurstyp
              p_clcdat
              p_waers
              it_rc_t001-waers
              g_dp_rate.
    ENDIF.
  ENDIF.

ENDFORM.                    "acount_info_fill

*&---------------------------------------------------------------------*
*&      Form  SET_PF_STATUS
*&---------------------------------------------------------------------*
FORM rc_set_pf_status USING t_extab TYPE slis_t_extab.
  DATA: fcode TYPE TABLE OF sy-ucomm.

* if locked then do not allow SAVE
  IF automode CA gc_auto_mode_sel.
*   SD: select down payments - do not allow clear
    IF g_locked NE 'X'.
      APPEND 'RESET' TO fcode.
    ENDIF.
  ELSEIF g_locked = 'X'.
    APPEND 'SAVE'  TO fcode.
    APPEND 'SAVD'  TO fcode.
  ELSE.
    APPEND 'RESET' TO fcode.
  ENDIF.

  SET PF-STATUS 'ALV_ITEMS' OF PROGRAM sy-repid EXCLUDING fcode.
ENDFORM.                    "set_pf_status

*&---------------------------------------------------------------------*
*&      Form  RC_TOP_OF_PAGE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM rc_top_of_page.
  PERFORM show_status.
ENDFORM.                    "RC_TOP_OF_PAGE

*&---------------------------------------------------------------------*
*&      Form  RC_TOP_OF_LIST
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM rc_top_of_list.

ENDFORM.                    "RC_TOP_OF_LIST

*&---------------------------------------------------------------------*
*&      Form  show_status
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM show_status.
  CONSTANTS: status_column TYPE i VALUE 56,
             rate_column   TYPE i VALUE 63.
  DATA     : v TYPE bseg-wrbtr.
  DATA     : s TYPE string.

  PERFORM calc_down_payments USING p_amount p_clcdat p_clcrat.

  IF NOT p_kunnr IS INITIAL.
    WRITE: / 'Customer:'(800),
          AT status_column p_kunnr.
  ENDIF.

  IF NOT p_lifnr IS INITIAL.
    WRITE: / 'Vendor:'(801),
          AT status_column p_lifnr.
  ENDIF.

  v = p_amount - g_dp_amount.

  WRITE: / 'Selected Down Payments:'(802),
          AT status_column(16) g_dp_count.
  WRITE: / 'Invoice Amount:'(803),
          AT status_column(16) p_amount CURRENCY p_waers,
          p_waers.
  WRITE: / 'Assigned:'(804),
          AT status_column(16) g_dp_amount CURRENCY p_waers,
          p_waers.
  WRITE: / 'Not Assigned:'(805),
          AT status_column(16) v CURRENCY p_waers.

  IF g_dp_amount > 0 AND NOT g_dp_rate IS INITIAL.
    WRITE icon_green_light AS ICON. " green always when can be calculated
  ELSE.
    WRITE icon_red_light AS ICON.
  ENDIF.

  " conversion factors
  PERFORM get_conv_factor CHANGING s.

  WRITE: / 'Average Invoice Exchange Rate:'(806).
  IF NOT g_dp_rate IS INITIAL.
    WRITE: AT rate_column(16) g_dp_rate RIGHT-JUSTIFIED,
           s.
  ENDIF.

  WRITE: / 'Exch. Rate for Clearing Down Payts (Not Invoice Posting):'(810).
  IF NOT g_cl_rate IS INITIAL.
    WRITE: AT rate_column(16) g_cl_rate RIGHT-JUSTIFIED,
           s.
  ENDIF.

  WRITE: / 'Partner Locked By:'(811),
         AT status_column(16) g_uname.

  SKIP.
ENDFORM.                    "show_status

*&---------------------------------------------------------------------*
*&      Form  RC_USER_COMMAND
*&---------------------------------------------------------------------*
FORM rc_user_command USING r_ucomm     LIKE sy-ucomm
                           rs_selfield TYPE slis_selfield.  "#EC CALLED
  DATA: i TYPE i.

  IF r_ucomm EQ 'SAVD'.  " dummy function code
    r_ucomm = 'SAVE'.
  ENDIF.

  IF r_ucomm EQ '&IC1'.  " double click
    r_ucomm = 'ITEM'.
  ENDIF.

  CASE r_ucomm.

*   select all
    WHEN 'ALL_RC'.
      PERFORM okcode_all USING rs_selfield 'X'.

*   deselect all
    WHEN 'SAL_RC'.
      PERFORM okcode_all USING rs_selfield space.

*   display item:
    WHEN 'ITEM'.
      PERFORM okcode_item USING rs_selfield.
      rs_selfield-row_stable = 'X'.
      rs_selfield-col_stable = 'X'.

*   display master record info:
    WHEN 'MAST'.
      PERFORM okcode_mast USING rs_selfield.

*  preform calculations
    WHEN 'CALC' OR 'SAVE'.
*     validate - only one partial payment allowed
      CLEAR i.
      LOOP AT it_j_3rf_downpay WHERE chk_sel = 'X' AND chk_part = 'X'.
        i = i + 1.
      ENDLOOP.
      IF i > 1.
        MESSAGE i108(/ccis/ficlr).
      ENDIF.

      PERFORM calc_down_payments USING p_amount p_clcdat p_clcrat.
      IF g_dp_count EQ 0.
        MESSAGE s007(msitem).
      ENDIF.

*     save selected down payments
      IF r_ucomm = 'SAVE'.
        PERFORM okcode_save USING rs_selfield.
      ENDIF.

*   reset down payments list for selected customer
    WHEN 'RESET'.
      PERFORM okcode_reset USING rs_selfield.

  ENDCASE.
  CLEAR r_ucomm.

ENDFORM.                               " RC_USER_COMMAND

*&---------------------------------------------------------------------*
*&      Form  okcode_all
*&---------------------------------------------------------------------*
*       select or deselect all items
*----------------------------------------------------------------------*
*      -->RS_SELFIELD  text
*      -->PA_VALUE     text
*----------------------------------------------------------------------*
FORM okcode_all
  USING rs_selfield TYPE slis_selfield
        pa_value    TYPE c.

  FIELD-SYMBOLS: <fs> LIKE LINE OF it_j_3rf_downpay.

  LOOP AT it_j_3rf_downpay ASSIGNING <fs>.
    <fs>-chk_sel = pa_value.
  ENDLOOP.

  rs_selfield-row_stable = 'X'.
  rs_selfield-col_stable = 'X'.
  rs_selfield-refresh    = 'X'.

ENDFORM.                    "okcode_all

*&---------------------------------------------------------------------*
*&      Form  OKCODE_ITEM
*&---------------------------------------------------------------------*
FORM okcode_item USING rs_selfield TYPE slis_selfield.
*... cursor on item line?
  IF rs_selfield-tabindex > 0 AND rs_selfield-sumindex LE 0.
*   set parameters:
    READ TABLE it_j_3rf_downpay
      INTO  it_j_3rf_downpay
      INDEX rs_selfield-tabindex.
    IF sy-subrc = 0.
      SET PARAMETER ID 'BLN' FIELD it_j_3rf_downpay-belnr.
      SET PARAMETER ID 'BUK' FIELD it_j_3rf_downpay-bukrs.
      SET PARAMETER ID 'GJR' FIELD it_j_3rf_downpay-gjahr.

      CALL TRANSACTION 'FB03' AND SKIP FIRST SCREEN.
    ENDIF.
  ELSE.
    MESSAGE s001(msitem).
  ENDIF.
ENDFORM.                               " OKCODE_ITEM

*&---------------------------------------------------------------------*
*&      Form  OKCODE_MAST
*&---------------------------------------------------------------------*
FORM okcode_mast USING rs_selfield TYPE slis_selfield.

  DATA: l_konto TYPE ktonr_av.

*... cursor on item line?
  IF rs_selfield-tabindex > 0 AND rs_selfield-sumindex LE 0.
*   display master data related to item:
    READ TABLE it_j_3rf_downpay INDEX rs_selfield-tabindex.
    IF sy-subrc = 0.
      IF NOT it_j_3rf_downpay-lifnr IS INITIAL.
        l_konto = it_j_3rf_downpay-lifnr.
      ELSEIF NOT it_j_3rf_downpay-kunnr IS INITIAL.
        l_konto = it_j_3rf_downpay-kunnr.
      ELSE.
        EXIT.
      ENDIF.

      PERFORM display_master_rec USING l_konto
                                       it_j_3rf_downpay-bukrs
                                       it_j_3rf_downpay-koart.
    ENDIF.
  ELSE.
    MESSAGE s013(msitem).
  ENDIF.

ENDFORM.                               " OKCODE_MAST

*&---------------------------------------------------------------------*
*&      Form  DISPLAY_MASTER_REC
*&---------------------------------------------------------------------*
FORM display_master_rec USING    p_items_konto TYPE ktonr_av
                                 p_items_bukrs TYPE bukrs
                                 p_items_koart TYPE koart.

  DATA: text(100)    TYPE c VALUE space.

  SET PARAMETER ID 'BUK' FIELD p_items_bukrs.
  CASE p_items_koart.
    WHEN gc_koart_d.
      text = '/111/120/125/130/210/215/220/230/340/360/370/600/610'.
      SET PARAMETER ID 'KUN' FIELD p_items_konto.
      SET PARAMETER ID 'DDY' FIELD text.
      CALL TRANSACTION 'FD03' AND SKIP FIRST SCREEN.
    WHEN gc_koart_k.
      text = '/111/120/130/210/215/220/380/600/610'.
      SET PARAMETER ID 'LIF' FIELD p_items_konto.
      SET PARAMETER ID 'DDY' FIELD text.
      CALL TRANSACTION 'FK03' AND SKIP FIRST SCREEN.
    WHEN gc_shkzg_s.
      CALL FUNCTION 'GL_ACCT_MASTER_MAINTAIN_SINGLE'
        EXPORTING
          activity            = '1'
          x_chart_of_accounts = 'X'
          x_company_code      = 'X'
          account_number      = p_items_konto
          company_code        = p_items_bukrs
        EXCEPTIONS
          OTHERS              = 0.
    WHEN OTHERS.
  ENDCASE.

ENDFORM.                               " DISPLAY_MASTER_REC

*&---------------------------------------------------------------------*
*&      Form  okcode_save
*&---------------------------------------------------------------------*
FORM okcode_save USING rs_selfield TYPE slis_selfield.
  DATA: it_inv   TYPE STANDARD TABLE OF j_3rfin_rate_clc WITH HEADER LINE,
        it_dp    TYPE STANDARD TABLE OF j_3rfpm_rate_clc WITH HEADER LINE,
        l_waers  TYPE waers.
  FIELD-SYMBOLS: <fs> LIKE LINE OF it_j_3rf_downpay.
  DATA         : l_dat(10) TYPE c.

*  calculate
  PERFORM calc_down_payments USING p_amount p_clcdat p_clcrat.

* are items selected?
  IF g_dp_count EQ 0.
    MESSAGE s007(msitem).
    EXIT.
  ENDIF.

*  do not allow to save down payment amount > invoice
  IF g_dp_amount > p_amount.
    MESSAGE s113(/ccis/ficlr).
    EXIT.
  ENDIF.

*  check - all records should be in one currency
  CLEAR l_waers.
  LOOP AT it_j_3rf_downpay ASSIGNING <fs> WHERE chk_sel = 'X'.
    IF l_waers IS INITIAL.
      l_waers = <fs>-waers_inv.
    ELSEIF l_waers NE <fs>-waers_inv.
      MESSAGE s109(/ccis/ficlr).
      EXIT.
    ENDIF.
  ENDLOOP.

* save to the database
  CLEAR it_inv.
  LOOP AT it_j_3rf_downpay ASSIGNING <fs> WHERE chk_sel = 'X'.

    " create invoice
    IF it_inv IS INITIAL.
      it_inv-mandt     = sy-mandt.
      it_inv-lifnr     = p_lifnr.
      it_inv-kunnr     = p_kunnr.
      it_inv-usnam     = sy-uname.
      it_inv-rate_inv  = g_dp_rate.
      it_inv-dmbtr_inv = g_dp_rate * p_amount.
      it_inv-wrbtr_inv = p_amount.
      it_inv-waers_inv = p_waers.
      it_inv-awkey_inv = g_awkey_inv.
      it_inv-rate_clr  = g_cl_rate.
      IF NOT b_gjahr IS INITIAL.
        it_inv-gjahr_inv = b_gjahr.
      ELSE.
        IF p_clcdat IS INITIAL.
          p_clcdat = sy-datum.
        ENDIF.
        WRITE p_clcdat TO l_dat MM/DD/YYYY.
        it_inv-gjahr_inv = l_dat+6(4). " extract year
      ENDIF.
      it_inv-bukrs_inv = p_bukrs.

*      " auto clearing options
*      it_inv-clr_auto  = 'X'.
*      it_inv-clr_blart = b_blart.
*      it_inv-clr_rstgr = b_rstgr.
*      it_inv-clr_part  = pa_prpay.
*      IF automode CA gc_auto_mode_sel. " if selection from SD
*        it_inv-clr_auto = p_clear.    " then use customer selection
*      ENDIF.

      APPEND it_inv.
    ENDIF.

    CLEAR it_dp.
    it_dp-mandt     = sy-mandt.
    it_dp-lifnr     = p_lifnr.
    it_dp-kunnr     = p_kunnr.
    it_dp-bukrs     = <fs>-bukrs.
    it_dp-gjahr     = <fs>-gjahr.
    it_dp-belnr_pay = <fs>-belnr.
    it_dp-buzei_pay = <fs>-buzei.
    it_dp-rate_pay  = <fs>-rate_pay.
    it_dp-chk_part  = <fs>-chk_part.

    IF <fs>-chk_part NE 'X'.
      it_dp-dmbtr = <fs>-dmbtr.
      it_dp-wrbtr = <fs>-wrbtr_inv.
    ELSE.
      it_dp-wrbtr = g_dp_partial.
      IF <fs>-wrbtr_inv > 0.
        it_dp-dmbtr = ( it_dp-wrbtr / <fs>-wrbtr_inv ) * <fs>-dmbtr.
      ENDIF.
    ENDIF.

    APPEND it_dp.

  ENDLOOP.

  CHECK LINES( it_inv ) > 0 AND LINES( it_dp ) > 0.

* if this customer/vendor exist then delete records for SD
  IF automode EQ gc_auto_mode_sd.
    PERFORM db_clear_down_payments USING p_lifnr p_kunnr.
  ENDIF.

  IF automode NE gc_auto_mode_mm.
*   save to the database (except MM)
  INSERT j_3rfin_rate_clc FROM TABLE it_inv.
  INSERT j_3rfpm_rate_clc FROM TABLE it_dp.

*   refresh the grid
    PERFORM refresh_grid USING rs_selfield.
  ELSE.
*   MM - update list
    DELETE it_j_3rf_downpay WHERE chk_sel NE 'X'.
    REFRESH: it_j_3rf_invoice.
    LOOP AT it_inv.
      MOVE-CORRESPONDING it_inv TO it_j_3rf_invoice."#EC ENHOK
      APPEND it_j_3rf_invoice.
    ENDLOOP.
  ENDIF.

* clear memory
  REFRESH: it_inv, it_dp.

* for selection from SD/MM - close the form
  IF automode CA gc_auto_mode_sel.
    CLEAR g_loop.
    rs_selfield-exit = 'X'.
  ENDIF.

ENDFORM.                    "okcode_save

*&---------------------------------------------------------------------*
*&      Form  okcode_reset
*&---------------------------------------------------------------------*
*       Delete down payments from the temporary table
*----------------------------------------------------------------------*
FORM okcode_reset USING rs_selfield TYPE slis_selfield.

* delete from database
  PERFORM db_clear_down_payments USING p_lifnr p_kunnr.

*  refresh the grid
  PERFORM refresh_grid USING rs_selfield.
ENDFORM.                    "okcode_reset

*&---------------------------------------------------------------------*
*&      Form  clear_invoice
*&---------------------------------------------------------------------*
*       clear down payments with invoice
*----------------------------------------------------------------------*
*  if is_dialog = 'X' then the routine is called from dialog
*----------------------------------------------------------------------*
FORM clear_invoice
  USING is_dialog TYPE c.

*  DATA: p_type        TYPE c,
*        p_code        LIKE selposgr-kunnr,
*        rs_selfield   TYPE slis_selfield,
*        l_belnr       TYPE bkpf-belnr,
*        l_belnr1      TYPE bkpf-belnr,
*        l_cleared     TYPE c,
*        l_cancelled   TYPE c,
*        it_pos        TYPE j3rc_tt_selpos WITH HEADER LINE,
*        l_group       LIKE procpos-group,
*        it_log_result TYPE t_log_result WITH HEADER LINE,
*        l_belnr_pay   TYPE bkpf-belnr,
*        l_batch_cnt   TYPE i.
*
*  IF NOT p_lifnr IS INITIAL.
*    p_type = gc_creditor.    " transaction to clear vendor
*    p_code = p_lifnr.
*  ELSEIF NOT p_kunnr IS INITIAL.
*    p_type = gc_debtor.    " transaction to clear customer
*    p_code = p_kunnr.
*  ELSE.
*    EXIT.
*  ENDIF.
*
*  IF b_blart IS INITIAL.
*    b_blart = 'AB'.
*  ENDIF.
*  PERFORM check_rstgr CHANGING b_rstgr.
*  IF b_rstgr IS INITIAL.
*    b_rstgr = '055'.
*  ENDIF.
*
*  REFRESH it_log_result.
*
** if it_j_3rf_invoice contains record then use rates from table
*  READ TABLE it_j_3rf_invoice INDEX 1.
*  IF sy-subrc EQ 0.
*    IF it_j_3rf_invoice-wrbtr_inv = g_dp_amount AND
*       it_j_3rf_invoice-waers_inv = p_waers     AND
*       NOT it_j_3rf_invoice-rate_inv IS INITIAL AND
*       NOT it_j_3rf_invoice-rate_clr IS INITIAL.
*
*      g_dp_rate = it_j_3rf_invoice-rate_inv.
*      g_cl_rate = it_j_3rf_invoice-rate_clr.
*
*    ENDIF.
*  ENDIF.
*
** check if the invoice is already cleared
*  PERFORM is_doc_cleared
*     USING    b_inv b_gjahr '000'
*     CHANGING l_cleared l_cancelled.
*  IF l_cleared = 'X'.
*    g_msg = 'Invoice & is already cleared'(815).
*    REPLACE '&' WITH b_inv INTO g_msg.
*
*    it_log_result-desc = g_msg.
*    APPEND it_log_result TO it_log_result.
*    PERFORM log_clearing_result USING it_log_result[].
*    EXIT.
*  ENDIF.
*  IF l_cancelled = 'X'.
*    g_msg = 'Invoice & is cancelled'(817).
*    REPLACE '&' WITH b_inv INTO g_msg.
*    it_log_result-desc = g_msg.
*    APPEND it_log_result TO it_log_result.
*    PERFORM log_clearing_result USING it_log_result[].
*    EXIT.
*  ENDIF.
*
** check if down payments are already cleared
*  LOOP AT it_j_3rf_downpay.
*    PERFORM is_doc_cleared
*       USING    it_j_3rf_downpay-belnr
*                it_j_3rf_downpay-gjahr
*                it_j_3rf_downpay-buzei
*       CHANGING l_cleared l_cancelled.
*    IF l_cleared = 'X'.
*      g_msg = 'Down payment & is already cleared'(816).
*      REPLACE '&' WITH it_j_3rf_downpay-belnr INTO g_msg.
*      it_log_result-desc = g_msg.
*      APPEND it_log_result TO it_log_result.
*      PERFORM log_clearing_result USING it_log_result[].
*      EXIT.
*    ENDIF.
*    IF l_cancelled = 'X'.
*      g_msg = 'Down payment & is cancelled'(818).
*      REPLACE '&' WITH it_j_3rf_downpay-belnr INTO g_msg.
*      it_log_result-desc = g_msg.
*      APPEND it_log_result TO it_log_result.
*      PERFORM log_clearing_result USING it_log_result[].
*      EXIT.
*    ENDIF.
*  ENDLOOP.
*  CHECK l_cleared NE 'X'.
*
** init vars for J_3RCALD / J_3RCALK
*  PERFORM init_var USING p_type.
*
** build positions list to call J_3RCALD / J_3RCALK
*  PERFORM build_positions CHANGING it_pos[].
*
** delete selected down payments to avoid infinite loop
*  PERFORM db_clear_down_payments USING p_lifnr p_kunnr.
*
** process positions
*  DO.
*    " read positions to call clearing transaction
*    READ TABLE it_pos INTO it_pos INDEX 1.
*    IF NOT sy-subrc IS INITIAL.
*      EXIT.
*    ENDIF.
*
*    CLEAR l_belnr_pay.
*    l_group   = it_pos-group.
*    g_cl_rate = g_dp_rate.
*    REFRESH procpos.
*    LOOP AT it_pos WHERE group = l_group.
*      CLEAR it_pos-group.
*      APPEND it_pos TO procpos.
*      IF it_pos-UMSKS = 'A'.   " down payment
*       l_belnr_pay = it_pos-belnr.
*       g_cl_rate   = it_pos-kursf. " use payment rate
*     ENDIF.
*    ENDLOOP.
*    DELETE it_pos WHERE group = l_group.
*    IF procpos[] IS INITIAL.
*      EXIT.
*    ENDIF.
*
**   start batch session
*  IF b_name IS INITIAL.
*    b_name = sy-repid.
*  ENDIF.
*    binp_name = b_name.
*    IF STRLEN( binp_name ) > 10.
*      binp_name = binp_name(10).
*    ENDIF.
*    CONCATENATE binp_name l_group+4 INTO binp_name.
*
**   save BELNR
*    GET PARAMETER ID 'BLN' FIELD l_belnr1.
*
**   ERP 2005 and newer
*    PERFORM start_processing
*        USING b_input binp_name
*        CHANGING d01_flag.
*
**    ERP 2004 and older
**    IF b_input EQ 'X'.
**      perform open_group
**          using binp_name
**          changing g_batch_open.
**    ENDIF.
*
*  PERFORM call_processing
*    USING p_type
*          p_code
*          p_bukrs
*          g_cl_rate  "g_dp_rate
*          b_budat
*          p_amount
*          g_dp_amount
*          '1'
*          '0'.
*
**   close session for ERP 2004 and older
*    IF g_batch_open = gc_true.
*      CLEAR g_batch_open.
*    CALL FUNCTION 'BDC_CLOSE_GROUP'
*      EXCEPTIONS
*        not_open    = 1
*        queue_error = 2
*        OTHERS      = 3.
*    IF NOT sy-subrc IS INITIAL.
*      MESSAGE e022(/ccis/ficlr).
*    ENDIF.
*  ENDIF.
*
**   close session for ERP 2005 and newer
*    IF d01_flag EQ '1'.
*      d01_flag = '0'.
*
*    CALL FUNCTION 'POSTING_INTERFACE_END'
*      EXCEPTIONS
*        session_not_processable = 1
*        OTHERS                  = 2.
*
*    IF NOT sy-subrc IS INITIAL.
*      MESSAGE w022(/ccis/ficlr).
*    ENDIF.
*  ENDIF.
*
*  IF x_call EQ 'X'.
*      CLEAR it_log_result.
*      GET PARAMETER ID 'BLN' FIELD l_belnr.
*      IF sy-subrc EQ 0 AND l_belnr1 <> l_belnr.
*        it_log_result-success   = 'X'.
*        it_log_result-batch     = ' '.
*        it_log_result-desc      = l_belnr.
*        it_log_result-belnr_pay = l_belnr_pay.
*      ELSE.
*        it_log_result-success   = ' '.
*        it_log_result-batch     = 'X'.
*        it_log_result-desc      = ' '.
*        it_log_result-belnr_pay = l_belnr_pay.
*        l_batch_cnt = l_batch_cnt + 1.
*      ENDIF.
*      APPEND it_log_result TO it_log_result.
*
*    ELSEIF b_input EQ 'X'.
*      " log result to the screen
*      g_msg = text-809.
*      CONDENSE g_msg.
*      WRITE: / g_msg, '-', binp_name.
*      l_batch_cnt = l_batch_cnt + 1.
*    ENDIF.
*
*  ENDDO.
*
** when several payments are cleared in batch input,
** then invoice should be cleared manually
*  IF l_batch_cnt > 1 AND x_call IS INITIAL.
*    ULINE.
*    WRITE: / text-819.
*  ENDIF.
*
*  IF NOT it_log_result[] IS INITIAL.
*    PERFORM log_clearing_result USING it_log_result[].
*  ENDIF.

ENDFORM.                    "clear_invoice

*&---------------------------------------------------------------------*
*&      Form  build_positions
*&---------------------------------------------------------------------*
*  Build positions list to call J_3RCALD / J_3RCALK
*  The read_invoice() should be called to initiate global variables
*  before this routine.
*----------------------------------------------------------------------*
FORM build_positions
  CHANGING it_pos TYPE j3rc_tt_selpos.

*  DATA: pay_amount TYPE bseg-wrbtr, " amount of selected down payments
*        v          TYPE bseg-wrbtr, " temporary variable
*        wa_bkpf    TYPE bkpf,
*        amt        TYPE bseg-wrbtr,
*        it_bkpf    TYPE TABLE OF bkpf,
*        it_bseg    TYPE TABLE OF bseg,
*        it_paypos  TYPE j3rc_tt_selpos,
*        it_paybseg TYPE TABLE OF bseg,
*        it_invpos  TYPE j3rc_tt_selpos,
*        l_group    LIKE procpos-group.
*  FIELD-SYMBOLS: <fs_bseg> TYPE bseg,
*                 <fs_pos>  LIKE LINE OF procpos,
*                 <fs_paypos> LIKE LINE OF it_paypos,
*                 <fs_invpos> LIKE LINE OF it_invpos.
*
*  REFRESH: procpos, selposgr.
*  CLEAR  : pay_amount.
*
** read invoice
*  SELECT * FROM bkpf
*    INTO TABLE it_bkpf
*    WHERE bukrs = p_bukrs AND
*          belnr = b_inv   AND
*          gjahr = b_gjahr.
*
*  SELECT * FROM bseg
*    INTO TABLE it_bseg
*    WHERE bukrs = p_bukrs AND
*          belnr = b_inv   AND
*          gjahr = b_gjahr.
*
*  READ TABLE it_bkpf INTO wa_bkpf INDEX 1.
*
*  inv_waer-low = p_waers.  " clearing currency
*
** N1310626: load original payments
*  SELECT * FROM bseg
*    INTO TABLE it_paybseg
*    FOR ALL ENTRIES IN it_j_3rf_downpay
*    WHERE bukrs = it_j_3rf_downpay-bukrs AND
*          belnr = it_j_3rf_downpay-belnr AND
*          gjahr = it_j_3rf_downpay-gjahr AND
*          buzei = it_j_3rf_downpay-buzei.
*  SORT it_paybseg BY bukrs belnr gjahr buzei.
*
** recalculate down payments and partial amount
*  PERFORM calc_down_payments USING p_amount p_clcdat p_clcrat.
*
**  build positions
*  LOOP AT it_j_3rf_downpay.
*    CLEAR procpos.
*    MOVE-CORRESPONDING it_j_3rf_downpay TO procpos.
*
*    procpos-kunnr = p_kunnr.
*    procpos-lifnr = p_lifnr.
*    procpos-dmbtr = it_j_3rf_downpay-dmbtr.
*    procpos-wrbtr = it_j_3rf_downpay-wrbtr_inv.
*    procpos-kursf = it_j_3rf_downpay-rate_pay.
*    procpos-waers = p_waers.
*    procpos-clwrs = p_waers.
*    pay_amount    = pay_amount + procpos-wrbtr.
*
*    procpos-clrng = abs( procpos-wrbtr ). " payment amount
*    IF it_j_3rf_downpay-chk_part = 'X' AND NOT g_dp_partial IS INITIAL.
*      " partial payment
*      procpos-clrng = g_dp_partial. " payment amount
*      pay_amount = pay_amount - procpos-wrbtr + g_dp_partial.
*      procpos-clrng = g_dp_partial.
*    ENDIF.
*
*    "N1310626: restore original payment
*    READ TABLE it_paybseg ASSIGNING <fs_bseg>
*      BINARY SEARCH
*      WITH KEY bukrs = it_j_3rf_downpay-bukrs
*               belnr = it_j_3rf_downpay-belnr
*               gjahr = it_j_3rf_downpay-gjahr
*               buzei = it_j_3rf_downpay-buzei.
*    IF sy-subrc IS INITIAL.
*      IF <fs_bseg>-dmbtr NE procpos-dmbtr.
*        procpos-dmbtr = <fs_bseg>-dmbtr.
*        procpos-wrbtr = <fs_bseg>-wrbtr.
*      ENDIF.
*    ENDIF.
*
*    APPEND procpos TO it_paypos.
*  ENDLOOP.
*
** append all items for invoice, limit invoice to selected down payments
*  CLEAR amt.
*  LOOP AT it_bseg ASSIGNING <fs_bseg>.
*    IF NOT p_kunnr IS INITIAL.
*      CHECK <fs_bseg>-kunnr = p_kunnr.
*    ELSEIF NOT p_lifnr IS INITIAL.
*      CHECK <fs_bseg>-lifnr = p_lifnr.
*    ELSE.
*      EXIT.
*    ENDIF.
*
*    CLEAR procpos.
*    MOVE-CORRESPONDING wa_bkpf   TO procpos.                "#EC ENHOK
*    MOVE-CORRESPONDING <fs_bseg> TO procpos.                "#EC ENHOK
*    procpos-clwrs = p_waers.
*
*    " if currency of the invoice doesn't match to clearing currency then convert
*    IF procpos-waers NE p_waers.
*      " for LC
*      IF p_waers EQ it_rc_t001-waers.
*        procpos-wrbtr = procpos-dmbtr.
*      ELSE.
*        " calculate exchange rate on the invoice date
*        CALL FUNCTION 'CONVERT_TO_FOREIGN_CURRENCY'
*          EXPORTING
*            date             = wa_bkpf-budat
*            foreign_currency = p_waers
*            local_amount     = procpos-dmbtr
*            local_currency   = it_rc_t001-waers
*          IMPORTING
*            foreign_amount   = procpos-wrbtr
*          EXCEPTIONS
*            OTHERS           = 6.
*        IF sy-subrc <> 0.
*          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*             WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*        ENDIF.
*      ENDIF.
*
*      procpos-waers = p_waers. " override currency
*    ENDIF.
*
*    procpos-clrng = abs( procpos-wrbtr ).
*
*    " limit to payed amount
*    v = amt + procpos-wrbtr.
*    IF v > pay_amount.
*      " partial payment amount
*      procpos-clrng = abs( pay_amount - amt ).
*    ENDIF.
*
*    APPEND procpos TO it_invpos.
*
*    IF procpos-difsumma IS INITIAL.
*      amt = amt + procpos-wrbtr.
*    ELSE.
*      amt = amt + ABS( procpos-clrng ).
*    ENDIF.
*  ENDLOOP.
*
** N1307599 - split invoice positions for each payment
** use group to group positions
** sort by amount.
*  SORT it_paypos BY wrbtr.
*  SORT it_invpos BY wrbtr.
*  LOOP AT it_paypos ASSIGNING <fs_paypos>.
*    l_group = sy-tabix.
*    pay_amount = <fs_paypos>-clrng. " payment clearing amount
*
*    " create payment position
*    IF pay_amount <> abs( <fs_paypos>-wrbtr ).
*      " change partial invoice
*      IF pa_remin = 'X'.
*        " residual item
*        <fs_paypos>-difsumma = ABS( <fs_paypos>-wrbtr - pay_amount ).
*        " set negative sign
*        IF procpos-shkzg EQ gc_shkzg_h.
*          <fs_paypos>-difsumma = - <fs_paypos>-difsumma.
*        ENDIF.
*      ELSE.
*        " partial payment
*        <fs_paypos>-difsumma = pay_amount.
*      ENDIF.
*    ENDIF.
*    <fs_paypos>-clrng = pay_amount.
*    <fs_paypos>-group = l_group.
*    <fs_paypos>-umsks = 'A'.  " down payment
*    APPEND <fs_paypos> TO it_pos.
*
*    " process invoice positions
*    LOOP AT it_invpos ASSIGNING <fs_invpos> WHERE clrng > 0.
*      amt = <fs_invpos>-clrng. " invoice clearing amount
*      IF amt > pay_amount.
*        amt = pay_amount. " amount for clearing
*      ENDIF.
*      MOVE-CORRESPONDING <fs_invpos> TO procpos.
*      procpos-clrng = amt.
*      procpos-clwrs = p_waers.
*      IF procpos-wrbtr <> amt.
*         " partial position
*        IF pa_remin = 'X'.
*          " residual item
*          "procpos-difsumma = ABS( procpos-clrng - amt ).
*          procpos-difsumma = ABS( procpos-wrbtr - amt ).
*          " set negative sign
*          IF procpos-shkzg EQ gc_shkzg_h.
*            procpos-difsumma = - procpos-difsumma.
*          ENDIF.
*        ELSE.
*          " partial payment
*          procpos-difsumma = amt.
*        ENDIF.
*        procpos-clrng = amt.
*      ENDIF.
*      procpos-group = l_group.
*      APPEND procpos TO it_pos.
*
*      " subtract cleared amount
*      <fs_invpos>-clrng = <fs_invpos>-clrng - amt.
*      pay_amount        = pay_amount - amt.
*      IF pay_amount <= 0.
*        EXIT. " if payment is assigned then stop the loop
*      ENDIF.
*    ENDLOOP.
*  ENDLOOP.
*
** fill fields
*  LOOP AT it_pos ASSIGNING <fs_pos>.
*    IF <fs_pos>-rebzg EQ space OR
*       <fs_pos>-rebzj EQ space OR
*       <fs_pos>-rebzz EQ space OR
*       <fs_pos>-rebzt = 'V'.
*      <fs_pos>-rebzg = <fs_pos>-belnr.
*      <fs_pos>-rebzz = <fs_pos>-buzei.
*      <fs_pos>-rebzj = <fs_pos>-gjahr.
*    ENDIF.
*  ENDLOOP.

ENDFORM.                    "build_positions

*&---------------------------------------------------------------------*
*&      Form  j_3rf_rate_calc_enabled
*&---------------------------------------------------------------------*
*       Returns pa_enabled='X' when customization in T007K is enabled
*----------------------------------------------------------------------*
*      -->FENABLED   text
*----------------------------------------------------------------------*
FORM j_3rf_rate_calc_enabled
  USING    pa_land    TYPE t007k-land1
  CHANGING pa_enabled TYPE c.

  STATICS: l_enabled TYPE c VALUE '1',
           l_land    TYPE t007k-land1.

  IF l_enabled EQ '1'     OR   " valid values are ' ' or 'X'
     l_land    NE pa_land.

    DATA: wa_t007k TYPE t007k.

    l_land    = pa_land.
    l_enabled = ' '.
    SELECT SINGLE * FROM t007k
      INTO wa_t007k
      WHERE land1   = l_land    AND
            version = gc_t007k_ver_calc.
    IF sy-subrc IS INITIAL.
      l_enabled = 'X'.
    ENDIF.
  ENDIF.
  pa_enabled = l_enabled.
ENDFORM.                    "j_3rf_rate_calc_enabled
*&---------------------------------------------------------------------*
*&      Form  j_3rf_rate_calc_userexit
*&---------------------------------------------------------------------*
*
*  SD part - show dialog, select down payments
*  The routine is called from EXIT_SAPLV60A_001 (BADI enhancement SDVFX009)
*  before the SD invoice is created. The routine allows a user to select
*  down payments and replaces SD document currency rate (xvbrk-kurrf).
*
*----------------------------------------------------------------------*
*      -->XVBRK      invoice header record
*      -->VBRK       invoice header record
*----------------------------------------------------------------------*
FORM j_3rf_rate_calc_userexit
  USING    with_posting TYPE c
           fvbrp        TYPE vbrpvb_t "CR3854 Add
  CHANGING fxvbrk TYPE vbrkvb
           fvbrk  TYPE vbrk.

  DATA: l_valid   TYPE c,
        l_sel_ok  TYPE c,
        l_data_ok TYPE c,
        l_data2_ok type c,
        l_title   TYPE sy-title,    "CR3854 Add
        l_message TYPE char200,     "CR3854 Add
        l_message1 TYPE char200,    "CR3854 Add
        l_konto   TYPE lifnr.

* no dialog for batch inputs and backgrounds
  CHECK sy-binpt IS INITIAL AND sy-batch IS INITIAL.

* should the document be processed?
  PERFORM if_process_sd
     USING    with_posting
              fxvbrk
              fvbrp       " CR3854 ADD
     CHANGING l_valid.

* begin of insert lme001 air21099 for CR1568 - CD1K959568
  IF l_valid <> 'X' AND fxvbrk-bukrs = 'MRUA' AND fxvbrk-fkart = 'Z1F8'.
    l_valid = 'X'.
  ENDIF.
* end of insert lme001
  CHECK l_valid = 'X'.

* skip STORNOs
  CHECK fxvbrk-fksto IS INITIAL.
  CHECK fxvbrk-sfakn IS INITIAL.
  CHECK fxvbrk-vbtyp CA vbtyp_fakt.     " only BILLING
  CHECK fxvbrk-vbtyp NA vbtyp_fakt_sto. " skip STORNO
* N1340757 - now user defines document types
* CHECK fxvbrk-vbtyp NA vbtyp_fakt_gut. " skip CREDIT MEMO
* CHECK fxvbrk-vbtyp NA vbtyp_last.     " skip DEBIT MEMO
* CHECK fxvbrk-vbtyp NA vbtyp_prof.     " skip PROFORMA
* CHECK fxvbrk-fktyp NE 'P'.            " skip DOWN PAYMENTS

* routine works when a new document is created only
  CHECK fxvbrk-belnr IS INITIAL AND NOT fxvbrk-vbeln IS INITIAL.

* initialize global variables
  CLEAR: p_rb_lif, p_lifnr, p_clear.
  p_bukrs  = fxvbrk-bukrs.
  p_rb_kun = 'X'.
  p_kunnr  = fxvbrk-kunrg.
* amount = NET + TAX
  p_amount = fxvbrk-netwr + fxvbrk-mwsbk.
  p_waers  = fxvbrk-waerk.
  p_clcdat = fxvbrk-fkdat.
  bkpf-waers = p_waers. "N1363895 - set currency

* N1363895
  if fxvbrk-vbtyp ca '56' and not fxvbrk-kurst is initial.
    g_kurstyp = fxvbrk-kurst.
  else.
    g_kurstyp = 'M'.
  endif.
  g_dp_rate = fxvbrk-kurrf.

* enable for foreign currencies only
  PERFORM acount_info_fill.
  CHECK ( NOT it_rc_t001-waers IS INITIAL ) AND
        ( it_rc_t001-waers NE p_waers     ).

* check whether the customization is enabled for country
  PERFORM j_3rf_rate_calc_enabled
    USING    it_rc_t001-land1
    CHANGING l_valid.
  CHECK l_valid = 'X'.

* check whether the SD biling type is enabled
  PERFORM if_sd_fkart_enabled
    USING    fxvbrk-fkart
             p_bukrs
    CHANGING l_valid.
  CHECK l_valid = 'X'.

* validate: if the customer/vendor was already locked then
* invoice amount should be matched to the entered value
* when down payments were selected
*  PERFORM check_invoice
*    USING p_bukrs
*          p_lifnr
*          p_kunnr
*          p_amount
*          p_waers
*    CHANGING
*          l_valid
*          g_uname.
*  IF l_valid NE 'X'.
*    " show error, break billing process
*    IF NOT p_lifnr IS INITIAL.
*      l_konto = p_lifnr.
*    ELSE.
*      l_konto = p_kunnr.
*    ENDIF.
*    MESSAGE e115(/ccis/ficlr) WITH l_konto p_bukrs g_uname.
*    EXIT.
*  ENDIF.

  CLEAR p_zuonr.
  IF fxvbrk-zuonr NE fxvbrk-vbeln AND fxvbrk-zuonr(1) NE '$'.
    " ZUONR is filled only when ZUONR is a parameter for automatic clearing
    DATA: l_ktopl TYPE tf123-ktopl.
    SELECT SINGLE ktopl FROM tf123
      INTO l_ktopl
      WHERE ktopl = it_rc_t001-ktopl
        AND ( bedg1 = 'ZUONR' OR
              bedg2 = 'ZUONR' OR
              bedg3 = 'ZUONR' OR
              bedg4 = 'ZUONR' OR
              bedg5 = 'ZUONR' ).
    IF sy-subrc IS INITIAL.
      p_zuonr = fxvbrk-zuonr.
    ENDIF.
  ENDIF.

***BEGIN OF CR3854 ADD***
**Note: This is not actived since popup not only works on downpayments
** 1841035 check open downpayments
*  PERFORM check_open_down_payments USING    p_bukrs
*                                            p_lifnr
*                                            p_kunnr
*                                   CHANGING l_valid.
*  CHECK l_valid = 'X'.

* 1673772 - show confirmation dialog for Billing Plans
  IF g_sd_billing_plan = 'X'.
    l_title = sy-title.
    MESSAGE s118(/ccis/ficlr) INTO l_message1.
    MESSAGE s119(/ccis/ficlr) INTO l_message.
    CONCATENATE l_message1 l_message
      INTO l_message SEPARATED BY SPACE.
    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar              = l_title
        text_question         = l_message
        display_cancel_button = ' '
      IMPORTING
        answer                = l_sel_ok.
    IF l_sel_ok <> '1'.
*     Cancel is clicked - abort processing
      MESSAGE e342(F5).
    ENDIF.
  ENDIF.
***END OF CR3854 ADD****
* call the screen to select down payments
  automode = gc_auto_mode_sd.
*  p_clear  = 'X'. " clearing by default
  DO.
    CLEAR: l_sel_ok, l_data_ok.

    " call selection screen
    PERFORM show_selection  CHANGING l_sel_ok.
    IF l_sel_ok IS INITIAL.
      EXIT.
    ENDIF.

    PERFORM start_selection CHANGING l_data_ok.
    IF l_data_ok EQ 'X'.
      PERFORM end_selection CHANGING g_data_back.
      IF g_data_back EQ 'X'.
        CONTINUE.
      ENDIF.
      EXIT.
    else.
*.... call the screen to manipulate exchange rate
      clear: l_sel_ok, l_data2_ok.
      perform show_selection_2 changing l_sel_ok.
      IF l_sel_ok IS INITIAL.
        EXIT.
      ENDIF.

      PERFORM start_selection_2 CHANGING l_data2_ok.
      IF l_data2_ok EQ 'X'.
        PERFORM end_selection_2 CHANGING g_data_back.
        IF g_data_back EQ 'X'.
          CONTINUE.
        ENDIF.
        exit.
      endif.
    ENDIF.
  ENDDO.

* CHECK NOT l_data_ok IS INITIAL.
  if not l_data_ok is initial.

* get list of down payments
  PERFORM get_down_payments
    TABLES p_belnr
           p_budat
           p_bldat
           p_umskz
    USING  p_bukrs
           p_lifnr
           p_kunnr
           p_zuonr
           p_gsber
           p_waers
           p_pwaers
           p_blart
           p_xref2
  .

  IF LINES( it_j_3rf_downpay ) > 0.
    " validate that there are selected payments
    READ TABLE it_j_3rf_downpay WITH KEY chk_sel = 'X'.
    IF sy-subrc IS INITIAL.
      PERFORM calc_down_payments USING p_amount p_clcdat p_clcrat.

      IF NOT g_dp_rate IS INITIAL.
        " check back rates
        IF fxvbrk-kurrf < 0.
          g_dp_rate = - ( c_round_mul / g_dp_rate ) / c_round_mul.
        ENDIF.

        " change currency rate in SD document
        fxvbrk-kurrf = g_dp_rate.
        fvbrk-kurrf  = fxvbrk-kurrf.
      ENDIF.
    ENDIF.
  ENDIF.

  else.
*   IF NOT g_dp_rate IS INITIAL.
    " change currency rate in SD document
    if not p_invdat is initial.
      fxvbrk-kurrf = g_dp_rate.
      fvbrk-kurrf  = fxvbrk-kurrf.
    else.
      fxvbrk-kurrf = p_clcrat.
      fvbrk-kurrf  = fxvbrk-kurrf.
    ENDIF.
  endif.


ENDFORM.                    "j_3rf_rate_calc_userexit


*&---------------------------------------------------------------------*
*&      Form  check_partner
*&---------------------------------------------------------------------*
*       Validate if PBU3 logic is applied for OPEN-FI calls,
*       check whether the partner is locked
*----------------------------------------------------------------------*
*  Input:
*      -->T_BKPF     - document header
*      -->T_BSEG     - document positions
*      -->pa_chk_clr TYPE - if X then check for clearing
* Output
*      <--pa_valid: 0 - valid, no process,
*                   1 - valid, process
*                   2 - invalid (i.e. partner is locked)
*----------------------------------------------------------------------*
FORM check_partner
  TABLES   t_bkpf     STRUCTURE  bkpf
           t_bseg     STRUCTURE  bseg
  USING    pa_chk_clr TYPE c  " if X then check for clearing
  CHANGING pa_valid   TYPE i.

  DATA:          l_amount   TYPE bseg-wrbtr,
                 l_amount_h TYPE bseg-wrbtr,
                 l_amount_s TYPE bseg-wrbtr,
                 l_enabled  TYPE c,
                 l_payment  TYPE c.
  FIELD-SYMBOLS: <fs_bkpf> TYPE bkpf,
                 <fs_bseg> TYPE bseg.

  pa_valid = 0.

*  skip batch inputs
  CHECK sy-binpt IS INITIAL.

* skip STORNO transactions
  CHECK sy-tcode NE 'VF11'.

* N1385729: detect processed document
  IF LINES( t_bkpf ) > 1.
    DATA: wa_t001 TYPE t001.
    " when there are several documents then leave only
    " document with foreign currency
    LOOP AT t_bkpf ASSIGNING <fs_bkpf>.
      CALL FUNCTION 'FI_COMPANY_CODE_DATA'
        EXPORTING i_bukrs = <fs_bkpf>-bukrs
        IMPORTING e_t001  = wa_t001.
      IF <fs_bkpf>-waers = wa_t001-waers.
        CLEAR <fs_bkpf>-bukrs.
      ENDIF.
    ENDLOOP.
    DELETE t_bkpf WHERE bukrs IS INITIAL.
  ENDIF.
* end of N1385729

  CHECK LINES( t_bkpf ) > 0.

* read BKPF
  READ TABLE t_bkpf ASSIGNING <fs_bkpf> INDEX 1.
*  we need valid document number for clearing
  IF pa_chk_clr EQ 'X'.
    CHECK NOT <fs_bkpf>-belnr IS INITIAL.
    CHECK <fs_bkpf>-belnr(1) NE '$'.
  ENDIF.
* reference to SD invoice for auto clearing from SD only
  g_awkey_inv = <fs_bkpf>-awkey(10).
  IF NOT g_awkey_inv IS INITIAL.
    g_awkey_inv = <fs_bkpf>-awkey.
  ENDIF.
*  CHECK NOT g_awkey_inv IS INITIAL.

  p_bukrs  = <fs_bkpf>-bukrs.
  p_waers  = <fs_bkpf>-waers.
  p_clcdat = <fs_bkpf>-budat.
  b_gjahr  = <fs_bkpf>-gjahr.

* clearance for foreign currencies only
  PERFORM acount_info_fill.
  CHECK ( NOT it_rc_t001-waers IS INITIAL ).
* do not lock partner for LC payments
  CHECK ( it_rc_t001-waers NE p_waers ).

* check whether the customization is enabled for country
  PERFORM j_3rf_rate_calc_enabled
    USING    it_rc_t001-land1
    CHANGING l_enabled.
  CHECK l_enabled = 'X'.

* get debitor or creditor from the document
  CLEAR: p_rb_lif, p_rb_kun, p_lifnr, p_kunnr.
  CLEAR: l_amount, l_amount_h, l_amount_s, l_payment.
  LOOP AT t_bseg ASSIGNING <fs_bseg>.
    CHECK <fs_bseg>-bukrs = <fs_bkpf>-bukrs. "N1385729
    CHECK <fs_bseg>-ktosl NE 'BUV'.
    IF <fs_bseg>-koart = gc_koart_d AND NOT <fs_bseg>-kunnr IS INITIAL.
      p_kunnr  = <fs_bseg>-kunnr.
      l_amount = l_amount + <fs_bseg>-wrbtr.
    ELSEIF <fs_bseg>-koart = gc_koart_k AND NOT <fs_bseg>-lifnr IS INITIAL.
      p_lifnr  = <fs_bseg>-lifnr.
      l_amount = l_amount + <fs_bseg>-wrbtr.
    ENDIF.

    IF <fs_bseg>-koart = gc_koart_d OR
       <fs_bseg>-koart = gc_koart_k.
      IF <fs_bseg>-shkzg EQ gc_shkzg_h.
        l_amount_h = l_amount_h + <fs_bseg>-wrbtr.
      ELSE.
        l_amount_s = l_amount_s + <fs_bseg>-wrbtr.
      ENDIF.
    ENDIF.

    IF <fs_bseg>-umskz = 'A' OR <fs_bseg>-xzahl = 'X'.
      l_payment = 'X'.
    ENDIF.

  ENDLOOP.

* ignore payments
  CHECK l_payment IS INITIAL.

* validate - only debitor OR creditor is allowed
  CHECK ( p_kunnr IS INITIAL AND NOT p_lifnr IS INITIAL ) OR
        ( NOT p_kunnr IS INITIAL AND p_lifnr IS INITIAL ).
  IF NOT p_kunnr IS INITIAL.
    p_rb_kun = 'X'.
  ELSE.
    p_rb_lif = 'X'.
  ENDIF.

* validate - only debit OR credit is allowed
  CHECK ( l_amount_h IS INITIAL ) OR ( l_amount_s IS INITIAL ).
  CHECK ( NOT l_amount IS INITIAL ).

* validate invoice
  PERFORM down_payments_locked
    USING
       p_lifnr
       p_kunnr
    CHANGING
       g_locked
       p_amount
       p_waers
       g_uname.

  CHECK g_locked EQ 'X'.

* get list of down payments
  PERFORM get_down_payments
    TABLES p_belnr
           p_budat
           p_bldat
           p_umskz
    USING  p_bukrs
           p_lifnr
           p_kunnr
           p_zuonr
           p_gsber
           p_waers
           p_pwaers
           p_blart
           p_xref2.

  CHECK LINES( it_j_3rf_invoice ) > 0 AND
        LINES( it_j_3rf_downpay ) > 0.

* read invoice information
  READ TABLE it_j_3rf_invoice INDEX 1.

* is clearing enabled
  CHECK it_j_3rf_invoice-clr_auto EQ 'X'.

  pa_valid = 2. " set to invalid state

* validate SD document number
  READ TABLE it_j_3rf_invoice INDEX 1.
  IF NOT it_j_3rf_invoice-awkey_inv IS INITIAL.
    CHECK it_j_3rf_invoice-awkey_inv EQ <fs_bkpf>-awkey.
  ENDIF.

* validate invoice currency and amount
  CHECK it_j_3rf_invoice-waers_inv EQ <fs_bkpf>-waers.
  CHECK it_j_3rf_invoice-wrbtr_inv EQ l_amount.

  pa_valid = 0. " valid, skip

* clearing is enabled for FC currencies
  IF it_rc_t001-waers NE p_waers.
    pa_valid = 1. " valid to process
  ENDIF.

ENDFORM.                    "check_partner

*&---------------------------------------------------------------------*
*&      Form  j_3rf_rate_calc_badi_1025
*&---------------------------------------------------------------------*
*
*  Check whether the partner is locked. If partner is locked then the
*  warning message is shown and billing process is aborted.
*
*----------------------------------------------------------------------*
FORM j_3rf_rate_calc_badi_1025
  TABLES
    t_ausz1 STRUCTURE  ausz1
    t_ausz2 STRUCTURE  ausz2
    t_ausz3 STRUCTURE  ausz_clr
    t_bkp1  STRUCTURE  bkp1
    t_bkpf  STRUCTURE  bkpf
    t_bsec  STRUCTURE  bsec
    t_bsed  STRUCTURE  bsed
    t_bseg  STRUCTURE  bseg
    t_bset  STRUCTURE  bset
    t_bseu  STRUCTURE  bseu.

  DATA         : l_valid  TYPE i,
                 l_konto  TYPE string.
  DATA         : lt_bkpf  TYPE bkpf_t.

  lt_bkpf = t_bkpf[].  "N1385729
  PERFORM check_partner
     TABLES   lt_bkpf t_bseg
     USING    space
     CHANGING l_valid.

  " invalid transaction, show error, cancel billing process
  IF l_valid EQ 2.
    IF NOT p_lifnr IS INITIAL.
      l_konto = p_lifnr.
    ELSE.
      l_konto = p_kunnr.
    ENDIF.
    MESSAGE e115(/ccis/ficlr) WITH l_konto p_bukrs g_uname.
  ENDIF.

ENDFORM.                    "j_3rf_rate_calc_badi_1025

*&---------------------------------------------------------------------*
*&      Form  j_3rf_rate_calc_badi_1030
*&---------------------------------------------------------------------*
*
*  SD/MM part - clear down payments selected in j_3rf_rate_calc_userexit
*  with invoice
*
*----------------------------------------------------------------------*
FORM j_3rf_rate_calc_badi_1030
  TABLES t_bkp1 STRUCTURE  bkp1
         t_bkpf STRUCTURE  bkpf
         t_bsec STRUCTURE  bsec
         t_bsed STRUCTURE  bsed
         t_bseg STRUCTURE  bseg
         t_bset STRUCTURE  bset
         t_bseu STRUCTURE  bseu.

  PERFORM j_3rf_rate_calc_badi_1050
    TABLES t_bkp1
           t_bkpf
           t_bsec
           t_bsed
           t_bseg
           t_bset
           t_bseu.

ENDFORM.                    "j_3rf_rate_calc_badi_1030
*&---------------------------------------------------------------------*
*&      Form  j_3rf_rate_calc_badi_1050
*&---------------------------------------------------------------------*
*
*  SD/MM part - clear down payments selected in j_3rf_rate_calc_userexit
*  with invoice
*
*----------------------------------------------------------------------*
FORM j_3rf_rate_calc_badi_1050
  TABLES
      t_bkp1 STRUCTURE  bkp1
      t_bkpf STRUCTURE  bkpf
      t_bsec STRUCTURE  bsec
      t_bsed STRUCTURE  bsed
      t_bseg STRUCTURE  bseg
      t_bset STRUCTURE  bset
      t_bseu STRUCTURE  bseu.

  DATA         : l_valid  TYPE i.
  FIELD-SYMBOLS: <fs_bkpf> TYPE bkpf.
  DATA         : lt_bkpf   TYPE bkpf_t.

  lt_bkpf = t_bkpf[].  "N1385729
  PERFORM check_partner
     TABLES   lt_bkpf t_bseg
     USING    'X'
     CHANGING l_valid.
  CHECK l_valid EQ 1.

  READ TABLE lt_bkpf INDEX 1 ASSIGNING <fs_bkpf>.
  CHECK sy-subrc IS INITIAL.

* everything matches, save invoice number to the database
  UPDATE j_3rfin_rate_clc
    SET belnr_inv = <fs_bkpf>-belnr
        gjahr_inv = <fs_bkpf>-gjahr
        bukrs_inv = <fs_bkpf>-bukrs
    WHERE kunnr = p_kunnr AND
          lifnr = p_lifnr.

  READ TABLE it_j_3rf_invoice INDEX 1.
  IF sy-subrc IS INITIAL.

*   create job to clear down payments
  PERFORM create_job
     USING <fs_bkpf>-bukrs
           <fs_bkpf>-belnr
           <fs_bkpf>-gjahr
           <fs_bkpf>-budat
           it_j_3rf_invoice-clr_blart
           it_j_3rf_invoice-clr_rstgr
           it_j_3rf_invoice-clr_part .

  ENDIF.

ENDFORM.                    "j_3rf_rate_calc_badi_1050

*&---------------------------------------------------------------------*
*&      Form  create_job
*&---------------------------------------------------------------------*
*  Create job to clear invoices and down payments
*  The job is started in a minute and clear all records in
*  J_3RFPM_RATE_CLC where BELNR_INV is filled with invoice number
*  for current user
*----------------------------------------------------------------------*
FORM create_job
  USING p_bukrs TYPE bkpf-bukrs
        p_inv   TYPE bkpf-belnr
        p_gjahr TYPE bkpf-gjahr  " fiscal year of invoice
        p_budat TYPE bkpf-budat  " posting date of clearing document
        p_blart TYPE bkpf-blart
        p_rstgr TYPE df05b-rstgr
        p_part  TYPE c.

  DATA: job_count    LIKE tbtcjob-jobcount,
        job_name(32) TYPE c,
        job_released LIKE btch0000-char1,
        l_remin LIKE j_3rfclopt-j_3rfclrop12,
        l_prpay LIKE j_3rfclopt-j_3rfclrop12.

  CONCATENATE sy-uname sy-datum sy-uzeit
    INTO job_name SEPARATED BY '_'.

  CLEAR: l_remin, l_prpay.
  IF p_part = 'X'.
    l_prpay = 'X'.
  ELSE.
    l_remin = 'X'.
  ENDIF.

  CALL FUNCTION 'JOB_OPEN'
    EXPORTING
      jobname          = job_name
    IMPORTING
      jobcount         = job_count
    EXCEPTIONS
      cant_create_job  = 1
      invalid_job_data = 2
      jobname_missing  = 3
      OTHERS           = 4.

  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  SUBMIT j_3rf_rate_calc
    WITH p_bukrs  = p_bukrs
    WITH p_rb_lif = p_rb_lif
    WITH p_lifnr  = p_lifnr
    WITH p_rb_kun = p_rb_kun
    WITH p_kunnr  = p_kunnr
    WITH p_modclr = 'X'
    WITH x_call   = 'X'      " direct call. if unsuccessful then
    WITH b_input  = space    " batch input will be created
    WITH b_inv    = p_inv
    WITH b_gjahr  = p_gjahr
    WITH b_bldat  = p_budat
    WITH b_budat  = p_budat
    WITH b_blart  = p_blart
    WITH b_rstgr  = p_rstgr
    WITH pa_remin = l_remin
    WITH pa_prpay = l_prpay
    USER sy-uname
    VIA JOB job_name
    NUMBER job_count
    TO SAP-SPOOL
    WITHOUT SPOOL DYNPRO
    AND RETURN.

  CALL FUNCTION 'JOB_CLOSE'
    EXPORTING
      jobcount             = job_count
      jobname              = job_name
      strtimmed            = 'X'
    IMPORTING
      job_was_released     = job_released
    EXCEPTIONS
      cant_start_immediate = 1
      invalid_startdate    = 2
      jobname_missing      = 3
      job_close_failed     = 4
      job_nosteps          = 5
      job_notex            = 6
      lock_failed          = 7
      OTHERS               = 8.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

ENDFORM.                    "create_job

*&---------------------------------------------------------------------*
*&      Form  is_doc_cleared
*&---------------------------------------------------------------------*
*       Returns p_cleared = 'X' when the document is cleared
*               p_cancelled = 'X' when the document is cancelled
*----------------------------------------------------------------------*
*      -->P_BELNR    text
*      -->P_GJAHR    text
*      -->P_BUZEI    text
*      <--P_CLEARED  text
*      <--p_cancelled
*----------------------------------------------------------------------*
FORM is_doc_cleared
  USING    p_belnr TYPE bseg-belnr
           p_gjahr TYPE bseg-gjahr
           p_buzei TYPE bseg-buzei
  CHANGING p_cleared   TYPE c
           p_cancelled TYPE c.

  CLEAR p_cleared.

  DATA: it_bseg TYPE TABLE OF bseg,
        wa_bseg TYPE bseg.

  SELECT * FROM bseg
    INTO TABLE it_bseg
    WHERE bukrs = p_bukrs AND
          belnr = p_belnr AND
          gjahr = p_gjahr AND
          kunnr = p_kunnr AND
          lifnr = p_lifnr AND
          augbl <> ''.
  LOOP AT it_bseg INTO wa_bseg.
    " check cleared position
    IF p_buzei IS INITIAL OR
       p_buzei EQ wa_bseg-buzei.
      p_cleared = 'X'.
    ENDIF.
  ENDLOOP.

ENDFORM.                    "is_doc_cleared

*&---------------------------------------------------------------------*
*&      Form  send_message
*&---------------------------------------------------------------------*
*       send express document to a user
*----------------------------------------------------------------------*
*      -->t_msgs  - table with messages
*      -->p_title - message title
*----------------------------------------------------------------------*
FORM send_message
  TABLES t_msgs STRUCTURE soli
  USING  p_title TYPE string.

  DATA: l_object_type LIKE sood-objtp,
        t_obj_hd_chn  TYPE TABLE OF sood1 WITH HEADER LINE,
        t_obj_head    TYPE TABLE OF soli  WITH HEADER LINE,
        t_raw_head    TYPE TABLE OF sorh  WITH HEADER LINE,
        t_receivers   TYPE TABLE OF soos1 WITH HEADER LINE.

*  message header
  MOVE p_title  TO t_obj_hd_chn-objdes. " Title
  MOVE 'F'      TO t_obj_hd_chn-objsns. " Functional OBJECT
  MOVE sy-langu TO t_obj_hd_chn-objla.  " Language

* Object type of the new document
  MOVE 'RAW' TO l_object_type.

* Specific header (Dependent on the object type, here RAW)
  REFRESH t_obj_head.
  DESCRIBE TABLE t_msgs LINES t_raw_head-rawsiz.
  MOVE t_raw_head TO t_obj_head.
  APPEND t_obj_head.

* send to myself
  REFRESH t_receivers.
  CLEAR   t_receivers.
  MOVE sy-uname TO t_receivers-recnam. " User name
  MOVE 'B' TO t_receivers-recesc.      " Receiver type: "SAP user"
  MOVE 'X' TO t_receivers-sndex.       " express document
  APPEND t_receivers.

* send message
  CALL FUNCTION 'SO_OBJECT_SEND'
    EXPORTING
      object_hd_change = t_obj_hd_chn
      object_type      = l_object_type
      outbox_flag      = ''
      owner            = sy-uname
      store_flag       = space
    TABLES
      objcont          = t_msgs
      objhead          = t_obj_head
      receivers        = t_receivers.

ENDFORM.                    "send_message

*&---------------------------------------------------------------------*
*&      Form  send_notify
*&---------------------------------------------------------------------*
*       send notification message
*----------------------------------------------------------------------*
FORM log_clearing_result
  USING it_log_result TYPE t_log_result.

  DATA: t_msgs  TYPE STANDARD TABLE OF soli WITH HEADER LINE,
        l_title TYPE string,
        p_succ  TYPE c,
        p_fault TYPE c,
        p_batch TYPE c,
        i_batch TYPE i.
  FIELD-SYMBOLS: <fs> LIKE LINE OF it_log_result.

  REFRESH t_msgs.
  CLEAR   t_msgs.

* set
  LOOP AT it_log_result ASSIGNING <fs>.
    IF <fs>-success = 'X'.
      p_succ = 'X'.
    ELSE.
      p_fault = 'X'.
    ENDIF.
    IF <fs>-batch = 'X'.
      p_batch = 'X'.
      i_batch = i_batch + 1.
    ENDIF.
  ENDLOOP.

*  build message body
  IF p_fault IS INITIAL.
    l_title = 'Invoice & has been cleared successfully'(812).
    REPLACE '&' WITH b_inv INTO l_title.
  ELSE.
    l_title = 'Invoice & cannot be cleared.'(808).
    REPLACE '&' WITH b_inv INTO l_title.
  ENDIF.

  IF p_succ = 'X'.
    t_msgs-line = 'Invoice & is cleared automatically with down payments:'(813).
    REPLACE '&' WITH b_inv INTO t_msgs-line.
    APPEND t_msgs.

    LOOP AT it_log_result ASSIGNING <fs> WHERE success = 'X'.
      CONCATENATE '   ' <fs>-belnr_pay ' - ' text-807 INTO t_msgs-line.
      REPLACE '&' WITH <fs>-desc INTO t_msgs-line.
      APPEND t_msgs.
    ENDLOOP.
    APPEND INITIAL LINE TO t_msgs.
  ENDIF.

  IF p_fault = 'X'.
*   message content
    t_msgs-line = 'Invoice & cannot be cleared automatically with down payments:'(814).
    REPLACE '&' WITH b_inv INTO t_msgs-line.
    APPEND t_msgs.
    LOOP AT it_log_result ASSIGNING <fs> WHERE success = ' '.
      IF NOT <fs>-belnr_pay IS INITIAL.
        CONCATENATE '   ' <fs>-belnr_pay INTO t_msgs-line.
        APPEND t_msgs.
      ENDIF.
      IF NOT <fs>-desc IS INITIAL.
        t_msgs-line = <fs>-desc.
        APPEND t_msgs.
      ENDIF.
    ENDLOOP.
    APPEND INITIAL LINE TO t_msgs.
    ENDIF.

    IF p_batch = 'X'.
    t_msgs-line = 'Run batch input to clear invoice'(809).
    APPEND t_msgs.
    APPEND INITIAL LINE TO t_msgs.
  ENDIF.

* if several batch inputs are created then invoice should be cleared manually
  IF i_batch > 1.
    t_msgs-line = text-819.
    APPEND t_msgs.
  ENDIF.

* log
  WRITE: / l_title.
  SKIP.
  LOOP AT t_msgs.
    WRITE: / t_msgs-line.
  ENDLOOP.

* send message for job or background
  IF automode CA gc_auto_mode_sel OR g_bkgrnd = 'X'.
    PERFORM send_message
       TABLES t_msgs
       USING  l_title.
  ENDIF.

ENDFORM.                    "send_notify

*&---------------------------------------------------------------------*
*&      Form  check_job
*&---------------------------------------------------------------------*
*       When the program is started from the job then check
*       that the record in BKPF is created
*----------------------------------------------------------------------*
FORM check_job.

*  DATA: l_belnr TYPE bkpf-belnr,
*        l_found TYPE c.
*
**  for background run only
*  CHECK g_bkgrnd = 'X'.
*
** invoice information is required
*  CHECK NOT p_bukrs  IS INITIAL AND
*        NOT p_modclr IS INITIAL AND
*        NOT x_call   IS INITIAL AND
*        NOT b_inv    IS INITIAL AND
*        NOT b_gjahr  IS INITIAL.
*
** delay up to 20 secs
*  DO 20 TIMES.
*    SELECT SINGLE belnr FROM bkpf
*      INTO l_belnr
*      WHERE BUKRS = p_bukrs AND
*            BELNR = b_inv   AND
*            GJAHR = b_gjahr.
*    IF sy-subrc IS INITIAL.
*      " read bseg
*      SELECT SINGLE belnr FROM bseg
*        INTO l_belnr
*        WHERE BUKRS = p_bukrs AND
*              BELNR = b_inv   AND
*              GJAHR = b_gjahr.
*    ENDIF.
*
*    IF sy-subrc IS INITIAL.
*      l_found = 'X'.
*      EXIT.
*    ENDIF.
*
*    WAIT UP TO 1 SECONDS.
*
*  ENDDO.
*
*  IF l_found IS INITIAL.
*    MESSAGE s114(/ccis/ficlr) WITH b_inv.
*    " log for background job
*    MESSAGE s114(/ccis/ficlr) WITH b_inv INTO g_msg .
*    WRITE: / g_msg.
*  ENDIF.

ENDFORM.                    "check_job

*&---------------------------------------------------------------------*
*&      Form  if_process_sd
*&---------------------------------------------------------------------*
*       Returns pa_enabled='X' when SD document should be processed
*----------------------------------------------------------------------*
*      <-- with_posting - posting type
*      <-- fxvbrk       - SD document
*      --> pa_enabled   - result
*----------------------------------------------------------------------*
FORM if_process_sd
  USING    with_posting TYPE c
           fxvbrk       TYPE vbrkvb
           fvbrp        TYPE vbrpvb_t "CR3854 ADD
  CHANGING pa_enabled TYPE c.
***********CR3854 ADD BEGIN *****
  CONSTANTS:
        lc_fareg_downpayment(2) TYPE c VALUE '45'.
  DATA: ls_vbrp   TYPE vbrpvb.
***********CR3854 ADD END   *****
  DATA: l_rfbsk   TYPE vbrkvb-rfbsk.

* check validity of the SD document
  l_rfbsk = fxvbrk-rfbsk.
  IF l_rfbsk CA 'FGN'.
    l_rfbsk = space.
  ENDIF.
  IF l_rfbsk CA ' B'.
    IF fxvbrk-uvprs = 'X'.
      l_rfbsk = 'F'.
    ELSEIF fxvbrk-uvals CA 'XY'.
      l_rfbsk = 'G'.
    ENDIF.
  ENDIF.

  CLEAR pa_enabled.

* Comment or uncomment lines 1) or 2) to define valid behaviour
* 1) dialog for "Release to accounting" only
  IF with_posting CA 'ABCDEFH'.
    IF ( l_rfbsk CA ' H' ) OR
       ( l_rfbsk = 'A' AND with_posting = 'H' ).
      pa_enabled = 'X'.
    ENDIF.
  ENDIF.

* 2) dialog when SD document is created only
* IF fxvbrk-vbeln(1) EQ '$'.
*   pa_enabled = 'X'.
* ENDIF.

*******CR3854 ADD BEGIN****
* 1673772 - set flag "Billing Plan"
  CLEAR g_sd_billing_plan.
  IF pa_enabled = 'X'.
    LOOP AT fvbrp INTO ls_vbrp.
      IF ls_vbrp-FAREG CA lc_fareg_downpayment.
        g_sd_billing_plan = 'X'.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.
*******CR3854 ADD END  ****

* 3) or you can enhance the routine here
ENDFORM.                    "if_process_sd

*&---------------------------------------------------------------------*
*&      Form  if_sd_fkart_enabled
*&---------------------------------------------------------------------*
*       Returns pa_enabled='X' when type of SD document is enabled
*----------------------------------------------------------------------*
*      <-- pa_fkart   - SD document type
*      <-- pa_bukrs   - company code
*      --> pa_enabled - result
*----------------------------------------------------------------------*
FORM if_sd_fkart_enabled
  USING    pa_fkart   TYPE FKART
           pa_bukrs   TYPE BUKRS
  CHANGING pa_enabled TYPE c.

  DATA: wa TYPE J_3RFSD_RATE_CLC.

  CLEAR pa_enabled.

  SELECT SINGLE * FROM J_3RFSD_RATE_CLC
    INTO wa
    WHERE ( bukrs = pa_bukrs and fkart = pa_fkart ) or
          ( bukrs = ''       and fkart = pa_fkart ) or
          ( bukrs = pa_bukrs and fkart = '' ).
  IF sy-subrc IS INITIAL.
    pa_enabled = 'X'.
  ENDIF.

ENDFORM.                    "if_sd_fkart_enabled

************************************************************************
*                               MM routines
************************************************************************

*&---------------------------------------------------------------------*
*&      Form  j_3rf_rate_calc_mm_fcobu
*&---------------------------------------------------------------------*
*
*  The routine is called before the MM invoice is created.
*  The routine allows a user to select down payments and replaces MM
*  document currency rate (rbkpv-kursf and it_drseg-kursf).
*
*----------------------------------------------------------------------*
*      -->rbkpv      invoice header
*      -->it_drseg   invoice positions
*----------------------------------------------------------------------*
FORM j_3rf_rate_calc_mm_fcobu
  CHANGING rbkpv    TYPE mrm_rbkpv
           it_drseg TYPE mmcr_tdrseg.

  DATA: l_valid   TYPE c,
        l_sel_ok  TYPE c,
        l_data_ok TYPE c,
        l_konto   TYPE lifnr,
        l_abend   TYPE i,
        l_error   TYPE i.
  FIELD-SYMBOLS: <fs_drseg> LIKE LINE OF it_drseg.

* no dialog for batch inputs and backgrounds
  CHECK sy-binpt IS INITIAL AND sy-batch IS INITIAL.

* skip STORNOs
  CHECK rbkpv-stblg IS INITIAL.

* should the MM document be processed?
  PERFORM if_process_mm
     USING    rbkpv
              it_drseg
     CHANGING l_valid.
  CHECK l_valid = 'X'.

* check for error messages
  CALL FUNCTION 'MRM_PROT_ANALYSE'
     EXPORTING
        i_rblgp = 0
     IMPORTING
        e_abend = l_abend
        e_error = l_error.
* check for errors
* CHECK l_abend EQ 0 AND l_error EQ 0.

* did we already select down payments?
  PERFORM if_mm_selected
     USING    rbkpv
              it_drseg
     CHANGING l_valid.
  CHECK l_valid IS INITIAL. " do not reselect

  REFRESH: it_j_3rf_invoice[], it_j_3rf_downpay[].

* initialize global variables
  CLEAR: p_rb_lif, p_lifnr, p_clear.
  p_bukrs  = rbkpv-bukrs.
  p_rb_lif = 'X'.
  p_lifnr  = rbkpv-lifnr.
  p_amount = rbkpv-rmwwr.
  p_waers  = rbkpv-waers.
  p_clcdat = rbkpv-budat.
  bkpf-waers = p_waers. "N1363895 - set currency
  CLEAR g_awkey_inv.

* check invoice amount and currency
  CHECK p_amount NE '0.00' AND
        p_waers  NE space.

* read Type for Determining the Proposed Rate
  clear g_kurstyp.
  select single kurst from t003 into g_kurstyp
                      where blart = rbkpv-blart.
  if sy-subrc ne 0.
    g_kurstyp = 'M'.
  endif.
  g_dp_rate = rbkpv-kursf.

* enable for foreign currencies only
  PERFORM acount_info_fill.
  CHECK ( NOT it_rc_t001-waers IS INITIAL ) AND
        ( it_rc_t001-waers NE p_waers     ).

* check whether the customization is enabled for country
  PERFORM j_3rf_rate_calc_enabled
    USING    it_rc_t001-land1
    CHANGING l_valid.
  CHECK l_valid = 'X'.

* check whether the MM Purchase Order type is enabled
  PERFORM if_mm_bsart_enabled
    USING    rbkpv
             it_drseg
    CHANGING l_valid.
  CHECK l_valid = 'X'.

* validate: if the customer/vendor was already locked then
* invoice amount should be matched to the entered value
* when down payments were selected
  PERFORM check_invoice
    USING p_bukrs
          p_lifnr
          p_kunnr
          p_amount
          p_waers
    CHANGING
          l_valid
          g_uname.
  IF l_valid NE 'X'.
    " show error, break billing process
    IF NOT p_lifnr IS INITIAL.
      l_konto = p_lifnr.
    ELSE.
      l_konto = p_kunnr.
    ENDIF.
    MESSAGE e115(/ccis/ficlr) WITH l_konto p_bukrs g_uname.
    EXIT.
  ENDIF.

  CLEAR p_zuonr.
  IF rbkpv-zuonr NE rbkpv-belnr AND rbkpv-zuonr(1) NE '$'.
    " ZUONR is filled only when ZUONR is a parameter for automatic clearing
    DATA: l_ktopl TYPE tf123-ktopl.
    SELECT SINGLE ktopl FROM tf123
      INTO l_ktopl
      WHERE ktopl = it_rc_t001-ktopl
        AND ( bedg1 = 'ZUONR' OR
              bedg2 = 'ZUONR' OR
              bedg3 = 'ZUONR' OR
              bedg4 = 'ZUONR' OR
              bedg5 = 'ZUONR' ).
    IF sy-subrc IS INITIAL.
      p_zuonr = rbkpv-zuonr.
    ENDIF.
  ENDIF.

* call the screen to select down payments
  automode = gc_auto_mode_mm.
  p_clear  = 'X'. " clearing by default
  DO.
    CLEAR: l_sel_ok, l_data_ok.

    " call selection screen
    PERFORM show_selection  CHANGING l_sel_ok.
    IF l_sel_ok IS INITIAL.
      EXIT.
    ENDIF.

    PERFORM start_selection CHANGING l_data_ok.
    IF l_data_ok EQ 'X'.
      PERFORM end_selection CHANGING g_data_back.
      IF g_data_back EQ 'X'.
        CONTINUE.
      ENDIF.
      EXIT.
    ENDIF.
  ENDDO.

  CHECK NOT l_data_ok IS INITIAL.

  IF LINES( it_j_3rf_downpay ) > 0.
    " validate that there are selected payments
    READ TABLE it_j_3rf_downpay
      TRANSPORTING NO FIELDS
      WITH KEY chk_sel = 'X'.
    IF sy-subrc IS INITIAL.
      IF NOT g_dp_rate IS INITIAL.
        " check back rates
        IF rbkpv-kursf < 0.
          g_dp_rate = - ( c_round_mul / g_dp_rate ) / c_round_mul.
        ENDIF.

        " change currency rate in SD document
        rbkpv-kursf = g_dp_rate.
        loop at it_drseg assigning <fs_drseg>.
          <fs_drseg>-kursf = rbkpv-kursf.
        endloop.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    "j_3rf_rate_calc_mm_fcobu

*&---------------------------------------------------------------------*
*&      Form  j_3rf_rate_calc_mm_post
*&---------------------------------------------------------------------*
*
*  The routine is called from function module MRM_INVOICE_POST.
*  The routine locks the partner.
*
*----------------------------------------------------------------------*
*      -->rbkpv      invoice header
*      -->it_drseg   invoice positions
*----------------------------------------------------------------------*
FORM j_3rf_rate_calc_mm_post
  USING rbkpv    TYPE mrm_rbkpv
        it_drseg TYPE mmcr_tdrseg.

  DATA: l_valid     TYPE c,
        rs_selfield TYPE slis_selfield. "dummy variable

* no dialog for batch inputs and backgrounds
  CHECK sy-binpt IS INITIAL AND sy-batch IS INITIAL.

* skip STORNOs
  CHECK rbkpv-stblg IS INITIAL.

* should the MM document be processed?
  PERFORM if_process_mm
     USING    rbkpv
              it_drseg
     CHANGING l_valid.
  CHECK l_valid = 'X'.

* did we already select down payments?
  PERFORM if_mm_selected
     USING    rbkpv
              it_drseg
     CHANGING l_valid.
  CHECK l_valid = 'X'.

* save to the database
  automode = gc_auto_mode_sd.
  PERFORM okcode_save USING rs_selfield.

  REFRESH: it_j_3rf_invoice, it_j_3rf_downpay[].

ENDFORM.                    "j_3rf_rate_calc_mm_post

*&---------------------------------------------------------------------*
*&      Form  if_process_mm
*&---------------------------------------------------------------------*
*       Returns pa_enabled='X' when MM document should be processed
*----------------------------------------------------------------------*
*      <-- pa_rbkpv     - MM document
*      <-- it_drseg     - MM items
*      --> pa_enabled   - result
*----------------------------------------------------------------------*
FORM if_process_mm
  USING    pa_rbkpv   TYPE mrm_rbkpv
           it_drseg   TYPE mmcr_tdrseg
  CHANGING pa_enabled TYPE c.

  DATA: it_bkpf  TYPE bkpf_t,
        wa_bkpf  TYPE bkpf,
        ld_awkey TYPE bkpf-awkey,
        ld_found TYPE c.

  CLEAR pa_enabled.

* Check transaction type
*  CHECK pa_rbkpv-xrech EQ 'X' AND
*        pa_rbkpv-tbtkz = space.
* Transaction types:
*   xrech = ' ' and tbtkz = ' ' - credit note
*   xrech = ' ' and tbtkz = 'X' - subsequent credit
*   xrech = 'X' and tbtkz = ' ' - invoice
*   xrech = 'X' and tbtkz = 'X' - subsequent debit

* Check mode
  CHECK pa_rbkpv-ivtyp NE c_ivtyp_storno  AND
        pa_rbkpv-ivtyp NE c_ivtyp_web     AND
        pa_rbkpv-ivtyp NE c_ivtyp_edi     AND
        pa_rbkpv-ivtyp NE c_ivtyp_ersnull.

* Check invoice status
  CHECK pa_rbkpv-rbstat NE c_rbstat_delete.

* ignore items blocked for payment
* init internal vars
  IF it_008[] IS INITIAL.
*    PERFORM init_var USING gc_creditor.
  ENDIF.
* check blocked reason
  READ TABLE it_008
    INTO wa_008
    WITH KEY ZAHLS = pa_rbkpv-zlspr
    BINARY SEARCH.
  IF sy-subrc NE 0.
    wa_008-XOZSP = SPACE.
  ENDIF.
  CHECK wa_008-XOZSP IS INITIAL.

* if the document is updated check for FI reference
  IF NOT pa_rbkpv-belnr IS INITIAL AND
         pa_rbkpv-belnr(1) NE '$'.

    CONCATENATE pa_rbkpv-belnr pa_rbkpv-gjahr INTO ld_awkey.
    SELECT * FROM bkpf
      INTO CORRESPONDING FIELDS OF TABLE it_bkpf
      WHERE awtyp = c_awtyp_rmrp
        AND awkey = ld_awkey.

    IF sy-subrc IS INITIAL.
*     validate status
      CLEAR ld_found.
      LOOP AT it_bkpf INTO wa_bkpf.
        IF wa_bkpf-bstat NA 'VWZ' AND "ignore Parked documents
           wa_bkpf-bstat NA 'S'.      "ignore Noted items
          ld_found = 'X'.
          EXIT.
        ENDIF.
      ENDLOOP.
*     if FI document is found then not enabled
      CHECK ld_found IS INITIAL.
    ENDIF.
  ENDIF.

  pa_enabled = 'X'.

* you can enhance the routine here
* ...
ENDFORM.                    "if_process_mm

*&---------------------------------------------------------------------*
*&      Form  if_mm_bsart_enabled
*&---------------------------------------------------------------------*
*       Returns pa_enabled='X' when type of MM document is enabled
*----------------------------------------------------------------------*
*      <-- rbkpv      - header
*      <-- it_drseg   - items
*      --> pa_enabled - result
*----------------------------------------------------------------------*
FORM if_mm_bsart_enabled
  USING    rbkpv      TYPE mrm_rbkpv
           it_drseg   TYPE mmcr_tdrseg
  CHANGING pa_enabled TYPE c.

  DATA: wa_drseg TYPE mmcr_drseg,
        wa       TYPE J_3RFMM_RATE_CLC,
        ld_bukrs TYPE bkpf-bukrs.
  DATA: BEGIN OF it_order OCCURS 1, " list of PO
          ebeln TYPE drseg-ebeln,
        END OF it_order.
  DATA: BEGIN OF it_bsart OCCURS 1, " list of PO types
          bsart TYPE ekko-bsart,
        END OF it_bsart,
        it_tmp LIKE it_bsart[]. " temporary table

  CLEAR pa_enabled.

  ld_bukrs = rbkpv-bukrs.

* get POs
  LOOP AT it_drseg INTO wa_drseg.
    it_order-ebeln = wa_drseg-ebeln.
    COLLECT it_order.
  ENDLOOP.

* if order is not found then ignore
  CHECK NOT it_order[] IS INITIAL.

* get PO types
  SELECT bsart FROM ekko
    INTO CORRESPONDING FIELDS OF TABLE it_bsart
    FOR ALL ENTRIES IN it_order
    WHERE ebeln = it_order-ebeln.

  CHECK NOT it_bsart[] IS INITIAL.

* search types
  SELECT bsart FROM J_3RFMM_RATE_CLC
    INTO CORRESPONDING FIELDS OF TABLE it_tmp
    FOR ALL ENTRIES IN it_bsart
    WHERE ( bukrs = ld_bukrs and bsart = it_bsart-bsart ) or
          ( bukrs = ''       and bsart = it_bsart-bsart ) or
          ( bukrs = ld_bukrs and bsart = '' ).
  IF sy-subrc IS INITIAL.
    pa_enabled = 'X'.
  ENDIF.

ENDFORM.                    "if_mm_bsart_enabled

*&---------------------------------------------------------------------*
*&      Form  if_mm_selected
*&---------------------------------------------------------------------*
*       Returns pa_selected='X' when down payments were already
*       selected for MM document
*----------------------------------------------------------------------*
*      <-- rbkpv        - MM document
*      <-- it_drseg     - MM items
*      --> pa_selected  - result
*----------------------------------------------------------------------*
FORM if_mm_selected
  USING    rbkpv       TYPE mrm_rbkpv
           it_drseg    TYPE mmcr_tdrseg
  CHANGING pa_selected TYPE c.

  CLEAR pa_selected.

* down payments should be selected
  CHECK NOT it_j_3rf_invoice[] IS INITIAL AND
        NOT it_j_3rf_downpay[] IS INITIAL.
  READ TABLE it_j_3rf_invoice INTO it_j_3rf_invoice INDEX 1.

* validate global variables
  CHECK NOT p_bukrs IS INITIAL                   AND
        p_bukrs     = rbkpv-bukrs                AND
        p_rb_lif    = 'X'                        AND
        p_lifnr     = it_j_3rf_invoice-lifnr     AND
        p_amount    = rbkpv-rmwwr                AND
        p_waers     = rbkpv-waers                AND
        p_amount    = it_j_3rf_invoice-wrbtr_inv AND
        p_waers     = it_j_3rf_invoice-waers_inv AND
        rbkpv-kursf = it_j_3rf_invoice-rate_inv  AND
        rbkpv-kursf = g_dp_rate.

  pa_selected = 'X'.

ENDFORM.                    "if_mm_selected

*Text symbol text
*001:Bill of debt course
*002:Payment course
*029:Clearing in currency
*030:Open items list
*031:Test processing
*032:Batch input
*033:DocumentCreation
*034:Items for clearing
*035:Residual items
*036:With reference to invoice
*037:Partitial payment
*041:Parameter With reference to invoice isn't conform system set
*240:DOC> Geneated clearing document number
*241:BIS> Group items were included into batch input session
*301:one <-> one
*302:many <-> many
*303:a invoice <-> payments
*304:a payment <-> invoices
*700:Down Payment Selection Parameters
*701:Clearing
*702:Call Transaction
*703:Batch Input
*704:Batch Input Session Name
*705:Posting Document Type
*706:Difference Reason
*707:Clearing Posting Date
*708:Posting Period
*709:With Residual Items
*710:With Partial Payment
*711:Invoice Amount / Currency
*712:/
*713:Invoice
*714:Partner Data
*715:Run Mode
*800:Customer:
*801:Vendor:
*802:Selected Down Payments:
*803:Invoice Amount:
*804:Assigned:
*805:Not Assigned:
*806:Average Invoice Exchange Rate:
*807:Generated clearing document number &
*808:Invoice & cannot be cleared.
*809:Run batch input to clear invoice
*810:Exch. Rate for Clearing Down Payts (Not Invoice Posting):
*811:Partner Locked By:
*812:Invoice & has been cleared successfully
*813:Invoice & is cleared automatically with down payments:
*814:Invoice & cannot be cleared automatically with down payments:
*815:Invoice & is already cleared
*816:Down payment & is already cleared
*817:Invoice & is cancelled
*818:Down payment & is cancelled

*819:Clear invoice manually when batch inputs are executed
*Selection text
*B_BLDAT:D       .
*B_GJAHR:D       .
*B_INV:D       .
*P_AMOUNT:D       .
*P_BELNR:D       .
*P_BLART:D       .
*P_BLDAT:D       .
*P_BUDAT:D       .
*P_BUKRS:D       .
*P_CLCDAT:        Invoice Date
*P_CLCRAT:        Exchange Rate
*P_GSBER:D       .
*P_INVDAT:D       .
*P_INVRAT:D       .
*P_KUNNR:D       .
*P_LIFNR:D       .
*P_MODCLR:D       .
*P_MODPAY:D       .
*P_PWAERS:D       .
*P_RB_KUN:        Customer
*P_RB_LIF:        Vendor
*P_UMSKZ:D       .
*P_VARI:D       .
*P_WAERS:D       .
*P_XREF2:D       .
*P_ZUONR:D       .
