*&---------------------------------------------------------------------*
*&  Include           YSE_STOCK_ITEM_FORMS_V2
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&  Include           YSE_STOCK_ITEM_FORMS                             *
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*&      Form  FILL_GAC_PGC_TABLE
*&---------------------------------------------------------------------*
FORM fill_gac_pgc_table.

* Select all level 2 hierarchy codes from the prodh table
  SELECT *
         FROM t179
         INTO TABLE it_t179
        WHERE stufe = '2'.

ENDFORM.                    "fill_gac_pgc_table

*&---------------------------------------------------------------------*
*&      Form  CHECK_GAC_PGC
*&---------------------------------------------------------------------*
FORM  check_gac_pgc.

* Default fields in range
  r_prdha-sign   = 'I'.
  r_prdha-option = 'EQ'.

* Loop over hierarchy codes where the first 4 char's fit in S_GAC
  CLEAR wa_t179-prodh.
  IF NOT s_gac IS INITIAL.
    LOOP AT it_t179 INTO wa_t179 WHERE prodh(4) IN s_gac.
      r_prdha-low = wa_t179-prodh.
      APPEND r_prdha.
    ENDLOOP.
* Show message if s_gac is a non existing gac and therefore no selection is made
    IF wa_t179-prodh IS INITIAL.
      MESSAGE e043.
    ENDIF.
  ENDIF.

* Loop over hierarchy codes where the second 4 char's fit in S_PGC
  CLEAR wa_t179-prodh.
  IF NOT s_pgc IS INITIAL.
    LOOP AT it_t179 INTO wa_t179 WHERE prodh+4(4) IN s_pgc.
      r_prdha-low = wa_t179-prodh.
      APPEND r_prdha.
    ENDLOOP.
* Show message if s_pgc is a non existing gac and therefore no selection is made
    IF wa_t179-prodh IS INITIAL.
      MESSAGE e044.
    ENDIF.
  ENDIF.

ENDFORM.                    "CHECK_GAC_PGC

*&---------------------------------------------------------------------*
*&      Form  get_material_stock
*&---------------------------------------------------------------------*
FORM get_material_stock.


* Select the materials which correspond to most of the selection crit.
  SELECT      a~matnr c~werks d~lgort a~mtart a~matkl c~mmsta a~meins
              a~prdha b~maktx bc~maktx bd~maktx
* Begin of insert MOD-013
              be~maktx
* End of insert MOD-013
              c~dismm d~labst d~insme d~speme d~retme
              d~umlme
* Begin of insert MOD-010
              d~lminb
* End of insert MOD-010
              c~umlmc c~trame c~minbe c~bstfe c~eisbe c~lgrad
              c~plifz c~maxlz c~mmstd c~nfmat c~prctr d~lgpbe
         INTO TABLE it_material
         FROM mara AS a
        INNER JOIN makt AS b
           ON a~matnr = b~matnr
* Begin of insert MOD-010
        INNER JOIN mvke AS m
           ON a~matnr = m~matnr
* End of insert MOD-010
        LEFT OUTER JOIN makt AS bc
           ON a~matnr = bc~matnr AND bc~spras EQ '1'
* Begin of insert MOD-007
        LEFT OUTER JOIN makt AS bd
           ON a~matnr = bd~matnr AND bd~spras EQ 'R'
* End of insert MOD-007
* Begin of insert MOD-013
        LEFT OUTER JOIN makt AS be
           ON a~matnr = be~matnr AND be~spras EQ 'L'
* End of insert MOD-013
        INNER JOIN marc AS c
           ON a~matnr = c~matnr
        LEFT OUTER JOIN mard AS d
           ON c~matnr = d~matnr
          AND c~werks = d~werks
        WHERE a~lvorm EQ space
          AND a~matnr IN s_matnr
*          AND A~PRDHA IN R_PRDHA
          AND b~spras = 'E'
          AND c~werks EQ p_werks
*          AND D~LGORT EQ P_LGORT.
* Begin of insert MOD-010
          AND m~vkorg EQ p_salorg.
* End of insert MOD-010


* Eliminate records where Storage location is filled but in conflict with selection parameter
  LOOP AT it_material.
    IF it_material-lgort NE space AND NOT it_material-lgort IN s_lgort.
      DELETE it_material.
    ENDIF.
  ENDLOOP.

* Check if stock found
  IF sy-subrc NE 0.
    MESSAGE s002.  " No stock found
    gv_noresult = 'X'.
    EXIT.
  ELSE.
*   If stock found, sort the selected data
    SORT it_material BY matnr werks lgort.
  ENDIF.

* Get the superseding items
  SELECT      matnr nfmat
         INTO TABLE it_supers
         FROM marc
        WHERE (    matnr IN s_matnr
                OR nfmat IN s_matnr )
          AND werks EQ p_werks.

* Get special stock from MSKU
  SELECT      matnr werks SUM( e~kulab )
         INTO TABLE it_msku
         FROM msku AS e
        WHERE matnr IN s_matnr
          AND werks EQ p_werks
          AND sobkz EQ 'W'
        GROUP BY matnr werks.

* Get sales order stock from MSKA
  SELECT      matnr werks lgort SUM( e~kalab )
         INTO TABLE it_mska
         FROM mska AS e
        WHERE matnr IN s_matnr
          AND werks EQ p_werks
          AND lgort IN s_lgort
          AND sobkz EQ 'E'
        GROUP BY matnr werks lgort.

* begin of insert MOD-008
* Get additional storage locations from table with sales order stock
  LOOP AT it_mska.
    READ TABLE it_material WITH KEY matnr = it_mska-matnr
                                    werks = it_mska-werks
                                    lgort = it_mska-lgort
                              BINARY SEARCH.
    IF sy-subrc <> 0.
      READ TABLE it_material WITH KEY matnr = it_mska-matnr
                                      werks = it_mska-werks
                                BINARY SEARCH.
      IF sy-subrc = 0.
        CLEAR: it_material-labst,
               it_material-insme,
               it_material-speme,
               it_material-retme,
               it_material-umlme,
               it_material-lgpbe.
        it_material-lgort = it_mska-lgort.
        APPEND it_material.
      ENDIF.
    ENDIF.
  ENDLOOP.
  SORT it_material BY matnr werks lgort.
* end of insert MOD-008

ENDFORM.                    " GET_MATERIAL_STOCK

*&---------------------------------------------------------------------*
*&      Form  output_table_fill
*&---------------------------------------------------------------------*
FORM output_table_fill.

  DATA:
    lv_skip TYPE c.
* begin of insertion MOD-004
  DATA : gv_bukrs TYPE bukrs,
         gv_bwkey TYPE bwkey.



* Begin of insert MOD-007
  TYPES: BEGIN OF ty_mcha,
          ersda TYPE ersda,
          matnr TYPE matnr,
          bwart TYPE bwart,
          charg TYPE charg_d,
         END OF   ty_mcha.



  CONSTANTS: lc_atnam       TYPE cabn-atnam  VALUE 'ZRU_GR_DATE'.

  DATA: lv_charg TYPE charg_d.

  DATA: v_cuobj_bm       TYPE mcha-cuobj_bm,
        inob_klart       TYPE inob-klart,
        inob_objek       TYPE inob-objek,
        inob_obtab       TYPE inob-obtab,
        it_class         TYPE TABLE OF sclass,
        it_clobjdat      TYPE TABLE OF clobjdat WITH HEADER LINE.



* End of insert MOD-007

  CLEAR: gv_bukrs, gv_bwkey.
  SELECT SINGLE bwkey INTO gv_bwkey FROM t001w
    WHERE werks = p_werks.
  SELECT SINGLE bukrs INTO gv_bukrs FROM t001k
    WHERE bwkey = gv_bwkey.

  SORT:
    it_t141t        BY mmsta,
    it_eord         BY matnr werks,
    it_msku         BY matnr werks,
    it_mbew         BY matnr werks,
    it_mska         BY matnr werks lgort,
    it_alloc        BY matnr werks lgort,
    it_matplant     BY matnr werks,
    it_eine         BY matnr werks,
    it_evers        BY evers,
    it_mvke         BY matnr,
    it_mvgr5        BY mvgr5,
    it_stbo_so      BY matnr werks lgort,
    it_transit_aggr BY matnr werks lgort,
    it_sohist       BY matnr,
    it_fchdr        BY matnr.

* Loop through stock per StLoc table
  LOOP AT it_material.

*   Copy fields from master table to output table
    CLEAR wa_output.
*   WA_OUTPUT-GAC   = IT_MATERIAL-PRDHA(4).    " GAC
*   WA_OUTPUT-PGC   = IT_MATERIAL-PRDHA+4(4).  " PGC
    wa_output-matnr = it_material-matnr.       " Material number
    wa_output-maktx = it_material-maktx.       " Material description
    wa_output-maktx_c = it_material-maktx_c.   " Chinese Material description
* Begin of insert MOD-007
    wa_output-maktx_d = it_material-maktx_d.   " Russian Material description
* End of insert MOD-007
* Begin of insert MOD-013
    wa_output-maktx_e = it_material-maktx_e.   " Poland Material description
* End of insert MOD-013
    wa_output-mtart = it_material-mtart.       " Mat type
    wa_output-matkl = it_material-matkl.       " Mat grp
    wa_output-werks = it_material-werks.       " Plant
    wa_output-lgort = it_material-lgort.       " Storage location
* begin of insertion MOD-004
    CALL FUNCTION 'YSE_CONVERT_PRCTR_BL'
      EXPORTING
        prctr_in    = it_material-prctr
        bukrs       = gv_bukrs
      IMPORTING
        segment_out = it_material-prctr.
* end of insertion MOD-004
* Begin of insert MOD-007
* Get storage date of oldest batch

    IF it_material-lgort IS INITIAL.
      SELECT MIN( charg )
            INTO lv_charg
            FROM mchb
          WHERE    mchb~matnr  EQ it_material-matnr AND
                   mchb~lgort  EQ '1000' AND
                   mchb~werks  EQ it_material-werks AND
                   mchb~clabs <> 0.

    ELSE.
      SELECT MIN( charg )
            INTO lv_charg
            FROM mchb
          WHERE    mchb~matnr  EQ it_material-matnr AND
                   mchb~lgort  EQ it_material-lgort AND
                   mchb~werks  EQ it_material-werks AND
                   mchb~clabs <> 0.
    ENDIF.

    SELECT SINGLE cuobj_bm " for batch detail
     FROM mcha
     INTO v_cuobj_bm
     WHERE matnr = it_material-matnr
     AND charg = lv_charg
     AND werks = it_material-werks.

    IF v_cuobj_bm IS NOT INITIAL. " for object link with material
      SELECT SINGLE klart
      objek
      obtab
      FROM inob
      INTO (inob_klart,inob_objek,inob_obtab)
      WHERE cuobj = v_cuobj_bm.
    ENDIF.

    IF inob_klart IS NOT INITIAL
    AND inob_objek IS NOT INITIAL
    AND inob_obtab IS NOT INITIAL.

      CALL FUNCTION 'CLAF_CLASSIFICATION_OF_OBJECTS' " extract Batch Characteristics
      EXPORTING
      classtype = inob_klart
      features = 'X'
      language = sy-langu
      object = inob_objek
      objecttable = inob_obtab
      TABLES
      t_class = it_class
      t_objectdata = it_clobjdat
      EXCEPTIONS
      no_classification = 1
      no_classtypes = 2
      invalid_class_type = 3
      OTHERS = 4.

      READ TABLE it_clobjdat WITH KEY atnam = lc_atnam.
      IF sy-subrc = 0 .
        CONCATENATE it_clobjdat-ausp1+6(4)  it_clobjdat-ausp1+3(2) it_clobjdat-ausp1+0(2) INTO wa_output-ersda.
      ENDIF.
    ENDIF.

* End of insert MOD-007
    wa_output-prctr = it_material-prctr.       " Profit center
    wa_output-mmsta = it_material-mmsta.       " Mat status
    wa_output-mmstd = it_material-mmstd.       " Valid from
    wa_output-labst = it_material-labst.       " UU stock
    wa_output-insme = it_material-insme.       " QI stock
    wa_output-speme = it_material-speme.       " Blocked stock
    wa_output-retme = it_material-retme.       " Return stock
    wa_output-umlmc = it_material-umlmc.       " Stock in transfer (plant)
    wa_output-umlme = it_material-umlme.       " Stock in transfer (StLoc)
    wa_output-trame = it_material-trame.       " Stock in transit (plant)
* Begin of insert MOD-010
    IF it_material-lgort = '1000'.
* End of insert MOD-010
      wa_output-minbe = it_material-minbe.       " Reorder point
* Begin of insert MOD-010
    ELSE.
      wa_output-minbe = it_material-lminb.       " Reorder point
    ENDIF.
    wa_output-vkorg = it_material-vkorg.      "Sales Organisation
    wa_output-ekorg = gv_ekorg.               "Purcharse Organisation
    wa_output-vkorg = p_salorg.               "Sales Organisation
* End of insert MOD-010
    wa_output-bstfe = it_material-bstfe.       " Lot size
    wa_output-eisbe = it_material-eisbe.       " Safety stock
    wa_output-lgrad = it_material-lgrad.       " Service level
    wa_output-plifz = it_material-plifz.       " Planned delivery time (mat)
    wa_output-maxlz = it_material-maxlz.       " Stock on request flag
    wa_output-nfmat = it_material-nfmat.       " Follow up material
    wa_output-lgpbe = it_material-lgpbe.       " Bin number
    wa_output-waerk = gv_waers.                " Currency key
    IF sy-batch EQ space.
      wa_output-meins = it_material-meins.     " UoM
    ELSE.
      CALL FUNCTION 'CONVERSION_EXIT_CUNIT_OUTPUT'
        EXPORTING
          input    = it_material-meins
          language = sy-langu
        IMPORTING
          output   = wa_output-meins.
    ENDIF.

*   Fixed vendor
    PERFORM find_fixed_vendor_for_mat CHANGING lv_skip.
*   If vendor not according to selection criteria, skip the material
    IF lv_skip NE space.
      CONTINUE.
    ENDIF.
*   GAC / PGC, MVGR5 (Anti piracy flag), distribution mode
    PERFORM set_sales_data CHANGING lv_skip.
*   Don't keep material if GAC / PGC not found (not meeting selection screen parameter)
    IF wa_output-gac EQ space AND wa_output-pgc EQ space.
      CONTINUE.
    ENDIF.

* Begin of insert MOD-007
    PERFORM set_hits_for_x_months.
* End of insert MOD-007
*   MRP Type
    PERFORM set_mrp_type_for_mat.
*   Material status description
    PERFORM set_status_desc_for_mat.
*   Consignment stock
    PERFORM set_consign_stock_for_mat.
*   Standard cost
    PERFORM set_stcost_for_mat.
*   Sales order stock
    PERFORM set_so_stock_for_mat.
*   Stock (Allocated)
    PERFORM set_alloc_stock_for_mat.
*   Lot size flag and Pack qty
    PERFORM set_matplant_data.
*   Planned delivery time (info record), shipping instructions and transfer price
    PERFORM set_pir_data.
*   Last receipt ans issue dates
    PERFORM set_iss_rec_dates.
*   Stock Back Ordered
    PERFORM set_stock_back_ordered.
*   Material memo
    PERFORM get_material_memo.

* Begin of insert MOD-010
    IF p_goods <> 'X'.
* End of insert MOD-010
*   Goods in Transit
      PERFORM set_goods_in_transit.
* Begin of insert MOD-010
    ENDIF.
* End of insert MOD-010

*   Calculate "Total stock balance","Total stock value", "Stock available" ...
    PERFORM calc_for_mat.
*   Planned reciepts (open po qty)
    PERFORM set_planned_receipts.
*   Set Stock History
    PERFORM set_stock_history.
*   Set Stock Forecast
    PERFORM set_history_forecast.

    APPEND wa_output TO it_output.

  ENDLOOP.

  SORT it_output BY gac pgc matnr.

ENDFORM.                    " OUTPUT_TABLE_FILL

*&---------------------------------------------------------------------*
*&      Form  OUTPUT_TABLE_RESTRICT
*&---------------------------------------------------------------------*
FORM output_table_restrict .

* Filter the extra selection criteria on the selection screen
  it_output1[] = it_output[].
  CLEAR it_output[].

* Filter all the values on the screen
  LOOP AT it_output1 INTO wa_output.
    CHECK wa_output-stprs IN s_stprs.
* begin of insertion MOD-006
    CHECK wa_output-verpr IN s_verpr.
* end of insertion MOD-006
    CHECK wa_output-prctr IN s_prctr.
    CHECK wa_output-matkl IN s_matkl.
    CHECK wa_output-lgpbe IN s_lgpbe.
    CHECK wa_output-distri_mode IN s_dismod.
    CHECK wa_output-stock_pol IN s_stpol.
    CHECK wa_output-mmsta IN s_mmsta.
    CHECK wa_output-lgrad IN s_lgrad.
    CHECK wa_output-plifz IN s_plifz.
    CHECK wa_output-aplfz IN s_aplfz.
    CHECK wa_output-minbe IN s_minbe.
    CHECK wa_output-lotsize_ind IN s_lotind.
    CHECK wa_output-bstfe IN s_bstfe.
    CHECK wa_output-eisbe IN s_eisbe.
    CHECK wa_output-last_iss_date IN s_lissd.
    CHECK wa_output-last_rec_date IN s_lrecd.
    CHECK wa_output-evers IN s_evers.
    CHECK wa_output-mvgr5 IN s_mvgr5.
    CHECK wa_output-labst IN s_labst.
    CHECK wa_output-insme IN s_insme.
    CHECK wa_output-speme IN s_speme.
    CHECK wa_output-retme IN s_retme.
    CHECK wa_output-umlmc IN s_umlmc.
    CHECK wa_output-umlme IN s_umlme.
    CHECK wa_output-trame IN s_trame.
    CHECK wa_output-total_stock IN s_totst.
    CHECK wa_output-available IN s_avail.
    APPEND wa_output TO it_output.
  ENDLOOP.

ENDFORM.                    " OUTPUT_TABLE_RESTRICT

*&---------------------------------------------------------------------*
*&      Form  get_goods_in_transit
*&---------------------------------------------------------------------*
FORM get_goods_in_transit.

* Get qty's of inbound delivery items not status "complete"
  SELECT      lips~vbeln lips~posnr matnr lips~werks lgort lfimg
         INTO TABLE it_transit
         FROM likp
        INNER JOIN lips
           ON likp~vbeln = lips~vbeln
        INNER JOIN vbup
           ON lips~vbeln = vbup~vbeln
          AND lips~posnr = vbup~posnr
        WHERE lips~matnr IN s_matnr
          AND lfart      EQ 'EL'
          AND lips~werks EQ p_werks
*          AND LGORT      EQ P_LGORT
          AND lgort      IN s_lgort
          AND (    vbup~wbsta EQ 'A'
                OR vbup~wbsta EQ 'B' ).
* Begin of insert MOD-010
*          AND likp~VKORG EQ p_SALORG.
* End of insert MOD-010


* Sum Qty's per material/plant/StLoc
  LOOP AT it_transit.
    READ TABLE it_material WITH KEY matnr = it_transit-matnr
                                    werks = it_transit-werks
                                    lgort = it_transit-lgort.
    IF sy-subrc EQ 0.
      MOVE-CORRESPONDING it_transit TO it_transit_aggr.
      COLLECT it_transit_aggr.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " GET_GOODS_IN_TRANSIT

*&---------------------------------------------------------------------*
*&      Form  get_allocated_stock
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_allocated_stock.

* Get Safety stock
  PERFORM get_safety_stock.

* Get open sales orders
  PERFORM get_open_sales_orders.

* Get open reservations
  PERFORM get_open_reservations.

* Get open transport req
  PERFORM get_open_transport_req.

* Get open transport orders
* Cf. Function get_allocated stock > perform find_open_transport_orders
  PERFORM get_open_transport_orders.

ENDFORM.                    " GET_ALLOCATED_STOCK

*&---------------------------------------------------------------------*
*&      Form  GET_STOCK_BORDER
*&---------------------------------------------------------------------*
*       Stock back order
*----------------------------------------------------------------------*
FORM get_stock_border .

* Sales order part *
* **************** *
* Open quantity already collected into IT_STBO_SO during VBAP loop for Open quantity in Allocations routine

* Get confirmed quantities
  IF NOT it_vbap[] IS INITIAL.
    SELECT      vbeln posnr bmeng
           INTO TABLE it_vbep
           FROM vbep
            FOR ALL ENTRIES IN it_vbap
          WHERE vbeln EQ it_vbap-vbeln
            AND posnr EQ it_vbap-posnr.
    SORT it_vbep BY vbeln posnr.

* Subtract confirmed quantities from back order table
    LOOP AT it_vbap.
      it_stbo_so-matnr = it_vbap-matnr.
      it_stbo_so-werks = it_vbap-werks.
      it_stbo_so-lgort = it_vbap-lgort.
      it_stbo_so-alloc_quantity = 0.
      LOOP AT it_vbep WHERE vbeln = it_vbap-vbeln
                        AND posnr = it_vbap-posnr.
        it_stbo_so-alloc_quantity = it_vbep-bmeng * ( -1 ).
      ENDLOOP.
      COLLECT it_stbo_so.
    ENDLOOP.
  ENDIF.
* Service part *
* ************ *
* Open quantity already collected into IT_STBO_SO during RESB loop for Open quantity in Allocations routine

* subtract confirmed quantities from back order table
  LOOP AT it_resb WHERE xwaok EQ 'X'.
    READ TABLE it_material WITH KEY matnr = it_resb-matnr
                                    werks = it_resb-werks
                           BINARY SEARCH.
    IF sy-subrc EQ 0.
      it_stbo_so-matnr = it_resb-matnr.
      it_stbo_so-werks = it_resb-werks.
      it_stbo_so-alloc_quantity = ( it_resb-vmeng * ( it_resb-umren / it_resb-umrez ) ) * -1.
      COLLECT it_stbo_so.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " GET_STOCK_BORDER

*&---------------------------------------------------------------------*
*&      Form  view_material
*&---------------------------------------------------------------------*

FORM view_material  USING    p_e_row_id TYPE lvc_s_row.

  READ TABLE it_output INTO wa_output INDEX p_e_row_id.

  SET PARAMETER ID 'MAT' FIELD wa_output-matnr.
  CALL TRANSACTION 'MM03' AND SKIP FIRST SCREEN.

ENDFORM.                    " view_material

*&---------------------------------------------------------------------*
*&      Form  check_authorization
*&---------------------------------------------------------------------*

FORM check_authorization .

  DATA: t_t001w LIKE STANDARD TABLE OF t001w WITH HEADER LINE.

  SELECT *
  FROM t001w
  INTO TABLE t_t001w WHERE werks EQ p_werks. " so_werks.

  LOOP AT t_t001w.
    AUTHORITY-CHECK OBJECT 'M_MATE_WRK'
             ID 'ACTVT' DUMMY
             ID 'WERKS' FIELD t_t001w-werks.
    IF sy-subrc = 4.
*   No authorisation to display data from Sales Organisation p_vkorg
      MESSAGE ID 'YSE_GENERAL' TYPE 'E' NUMBER '008' WITH t_t001w-werks.
      EXIT.
    ELSEIF sy-subrc <> 0.
*   Error checking authorization.
      MESSAGE ID 'YSE_GENERAL' TYPE 'E' NUMBER '004'.
      EXIT.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " check_authorization

*&---------------------------------------------------------------------*
*&      Form  VALREQ_WERKS
*&---------------------------------------------------------------------*
FORM valreq_werks.

  SELECT      a~werks a~whtype a~whstdes b~name1
*         INTO CORRESPONDING FIELDS OF TABLE IT_PLANT
         INTO TABLE it_plant
         FROM yse_em_plant AS a
        INNER JOIN t001w AS b
           ON a~werks = b~werks
        WHERE a~whtype NE 'D'   " Report only for non DTC plants
          AND b~spras  EQ 'E'.                         "#EC CI_BUFFJOIN

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'WERKS'
      window_title    = text-003
      value_org       = 'S'
    TABLES
      value_tab       = it_plant
      return_tab      = it_return_tab
    EXCEPTIONS
      parameter_error = 0
      no_values_found = 0
      OTHERS          = 0.

ENDFORM.                    " VALREQ_WERKS

*&---------------------------------------------------------------------*
*&      Form  SEND2SPOOL
*&---------------------------------------------------------------------*
FORM send2spool.

  DATA:
    fnam             LIKE rlgrap-filename,
    it_dd03l         LIKE dd03l OCCURS 0 WITH HEADER LINE,
    it_dd04t         LIKE dd04t OCCURS 0 WITH HEADER LINE,
    it_outxls(4096)  TYPE c OCCURS 0,
    wa_outxls(4096)  TYPE c.

  CONSTANTS:
    c_tab TYPE c VALUE cl_abap_char_utilities=>horizontal_tab.

* Get fields of structure 'YSE_STOCK_OVERVIEW_ITEM'
  SELECT *
         FROM dd03l
         INTO TABLE it_dd03l
        WHERE tabname = 'YSE_STOCK_OVERVIEW_ITEM'.

* Get the descriptions of the fields in the structure
  SELECT *
         FROM dd04t
         INTO TABLE it_dd04t
          FOR ALL ENTRIES IN it_dd03l
        WHERE rollname EQ it_dd03l-rollname
          AND ddlanguage EQ 'EN'.

* Build filename
  CONCATENATE '/var/load/' sy-sysid '/UK/original/YSE_ITEMREP_'
              sy-uname '_' v_dat '_' v_tim '.TXT'
         INTO fnam.

* Make the output table ; delimited
  CALL FUNCTION 'SAP_CONVERT_TO_CSV_FORMAT'
    TABLES
      i_tab_sap_data       = it_output
    CHANGING
      i_tab_converted_data = it_outxls
    EXCEPTIONS
      conversion_failed    = 1
      OTHERS               = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

* Open file
  OPEN DATASET fnam FOR OUTPUT IN TEXT MODE ENCODING DEFAULT.
  IF sy-subrc <> 0.
    WRITE 'Error opening file. Action aborted.'(026).
    EXIT.
  ENDIF.

* Write header line
  CLEAR wa_outxls.
  SORT it_dd03l BY position.
  LOOP AT it_dd03l.
    READ TABLE it_dd04t WITH KEY rollname = it_dd03l-rollname.
    IF wa_outxls IS INITIAL.
      wa_outxls = it_dd04t-reptext.
    ELSE.
      CONCATENATE wa_outxls c_tab it_dd04t-reptext INTO wa_outxls.
    ENDIF.
  ENDLOOP.
  TRANSFER wa_outxls TO fnam LENGTH 4096.

* Process lines
  LOOP AT it_outxls INTO wa_outxls.
    REPLACE ALL OCCURRENCES OF ';' IN wa_outxls WITH c_tab.
    TRANSFER wa_outxls TO fnam.
  ENDLOOP.

  CLOSE DATASET fnam.

  WRITE: 'Report output written to file:'(027),
         fnam.

ENDFORM.                    " SEND2SPOOL

*&---------------------------------------------------------------------*
*&      Form  GET_open_sales_orders
*&---------------------------------------------------------------------*
FORM get_open_sales_orders .

* Salesorder items have been selected before

* Add order quantities to allocations table
  SORT it_vbap BY matnr.
  LOOP AT it_vbap WHERE abgru EQ space.
*   When the sales item's StLoc is initial, treat it is if it were
*   StLoc 1000
    IF it_vbap-lgort IS INITIAL.
      it_vbap-lgort = '1000'.
    ENDIF.
    READ TABLE it_material WITH KEY matnr = it_vbap-matnr
                                    werks = it_vbap-werks
                                    lgort = it_vbap-lgort
                           BINARY SEARCH.
    IF sy-subrc EQ 0.
      it_alloc-lgort          = it_vbap-lgort.
      it_alloc-werks          = it_vbap-werks.
      it_alloc-matnr          = it_vbap-matnr.
      it_alloc-alloc_quantity = it_vbap-kwmeng.
      COLLECT it_alloc.
*     To collect the Open Qty for Stock Back Ordered
      COLLECT it_alloc INTO it_stbo_so.
    ENDIF.
  ENDLOOP.

* Get delivered quantities for the above selected order items
  IF NOT it_vbap[] IS INITIAL.
    SELECT      b~vbeln b~posnr b~matnr b~lgort b~lfimg b~werks
           INTO TABLE it_lips
           FROM vbfa AS a
           JOIN lips AS b
             ON a~vbeln EQ b~vbeln
            AND a~posnn EQ b~posnr
           JOIN vbuk AS c
             ON a~vbeln EQ c~vbeln
            FOR ALL ENTRIES IN it_vbap
          WHERE a~vbelv = it_vbap-vbeln
            AND a~posnv = it_vbap-posnr
            AND a~vbtyp_n = 'J'  " Deliveries
            AND c~wbstk = 'C'.
  ENDIF.

* Subtract remaining delivered quantities from allocation table
  LOOP AT it_lips.
*   StLoc 1000
    IF it_lips-lgort IS INITIAL.
      it_lips-lgort = '1000'.
    ENDIF.
    READ TABLE it_material WITH KEY matnr = it_lips-matnr
                                    werks = it_lips-werks
                                    lgort = it_lips-lgort
                           BINARY SEARCH.
    IF sy-subrc EQ 0.
      it_alloc-lgort          = it_lips-lgort.
      it_alloc-werks          = it_lips-werks.
      it_alloc-matnr          = it_lips-matnr.
      it_alloc-alloc_quantity = it_lips-lfimg * ( -1 ).
      COLLECT it_alloc.
*     To collect the Open Qty for Stock Back Ordered
      COLLECT it_alloc INTO it_stbo_so.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " GET_open_sales_orders

*&---------------------------------------------------------------------*
*&      Form  GET_open_reservations
*&---------------------------------------------------------------------*
FORM get_open_reservations .

* Service details selected before, but whithout condition >> XWAOK EQ 'X' <<

* Add open reservation quantities to allocations table
  SORT it_resb BY matnr werks lgort.
  LOOP AT it_resb WHERE xwaok EQ 'X'.
    READ TABLE it_material
               WITH KEY matnr = it_resb-matnr
                        werks = it_resb-werks
                        lgort = it_resb-lgort
               BINARY SEARCH.
    IF sy-subrc EQ 0.
      it_alloc-matnr          = it_resb-matnr.
      it_alloc-werks          = it_resb-werks.
      it_alloc-lgort          = it_resb-lgort.
      it_alloc-alloc_quantity = it_resb-bdmng - it_resb-enmng.
      COLLECT it_alloc.
*     To collect the Open Qty for Stock Back Ordered
      COLLECT it_alloc INTO it_stbo_so.
    ENDIF.
  ENDLOOP.




ENDFORM.                    " GET_open_reservations

*&---------------------------------------------------------------------*
*&      Form  get_safety_stock
*&---------------------------------------------------------------------*
FORM get_safety_stock .

* Only consider safety stock if "safety stock indicator" is flagged
  CHECK p_saf = 'X'.
* Only consider safety stock if storage location = 1000
*  CHECK P_LGORT = '1000'.
  IF '1000' IN s_lgort.

* Safety stock has already been fetched from MARC, just copy it over into IT_ALLOC_EXT
* Put material with it's safety stock in allocations table
    it_alloc-lgort          = '1000'.
    LOOP AT it_material.
      it_alloc-matnr          = it_material-matnr.
      it_alloc-werks          = it_material-werks.
      it_alloc-alloc_quantity = it_material-eisbe.
      COLLECT it_alloc.
    ENDLOOP.
  ENDIF.
ENDFORM.                    " get_safety_stock

*&---------------------------------------------------------------------*
*&      Form  get_open_transport_req
*&---------------------------------------------------------------------*
FORM get_open_transport_req .

* Only consider open transport req if storage location = 1000
*  CHECK p_lgort = '1000'.

  IF '1000' IN s_lgort.

    SELECT      matnr reswk menge
           INTO TABLE it_eban
           FROM eban
          WHERE matnr IN s_matnr
            AND bsart EQ c_po_replenishment
            AND pstyp EQ c_pstyp_stock_tr      "STOCK TRANSFER
            AND statu EQ 'N'
            AND loekz EQ space
            AND ebakz EQ space
            AND reswk EQ p_werks " so_werks
            AND ( lgort EQ '1000'
                 OR lgort EQ ' ').
* Begin of insert MOD-010
*            AND EKORG = gv_EKORG.
* End of insert MOD-010

* Add open transport req quant's to allocations table
    LOOP AT it_eban.
      READ TABLE it_material WITH KEY matnr = it_eban-matnr
                                      werks = it_eban-reswk
                             BINARY SEARCH.
      it_alloc-lgort = '1000'.
      IF sy-subrc EQ 0.
        it_alloc-matnr = it_eban-matnr.
        it_alloc-werks = it_eban-reswk.
        it_alloc-alloc_quantity = it_eban-menge.
        COLLECT it_alloc.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                    " GET_open_transport_req

*&---------------------------------------------------------------------*
*&      Form  get_material_memo
*&---------------------------------------------------------------------*
FORM get_material_memo.

  CLEAR lv_tdname.
  lv_tdname(18)   = it_material-matnr.
  lv_tdname+19(4) = it_material-werks.

  CLEAR: it_lines, it_lines[].
  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id                      = 'LTXT'
      language                = 'E'
      name                    = lv_tdname
      object                  = 'MDTXT'
    TABLES
      lines                   = it_lines
    EXCEPTIONS
      id                      = 1
      language                = 2
      name                    = 3
      not_found               = 4
      object                  = 5
      reference_check         = 6
      wrong_access_to_archive = 7
      OTHERS                  = 8.
  IF sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

  READ TABLE it_lines INDEX 1.
  IF sy-subrc EQ 0.
    wa_output-matnr_memo = it_lines-tdline.
  ENDIF.

ENDFORM.                    " get_material_memo

*&---------------------------------------------------------------------*
*&      Form  GET_dateS
*&---------------------------------------------------------------------*
FORM get_dates.

  DATA:
    BEGIN OF lt_ebeln_keep OCCURS 0,
      ebeln LIKE mseg-ebeln,
    END OF lt_ebeln_keep,
    BEGIN OF lt_ebeln_receipt OCCURS 0,
      ebeln LIKE mseg-ebeln,
    END OF lt_ebeln_receipt,
    BEGIN OF lt_vbeln_keep OCCURS 0,
      vbeln LIKE mseg-mblnr,
    END OF lt_vbeln_keep,
    BEGIN OF lt_vbeln_issue OCCURS 0,
      vbeln LIKE vbfa-vbeln,
    END OF lt_vbeln_issue.

* **************************************************************************************************
* TVO: New logic is just after the commented lines: process monitor showed that at least 2 hours of
*      the total running time was spent selecting from MSEG. Therefore trying to combine into 1
*      select and further refinement in later processing
* **************************************************************************************************
** Receipt dates from MKPF/MSEG
*  SELECT      MKPF~MBLNR MKPF~MJAHR MSEG~ZEILE MKPF~BUDAT MSEG~BWART MSEG~MATNR
*         INTO TABLE IT_MSEG
*         FROM MSEG
*         JOIN MKPF
*           ON MKPF~MBLNR = MSEG~MBLNR
*          AND MKPF~MJAHR = MSEG~MJAHR
*         JOIN EKKO
*           ON MSEG~EBELN = EKKO~EBELN
*          FOR ALL ENTRIES IN IT_SUPERS
*        WHERE MSEG~BWART IN R_BWART_RECEIPT
*          AND MSEG~MATNR EQ IT_SUPERS-MATNR
*          AND WERKS EQ P_WERKS
*          AND BSART NE 'ZUB1'
*          AND LGORT EQ P_LGORT.
** Issue dates from MKPF/MSEG
*  SELECT      MKPF~MBLNR MKPF~MJAHR MSEG~ZEILE MKPF~BUDAT MSEG~BWART MSEG~MATNR
*    APPENDING TABLE IT_MSEG
*         FROM MSEG
*         JOIN MKPF
*           ON MKPF~MBLNR = MSEG~MBLNR
*          AND MKPF~MJAHR = MSEG~MJAHR
*         JOIN VBFA
*           ON MSEG~MBLNR = VBFA~VBELN
*         JOIN LIKP
*           ON VBFA~VBELV = LIKP~VBELN
*          FOR ALL ENTRIES IN IT_SUPERS
*        WHERE MSEG~BWART IN R_BWART_ISSUE
*          AND MSEG~MATNR EQ IT_SUPERS-MATNR
*          AND MSEG~WERKS EQ P_WERKS
*          AND LGORT      EQ P_LGORT
*          AND VBTYP_N    EQ 'R'          " Document flow: Follow up doc is "Goods mvt"
*          AND VBTYP_V    EQ 'J'          " Document flow: Preced doc is "Delivery"
*          AND LFART      NE 'NL'.
** Sort the table by date descending
*  SORT IT_MSEG BY BUDAT DESCENDING.


* New logic starts here/ get all goods movements
  IF NOT it_supers[] IS INITIAL.
    SELECT      mkpf~mblnr mkpf~mjahr mseg~zeile mkpf~budat mseg~bwart mseg~matnr mseg~ebeln
           INTO TABLE it_mseg
           FROM mseg
           JOIN mkpf
             ON mkpf~mblnr = mseg~mblnr
            AND mkpf~mjahr = mseg~mjahr
            FOR ALL entries IN it_supers
          WHERE mseg~bwart IN r_bwart_all
            AND mseg~matnr EQ it_supers-matnr
            AND werks EQ p_werks
            AND lgort EQ '1000'.
  ENDIF.

* Build tables with PO numbers for receipts and with Goods Mvt numbers for issues
  LOOP AT it_mseg.
    IF it_mseg-bwart IN r_bwart_receipt.
      lt_ebeln_receipt-ebeln = it_mseg-ebeln.
      APPEND lt_ebeln_receipt.
    ELSEIF it_mseg-bwart IN r_bwart_issue.
      lt_vbeln_issue-vbeln = it_mseg-mblnr.
      APPEND lt_vbeln_issue.
    ENDIF.
  ENDLOOP.
  SORT:
    lt_ebeln_receipt BY ebeln,
    lt_vbeln_issue   BY vbeln.
  DELETE ADJACENT DUPLICATES FROM:
    lt_ebeln_receipt,
    lt_vbeln_issue.
* Check the PO type for receipts (internal orders don't count)
  IF NOT lt_ebeln_receipt[] IS INITIAL.
    SELECT      ebeln
           INTO TABLE lt_ebeln_keep
           FROM ekko
            FOR ALL ENTRIES IN lt_ebeln_receipt
          WHERE ebeln EQ lt_ebeln_receipt-ebeln
            AND bsart NE 'ZUB1'.
    SORT lt_ebeln_keep BY ebeln.
  ENDIF.
* Check the delivery type preceding the currently selected good mvt's
  IF NOT lt_vbeln_issue[] IS INITIAL.
    SELECT      vbfa~vbeln
           INTO TABLE lt_vbeln_keep
           FROM vbfa
           JOIN likp
             ON vbfa~vbelv = likp~vbeln
            FOR ALL entries IN lt_vbeln_issue
          WHERE vbfa~vbeln EQ lt_vbeln_issue-vbeln
            AND vbtyp_n    EQ 'R'          " Document flow: Follow up doc is "Goods mvt"
            AND vbtyp_v    EQ 'J'          " Document flow: Preced doc is "Delivery"
            AND lfart      NE 'NL'.
    SORT lt_vbeln_keep BY vbeln.
  ENDIF.
* Issue and receipt dates from YSE_SURPLUS_HD01
  IF NOT it_supers[] IS INITIAL.
    SELECT      *
           FROM yse_surplus_hd01
           INTO TABLE it_surplus
            FOR ALL ENTRIES IN it_supers
          WHERE werks EQ p_werks
            AND matnr EQ it_supers-matnr
*          AND lgort EQ p_lgort.
             AND lgort IN s_lgort.

    SORT it_surplus BY budat DESCENDING.
  ENDIF.

* Add MSEG (goods mvt data) to surplus table, which than holds all receipts and issue dates
  LOOP AT it_mseg.
    it_surplus-matnr = it_mseg-matnr.
    it_surplus-werks = p_werks.
    it_surplus-lgort = '1000'.
*   When receipt
    IF it_mseg-bwart IN r_bwart_receipt.
      it_surplus-zmovt = 'R'.
*     Check if PO type is correct
      READ TABLE lt_ebeln_keep WITH KEY ebeln = it_mseg-ebeln BINARY SEARCH.
      IF sy-subrc EQ 0.
        it_surplus-budat = it_mseg-budat.
        APPEND it_surplus.
      ENDIF.
*   When issue
    ELSEIF it_mseg-bwart IN r_bwart_issue.
      it_surplus-zmovt = 'I'.
*     Check preceding delivery type
      READ TABLE lt_vbeln_keep WITH KEY vbeln = it_mseg-mblnr BINARY SEARCH.
      IF sy-subrc EQ 0.
        it_surplus-budat = it_mseg-budat.
        APPEND it_surplus.
      ENDIF.
    ENDIF.
  ENDLOOP.

* Sort the issue and receipt data
  SORT it_surplus BY matnr ASCENDING budat DESCENDING.
* Process all dates to keep only 1 issue and 1 receipt date per material
  LOOP AT it_surplus.
*   When receipt
    IF it_surplus-zmovt = 'R'.
*     When we don't have a receipt date for the material yet
      IF it_surplus-matnr NE it_rec-matnr.
*       Keep the date (due to sorting, it will be the most recent receipt)
        it_rec-matnr = it_surplus-matnr.
        it_rec-budat = it_surplus-budat.
        APPEND it_rec.
      ENDIF.
*   When issue
    ELSEIF it_surplus-zmovt = 'I'.
*     When we don't have a issue date for the material yet
      IF it_surplus-matnr NE it_iss-matnr.
*       Keep the date (due to sorting, it will be the most recent receipt)
        it_iss-matnr = it_surplus-matnr.
        it_iss-budat = it_surplus-budat.
        APPEND it_iss.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " GET_dateS


*&---------------------------------------------------------------------*
*&      Form  get_data_mkpf
*&---------------------------------------------------------------------*
FORM get_data_mkpf .

* Last receipt date.
  IF NOT it_material IS INITIAL.
    SELECT mkpf~mblnr mseg~matnr mseg~matnr mseg~werks mkpf~budat mseg~ebeln
        INTO TABLE gt_rec_dat
        FROM mseg
       INNER JOIN mkpf
          ON   mseg~mblnr EQ mkpf~mblnr
         AND   mseg~mjahr EQ mkpf~mjahr
     FOR ALL entries IN it_material
     WHERE    mseg~matnr  EQ it_material-matnr
          AND mseg~werks  EQ p_werks " so_werks
          AND ( mseg~bwart EQ '101'
          OR   mseg~bwart EQ '651'
          OR   mseg~bwart EQ '634' ).
  ENDIF.

* Superseding materials for receipt date
  IF NOT it_supers[] IS INITIAL.
    SELECT mkpf~mblnr mseg~matnr mseg~werks mkpf~budat mseg~ebeln
*      INTO  CORRESPONDING FIELDS OF TABLE GT_REC_DAT1
        INTO TABLE gt_rec_dat1
        FROM mseg
       INNER JOIN mkpf
          ON   mseg~mblnr EQ mkpf~mblnr
         AND   mseg~mjahr EQ mkpf~mjahr
     FOR ALL entries IN it_supers
     WHERE    mseg~matnr  EQ it_supers-matnr
          AND mseg~werks  EQ p_werks " so_werks
          AND ( mseg~bwart EQ '101'
          OR   mseg~bwart EQ '651'
          OR   mseg~bwart EQ '634' ).
  ENDIF.

* Append the superseded items to the table
  LOOP AT gt_rec_dat1.
    READ TABLE it_supers WITH KEY matnr = gt_rec_dat1-matnr.
    IF sy-subrc EQ 0.
      CLEAR gt_rec_dat.
      MOVE-CORRESPONDING gt_rec_dat1 TO gt_rec_dat.
      gt_rec_dat-nfmat = it_supers-nfmat.
      APPEND gt_rec_dat.
    ENDIF.
  ENDLOOP.

  SORT gt_rec_dat BY budat DESCENDING.

  LOOP AT gt_rec_dat.
    READ TABLE it_material
                  WITH KEY matnr = gt_rec_dat-nfmat
                           werks = gt_rec_dat-werks.
    IF sy-subrc NE 0.
      DELETE gt_rec_dat.
    ELSE.
*     Do another check on type of po linked, must not be ZUB1
      IF NOT gt_rec_dat-ebeln IS INITIAL.
*       Means it was a 101 movement
        SELECT SINGLE ebeln FROM ekko INTO ekko-ebeln
                     WHERE ebeln EQ gt_rec_dat-ebeln AND
                           bsart EQ 'ZUB1'.          "#EC CI_SEL_NESTED
        IF sy-subrc EQ 0.
          DELETE gt_rec_dat.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.


* Last issue date.
  IF NOT it_material[] IS INITIAL.
    SELECT mkpf~mblnr mseg~matnr mseg~matnr mseg~werks mkpf~budat
        INTO TABLE gt_iss_dat
        FROM mseg
       INNER JOIN mkpf
          ON   mseg~mblnr EQ mkpf~mblnr
         AND   mseg~mjahr EQ mkpf~mjahr
     FOR ALL entries IN it_material
     WHERE     mseg~matnr  EQ it_material-matnr
           AND mseg~werks  EQ p_werks " so_werks
           AND ( mseg~bwart EQ '261'
            OR   mseg~bwart EQ '601'
            OR   mseg~bwart EQ '633' ).
  ENDIF.
* Get the superseded items
  IF NOT it_supers[] IS INITIAL.
    SELECT mkpf~mblnr mseg~matnr mseg~werks mkpf~budat
        INTO TABLE gt_iss_dat1
        FROM mseg
       INNER JOIN mkpf
          ON   mseg~mblnr EQ mkpf~mblnr
         AND   mseg~mjahr EQ mkpf~mjahr
     FOR ALL entries IN it_supers
     WHERE     mseg~matnr  EQ it_supers-matnr
           AND mseg~werks  EQ p_werks " so_werks
           AND ( mseg~bwart EQ '261'
            OR   mseg~bwart EQ '601'
            OR   mseg~bwart EQ '633' ).

* Append the superseded items to the table
    LOOP AT gt_iss_dat1.
      READ TABLE it_supers WITH KEY matnr = gt_iss_dat1-matnr.
      IF sy-subrc EQ 0.
        CLEAR gt_iss_dat.
        MOVE-CORRESPONDING gt_iss_dat1 TO gt_iss_dat.
        gt_iss_dat-nfmat = it_supers-nfmat.
        APPEND gt_iss_dat.
      ENDIF.
    ENDLOOP.
  ENDIF.

  SORT gt_iss_dat BY budat DESCENDING.


  LOOP AT gt_iss_dat.
    READ TABLE it_material
                  WITH KEY matnr = gt_iss_dat-nfmat
                           werks = gt_iss_dat-werks.
    IF sy-subrc NE 0.
      DELETE gt_iss_dat.
    ELSE.
*     Do another check on type delivery.
      SELECT SINGLE likp~vbeln INTO likp-vbeln FROM likp
                        INNER JOIN vbfa
                        ON vbfa~vbeln EQ likp~vbeln
                        WHERE vbfa~vbeln EQ gt_iss_dat-mblnr AND
                              vbfa~vbtyp_v EQ 'J' AND
                              likp~lfart EQ 'NL'.    "#EC CI_SEL_NESTED
      IF sy-subrc EQ 0.
        DELETE gt_iss_dat.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    " get_data_mkpf

*&---------------------------------------------------------------------*
*&      Form  SET_12_MONTH_PERIOD
*&---------------------------------------------------------------------*
FORM set_12_month_period.

  DATA:
    lv_datum      LIKE sy-datum.

* *****
* Start with current date
  MOVE sy-datum TO lv_datum.
* Set the "day" to 01 ==> first of current month
  lv_datum+6 = '01'.
* Go to the day before the first of current month ==> last day of last month
  lv_datum = lv_datum - 1.
* Set "last month" period
  wa_per_lastmonth = lv_datum(6).

* *****
* Go 11 months back from last month ==> 1 yr back
  CALL FUNCTION 'MONTH_PLUS_DETERMINE'
    EXPORTING
      months  = -11
      olddate = lv_datum
    IMPORTING
      newdate = lv_datum.
* Set "1 Year Back" period
  MOVE lv_datum(6) TO  wa_per_1yrback.

ENDFORM.                    " SET_12_MONTH_PERIOD

*&---------------------------------------------------------------------*
*&      Form  GET_stock_history
*&---------------------------------------------------------------------*
FORM get_stock_history .

  DATA: prev_matnr TYPE matnr.

* Get P_VKORG from the plant (can be only 1 from selection screen)
  READ TABLE it_mvke INDEX 1.
  IF sy-subrc EQ 0.
    p_vkorg = it_mvke-vkorg.
  ENDIF.

* The linked sales organisation will be on all lines but just different matnr
* SELECT ALL PLANTS FOR WHICH CHOSEN PLANT IS RESPONSIBLE
  SELECT *
  INTO TABLE it_yse_em_pl_centr
    FROM yse_em_pl_centr
    WHERE cwerks = p_werks.
* If no branch plants found for the provided plant on selection screen
  IF sy-subrc NE 0.
    CLEAR sy-subrc.
*   Just add a line for the branch plant
    it_yse_em_pl_centr-bwerks = p_werks.
    APPEND it_yse_em_pl_centr.
  ENDIF.

  IF sy-subrc EQ 0.
    SELECT *
      INTO TABLE it_yse_em_pl_distr
      FROM yse_em_pl_distr
      FOR ALL ENTRIES IN it_yse_em_pl_centr
      WHERE werks = it_yse_em_pl_centr-bwerks.
*-- selection of sales organisation/plant combinations
    CLEAR: it_tvkwz.
    REFRESH: it_tvkwz.
    SELECT vkorg vtweg werks
        FROM tvkwz
        INTO TABLE it_tvkwz
           WHERE vkorg EQ p_vkorg.
    CLEAR: r_bzirk.
    REFRESH: r_bzirk.
    LOOP AT  it_yse_em_pl_distr.
* CHECK IF THE DEPENDEND PLANT IS ALLOWED
* FOR SALES ORG/DIST CHANNEL
      READ TABLE it_tvkwz
      WITH KEY werks =  it_yse_em_pl_distr-werks.
      CHECK sy-subrc EQ 0.
      CLEAR: r_bzirk.
      r_bzirk-sign   = 'I'.
      r_bzirk-option = 'EQ'.
      r_bzirk-low    = it_yse_em_pl_distr-bzirk.
      APPEND r_bzirk.
    ENDLOOP.
  ENDIF.

* ADD HISTORY FOR DEPENDEND SALES DISTRICTS
  READ TABLE r_bzirk INDEX 1.

  IF sy-subrc EQ 0.
    SELECT *
     INTO TABLE it_yse_em_sohist
     FROM yse_em_sohist
     WHERE vkorg EQ p_vkorg
     AND bzirk IN r_bzirk
     AND period
     BETWEEN wa_per_1yrback AND wa_per_lastmonth.
    SELECT * FROM yse_em_sohistmig WHERE period LE wa_per_lastmonth
                                    AND period GE wa_per_1yrback
                                    AND vkorg  EQ p_vkorg
                                    AND bzirk IN r_bzirk
                                    AND werks EQ p_werks.
      it_yse_em_sohist = yse_em_sohistmig.
      COLLECT it_yse_em_sohist.
    ENDSELECT.
  ENDIF.

  SORT it_yse_em_sohist.
* Set history for materials without history to 0.01
  SORT it_material BY werks matnr lgort.
  DELETE ADJACENT DUPLICATES FROM it_material COMPARING werks matnr lgort.

  LOOP AT it_material.
    CLEAR it_sohist.
    IF it_material-matnr NE prev_matnr OR prev_matnr IS INITIAL.
      MOVE it_material-matnr TO prev_matnr.
      LOOP AT it_yse_em_sohist WHERE matnr EQ it_material-matnr.
*                             and   werks EQ it_material-werks.
        MOVE-CORRESPONDING it_yse_em_sohist TO it_sohist.

        PERFORM round_value CHANGING it_sohist-zmeng.

        COLLECT it_sohist.
      ENDLOOP.
    ENDIF.

  ENDLOOP.

ENDFORM.                    " get_stock_history
*&---------------------------------------------------------------------*
*&      Form  round_value
*&---------------------------------------------------------------------*
FORM round_value  CHANGING number TYPE sbmenge.

  CALL FUNCTION 'ROUND'
    EXPORTING
      decimals      = 0
      input         = number
*     sign          = ' '
    IMPORTING
      output        = number
    EXCEPTIONS
      input_invalid = 1
      overflow      = 2
      type_invalid  = 3
      OTHERS        = 4.
  IF sy-subrc <> 0.
*   message id sy-msgid type sy-msgty number sy-msgno
*           with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

ENDFORM.                    " round_value

*&---------------------------------------------------------------------*
*&      Form  VALREQ_DISMODE
*&---------------------------------------------------------------------*
FORM valreq_dismode.

  REFRESH it_dismod.
  it_dismod-dismod = 'DTC'.
  APPEND it_dismod.

  it_dismod-dismod = 'NDTC'.
  APPEND it_dismod.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'DISMOD'
      window_title    = text-019
      value_org       = 'S'
    TABLES
      value_tab       = it_dismod
      return_tab      = it_return_tab
    EXCEPTIONS
      parameter_error = 0
      no_values_found = 0
      OTHERS          = 0.

ENDFORM.                    " VALREQ_DISMODE

*&---------------------------------------------------------------------*
*&      Form  VALREQ_STPOL
*&---------------------------------------------------------------------*
FORM valreq_stpol. " MRP type

  REFRESH it_stockpol.
  it_stockpol-stockpol = 'ST'.
  APPEND it_stockpol.

  it_stockpol-stockpol = 'NS'.
  APPEND it_stockpol.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'STOCKPOL'
      window_title    = text-020
      value_org       = 'S'
    TABLES
      value_tab       = it_stockpol
      return_tab      = it_return_tab
    EXCEPTIONS
      parameter_error = 0
      no_values_found = 0
      OTHERS          = 0.

ENDFORM.                    " VALREQ_STPOL

*&---------------------------------------------------------------------*
*&      Form  SET_DATE_AND_TIME
*&---------------------------------------------------------------------*
FORM set_date_and_time .

  IF sy-batch NE space.
    v_dat = sy-datum.
    v_tim = sy-uzeit.
  ENDIF.

ENDFORM.                    " SET_DATE_AND_TIME

*&---------------------------------------------------------------------*
*&      Form  GET_ADD_DATA
*&---------------------------------------------------------------------*
FORM get_add_data .

* Begin of change MOD-010
* Get responsible POrg for the provided plant
*  SELECT SINGLE ekorg
*           INTO gv_ekorg
*           FROM t001w
*          WHERE werks EQ p_werks.

  SELECT SINGLE ekorg FROM yse_po_sorg_porg INTO gv_ekorg
    WHERE vkorg = p_salorg.
* End of change MOD-010

* Get Material/plant parameters
  SELECT      *
         INTO TABLE it_matplant
         FROM yse_em_matplant
        WHERE matnr IN s_matnr
          AND werks EQ p_werks.

* Get the descriptions of the material status
  SELECT      *
         INTO TABLE it_t141t
         FROM t141t
        WHERE spras EQ sy-langu.

* Get the sales data of the materials selected before
*  SELECT      MVKE~MATNR MVKE~VKORG MVKE~VTWEG MVKE~PRODH T001W~WERKS MVKE~MTPOS MVKE~MVGR5 MVKE~MVGR4
  IF NOT it_material[] IS INITIAL.
    SELECT      matnr vkorg vtweg prodh mtpos mvgr5 mvgr4
           INTO TABLE it_mvke
*         FROM T001W
*         JOIN YSE_PO_SORG_PORG
*           ON YSE_PO_SORG_PORG~EKORG EQ T001W~EKORG
*         JOIN MVKE
*           ON MVKE~VKORG EQ YSE_PO_SORG_PORG~VKORG
           FROM mvke
            FOR ALL ENTRIES IN it_material
*        WHERE T001W~WERKS EQ P_WERKS
*          AND MVKE~MATNR  EQ IT_MATERIAL-MATNR
*          AND MVKE~VTWEG  EQ '01'.  "#EC CI_BUFFJOIN
          WHERE matnr EQ it_material-matnr
* Begin of change MOd-010
            AND vkorg EQ p_salorg
*            AND vkorg EQ gv_vkorg
* End of change MOd-010
            AND vtweg EQ '01'
            AND prodh IN r_prdha.                     "#EC CI_BUFFJOIN*
  ENDIF.

* Get the description of MVKE-MVGR5 values
  SELECT      *
         FROM tvm5t
         INTO TABLE it_mvgr5
        WHERE spras EQ sy-langu.

* Get the shipping instruction for EINE-EVERS
  SELECT      *
         FROM t027b
         INTO TABLE it_evers
        WHERE spras EQ sy-langu.

* Currency
  SELECT SINGLE t001~waers
           INTO gv_waers
           FROM t001w
          INNER JOIN t001k
             ON t001w~bwkey = t001k~bwkey
          INNER JOIN t001
             ON t001k~bukrs = t001~bukrs
          WHERE t001w~werks EQ p_werks.                "#EC CI_BUFFJOIN

* Fixed vendor
  IF NOT it_material[] IS INITIAL.
    SELECT      matnr eord~werks eord~lifnr flifn ktokk
           INTO TABLE it_eord
           FROM eord
          INNER JOIN lfa1
             ON eord~lifnr = lfa1~lifnr
            FOR ALL entries IN it_material
          WHERE matnr EQ it_material-matnr
            AND eord~werks EQ p_werks
            AND flifn EQ c_x.                          "#EC CI_BUFFJOIN
  ENDIF.

* Get PIR data, but only when we have suppliers
  READ TABLE it_eord INDEX 1.
  IF sy-subrc EQ 0.
    SELECT      a~matnr
                b~werks b~netpr b~peinh b~waers b~aplfz b~evers
           INTO TABLE it_eine
           FROM eina AS a
          INNER JOIN eine AS b
             ON a~infnr = b~infnr
            FOR ALL ENTRIES IN it_eord
          WHERE a~matnr EQ it_eord-matnr
            AND a~lifnr EQ it_eord-lifnr
            AND a~loekz EQ space
            AND b~werks EQ p_werks
            AND b~ekorg EQ gv_ekorg.

*   Get transfer prices
    IF NOT it_eord[] IS INITIAL.
      SELECT      kappl kschl lifnr matnr ekorg werks esokz datbi datab knumh
             INTO CORRESPONDING FIELDS OF TABLE it_a017
             FROM a017
              FOR ALL ENTRIES IN it_eord
            WHERE kappl EQ 'M'
              AND kschl EQ 'PB00'
              AND lifnr EQ it_eord-lifnr
              AND matnr EQ it_eord-matnr
              AND datbi GT sy-datum
              AND esokz EQ '0'.
* Begin of MOD-010
*              AND ekorg EQ gv_ekorg.
* End of MOD-010
    ENDIF.
    SORT it_a017 BY lifnr matnr ekorg werks.
* Begin of delete MOD-012
*    LOOP AT it_a017.
*      SELECT SINGLE kopos kbetr kpein konwa
*               INTO (it_a017-kopos, it_a017-kbetr, it_a017-kpein, it_a017-konwa)
*               FROM konp
*              WHERE knumh EQ it_a017-knumh.
*      MODIFY it_a017.
*    ENDLOOP.
* End of delete MOD-012
* Begin of insert MOD-012
    IF it_a017[] IS NOT INITIAL.
      SELECT kopos kbetr kpein konwa
      INTO  (it_a017-kopos, it_a017-kbetr, it_a017-kpein, it_a017-konwa)
      FROM konp FOR ALL ENTRIES IN it_a017
      WHERE knumh EQ it_a017-knumh.
         IF sy-subrc = 0.
          APPEND it_a017.
          CLEAR it_a017.
        ENDIF.
      ENDSELECT.
    ENDIF.
* End of insert MOD-012
    ENDIF.

* Material cost (standard price)
    IF NOT it_material[] IS INITIAL.
      SELECT      stprs matnr peinh werks
* begin of insertion MOD-006
                  verpr
* end of insertion MOD-006
             INTO CORRESPONDING FIELDS OF TABLE it_mbew
             FROM mbew
            INNER JOIN t001w
               ON mbew~bwkey = t001w~bwkey
              FOR ALL entries IN it_material
            WHERE matnr = it_material-matnr
              AND werks = p_werks
* begin of insertion MOD-006
              AND bwtar = ' '.
* end of insertion MOD-006
    ENDIF.
* Get Planned receipts
    PERFORM get_planned_receipts.

* Begin of insert MOD-010
    IF p_goods <> 'X'.
* End of insert MOD-010
* Get goods qty's in transit
      PERFORM get_goods_in_transit.
* Begin of insert MOD-010
    ENDIF.
* End of insert MOD-010


* Get order data for "stock back order" and "open sales orders" (allocated stock)
    PERFORM get_order_data.

* Get service reservation data for "stock back order" and "open reservations" (allocated stock)
    PERFORM get_service_data.

* Get allocated stock
    PERFORM get_allocated_stock.

*>>>>>> Begin of insert EXTUVE 20090807
    PERFORM get_allocated_stock1.
*>>>>>> End of insert EXTUVE 20090807
* Get stock back order
    PERFORM get_stock_border.

* Get issue / receipt data
    PERFORM get_dates.

* Surplus data
*  PERFORM FILL_SURPLUS.

* Find the stock history

    PERFORM get_stock_history.

* Find the stock forecast
    PERFORM get_stock_forecast.

  ENDFORM.                    " GET_ADD_DATA

*&---------------------------------------------------------------------*
*&      Form  GET_PLANNED_RECEIPTS
*&---------------------------------------------------------------------*
FORM get_planned_receipts.

*if in selection screen 1000 as storage location, take materials into account storage location blank
*  IF p_lgort NE '1000'.
  IF '1000' NOT IN s_lgort .
* Find PO quantities
    SELECT    ebeln ebelp matnr werks lgort menge
      INTO TABLE it_ekpo
      FROM ekpo
* Begin of change MOD-010
*     AS a INNER JOIN ekpo AS b
*      ON a~ebeln = b~ebeln
*           FROM ekpo
* End of change MOD-010
          WHERE matnr IN s_matnr
            AND werks EQ p_werks
*            AND lgort EQ p_lgort
            AND lgort IN s_lgort
            AND loekz EQ space
            AND retpo EQ space
            AND elikz EQ space.
* Begin of insert MOD-010
*            AND ekorg = gv_ekorg.
* End of insert MOD-010
  ELSE.
    SELECT     ebeln ebelp matnr werks lgort menge
      INTO TABLE it_ekpo
      FROM ekpo
* Begin of change MOD-010
*       AS a INNER JOIN ekpo AS b
*      ON a~ebeln = b~ebeln
*         FROM ekpo
* End of change MOD-010
         WHERE matnr IN s_matnr
          AND werks EQ p_werks
*          AND ( lgort EQ '1000'
           AND ( lgort IN s_lgort
                      OR  lgort EQ  '' )
          AND loekz EQ space
          AND retpo EQ space
          AND elikz EQ space.
* Begin of insert MOD-010
*          AND a~ekorg = gv_ekorg.
* End of insert MOD-010
  ENDIF.

* Summarize PO target quanities per Plant/Stloc material
*   and delete entries that are not in material table
  LOOP AT it_ekpo.
    READ TABLE it_material WITH KEY matnr = it_ekpo-matnr
                           BINARY SEARCH.
    IF sy-subrc NE 0.
      DELETE it_ekpo.
    ELSE.
      it_open_po-matnr = it_ekpo-matnr.
      it_open_po-werks = it_ekpo-werks.
      it_open_po-lgort = it_ekpo-lgort.
      it_open_po-qty   = it_ekpo-menge.
      COLLECT it_open_po.
    ENDIF.
  ENDLOOP.

* If open PO quantities found
  READ TABLE it_open_po INDEX 1.
  IF sy-subrc EQ 0.

*   Select receipt items
    SELECT      ebeln ebelp zekkn vgabe gjahr belnr buzei matnr werks menge bwart
           INTO TABLE it_ekbe
           FROM ekbe
            FOR ALL ENTRIES IN it_ekpo
          WHERE ebeln EQ it_ekpo-ebeln
            AND vgabe = '1'.            " Goods Receipt

*   Subtract receipted qty's from open PO table
    LOOP AT it_ekbe.
      READ TABLE it_ekpo WITH KEY ebeln = it_ekbe-ebeln
                                  ebelp = it_ekbe-ebelp.
      IF sy-subrc EQ 0.
        it_open_po-matnr = it_ekbe-matnr.
        it_open_po-werks = it_ekpo-werks.
        it_open_po-lgort = it_ekpo-lgort.
*  Take debet and credit (or bwart into account)
        IF it_ekbe-bwart EQ '641' OR it_ekbe-bwart EQ '101' OR it_ekbe-bwart EQ '643'.
          it_open_po-qty = it_ekbe-menge * ( -1 ).
        ELSEIF it_ekbe-bwart EQ '642' OR it_ekbe-bwart EQ '102' OR it_ekbe-bwart EQ '644'.
          it_open_po-qty = it_ekbe-menge.
        ELSE.
          CLEAR it_open_po-qty.
        ENDIF.
        COLLECT it_open_po.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                    " GET_PLANNED_RECEIPTS

*&---------------------------------------------------------------------*
*&      Form  SET_ADD_VARS
*&---------------------------------------------------------------------*
FORM set_add_vars .

* To get automatic search help for vendor, another field was referenced. However, that
* field allows for 4 more positions, so that testing for equality fails. Therefore, copy
* to global variable.
  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
    EXPORTING
      input  = p_lifnr
    IMPORTING
      output = gv_lifnr.

ENDFORM.                    " SET_ADD_VARS

*&---------------------------------------------------------------------*
*&      Form  FIND_FIXED_VENDOR_FOR_MAT
*&---------------------------------------------------------------------*
FORM find_fixed_vendor_for_mat CHANGING p_skip TYPE c.

* Assume we want to keep the material
  CLEAR p_skip.
* Supplier (fixed vendor)
  CLEAR sy-subrc.
* If current entry in EORD does not correspond to current materil
  IF    it_material-matnr NE it_eord-matnr
     OR it_material-werks NE it_eord-werks.
*   Read table EORD for current material
    READ TABLE it_eord WITH KEY matnr = it_material-matnr
                                werks = it_material-werks.
  ENDIF.
* If supplier found, check it against selection criteria
  IF sy-subrc EQ 0.
*   Copy supplier
    wa_output-lifnr = it_eord-lifnr.    " Supplier (fixed vendor)
*   If user specified vendor on selection screen
    IF NOT p_lifnr IS INITIAL.
*     If different from vendor of the material, skip the material
      IF it_eord-lifnr NE gv_lifnr.
        p_skip = 'X'.
      ENDIF.
    ENDIF.
*   If user specified vendor account group on selection screen
    IF NOT p_ktokk IS INITIAL.
*     If vendor account group is different from selection crit, skip
      IF it_eord-ktokk NE p_ktokk.
        p_skip = 'X'.
      ENDIF.
    ENDIF.
* Supplier not found, while vendor or vendor account group specified
* on selection screen, skip the material
  ELSEIF NOT p_lifnr IS INITIAL OR NOT p_ktokk IS INITIAL.
    p_skip = 'X'.
  ENDIF.

ENDFORM.                    " FIND_FIXED_VENDOR_FOR_MAT

*&---------------------------------------------------------------------*
*&      Form  SET_MRP_TYPE_FOR_MAT
*&---------------------------------------------------------------------*
FORM set_mrp_type_for_mat .

  CASE it_material-dismm.
    WHEN 'Z5'.
      wa_output-stock_pol = 'ST'.
    WHEN 'Z6' OR 'Z7'.
      wa_output-stock_pol = 'NS'.
  ENDCASE.

ENDFORM.                    " SET_MRP_TYPE_FOR_MAT


* Begin of insert MOD-007
*&---------------------------------------------------------------------*
*&      Form  SET_HITS_FOR_X_MONTHS
*&---------------------------------------------------------------------*
FORM set_hits_for_x_months.

  DATA: p_date6 LIKE sy-datum,
        p_date12 LIKE sy-datum.

*Begin of insert MOD-009
  TYPES: BEGIN OF ty_vbrp_zor_qty,
           vbeln TYPE vbeln_vf,
           posnr TYPE posnr_vf,
           fkimg TYPE fkimg,
           aubel TYPE vbeln_va,
           matnr TYPE matnr,
         END OF ty_vbrp_zor_qty.

  TYPES: BEGIN OF ty_vbap_zre1_qty,
           vbeln  TYPE vbeln_va,
           posnr  TYPE posnr_va,
           matnr  TYPE matnr,
           kwmeng TYPE kwmeng,
         END OF ty_vbap_zre1_qty.

  TYPES: BEGIN OF ty_lips_zo03_qty,
           vbeln  TYPE vbeln_vl,
           posnr  TYPE posnr_vl,
           matnr  TYPE matnr,
           lfimg  TYPE lfimg,
         END OF ty_lips_zo03_qty.

  DATA: it_vbrp_zor_qty_6   TYPE STANDARD TABLE OF ty_vbrp_zor_qty,
        wa_vbrp_zor_qty_6   TYPE ty_vbrp_zor_qty,
        lv_qty_zor_6        TYPE vbrp-fkimg,
        it_vbrp_zor_qty_12  TYPE STANDARD TABLE OF ty_vbrp_zor_qty,
        wa_vbrp_zor_qty_12  TYPE ty_vbrp_zor_qty,
        lv_qty_zor_12       TYPE vbrp-fkimg,
        it_vbap_zre1_qty_6  TYPE STANDARD TABLE OF ty_vbap_zre1_qty,
        wa_vbap_zre1_qty_6  TYPE ty_vbap_zre1_qty,
        lv_qty_zre1_6       TYPE vbap-kwmeng,
        it_vbap_zre1_qty_12 TYPE STANDARD TABLE OF ty_vbap_zre1_qty,
        wa_vbap_zre1_qty_12 TYPE ty_vbap_zre1_qty,
        lv_qty_zre1_12      TYPE vbap-kwmeng,
        it_lips_ht_zo03_6   TYPE STANDARD TABLE OF ty_lips_zo03_qty,
        wa_lips_ht_zo03_6   TYPE ty_lips_zo03_qty,
        lv_qty_zo03_6       TYPE lips-lfimg,
        it_lips_ht_zo03_12  TYPE STANDARD TABLE OF ty_lips_zo03_qty,
        wa_lips_ht_zo03_12  TYPE ty_lips_zo03_qty,
        lv_qty_zo03_12      TYPE lips-lfimg.

  REFRESH: it_vbrp_zor_qty_6,
           it_vbrp_zor_qty_12,
           it_vbap_zre1_qty_6,
           it_vbap_zre1_qty_12.

  CLEAR:   lv_qty_zor_6,
           lv_qty_zor_12,
           lv_qty_zre1_6,
           lv_qty_zre1_12.

*End of insert MOD-009

  CLEAR lv_nbr_zor_6.
  CLEAR lv_nbr_zor_12.
  CLEAR lv_nbr_zre1_6.
  CLEAR lv_nbr_zre1_12.
  CLEAR lv_nbr_zo03_6.
  CLEAR lv_nbr_zo03_12.
  CLEAR it_vbap_ht_zor_6[].
  CLEAR it_vbap_ht_zor_12[].
  CLEAR it_vbap_ht_zo03_6[].
  CLEAR it_vbap_ht_zo03_12[].

* Retrieve period 6 months
  CALL FUNCTION 'MONTH_PLUS_DETERMINE'
    EXPORTING
      months  = -6
      olddate = sy-datum
    IMPORTING
      newdate = p_date6.
  p_date6 = p_date6 + 1.

* Retrieve period 12 months
  CALL FUNCTION 'MONTH_PLUS_DETERMINE'
    EXPORTING
      months  = -12
      olddate = sy-datum
    IMPORTING
      newdate = p_date12.
  p_date12 = p_date12 + 1.

  IF it_material-lgort IS INITIAL OR it_material-lgort = '1000'.
* Retrieve type ZOR orders
    SELECT vbap~vbeln vbap~posnr vbap~matnr vbap~kwmeng vbap~werks vbak~vbtyp
         INTO TABLE it_vbap_ht_zor
         FROM vbak
        INNER JOIN vbap
           ON vbak~vbeln EQ vbap~vbeln
        WHERE auart IN ('ZOR') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              ( lgort = '1000' OR lgort = ' ' ).
* Begin of insert MOD-010
*        AND vbak~VKORG = p_SALORG.
* End of insert MOD-010




* Retrieve type ZO03 orders
    SELECT vbap~vbeln vbap~posnr vbap~matnr vbap~kwmeng vbap~werks vbak~vbtyp
         INTO TABLE it_vbap_ht_zo03
         FROM vbak
        INNER JOIN vbap
           ON vbak~vbeln EQ vbap~vbeln
        WHERE auart IN ('ZO03') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              ( lgort = '1000' OR lgort = ' ' ).
* Begin of insert MOD-010
*        AND vbak~VKORG = p_SALORG.
* End of insert MOD-010



* Retrieve nbr of type ZRE1 orders for 6 months period
    SELECT COUNT(*)
         INTO lv_nbr_zre1_6
         FROM vbak AS a
        INNER JOIN vbap AS b
           ON a~vbeln EQ b~vbeln
        WHERE auart IN ('ZRE1') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              ( lgort = '1000' OR lgort = ' ' ) AND
              a~erdat BETWEEN p_date6 AND sy-datum.
* Begin of insert MOD-010
*              AND a~VKORG = p_SALORG.
* End of insert MOD-010
*Begin of insert MOD-009
*Retrieve quantities of type ZRE1 orders for 6 months period
    SELECT b~vbeln
           b~posnr
           b~matnr
           b~kwmeng
         INTO CORRESPONDING FIELDS OF TABLE it_vbap_zre1_qty_6
         FROM vbak AS a
        INNER JOIN vbap AS b
           ON a~vbeln EQ b~vbeln
        WHERE auart IN ('ZRE1') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              ( lgort = '1000' OR lgort = ' ' ) AND
              a~erdat BETWEEN p_date6 AND sy-datum.
* Begin of insert MOD-010
*        AND a~VKORG = p_SALORG.
* End of insert MOD-010

*Total quantity for ZRE1 type for 6 months
    CLEAR: lv_qty_zre1_6.
    LOOP AT it_vbap_zre1_qty_6 INTO wa_vbap_zre1_qty_6.
      lv_qty_zre1_6 = lv_qty_zre1_6 + wa_vbap_zre1_qty_6-kwmeng.
    ENDLOOP.

*End of insert MOD-009

* Retrieve nbr of type ZRE1 orders for 12 months period
    SELECT COUNT(*)
         INTO lv_nbr_zre1_12
         FROM vbak AS a
        INNER JOIN vbap AS b
           ON a~vbeln EQ b~vbeln
        WHERE auart IN ('ZRE1') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              ( lgort = '1000' OR lgort = ' ' ) AND
              a~erdat BETWEEN p_date12 AND sy-datum.
* Begin of insert MOD-010
*        AND a~VKORG = p_SALORG.
* End of insert MOD-010

*Begin of insert MOD-009
*Retrieve quantities of type ZRE1 orders for 12 months period
    SELECT b~vbeln
           b~posnr
           b~matnr
           b~kwmeng
         INTO CORRESPONDING FIELDS OF TABLE it_vbap_zre1_qty_12
         FROM vbak AS a
        INNER JOIN vbap AS b
           ON a~vbeln EQ b~vbeln
        WHERE auart IN ('ZRE1') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              ( lgort = '1000' OR lgort = ' ' ) AND
              a~erdat BETWEEN p_date12 AND sy-datum.
* Begin of insert MOD-010
*        AND a~VKORG = p_SALORG.
* End of insert MOD-010

*Total quantity for ZRE1 type for 12 months
    CLEAR: lv_qty_zre1_12.
    LOOP AT it_vbap_zre1_qty_12 INTO wa_vbap_zre1_qty_12.
      lv_qty_zre1_12 = lv_qty_zre1_12 + wa_vbap_zre1_qty_12-kwmeng.
    ENDLOOP.

*End of insert MOD-009

  ELSE.
* Retrieve type ZOR orders
    SELECT vbap~vbeln vbap~posnr vbap~matnr vbap~kwmeng vbap~werks vbak~vbtyp
         INTO TABLE it_vbap_ht_zor
         FROM vbak
        INNER JOIN vbap
           ON vbak~vbeln EQ vbap~vbeln
        WHERE auart IN ('ZOR') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              lgort = it_material-lgort.
* Begin of insert MOD-010
*        AND vbak~VKORG = p_SALORG.
* End of insert MOD-010




* Retrieve type ZO03 orders
    SELECT vbap~vbeln vbap~posnr vbap~matnr vbap~kwmeng vbap~werks vbak~vbtyp
         INTO TABLE it_vbap_ht_zo03
         FROM vbak
        INNER JOIN vbap
           ON vbak~vbeln EQ vbap~vbeln
        WHERE auart IN ('ZO03') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              lgort = it_material-lgort.
* Begin of insert MOD-010
*        AND vbak~VKORG = p_SALORG.
* End of insert MOD-010



* Retrieve nbr of type ZRE1 orders for 6 months period
    SELECT COUNT(*)
         INTO lv_nbr_zre1_6
         FROM vbak AS a
        INNER JOIN vbap AS b
           ON a~vbeln EQ b~vbeln
        WHERE auart IN ('ZRE1') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              lgort = it_material-lgort AND
              a~erdat BETWEEN p_date6 AND sy-datum.
* Begin of insert MOD-010
*        AND a~VKORG = p_SALORG.
* End of insert MOD-010

*Begin of insert MOD-009
*Retrieve quantities of type ZRE1 orders for 6 months period
    SELECT b~vbeln
           b~posnr
           b~matnr
           b~kwmeng
         INTO CORRESPONDING FIELDS OF TABLE it_vbap_zre1_qty_6
         FROM vbak AS a
        INNER JOIN vbap AS b
           ON a~vbeln EQ b~vbeln
        WHERE auart IN ('ZRE1') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              lgort = it_material-lgort AND
              a~erdat BETWEEN p_date6 AND sy-datum.
* Begin of insert MOD-010
*        AND a~VKORG = p_SALORG.
* End of insert MOD-010

*Total quantity for ZRE1 type for 6 months
    CLEAR: lv_qty_zre1_6.
    LOOP AT it_vbap_zre1_qty_6 INTO wa_vbap_zre1_qty_6.
      lv_qty_zre1_6 = lv_qty_zre1_6 + wa_vbap_zre1_qty_6-kwmeng.
    ENDLOOP.

*End of insert MOD-009

* Retrieve nbr of type ZRE1 orders for 12 months period
    SELECT COUNT(*)
         INTO lv_nbr_zre1_12
         FROM vbak AS a
        INNER JOIN vbap AS b
           ON a~vbeln EQ b~vbeln
        WHERE auart IN ('ZRE1') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              lgort = it_material-lgort AND
              a~erdat BETWEEN p_date12 AND sy-datum.
* Begin of insert MOD-010
*        AND a~VKORG = p_SALORG.
* End of insert MOD-010

*Begin of insert MOD-009
*Retrieve quantities of type ZRE1 orders for 12 months period
    SELECT b~vbeln
           b~posnr
           b~matnr
           b~kwmeng
         INTO CORRESPONDING FIELDS OF TABLE it_vbap_zre1_qty_12
         FROM vbak AS a
        INNER JOIN vbap AS b
           ON a~vbeln EQ b~vbeln
        WHERE auart IN ('ZRE1') AND
              matnr = it_material-matnr AND
              werks = p_werks AND
              lgort = it_material-lgort AND
              a~erdat BETWEEN p_date12 AND sy-datum.
* Begin of insert MOD-010
*        AND a~VKORG = p_SALORG.
* End of insert MOD-010

*Total quantity for ZRE1 type for 12 months
    CLEAR: lv_qty_zre1_12.
    LOOP AT it_vbap_zre1_qty_12 INTO wa_vbap_zre1_qty_12.
      lv_qty_zre1_12 = lv_qty_zre1_12 + wa_vbap_zre1_qty_12-kwmeng.
    ENDLOOP.

*End of insert MOD-009

  ENDIF.

********************** ZOR ********************************
* Valid ZOR's for 6 months period
  IF NOT it_vbap_ht_zor[] IS INITIAL.
    SELECT      a~vbelv b~vbeln
           INTO TABLE it_vbap_ht_zor_6
           FROM vbfa AS a
           JOIN vbrk AS b
             ON a~vbeln EQ b~vbeln
            FOR ALL ENTRIES IN it_vbap_ht_zor
          WHERE a~vbelv = it_vbap_ht_zor-vbeln
            AND a~posnv = it_vbap_ht_zor-posnr
            AND a~vbtyp_n = 'M'
            AND b~fkdat BETWEEN p_date6 AND sy-datum.
    .  " Deliveries
*            AND c~wbstk = 'C'.
  ENDIF.

* select number of hits material in 6 months (ZOR)
  IF it_vbap_ht_zor_6[] IS NOT INITIAL.
    SELECT COUNT(*) INTO lv_nbr_zor_6 FROM vbap
      FOR ALL ENTRIES IN it_vbap_ht_zor_6
      WHERE vbeln = it_vbap_ht_zor_6-vbeln AND
            matnr = it_material-matnr AND
            kwmeng <> 0.
  ENDIF.

*Begin of insert MOD-009
*Get ZOR's quanities for 6 months period
  IF it_vbap_ht_zor_6[] IS NOT INITIAL.
    SELECT vbeln
           posnr
           fkimg
           aubel
           matnr
    INTO   CORRESPONDING FIELDS OF TABLE it_vbrp_zor_qty_6
    FROM   vbrp
    FOR    ALL ENTRIES IN it_vbap_ht_zor_6
    WHERE  vbeln EQ it_vbap_ht_zor_6-vbelv
    AND    matnr EQ it_material-matnr.
  ENDIF.

*Total quantity for ZOR for 6 months period
  CLEAR: wa_vbrp_zor_qty_6,
         lv_qty_zor_6.
  LOOP AT it_vbrp_zor_qty_6 INTO wa_vbrp_zor_qty_6.
    lv_qty_zor_6 = lv_qty_zor_6 + wa_vbrp_zor_qty_6-fkimg.
  ENDLOOP.
*End of insert MOD-009


* Valid ZOR's for 12 months period
  IF NOT it_vbap_ht_zor[] IS INITIAL.
    SELECT      a~vbelv b~vbeln
           INTO TABLE it_vbap_ht_zor_12
           FROM vbfa AS a
           JOIN vbrk AS b
             ON a~vbeln EQ b~vbeln
            FOR ALL ENTRIES IN it_vbap_ht_zor
          WHERE a~vbelv = it_vbap_ht_zor-vbeln
            AND a~posnv = it_vbap_ht_zor-posnr
            AND a~vbtyp_n = 'M'
            AND b~fkdat BETWEEN p_date12 AND sy-datum.
    .  " Deliveries
*            AND c~wbstk = 'C'.
  ENDIF.

* select number of hits material in 12 months (ZOR)
  IF it_vbap_ht_zor_12[] IS NOT INITIAL.
*  Begin of Deletion of MOD-014
*    SELECT COUNT(*) INTO lv_nbr_zor_12 FROM vbap
*      FOR ALL ENTRIES IN it_vbap_ht_zor_12
*      WHERE vbeln = it_vbap_ht_zor_12-vbeln AND
*            matnr = it_material-matnr AND
*            kwmeng <> 0.
*  End of Deletion of MOD-014
*   Begin of Insertion of MOD-014
    SELECT COUNT(*) INTO lv_nbr_zor_12
    FROM   vbrp
    FOR    ALL ENTRIES IN it_vbap_ht_zor_12
    WHERE  vbeln EQ it_vbap_ht_zor_12-vbelv
    AND    matnr EQ it_material-matnr
    AND    FKIMG <> 0.
*   End of Insertion of MOD-014
  ENDIF.

*Begin of insert MOD-009
*Get ZOR's quanities for 12 months period
  IF it_vbap_ht_zor_12[] IS NOT INITIAL.
    SELECT vbeln
           posnr
           fkimg
           aubel
           matnr
    INTO   CORRESPONDING FIELDS OF TABLE it_vbrp_zor_qty_12
    FROM   vbrp
    FOR    ALL ENTRIES IN it_vbap_ht_zor_12
    WHERE  vbeln EQ it_vbap_ht_zor_12-vbelv
    AND    matnr EQ it_material-matnr.
  ENDIF.

*Total quantity for ZOR for 12 months period
  CLEAR: wa_vbrp_zor_qty_12,
         lv_qty_zor_12.
  LOOP AT it_vbrp_zor_qty_12 INTO wa_vbrp_zor_qty_12.
    lv_qty_zor_12 = lv_qty_zor_12 + wa_vbrp_zor_qty_12-fkimg.
  ENDLOOP.
*End of insert MOD-009

****************** ZO03 ***********************************
* Valid ZO03's for 6 months period
  IF NOT it_vbap_ht_zo03[] IS INITIAL.
    SELECT      a~vbelv b~vbeln
           INTO TABLE it_vbap_ht_zo03_6
           FROM vbfa AS a
           JOIN likp AS b
             ON a~vbeln EQ b~vbeln
            FOR ALL ENTRIES IN it_vbap_ht_zo03
          WHERE a~vbelv = it_vbap_ht_zo03-vbeln
            AND a~posnv = it_vbap_ht_zo03-posnr
            AND a~vbtyp_n = 'J'
            AND b~wadat BETWEEN p_date6 AND sy-datum.
    .  " Deliveries
*            AND c~wbstk = 'C'.
  ENDIF.

* select number of hits material in 6 months (ZO03)
  IF it_vbap_ht_zo03_6[] IS NOT INITIAL.
    SELECT COUNT(*) INTO lv_nbr_zo03_6 FROM vbap
      FOR ALL ENTRIES IN it_vbap_ht_zo03_6
      WHERE vbeln = it_vbap_ht_zo03_6-vbeln AND
            matnr = it_material-matnr AND
            kwmeng <> 0.
  ENDIF.

*Begin of insert MOD-009
*Retrieve quantities for type ZO03 for 6 months
  IF NOT it_vbap_ht_zo03_6[] IS INITIAL.
    SELECT vbeln
           posnr
           matnr
           lfimg
    FROM   lips
    INTO   CORRESPONDING FIELDS OF TABLE it_lips_ht_zo03_6
    FOR    ALL ENTRIES IN it_vbap_ht_zo03_6
    WHERE  vbeln EQ it_vbap_ht_zo03_6-vbelv
    AND    matnr EQ it_material-matnr.
  ENDIF.

*Total quantity for ZO03 type for 6 months
  LOOP AT it_lips_ht_zo03_6 INTO wa_lips_ht_zo03_6.
    lv_qty_zo03_6 = lv_qty_zo03_6 + wa_lips_ht_zo03_6-lfimg.
  ENDLOOP.
*End of insert MOD-009

* Valid ZO03's for 12 months period
  IF NOT it_vbap_ht_zo03[] IS INITIAL.
    SELECT      a~vbelv b~vbeln
           INTO TABLE it_vbap_ht_zo03_12
           FROM vbfa AS a
           JOIN likp AS b
             ON a~vbeln EQ b~vbeln
            FOR ALL ENTRIES IN it_vbap_ht_zo03
          WHERE a~vbelv = it_vbap_ht_zo03-vbeln
            AND a~posnv = it_vbap_ht_zo03-posnr
            AND a~vbtyp_n = 'J'
            AND b~wadat BETWEEN p_date12 AND sy-datum.
    .  " Deliveries
*            AND c~wbstk = 'C'.
  ENDIF.

* select number of hits material in 12 months (ZO03)
  IF it_vbap_ht_zo03_12[] IS NOT INITIAL.
    SELECT COUNT(*) INTO lv_nbr_zo03_12 FROM vbap
      FOR ALL ENTRIES IN it_vbap_ht_zo03_12
      WHERE vbeln = it_vbap_ht_zo03_12-vbeln AND
            matnr = it_material-matnr AND
            kwmeng <> 0.
  ENDIF.

*Begin of insert MOD-009
*Retrieve quantities for type ZO03 for 6 months
  IF it_vbap_ht_zo03_12[] IS NOT INITIAL.
    SELECT vbeln
           posnr
           matnr
           lfimg
    FROM   lips
    INTO   CORRESPONDING FIELDS OF TABLE it_lips_ht_zo03_12
    FOR    ALL ENTRIES IN it_vbap_ht_zo03_12
    WHERE  vbeln EQ it_vbap_ht_zo03_12-vbelv
    AND    matnr EQ it_material-matnr.
  ENDIF.

  LOOP AT it_lips_ht_zo03_12 INTO wa_lips_ht_zo03_12.
    lv_qty_zo03_12 = lv_qty_zo03_12 + wa_lips_ht_zo03_12-lfimg.
  ENDLOOP.
*End of insert MOD-009

  wa_output-hits6 = lv_nbr_zor_6 + lv_nbr_zo03_6 - lv_nbr_zre1_6.
  wa_output-hits12 = lv_nbr_zor_12 + lv_nbr_zo03_12 - lv_nbr_zre1_12.

*Begin of insert MOD-009
  wa_output-qty6  = lv_qty_zor_6  + lv_qty_zo03_6  - lv_qty_zre1_12.
  wa_output-qty12 = lv_qty_zor_12 + lv_qty_zo03_12 - lv_qty_zre1_12.
*End of insert MOD-009

ENDFORM.                    "set_hits_for_x_months
* End of insert MOD-007

*&---------------------------------------------------------------------*
*&      Form  SET_STATUS_DESC_FOR_MAT
*&---------------------------------------------------------------------*
FORM set_status_desc_for_mat .

  CLEAR it_t141t.
  READ TABLE it_t141t WITH KEY mmsta = it_material-mmsta
                      BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-mmsta_descr = it_t141t-mtstb.
  ENDIF.

ENDFORM.                    " SET_STATUS_DESC_FOR_MAT

*&---------------------------------------------------------------------*
*&      Form  SET_CONSIGN_STOCK_FOR_MAT
*&---------------------------------------------------------------------*
FORM set_consign_stock_for_mat .

  CLEAR it_msku.
  READ TABLE it_msku WITH KEY matnr = it_material-matnr
                              werks = it_material-werks
                     BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-kulab = it_msku-kulab.
  ENDIF.

ENDFORM.                    " SET_CONSIGN_STOCK_FOR_MAT

*&---------------------------------------------------------------------*
*&      Form  SET_STCOST_FOR_MAT
*&---------------------------------------------------------------------*
FORM set_stcost_for_mat .

  CLEAR it_mbew.
* Standard cost
  READ TABLE it_mbew WITH KEY matnr = it_material-matnr
                              werks = it_material-werks
                     BINARY SEARCH.
  IF sy-subrc EQ 0.
    IF it_mbew-peinh NE 0.
      wa_output-stprs = it_mbew-stprs / it_mbew-peinh.
* begin of insertion MOD-006
      wa_output-verpr = it_mbew-verpr / it_mbew-peinh.
* end of insertion MOD-006
    ENDIF.
  ENDIF.

ENDFORM.                    " SET_STCOST_FOR_MAT

*&---------------------------------------------------------------------*
*&      Form  CALC_FOR_MAT
*&---------------------------------------------------------------------*
FORM calc_for_mat .

* Total stock balance
  wa_output-total_stock = wa_output-labst +
                          wa_output-insme +
                          wa_output-speme +
                          wa_output-retme +
                          wa_output-umlmc +
                          wa_output-umlme +
                          wa_output-trame +
                          wa_output-kulab.

* Total stock value/Goods in transit value
  IF wa_output-stprs EQ '999999999'.
    wa_output-total_value = wa_output-stprs.
    wa_output-git = wa_output-stprs.
* begin of inertion MOD-006
    wa_output-total_value_mac = wa_output-verpr.
    wa_output-git_mac = wa_output-verpr.
* end of insertion MOD-006
  ELSE.
    wa_output-total_value = wa_output-total_stock * wa_output-stprs.
    wa_output-git = wa_output-goods_transit * wa_output-stprs.
* begin of insertion MOD-006
    wa_output-total_value_mac = wa_output-total_stock * wa_output-verpr.
    wa_output-git_mac = wa_output-goods_transit * wa_output-verpr.
* end of insertion MOD-006
  ENDIF.
*  Begin Of Insert EXTUVE 20090821
* Stock available
  wa_output-available = wa_output-labst - wa_output-allocated.
*  end Of Insert EXTUVE 20090821
* SBO
*  Begin Of Insert EXTUVE 20090810
*  wa_output-back = wa_output-available - wa_output-allocated.
*  commented on 15/10/2009
*  End of Insert EXTUVE 20090810

ENDFORM.                    " CALC_FOR_MAT

*&---------------------------------------------------------------------*
*&      Form  SET_SO_STOCK_FOR_MAT
*&---------------------------------------------------------------------*
FORM set_so_stock_for_mat .

* Sales order stock (not on lgort level)
  READ TABLE it_mska WITH KEY matnr = it_material-matnr
                              werks = it_material-werks
                              lgort = it_material-lgort     "CR1452
                              BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-kalab = it_mska-kalab.
  ENDIF.

ENDFORM.                    " SET_SO_STOCK_FOR_MAT

*&---------------------------------------------------------------------*
*&      Form  SET_ALLOC_STOCK_FOR_MAT
*&---------------------------------------------------------------------*
FORM set_alloc_stock_for_mat .

* Allocated stock
  READ TABLE it_alloc WITH KEY matnr = it_material-matnr
                               werks = it_material-werks
*                               lgort = it_material-lgort "EXTUVE
                      BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-allocated = it_alloc-alloc_quantity.
  ENDIF.

ENDFORM.                    " SET_ALLOC_STOCK_FOR_MAT

*&---------------------------------------------------------------------*
*&      Form  GET_ORDER_DATA
*&---------------------------------------------------------------------*
FORM get_order_data .

  RANGES:
    r_lgort FOR vbap-lgort.

* Fill R_LGORT: If StLoc (LGORT) is 1000, also include lines with LGORT = '    '
*  r_lgort-sign   = 'I'.
*  r_lgort-option = 'EQ'.
*  r_lgort-low    = p_lgort.
*  APPEND r_lgort.
*  IF p_lgort = '1000'.
*    r_lgort-low  = '    '.
*    APPEND r_lgort.
*  ENDIF.

  r_lgort[]  = s_lgort[].

*>>>>>> bEGIN OF MOD 005 EXTUVE   20090602
*  IF '1000' IN s_lgort.
*    r_lgort-sign   = 'I'.
*    r_lgort-option = 'EQ'.
*    r_lgort-low  = '    '.
*    APPEND r_lgort.
*  ENDIF.
*>>>>>> eND OF MOD 005 EXTUVE   20090602

* Get open order item quantities
  SELECT      vbap~vbeln vbap~posnr matnr kwmeng werks lgort abgru
         INTO TABLE it_vbap
         FROM vbak
        INNER JOIN vbap
           ON vbak~vbeln EQ vbap~vbeln
        WHERE matnr IN s_matnr
          AND werks EQ p_werks
          AND (    lgort IN r_lgort
                OR lgort EQ ' ' )
          AND pstyv IN s_pstyv
          AND vbtyp EQ 'C'.
* Begin of insert MOD-010
*         AND vbak~vkorg EQ p_SALORG.
* End of insert MOD-010

ENDFORM.                    " GET_ORDER_DATA

*&---------------------------------------------------------------------*
*&      Form  GET_SERVICE_DATA
*&---------------------------------------------------------------------*
FORM get_service_data .

* Get reservation data
* Begin of change MOD-010
*  SELECT      matnr werks lgort bdmng enmng vmeng umrez umren xwaok
*         INTO TABLE it_resb
*         FROM resb
*        WHERE matnr IN s_matnr
*          AND werks EQ p_werks
**          AND lgort EQ p_lgort
*          AND (    lgort IN s_lgort
*                OR lgort EQ ' ' )
*          AND xloek EQ space
*          AND (    xwaok EQ 'X'
*           OR xwaok EQ space ).

  SELECT      r~matnr r~werks r~lgort r~bdmng r~enmng r~vmeng r~umrez r~umren r~xwaok a~aufnr
         INTO TABLE it_resb
         FROM resb AS r
         INNER JOIN aufk AS a
          ON r~kdauf EQ a~aufnr
         INNER JOIN vbak AS v
          ON a~kdauf EQ v~vbeln
        WHERE r~matnr IN s_matnr
          AND r~werks EQ p_werks
*          AND lgort EQ p_lgort
          AND (    r~lgort IN s_lgort
                OR r~lgort EQ ' ' )
          AND r~xloek EQ space
          AND (    r~xwaok EQ 'X'
           OR r~xwaok EQ space )
          AND v~vkorg = p_salorg.
* End of change MOD-010

ENDFORM.                    " GET_SERVICE_DATA

*&---------------------------------------------------------------------*
*&      Form  SET_MATPLANT_DATA
*&---------------------------------------------------------------------*
FORM set_matplant_data .

* Pack qty and lot size flag
  READ TABLE it_matplant WITH KEY matnr = it_material-matnr
                                  werks = it_material-werks
                         BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-pack_qty    = it_matplant-pack_qty.
    wa_output-lotsize_ind = it_matplant-lotsize_ind.
  ENDIF.

ENDFORM.                    " SET_MATPLANT_DATA

*&---------------------------------------------------------------------*
*&      Form  SET_PIR_DATA
*&---------------------------------------------------------------------*
FORM set_pir_data .

* Find PIR line
  READ TABLE it_eine WITH KEY matnr = it_material-matnr
                              werks = it_material-werks
                     BINARY SEARCH.
  IF sy-subrc EQ 0.

*   Set planned delivery time (info record)
    wa_output-aplfz = it_eine-aplfz.

*   If there is a value in the PIR for shipping instructions
    IF NOT it_eine-evers IS INITIAL.

      READ TABLE it_evers WITH KEY evers = it_eine-evers BINARY SEARCH.
      wa_output-evers_descr = it_evers-evtxt.
      wa_output-evers = it_eine-evers.
    ENDIF.

  ENDIF.

* Find condition
  READ TABLE it_a017 WITH KEY lifnr = wa_output-lifnr
                              matnr = wa_output-matnr
                              ekorg = gv_ekorg
                              werks = wa_output-werks
                     BINARY SEARCH.
  IF sy-subrc EQ 0.
*   Transfer price
    wa_output-netpr = it_a017-kbetr.
    wa_output-netwa = it_a017-konwa.
*    IF IT_A017-KONWA = WA_OUTPUT-WAERK.
*      WA_OUTPUT-NETPR = IT_A017-KBETR.
**   If not in CoCo currency, convert the value
*    ELSE.
*      CALL FUNCTION 'CONVERT_AMOUNT_TO_CURRENCY'
*        EXPORTING
*          DATE             = SY-DATUM
*          FOREIGN_CURRENCY = IT_A017-KONWA
*          FOREIGN_AMOUNT   = IT_A017-KBETR
*          LOCAL_CURRENCY   = WA_OUTPUT-WAERK
*        IMPORTING
*          LOCAL_AMOUNT     = WA_OUTPUT-NETPR
*        EXCEPTIONS
*          ERROR            = 0
*          OTHERS           = 0.
*    ENDIF.
*   Now express it as unit price
    IF it_a017-kpein NE 0.
      wa_output-netpr = wa_output-netpr / it_a017-kpein.
    ENDIF.
  ENDIF.

ENDFORM.                    " SET_PIR_DATA

*&---------------------------------------------------------------------*
*&      Form  SET_SALES_DATA
*&---------------------------------------------------------------------*
FORM set_sales_data  CHANGING p_skip TYPE c.
* Begin of insert MOD-007
  DATA: lv_prctr_mat TYPE prctr,
        it_plc         TYPE k9rcd11000010    OCCURS 0 WITH HEADER LINE.
  DATA : gv_bukrs TYPE bukrs,
         gv_bwkey TYPE bwkey.

  CLEAR: gv_bukrs, gv_bwkey.
  SELECT SINGLE bwkey INTO gv_bwkey FROM t001w
    WHERE werks = p_werks.
  SELECT SINGLE bukrs INTO gv_bukrs FROM t001k
    WHERE bwkey = gv_bwkey.

* End of insert MOD-007

* Read sales data
  READ TABLE it_mvke WITH KEY matnr = it_material-matnr
                     BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-gac   = it_mvke-prodh(4).    " GAC
    wa_output-pgc   = it_mvke-prodh+4(4).  " PGC
* Begin of insert MOD-007
* Get PLC Data
    SELECT SINGLE prctr INTO lv_prctr_mat
                        FROM yse_prctr_deriv WHERE pgc = wa_output-pgc
                                             AND vtweg = '01'.
    IF sy-subrc = 0.

      CALL FUNCTION 'YSE_CONVERT_PRCTR_BL'
        EXPORTING
          prctr_in    = lv_prctr_mat
          bukrs       = gv_bukrs
        IMPORTING
          segment_out = lv_prctr_mat.
*.. Derive segment from profit center
      CLEAR it_plc[].
      SELECT      *
*         FROM K9RCD11000009
             FROM k9rcd11000010                             "20080417
             INTO TABLE it_plc.

      LOOP AT it_plc WHERE sour1_from LE lv_prctr_mat
                       AND sour1_to   GE lv_prctr_mat
                       AND valid_from LE sy-datum.
        wa_output-plc = it_plc-target1.
        EXIT.
      ENDLOOP.
    ENDIF.
* End of insert MOD-007

*   If anti piracy flag set
    IF NOT it_mvke-mvgr5 IS INITIAL.
*     Find description for anti piracy flag
      CLEAR it_mvgr5.
      READ TABLE it_mvgr5 WITH KEY mvgr5 = it_mvke-mvgr5 BINARY SEARCH.
      wa_output-mvgr5_descr = it_mvgr5-bezei.
      wa_output-mvgr5       = it_mvke-mvgr5.
    ENDIF.

*   Set distribution mode
    IF it_mvke-mtpos EQ 'ZDTC'.
      wa_output-distri_mode = 'DTC'.
    ELSEIF it_mvke-mtpos EQ 'NORM' AND it_mvke-mvgr4 EQ space.
      wa_output-distri_mode = 'NDTC'.
    ELSEIF it_mvke-mtpos EQ 'NORM' AND it_mvke-mvgr4 EQ 'LCL'.
      wa_output-distri_mode = 'LCL'.
    ENDIF.
  ELSE.
    p_skip = 'X'.
  ENDIF.

ENDFORM.                    " SET_SALES_DATA

*&---------------------------------------------------------------------*
*&      Form  FILL_RANGES
*&---------------------------------------------------------------------*
FORM fill_ranges .

  r_bwart_receipt-sign = 'I'.
  r_bwart_receipt-option = 'EQ'.
  r_bwart_receipt-low = '101'.
  APPEND r_bwart_receipt.
  r_bwart_receipt-low = '651'.
  APPEND r_bwart_receipt.
  r_bwart_receipt-low = '634'.
  APPEND r_bwart_receipt.

  r_bwart_issue-sign = 'I'.
  r_bwart_issue-option = 'EQ'.
  r_bwart_issue-low = '261'.
  APPEND r_bwart_issue.
  r_bwart_issue-low = '601'.
  APPEND r_bwart_issue.
  r_bwart_issue-low = '633'.
  APPEND r_bwart_issue.

  r_bwart_all[] = r_bwart_receipt[].
  APPEND LINES OF r_bwart_issue TO r_bwart_all.

ENDFORM.                    " FILL_RANGES

*&---------------------------------------------------------------------*
*&      Form  SET_ISS_REC_DATES
*&---------------------------------------------------------------------*
FORM set_iss_rec_dates .

** Set the last receipt date from MSEG
*  CLEAR IT_MSEG.
*  LOOP AT IT_MSEG WHERE MATNR EQ IT_MATERIAL-MATNR
*                    AND BWART IN R_BWART_RECEIPT.
*    EXIT.
*  ENDLOOP.
*  IF SY-SUBRC EQ 0 AND IT_MSEG-BUDAT GT WA_OUTPUT-LAST_REC_DATE.
*    WA_OUTPUT-LAST_REC_DATE = IT_MSEG-BUDAT.
*  ENDIF.
*
** Set the last receipt date from YSE_SURPLUS_HD01
*  CLEAR IT_SURPLUS.
*  LOOP AT IT_SURPLUS WHERE MATNR EQ IT_MATERIAL-MATNR
*                       AND ZMOVT EQ 'R'.
*    EXIT.
*  ENDLOOP.
*  IF SY-SUBRC EQ 0 AND IT_SURPLUS-BUDAT GT WA_OUTPUT-LAST_REC_DATE.
*    WA_OUTPUT-LAST_REC_DATE = IT_SURPLUS-BUDAT.
*  ENDIF.
*
** Set the last issue date from MSEG
*  CLEAR IT_MSEG.
*  LOOP AT IT_MSEG WHERE MATNR EQ IT_MATERIAL-MATNR
*                    AND BWART IN R_BWART_ISSUE.
*    EXIT.
*  ENDLOOP.
*  IF SY-SUBRC EQ 0 AND IT_MSEG-BUDAT GT WA_OUTPUT-LAST_ISS_DATE.
*    WA_OUTPUT-LAST_ISS_DATE = IT_MSEG-BUDAT.
*  ENDIF.
*
** Set the last issue date from YSE_SURPLUS_HD01
*  CLEAR IT_SURPLUS.
*  LOOP AT IT_SURPLUS WHERE MATNR EQ IT_MATERIAL-MATNR
*                       AND ZMOVT EQ 'I'.
*    EXIT.
*  ENDLOOP.
*  IF SY-SUBRC EQ 0 AND IT_SURPLUS-BUDAT GT WA_OUTPUT-LAST_ISS_DATE.
*    WA_OUTPUT-LAST_ISS_DATE = IT_SURPLUS-BUDAT.
*  ENDIF.

  READ TABLE it_rec WITH KEY matnr = it_material-matnr BINARY SEARCH.
  IF sy-subrc EQ 0 AND it_rec-budat GT wa_output-last_rec_date.
    wa_output-last_rec_date = it_rec-budat.
  ENDIF.

  READ TABLE it_iss WITH KEY matnr = it_material-matnr BINARY SEARCH.
  IF sy-subrc EQ 0 AND it_iss-budat GT wa_output-last_iss_date.
    wa_output-last_iss_date = it_iss-budat.
  ENDIF.


ENDFORM.                    " SET_ISS_REC_DATES

*&---------------------------------------------------------------------*
*&      Form  SET_STOCK_BACK_ORDERED
*&---------------------------------------------------------------------*
FORM set_stock_back_ordered .

  CLEAR it_stbo_so.
* Stock Back Ordered
  READ TABLE it_stbo_so WITH KEY matnr = it_material-matnr
                              werks = it_material-werks
                              lgort = it_material-lgort
                     BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-back = it_stbo_so-alloc_quantity.
  ENDIF.

ENDFORM.                    " SET_STOCK_BACK_ORDERED

*&---------------------------------------------------------------------*
*&      Form  SET_GOODS_IN_TRANSIT
*&---------------------------------------------------------------------*
FORM set_goods_in_transit.

  CLEAR it_transit_aggr.
* Goods in Transit
  READ TABLE it_transit_aggr WITH KEY matnr = it_material-matnr
                              werks = it_material-werks
                              lgort = it_material-lgort
                     BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-goods_transit = it_transit_aggr-lfimg.
  ENDIF.

ENDFORM.                    " GET_GOODS_TRANSIT

*&---------------------------------------------------------------------*
*&      Form  SET_PLANNED_RECEIPTS
*&---------------------------------------------------------------------*
FORM set_planned_receipts .

*   Planned reciepts (open po qty)
  CLEAR it_open_po.
  READ TABLE it_open_po WITH KEY matnr = it_material-matnr
                                       werks = it_material-werks
                                       lgort = it_material-lgort.
  IF sy-subrc EQ 0.
    wa_output-planned_receipt = it_open_po-qty.
  ENDIF.

ENDFORM.                    " SET_PLANNED_RECEIPTS

*&---------------------------------------------------------------------*
*&      Form  GET_STOCK_FORECAST
*&---------------------------------------------------------------------*
FORM get_stock_forecast .

* Weighted average forecast is now saved as part of the forecast results in Exc Mgt Run
  IF NOT it_material[] IS INITIAL.
    SELECT      matnr confc
           INTO TABLE it_fchdr
           FROM yse_em_fchdr
            FOR ALL ENTRIES IN it_material
          WHERE matnr EQ it_material-matnr
            AND werks EQ p_werks.
  ENDIF.

ENDFORM.                    " GET_STOCK_FORECAST

*&---------------------------------------------------------------------*
*&      Form  SET_STOCK_HISTORY
*&---------------------------------------------------------------------*
FORM set_stock_history .

*   Stock History
  CLEAR it_sohist.
  READ TABLE it_sohist WITH KEY matnr = it_material-matnr
                       BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-hist_qty = it_sohist-zmeng.
    wa_output-hist_lines = it_sohist-zline.
  ENDIF.

ENDFORM.                    " SET_STOCK_HISTORY

*&---------------------------------------------------------------------*
*&      Form  SET_HISTORY_FORECAST
*&---------------------------------------------------------------------*
FORM set_history_forecast .

*   Stock Forecast
  CLEAR it_fchdr.
  READ TABLE it_fchdr WITH KEY matnr = it_material-matnr
                      BINARY SEARCH.
  IF sy-subrc EQ 0.
    wa_output-confc = it_fchdr-confc.
  ENDIF.

ENDFORM.                    " SET_HISTORY_FORECAST

*&---------------------------------------------------------------------*
*&      Form  GET_OPEN_TRANSPORT_ORDERS
*&---------------------------------------------------------------------*
FORM get_open_transport_orders .

* Only consider open transport orders if storage location = 1000
*  CHECK p_lgort = '1000'.

  IF '1000' IN s_lgort.

* Select from ekpo/ekko
    IF NOT it_material[] IS INITIAL.
      SELECT      b~ebeln b~ebelp b~matnr b~lgort b~menge
             INTO TABLE it_ekpo2
             FROM ekko AS a
            INNER JOIN ekpo AS b
               ON a~ebeln = b~ebeln
              FOR ALL ENTRIES IN it_material
            WHERE b~matnr EQ it_material-matnr
              AND (    a~bsart EQ 'ZUB1'
                    OR a~bsart EQ 'ZNB4' )
              AND a~reswk EQ p_werks
              AND b~loekz EQ space.
* Begin of insert MOD-010
*              AND a~ekorg = gv_ekorg.
* End of insert MOD-010

* Don't continue open transport orders if no rows returned
      CHECK sy-subrc EQ 0.

* Select receipted quantities for the open transport order items
      SELECT      ebeln ebelp matnr menge belnr bwart
                  charg           "+MOD-015
             INTO TABLE it_ekbe2
             FROM ekbe
             FOR ALL ENTRIES IN it_ekpo2
            WHERE ebeln EQ it_ekpo2-ebeln
              AND ebelp EQ it_ekpo2-ebelp
              AND vgabe = '6'.

* Add transport orders to allocation table
      LOOP AT it_ekpo2.
        it_alloc-matnr = it_ekpo2-matnr.
        it_alloc-alloc_quantity = it_ekpo2-menge.
        COLLECT it_alloc.
      ENDLOOP.

* Subtract receipted qty's from allocation table
      LOOP AT it_ekbe2.
        it_alloc-matnr = it_ekbe2-matnr.
        IF it_ekbe2-bwart EQ '641'.
          it_alloc-alloc_quantity = it_ekbe2-menge * ( -1 ).
        ELSEIF it_ekbe2-bwart EQ '642'.
          it_alloc-alloc_quantity = it_ekbe2-menge.
        ENDIF.
        COLLECT it_alloc.
      ENDLOOP.
    ENDIF.
  ENDIF.

ENDFORM.                    " GET_OPEN_TRANSPORT_ORDERS

*&---------------------------------------------------------------------*
*&      Form  GET_SALESORG
*&---------------------------------------------------------------------*
*FORM get_salesorg .
*
*  CLEAR gv_vkorg.
*  SELECT SINGLE vkorg
*           INTO gv_vkorg
*           FROM tvkwz
*          WHERE vtweg EQ '01'
*            AND werks EQ p_werks.
*  IF sy-subrc NE 0.
*    MESSAGE ID 'YSE_SALES_LOG' TYPE 'E' NUMBER '301' WITH p_werks.
*  ENDIF.
*
*ENDFORM.                    " GET_SALESORG
*&---------------------------------------------------------------------*
*&      Form  GET_ALLOCATED_STOCK1
*&---------------------------------------------------------------------*
FORM get_allocated_stock1 .
  DATA : BEGIN OF it_vbbe OCCURS 0,
         vbeln LIKE vbbe-vbeln,
         posnr LIKE vbbe-posnr,
         matnr LIKE vbbe-matnr,
         werks LIKE vbbe-werks,
         lgort TYPE	lgort_d,       "+ MOD-015
         vbtyp LIKE vbbe-vbtyp,    "EXTUVE 2009/11/11
         vmeng LIKE vbbe-vmeng,
         END OF it_vbbe.
  DATA : wa_vbbe LIKE it_vbbe.
*>>>> bEGIN OF EXTUVE 21/08/2009
  DATA : BEGIN OF it_likp OCCURS 0,
         vbeln LIKE likp-vbeln,
         lfart LIKE likp-lfart,
         END OF it_likp.
  DATA : wa_likp LIKE it_likp.
*>>>> END OF EXTUVE 21/08/2009
*>>>> bEGIN OF EXTUVE 11/11/2009
  DATA : BEGIN OF it_lips OCCURS 0,
          vbeln LIKE lips-vbeln,
          posnr LIKE lips-posnr,
          pstyv LIKE lips-pstyv,
         END OF it_lips.
  DATA : wa_lips LIKE it_lips.
*>>>> END OF EXTUVE 11/11/2009

* Begin of deletion by MOD-015
*  SELECT vbeln posnr matnr werks vbtyp vmeng FROM vbbe
*               INTO TABLE it_vbbe
*                 WHERE matnr IN s_matnr
*                   AND werks EQ p_werks.
* Begin of deletion by MOD-015

* Begin of insertion by MOD-015
  SELECT vbeln
         posnr
         matnr
         werks
         lgort
         vbtyp
         vmeng FROM vbbe
               INTO TABLE it_vbbe
               WHERE      matnr IN s_matnr
               AND        werks EQ p_werks.
* Begin of insertion by MOD-015

* Begin of change MOD-010
*  SELECT A~vbeln A~posnr A~matnr A~werks A~vbtyp A~vmeng INTO TABLE it_vbbe
*               FROM vbbe AS A
*                INNER JOIN vbak AS B
*                 ON A~VBELN = B~VBELN
*                 WHERE A~matnr IN s_matnr
*                   AND A~werks EQ p_werks
*                   AND B~VKORG EQ p_SALORG.
* End of change MOD-010
  IF sy-subrc = 0.
    SORT it_vbbe BY matnr werks.
  ENDIF.

*>>>> bEGIN OF EXTUVE 21/08/2009
  CHECK NOT it_vbbe[] IS INITIAL.
  SELECT vbeln lfart  FROM likp
               INTO TABLE it_likp
                FOR ALL ENTRIES IN it_vbbe
                 WHERE vbeln = it_vbbe-vbeln.
  IF sy-subrc = 0.
    SORT it_likp BY vbeln.
    DELETE ADJACENT DUPLICATES FROM it_likp COMPARING ALL FIELDS.
  ENDIF.
*>>>> END OF EXTUVE 21/08/2009

* Begin of Deletion by MOD-015
*  REFRESH it_alloc.
*  CLEAR it_alloc.
* End of Deletion by MOD-015

  LOOP AT it_vbbe INTO wa_vbbe.
    READ TABLE it_material WITH KEY matnr = wa_vbbe-matnr
                                      werks = wa_vbbe-werks
                             BINARY SEARCH.
    IF sy-subrc EQ 0.
      it_alloc-werks          = wa_vbbe-werks.
      it_alloc-matnr          = wa_vbbe-matnr.
      it_alloc-alloc_quantity = wa_vbbe-vmeng.
      it_alloc-lgort          = wa_vbbe-lgort. "+ MOD-015
      COLLECT it_alloc.
    ENDIF.
  ENDLOOP.
*
*>>>> BEGIN OF EXTUVE 21/08/2009
  LOOP AT it_vbbe INTO wa_vbbe.
    CLEAR wa_likp.
    READ TABLE it_likp INTO wa_likp WITH KEY vbeln = wa_vbbe-vbeln
                            BINARY SEARCH.
    IF sy-subrc = 0 AND wa_likp-lfart = 'ZL03'.
      it_alloc-werks          = wa_vbbe-werks.
      it_alloc-matnr          = wa_vbbe-matnr.
      it_alloc-alloc_quantity = wa_vbbe-vmeng * -1.
      it_alloc-lgort          = wa_vbbe-lgort. "+ MOD-015
      COLLECT it_alloc.
    ENDIF.
  ENDLOOP.
*>>>> END OF EXTUVE 21/08/2009

*>>>> BEGIN OF EXTUVE 11/11/2009
  CHECK NOT it_vbbe[] IS INITIAL.
  SELECT vbeln
          posnr
          pstyv
          FROM lips
               INTO TABLE it_lips
                FOR ALL ENTRIES IN it_vbbe
                 WHERE vbeln = it_vbbe-vbeln
                   AND posnr = it_vbbe-posnr.
  IF sy-subrc = 0.
    SORT it_lips BY vbeln posnr.
  ENDIF.

  LOOP AT it_vbbe INTO wa_vbbe.
    CLEAR wa_lips.
    READ TABLE it_lips INTO wa_lips WITH KEY vbeln = wa_vbbe-vbeln
                                             posnr = wa_vbbe-posnr
                                             BINARY SEARCH.
    IF sy-subrc = 0 AND wa_vbbe-vbtyp = 'J' AND wa_lips-pstyv = 'ZDTC'.
      it_alloc-werks          = wa_vbbe-werks.
      it_alloc-matnr          = wa_vbbe-matnr.
      it_alloc-alloc_quantity = wa_vbbe-vmeng * -1.
      it_alloc-lgort          = wa_vbbe-lgort. "+ MOD-015
      COLLECT it_alloc.
    ENDIF.
  ENDLOOP.
*>>>> END OF EXTUVE 11/11/2009
ENDFORM.                    " GET_ALLOCATED_STOCK1
