***INCLUDE RIPRIF01 .
INCLUDE LIPRTF03.                      " common routines included
*$*$ General Routines used inside print ABAPS RIPRxxnn ----------------
*----------------------------------------------------------------------*
*       FORM UNDER_line                                                *
*----------------------------------------------------------------------*
*       Print an underline to help separate texts                      *
*----------------------------------------------------------------------*
FORM UNDER_LINE.
  WRITE C_UNDERSCORE_STR  TO WIPRT-COLHD.    " Underline
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING                       " write an underline
      ELEMENT = 'UNDERLINE'
      WINDOW  = 'MAIN'.
ENDFORM.                    "UNDER_LINE

*----------------------------------------------------------------------*
*       FORM DATA_IMPORT.                                              *
*----------------------------------------------------------------------*
*       Import data to be used in Print ABAPS RIPRxxnn                 *
*----------------------------------------------------------------------*
*  -->  p1  Export made in LIPRTF02, Function                          *
*           PM_NOTIFICATION_PRINT_CONTROL                              *
*----------------------------------------------------------------------*
FORM DATA_IMPORT.
  DATA H_T024I LIKE T024I.

  PERFORM NOTIFICATION_DATA_IMPORT
    TABLES
         IVIQMFE                       " ... positions
         IVIQMMA                       " ... codes
         IVIQMSM                       " ... codes
         IVIQMUR                       " ... codes
         IQKAT                         " ... Catalogue
         IHPAD_TAB                     " ... partner table
    CHANGING
         IVIQMEL                       " ... Notification
         RIWO1                         " ... Texts from Objects
         RIWO00                 " ... Dialog structure with status info
         RQM00.

  VIQMEL = IVIQMEL.         " Both workareas set. View needed in
  "      SAPSCRIPT
*-> clear header line to avoid error, if print redir. is called
*   before loop at iviqmfe
  CLEAR WQMFE.

  PERFORM GENERAL_DATA_IMPORT.
  IF ORIGINAL_PRINT_LANGUAGE <> PRINT_LANGUAGE.
    PERFORM READ_OBJECT_TEXTS USING RIWO1 PRINT_LANGUAGE.
  ENDIF.
*... special fields already used in forms are supported
*... The following lines are for upwards compatibilty defined
*... The fileds can be addressed directly via RIWO1- now
  MAKT-MAKTX =  RIWO1-BAUTX.
  EQKT-EQKTX =  RIWO1-EQTXT.
  IFLO-PLTXT =  RIWO1-PLTXT.

  REFRESH NOTIF_IHPAD_TAB.
*... move the passed notification partner details to special table
*... The  IHPAD_TAB is used generally for printing partner addresses
*... Not just Notifcation partner but also equipment partner.
  LOOP AT IHPAD_TAB.
    NOTIF_IHPAD_TAB = IHPAD_TAB.
    APPEND NOTIF_IHPAD_TAB.
  ENDLOOP.
  PERFORM READ_CATALOGUE_TABLES        " READ Quality control tables
          USING VIQMEL-QMART.          "     for catalog categories
  PERFORM READ_CATALOGUE_TEXTS.
  IF NOT VIQMEL-AUFNR IS INITIAL. " header order exists
*-> save RIWO1 from notif in WRIWO1
    REFRESH IRIWO1.
    IRIWO1 = RIWO1. " from notif
    APPEND IRIWO1.
*-> DO the same like FORM order_data_import in RIPRIF02
*... get the order data from memory, not there ABEND !!!!!!
    PERFORM ONLY_ORDER_DATA_IMPORT     " see  LIPRTF03.
      TABLES
       OP_PRINT_TAB
       KBEDP_TAB
       IHPAD_TAB
       IHSG_TAB
       IHGNS_TAB
       IAFVGD
       IRIPW0
       IRESBD
       IAFFHD
      CHANGING
       CAUFVD
       RIWO1
       ILOA.
    IF SYST-SUBRC <> 0.
      MESSAGE A650(ID).                  " import failed
    ENDIF.
    IF ORIGINAL_PRINT_LANGUAGE <> PRINT_LANGUAGE.
      PERFORM READ_OBJECT_TEXTS USING RIWO1 PRINT_LANGUAGE.
    ENDIF.
*-> save RIWO1 from order in WRIWO1 as well
    IRIWO1 = RIWO1. " from order
    APPEND IRIWO1.
*-> restore RIWO1 from notif
    READ TABLE IRIWO1 WITH KEY OBJNR = VIQMEL-OBJNR.
    RIWO1 = IRIWO1.

*-> clear header lines to avoid error, if print redir. is called
*   before loop at iafvgd or iresbd
    CLEAR AFVGD.
    CLEAR RESBD.
*-> read CAUFVD-INNAM because it is sometimes not filled
    IF NOT CAUFVD-INGPR IS INITIAL AND
       CAUFVD-INNAM IS INITIAL.
*-> read text
      CALL FUNCTION 'T024I_READ'
        EXPORTING
          INGRP    = CAUFVD-INGPR
          IWERK    = CAUFVD-IWERK
        IMPORTING
          STRUCT   = H_T024I
        EXCEPTIONS
          NO_ENTRY = 1
          OTHERS   = 2.
      IF SY-SUBRC = 0.
        CAUFVD-INNAM = H_T024I-INNAM.
      ENDIF.
    ENDIF.

    DESCRIBE TABLE OP_PRINT_TAB LINES OP_ENTRIES.
* PERFORM LEFT_JUSTIFY_MAT USING CAUFVD-BAUTL.
    REFRESH ORDER_IHPAD_TAB.
*... move the passed notification partner details to special table
*... The  IHPAD_TAB is used generally for printing partner addresses
*... Not just Order partner but also equipment partner.
    LOOP AT IHPAD_TAB.
      ORDER_IHPAD_TAB = IHPAD_TAB.
      APPEND ORDER_IHPAD_TAB.
    ENDLOOP.
*-> restore ihpad_tab from notif
    REFRESH IHPAD_TAB.
    LOOP AT NOTIF_IHPAD_TAB.
      IHPAD_TAB = NOTIF_IHPAD_TAB.
      APPEND IHPAD_TAB.
    ENDLOOP.
  ENDIF.
ENDFORM.                    "DATA_IMPORT
*----------------------------------------------------------------------*
*       FORM READ_CATALOGUE_TEXTS                                      *
*----------------------------------------------------------------------*
* read the texts of the catalogues with print-language again
*----------------------------------------------------------------------*
FORM READ_CATALOGUE_TEXTS.
*-> in order to ensure that also documents in foreign languages
*-> will have the correct catalogue texts
  LOOP AT IVIQMFE WHERE PRTKZ = YES.
*-> wqmfe texts
    CALL FUNCTION 'QPK1_CODE_TEXT'
      EXPORTING
        I_KATALOGART      = IVIQMFE-FEKAT
        I_CODEGRUPPE      = IVIQMFE-FEGRP
        I_CODE            = IVIQMFE-FECOD
        I_SPRACHE         = PRINT_LANGUAGE
      IMPORTING
        E_TEXT            = IVIQMFE-TXTCDGR
        E_GROUPTEXT       = IVIQMFE-TXTGR
      EXCEPTIONS
        NO_MATCH_IN_RANGE = 1
        OTHERS            = 2.
    IF SY-SUBRC <> 0.
      IVIQMFE-TXTCD   = SPACE.
      IVIQMFE-TXTGR   = SPACE.
      IVIQMFE-TXTCDGR = SPACE.
    ELSE.
*-> txtcd is often used instead of txtcdgr
      IVIQMFE-TXTCD   = IVIQMFE-TXTCDGR.
    ENDIF.
    CALL FUNCTION 'QPK1_CODE_TEXT'
      EXPORTING
        I_KATALOGART      = IVIQMFE-OTKAT
        I_CODEGRUPPE      = IVIQMFE-OTGRP
        I_CODE            = IVIQMFE-OTEIL
        I_SPRACHE         = PRINT_LANGUAGE
      IMPORTING
        E_TEXT            = IVIQMFE-TXTCDGROT
        E_GROUPTEXT       = IVIQMFE-TXTGROT
      EXCEPTIONS
        NO_MATCH_IN_RANGE = 1
        OTHERS            = 2.
    IF SY-SUBRC <> 0.
      IVIQMFE-TXTCDOT   = SPACE.
      IVIQMFE-TXTGROT   = SPACE.
      IVIQMFE-TXTCDGROT = SPACE.
    ELSE.
*-> txtcdot is often used instead of txtcdgrot
      IVIQMFE-TXTCDOT  = IVIQMFE-TXTCDGROT.
    ENDIF.
    MODIFY IVIQMFE.
  ENDLOOP.
*-> wqmma texts
  LOOP AT IVIQMMA.
    CALL FUNCTION 'QPK1_CODE_TEXT'
      EXPORTING
        I_KATALOGART      = IVIQMMA-MNKAT
        I_CODEGRUPPE      = IVIQMMA-MNGRP
        I_CODE            = IVIQMMA-MNCOD
        I_SPRACHE         = PRINT_LANGUAGE
      IMPORTING
        E_TEXT            = IVIQMMA-TXTCDGR
        E_GROUPTEXT       = IVIQMMA-TXTGR
      EXCEPTIONS
        NO_MATCH_IN_RANGE = 1
        OTHERS            = 2.
    IF SY-SUBRC <> 0.
      IVIQMMA-TXTGR   = SPACE.
      IVIQMMA-TXTCD   = SPACE.
      IVIQMMA-TXTCDGR = SPACE.
    ELSE.
*-> txtcd is often used instead of txtcdgr
      IVIQMMA-TXTCD   = IVIQMMA-TXTCDGR.
    ENDIF.
    MODIFY IVIQMMA.
  ENDLOOP.
*-> wqmsm texts
  LOOP AT IVIQMSM.
    CALL FUNCTION 'QPK1_CODE_TEXT'
      EXPORTING
        I_KATALOGART      = IVIQMSM-MNKAT
        I_CODEGRUPPE      = IVIQMSM-MNGRP
        I_CODE            = IVIQMSM-MNCOD
        I_SPRACHE         = PRINT_LANGUAGE
      IMPORTING
        E_TEXT            = IVIQMSM-TXTCDGR
        E_GROUPTEXT       = IVIQMSM-TXTGR
      EXCEPTIONS
        NO_MATCH_IN_RANGE = 1
        OTHERS            = 2.
    IF SY-SUBRC <> 0.
      IVIQMSM-TXTGR   = SPACE.
      IVIQMSM-TXTCD   = SPACE.
      IVIQMSM-TXTCDGR = SPACE.
    ELSE.
*-> txtcd is often used instead of txtcdgr
      IVIQMSM-TXTCD   = IVIQMSM-TXTCDGR.
    ENDIF.
    MODIFY IVIQMSM.
  ENDLOOP.
*-> wqmur texts
  LOOP AT IVIQMUR.
    CALL FUNCTION 'QPK1_CODE_TEXT'
      EXPORTING
        I_KATALOGART      = IVIQMUR-URKAT
        I_CODEGRUPPE      = IVIQMUR-URGRP
        I_CODE            = IVIQMUR-URCOD
        I_SPRACHE         = PRINT_LANGUAGE
      IMPORTING
        E_TEXT            = IVIQMUR-TXTCDGR
        E_GROUPTEXT       = IVIQMUR-TXTGR
      EXCEPTIONS
        NO_MATCH_IN_RANGE = 1
        OTHERS            = 2.
    IF SY-SUBRC <> 0.
      IVIQMUR-TXTGR   = SPACE.
      IVIQMUR-TXTCD   = SPACE.
      IVIQMUR-TXTCDGR = SPACE.
    ELSE.
*-> txtcd is often used instead of txtcdgr
      IVIQMUR-TXTCD   = IVIQMUR-TXTCDGR.
    ENDIF.
    MODIFY IVIQMUR.
  ENDLOOP.
*-> qkat texts
  LOOP AT IQKAT WHERE SPRACHE <> PRINT_LANGUAGE.
    CALL FUNCTION 'QPK1_CODE_TEXT'
      EXPORTING
        I_KATALOGART      = IQKAT-KATALOGART
        I_CODEGRUPPE      = IQKAT-CODEGRUPPE
        I_CODE            = IQKAT-CODE
        I_SPRACHE         = PRINT_LANGUAGE
      IMPORTING
        E_TEXT            = IQKAT-KURZTEXTCD
        E_GROUPTEXT       = IQKAT-KURZTEXTGR
      EXCEPTIONS
        NO_MATCH_IN_RANGE = 1
        OTHERS            = 2.
    IF SY-SUBRC <> 0.
      IQKAT-KURZTEXTCD = SPACE.
      IQKAT-KURZTEXTGR = SPACE.
    ENDIF.
    MODIFY IQKAT.
  ENDLOOP.
*-> fact text
  IF NOT VIQMEL-QMKAT IS INITIAL.
    CALL FUNCTION 'QPK1_CODE_TEXT'
      EXPORTING
        I_KATALOGART      = VIQMEL-QMKAT
        I_CODEGRUPPE      = VIQMEL-QMGRP
        I_CODE            = VIQMEL-QMCOD
        I_SPRACHE         = PRINT_LANGUAGE
      IMPORTING
        E_TEXT            = FACT_TXTCDGR
        E_GROUPTEXT       = FACT_TXTGR
      EXCEPTIONS
        NO_MATCH_IN_RANGE = 1
        OTHERS            = 2.
    IF SY-SUBRC <> 0.
      FACT_TXTCDGR = SPACE.
      FACT_TXTGR   = SPACE.
    ENDIF.
  ENDIF.
ENDFORM.                    "READ_CATALOGUE_TEXTS

*---------------------------------------------------------------------*
*       FORM GENERAL_DATA_IMPORT                                      *
*---------------------------------------------------------------------*
FORM GENERAL_DATA_IMPORT.
*... the general information used needed regardless of whether
*... Orders or notifications are being printed.
*... This information MUST be supplied. See export in
*... LIPRTF02 form   PRINT_PAPERS
  IMPORT WWORKPAPER                    " Control information
         T390                          " ...
         DEVICE                        " ...
         PRINT_LANGUAGE                " default language
         SY_UNAME
         SY_DATUM
         FROM MEMORY ID ID_IPRT_OPTIONS.

  IF SYST-SUBRC <> 0.
    MESSAGE A650(ID).
  ENDIF.

  ORIGINAL_PRINT_LANGUAGE =  PRINT_LANGUAGE.   "note original setting
*... if the user set a specific langauge for a paper, set print_lang
  IF NOT WWORKPAPER-PRINT_LANG IS INITIAL. "specific lang for paper
*... reset the default print_language with a specific language
*... if it was set in t390_u or set on the paper selection screen
    PRINT_LANGUAGE =  WWORKPAPER-PRINT_LANG.
  ENDIF.
  IF CAUFVD-ERNAM IS INITIAL.
    CAUFVD-ERNAM = SY_UNAME.
  ENDIF.
  IF CAUFVD-ERDAT IS INITIAL.
    CAUFVD-ERDAT = SY_DATUM.
  ENDIF.
ENDFORM.                    "GENERAL_DATA_IMPORT

*----------------------------------------------------------------------*
*       FORM READ_CATALOGUE_TABLES                                     *
*----------------------------------------------------------------------*
*       Read Tables tq80 and tq8t. The Notif type and category tables  *
*----------------------------------------------------------------------*
*  -->  NOTIF_TYPE    Usually from VIQMEL, the notification type.      *
*                     Database field QMEL-QMART.                  *
*----------------------------------------------------------------------*
FORM  READ_CATALOGUE_TABLES USING NOTIF_TYPE TYPE VIQMEL-QMART.
*... see structure tq8t   All category types are defined here.

  SELECT SINGLE * FROM  TQ80           "notif type
         WHERE  QMART       = NOTIF_TYPE.

  SELECT SINGLE * FROM  TQ80_T
         WHERE  SPRAS       = PRINT_LANGUAGE
         AND    QMART       = NOTIF_TYPE.

  SELECT SINGLE * FROM  TQ8T           "Notif category
         WHERE  QMTYP       = TQ80-QMTYP.
*... the longtext ID variable LTXT_ID must be set based on on the
*... Notification type.    The QM notifications have Longtext id
*... LTQM, PM and Service Notifications have ID LTXT.
  CASE TQ8T-QMTYP.
    WHEN C_QM_02.
* QM Notification
      LTXT_ID = C_LTQM.
      G_ARC_TYPE = C_ARC_TYPE_QM.
    WHEN C_PM_01.
* PM Notification
      LTXT_ID = C_LTXT.
      G_ARC_TYPE = C_ARC_TYPE_PM.
    WHEN C_SM_03.
* CS Notification
      LTXT_ID = C_LTXT.
      G_ARC_TYPE = C_ARC_TYPE_SM.
    WHEN C_G0_05.
* General Notification
      LTXT_ID = C_LTXT.
      G_ARC_TYPE = C_ARC_TYPE_G0.
  ENDCASE.
  SELECT SINGLE * FROM  T352B          " Report schema
         WHERE  RBNR        = TQ80-RBNR.    " for generic
  " catalogue  reads
  SELECT SINGLE * FROM  TQ15T
         WHERE  SPRACHE     = PRINT_LANGUAGE
         AND    KATALOGART  = TQ80-MFKAT.
ENDFORM.                    "READ_CATALOGUE_TABLES

*----------------------------------------------------------------------*
*       FORM READ_CODE_TEXT                                            *
*----------------------------------------------------------------------*
*       This form can be used to read the text for any code type.      *
*       If you do not know what Catalogue_type to use see T352B.       *
*       This record is already read and available in program           *
*----------------------------------------------------------------------*
*  -->  CATALOG_TYPE See Tq15                                          *
*  -->  CODE_GROUP   See T352b  Eg VIQMFE-FEGRP                        *
*  -->  CODE         See Any code from file.  Eg VIQMFE-FECOD          *
*  -->  Version                               EG VIQMFE-FEVER          *
*                                                                      *
*  <--  TEXT         The text from QPCT                                *
*----------------------------------------------------------------------*
FORM READ_CODE_TEXT USING CATALOG_TYPE
                          CODE_GROUP
                          CODE
                          VERSION
                 CHANGING TEXT.

  CALL FUNCTION 'QPK1_CODE_TEXT'
       EXPORTING
            I_KATALOGART      = CATALOG_TYPE
            I_CODEGRUPPE      = CODE_GROUP
            I_CODE            = CODE
            I_SPRACHE         = PRINT_LANGUAGE
       IMPORTING
            E_TEXT            = TEXT
*          e_grouptext       =
       EXCEPTIONS
            NO_MATCH_IN_RANGE = 1
            OTHERS            = 2.
ENDFORM.                    "READ_CODE_TEXT

*----------------------------------------------------------------------*
*       FORM READ_VIEW_TEXT_TABLES.                                    *
*----------------------------------------------------------------------*
*       " Read tables for VIQMEL                                       *
*----------------------------------------------------------------------*
FORM READ_VIEW_TEXT_TABLES.            " Read tables for VIQMEL

  SELECT SINGLE * FROM  T024I
         WHERE  IWERK       = VIQMEL-IWERK
         AND    INGRP       = VIQMEL-INGRP.

  SELECT SINGLE * FROM  T356_T
         WHERE  SPRAS       = PRINT_LANGUAGE
         AND    ARTPR       = VIQMEL-ARTPR
         AND    PRIOK       = VIQMEL-PRIOK.
  IF NOT PRINT_LANGUAGE IS INITIAL.
*--    Materialtext lesen
    IF NOT VIQMEL-MATNR IS INITIAL.
      PERFORM READ_MATERIAL.
    ENDIF.
    PERFORM READ_STATUS USING    VIQMEL-OBJNR
                        CHANGING RIWO00-STTXT.
  ENDIF.
*-> read text for workcenter with print-language
  CALL FUNCTION 'CR_WORKSTATION_READ'
    EXPORTING
      ID        = VIQMEL-ARBPL
      MSGTY     = 'W'
    IMPORTING
      ECRHD     = CRHD
    EXCEPTIONS
      NOT_FOUND = 01.
  IF SY-SUBRC = 0.
    RIWO00-GEWRK = CRHD-ARBPL.
    IF CRHD-OBJTY <> CRTX-OBJTY OR
       CRHD-OBJID <> CRTX-OBJID OR
       PRINT_LANGUAGE <> CRTX-SPRAS.
      SELECT SINGLE * FROM  CRTX
             WHERE  OBJTY       = CRHD-OBJTY
             AND    OBJID       = CRHD-OBJID
             AND    SPRAS       = PRINT_LANGUAGE.
    ENDIF.
    IF SY-SUBRC = 0.
      RIWO00-KTEXT = CRTX-KTEXT.
    ELSE.
      CLEAR RIWO00-KTEXT.
    ENDIF.
  ENDIF.
ENDFORM.                    "READ_VIEW_TEXT_TABLES

*----------------------------------------------------------------------*
*       FORM  READ_WQMFE_TABLES.                                       *
*----------------------------------------------------------------------*
*       Read text tables for WQMFE Notification position record        *
*----------------------------------------------------------------------*
FORM READ_WQMFE_TABLES.
  SELECT SINGLE * FROM  MAKT
         WHERE  MATNR       = WQMFE-BAUTL
         AND    SPRAS       = PRINT_LANGUAGE.
  IF SYST-SUBRC <> 0
  OR MAKT-MATNR IS INITIAL.
    CLEAR MAKT.
  ENDIF.
ENDFORM.                    "READ_WQMFE_TABLES

*----------------------------------------------------------------------*
*       FORM OPEN_FORM                                                 *
*----------------------------------------------------------------------*
*       Set print options and Open form                                *
*  ---> Alternative destination.   From Operation if it is available   *
*       Note that this alternative destination could also be over      *
*       written by printer redirection.                                *
*----------------------------------------------------------------------*
FORM OPEN_FORM USING ARCHIVE_TYPE TYPE CLIKE "Order or Notification type
                     OBJECT_ID    TYPE CLIKE " Order nr. or Notif.nr
                     ALTERNATE_DEST TYPE CLIKE.

*... Set the print options
  FORM_OPEN_FLAG = YES.                " set flag so close is performed
*... did an alternate printer come form print data ?
  IF ALTERNATE_DEST <> SPACE.          " normally from operation
    ITCPO-TDDEST           = ALTERNATE_DEST.  " from Operation
  ELSE.   " stay with standard dest for user from T390_u
    ITCPO-TDDEST           = WWORKPAPER-TDDEST.   " Where to print
  ENDIF.

  IF WWORKPAPER-TDCOPIES IS INITIAL.
    WWORKPAPER-TDCOPIES = 1.
  ENDIF.
  IF WWORKPAPER-TDARMOD  IS INITIAL.
    WWORKPAPER-TDARMOD  = '1'.
  ENDIF.

  ITCPO-TDCOPIES         = WWORKPAPER-TDCOPIES.    " copies
  ITCPO-TDNEWID          = WWORKPAPER-TDNEWID.     " new spool entry
  ITCPO-TDIMMED          = WWORKPAPER-TDIMMED.     " immediately
  ITCPO-TDDELETE         = WWORKPAPER-TDDELETE.    " delete after
  ITCPO-TDCOVER          = WWORKPAPER-TDCOVER.     " cover page
  ITCPO-TDCOVTITLE       = WWORKPAPER-TDCOVTITLE.  " title for cover
  ITCPO-TDRECEIVER       = WWORKPAPER-TDRECEIVER.  " report to ->
  ITCPO-TDARMOD          = WWORKPAPER-TDARMOD.     " Archive mode
  ITCPO-TDTELENUM        = WWORKPAPER-TDTELENUM.
  ITCPO-TDTELELAND       = WWORKPAPER-TDTELELAND.

  IF NOT WWORKPAPER-PRINT_LANG IS INITIAL.
*... reset the default print_language with a specific language
*... if it was set in t390_u or set on the paper selection screen
    PRINT_LANGUAGE =  WWORKPAPER-PRINT_LANG.
  ELSE.
    PRINT_LANGUAGE =  ORIGINAL_PRINT_LANGUAGE.
  ENDIF.

*... important is to set the program so variables to be used by
*... SAPSCRIPT should be read form the driving abap and not the
*... the original calling program.
  ITCPO-TDPROGRAM        = SYST-REPID. " This abap
*... should a print record be written later.
  IF DEVICE = C_SCREEN
  OR DEVICE = C_PREVIEW.
    DONT_LOG = YES.
  ELSE.
    DONT_LOG = SPACE.
  ENDIF.

*... Perform possible print redirection
  PERFORM PRINTER_REDIRECTION.

  IF DEVICE = C_PREVIEW.               " special print preview option
    ITCPO-TDPREVIEW = YES.
    ITCPO-TDNOPRINT = YES.   " no sneaky printing from SAPSCRIPT
  ELSE.
    ITCPO-TDPREVIEW = SPACE.   " make sure preview is off otherwise
  ENDIF.

*$*$ ARCHIVE LINK

  G_TOA_DARA_TAB-FUNCTION   = C_DARA.  "archive function
  G_TOA_DARA_TAB-SAP_OBJECT = ARCHIVE_TYPE. "Order or Notification
  G_TOA_DARA_TAB-AR_OBJECT  = T390-AR_OBJECT.  "arch object
  G_TOA_DARA_TAB-OBJECT_ID  = OBJECT_ID.    " order or notif number
  G_TOA_DARA_TAB-MANDANT = T390-MANDT.

  G_ARC_PARAMS_TAB-SAP_OBJECT  = ARCHIVE_TYPE. "Order or Notification
  G_ARC_PARAMS_TAB-AR_OBJECT   = T390-AR_OBJECT.
  G_ARC_PARAMS_TAB-MANDANT = T390-MANDT.
  G_ARC_PARAMS_TAB-REPORT = T390-ABAPNAME.
*-> SY fields not available in update task
  G_ARC_PARAMS_TAB-ARCUSER = SY_UNAME.
  G_ARC_PARAMS_TAB-DATUM   = SY_DATUM.

*... Now determine what device based on destination type.
  PERFORM DETERMINE_DEVICE USING ITCPO DEST_DEVICE.
*... Open the SAPSCRIPT FORM.
  CALL FUNCTION 'OPEN_FORM'
    EXPORTING
      ARCHIVE_INDEX  = G_TOA_DARA_TAB
      ARCHIVE_PARAMS = G_ARC_PARAMS_TAB
      DIALOG         = SPACE     " SAPSCRIPT diaglog
      DEVICE         = DEST_DEVICE
      FORM           = T390-FORM " the form to print
      LANGUAGE       = PRINT_LANGUAGE                 "
      OPTIONS        = ITCPO.

*... Any problems noted in SAPSCRIPT   , no exceptions used here

ENDFORM.                    "OPEN_FORM

*---------------------------------------------------------------------*
*       FORM DETERMINE_DEVICE                                         *
*---------------------------------------------------------------------*
*  -->  ITCPO                                                         *
*  -->  RET_DEVICE                                                    *
*---------------------------------------------------------------------*
FORM DETERMINE_DEVICE USING ITCPO STRUCTURE ITCPO
                            RET_DEVICE TYPE CLIKE. "ITCPP-TDDEVICE
  CALL FUNCTION 'PM_DETERMINE_OUTPUT_DEVICE'
    EXPORTING
      IN_ITCPO   = ITCPO
    IMPORTING
      OUT_DEVICE = RET_DEVICE.
ENDFORM.                    "DETERMINE_DEVICE

*----------------------------------------------------------------------*
*       FORM PRINTER_REDIRECTION                                       *
*----------------------------------------------------------------------*
*       Check the T392 / T392_s Tables for print redirection         *
*       The ITCPO (Print options are approriately set if valid         *
*       redirection records are found.                                 *
*----------------------------------------------------------------------*
*  <->  ITCPO     Print options used in CALL OPEN_FORM                 *
*   --> WWORKPAPER The current workpaper details                       *
*   <-- ITCPO-TDDEST is set globally here plus other  ITCPO vars       *
*----------------------------------------------------------------------*
FORM PRINTER_REDIRECTION.
  DATA: ON.
  PERFORM CHECK_REDIRECTION USING ON.
  CHECK ON = YES.        " did we find a valid redirection ?
*... that means after check we have a matching value for the right field
*... We can now alter the PRINTER OPTIONS
  ITCPO-TDDEST           = T392_V-TDDEST.      " Where to print
  ITCPO-TDCOPIES         = T392_V-TDCOPIES.    " copies
  ITCPO-TDNEWID          = T392_V-TDNEWID.     " new spool entry
  ITCPO-TDIMMED          = T392_V-TDIMMED.     " immediately
  ITCPO-TDDELETE         = T392_V-TDDELETE.    " delete after
  ITCPO-TDCOVER          = T392_V-TDCOVER.     " cover page
  ITCPO-TDCOVTITLE       = T392_V-TDCOVTITLE.  " title for cover
  ITCPO-TDRECEIVER       = T392_V-TDRECEIVER.  " report to ->
  ITCPO-TDPROGRAM        = SYST-REPID. " driving ABAP
  ITCPO-TDARMOD          = T392_V-TDARMOD.     " Archive mode
  ITCPO-TDTELENUM        = T392_V-TDTELENUM.                "
  ITCPO-TDTELELAND       = T392_V-TDTELELAND.               "

  IF NOT T392_V-PRINT_LANG IS INITIAL.
*... reset the default print_language with a specific language
*... if it was set in t392_V or set on the paper selection screen
    PRINT_LANGUAGE =  T392_V-PRINT_LANG.
  ENDIF.
*...
ENDFORM.                    "PRINTER_REDIRECTION


*----------------------------------------------------------------------*
*       FORM CHECK_REDIRECTION                                         *
*----------------------------------------------------------------------*
*       Test for redirection.                                          *
*       If printer redirection is active and a valid value found
*       the T392_V record is set and available globally
*----------------------------------------------------------------------*
*  -->  REDIRECTION_ON   'X' = yes  ' ' = no redirection               *
*  <--  T392_V    Globally                                             *
*----------------------------------------------------------------------*
FORM CHECK_REDIRECTION USING REDIRECTION_ON TYPE CLIKE.

*... Now test for Field Specific Printer redirection
*... T392 has defined for each paper if Redirection is active and
*... when it is active on what field redirection is based.
*... Check to see if paper redirection is active

  SELECT         * FROM T392
         WHERE PM_APPL      = WWORKPAPER-PM_APPL
         AND   WORKPAPER    = WWORKPAPER-WORKPAPER
         AND   OPT_ACTIVE   = 'X'.
    EXIT.           " only one record. array fetch not needed
  ENDSELECT.

  IF SYST-DBCNT = 0.          " only go on when redirection is set on
    REDIRECTION_ON = SPACE.  " in table t392 for this paper type
    EXIT.
  ENDIF.

  "  redirection is active, we found 1
  CLEAR FIELD_KNOWN.                 " default  field not in ABAP
  CLEAR PLANT_FIELD_KNOWN.           " plant field in <FIELD_WERK>

  PERFORM SPECIAL_FIELD_TEST.

  IF FIELD_KNOWN = SPACE.              " not a workcenter so test
    PERFORM TEST_OTHER_FIELDS.         " other field names
  ENDIF.

  IF FIELD_KNOWN = SPACE.              " field NOT  availabe in ABAP
    REDIRECTION_ON = SPACE.            " field can not be used in ABAP
    EXIT.
  ENDIF.

*... so far things are looking,
*... we now have active field for redirection that exists in this ABAP
*... We must now check if the current value in this field is defined
*... in T392_V.  Our last test for redirection.

  SELECT       * FROM T392_V INTO TABLE TEMP_T392_V
         WHERE PM_APPL     = WWORKPAPER-PM_APPL
         AND   WORKPAPER   = WWORKPAPER-WORKPAPER
         AND   DDIC_STRUC  = T392-DDIC_STRUC
         AND   PM_FLD_NAM  = T392-PM_FLD_NAM.

  TEMP_T392_V = SPACE.
  LOOP AT TEMP_T392_V.                 " loop on possible fields
    T392_V = TEMP_T392_V.              " set T392_V
*... compare T392_V value against current field contents
    CHECK <FIELD_CONT> CP T392_V-FIELDVALUE.
*... and if the plant field is set then check it aswell.
    IF  NOT T392_V-WERKS IS INITIAL AND PLANT_FIELD_KNOWN = YES.
      CHECK <FIELD_WERK> CP T392_V-WERKS.
    ENDIF.
    REDIRECTION_ON = YES.              " H I T !!!!!!!!!
    EXIT.                " the first match is as good as any
  ENDLOOP.                             " select values from t392_s
ENDFORM.                    "CHECK_REDIRECTION

*---------------------------------------------------------------------*
*       FORM SET_PLANT_FIELD                                          *
*---------------------------------------------------------------------*
FORM SET_PLANT_FIELD.
*... first test if how the Plant field should be decided ?
*... only necessary for some fields but we set it just in case
  CASE FIELD_CONT_NAME.
    WHEN 'VIQMEL-BEBER'.  FIELD_WERK_NAME = 'VIQMEL-SWERK'.
    WHEN 'VIQMEL-INGRP'.  FIELD_WERK_NAME = 'VIQMEL-IWERK'.
    WHEN 'VIQMEL-STORT'.  FIELD_WERK_NAME = 'VIQMEL-SWERK'.
    WHEN 'CAUFVD-APGPR'.  FIELD_WERK_NAME = 'CAUFVD-IWERK'.
    WHEN 'CAUFVD-STORT'.  FIELD_WERK_NAME = 'CAUFVD-WERKS'.
*... catch all plant for other cases
    WHEN OTHERS.  " just assume WERKS, this is most common
      FIELD_WERK_NAME       = T392-DDIC_STRUC.
      FIELD_WERK_NAME+10(1) = '-'.
      FIELD_WERK_NAME+11(10) = 'WERKS'.
      CONDENSE FIELD_WERK_NAME NO-GAPS.
  ENDCASE.
ENDFORM.                    "SET_PLANT_FIELD

*---------------------------------------------------------------------*
*       FORM SPECIAL_FIELD_TEST                                       *
*---------------------------------------------------------------------*
FORM SPECIAL_FIELD_TEST.
*... check now for workcenters we can convert internal field
*... to external field plus get the correct plant here
  IF T392-PM_FLD_NAM = 'PPSID'         " is it a work center
  OR T392-PM_FLD_NAM = 'GEWRK'         " under one of many names
*..  OR T392-PM_FLD_NAM = 'VAPLZ'   " NO already converted !!!!!!!!!!
  OR T392-PM_FLD_NAM = 'ARBID'
* Workcenter from notification is different
  OR ( T392-PM_FLD_NAM = 'ARBPL' AND   "Work center in notification
       T392-DDIC_STRUC = 'VIQMEL' ).

*... convert it from internal workstation to external

    PERFORM BUILD_REDIRECT_FIELD.      " Workstation is a known field

    CALL FUNCTION 'CR_WORKSTATION_READ'
      EXPORTING
        ID        = <FIELD_CONT>
      IMPORTING
        ARBPL     = RCR01-ARBPL
        ECRHD     = CRHD
        KTEXT     = RCR01-KTEXT
        WERKS     = RCR01-WERKS
      EXCEPTIONS
        NOT_FOUND = 01.          " ignore this !!!!
* Unicode: Test is only possible on runtime, therfore no typing
    ASSIGN RCR01-ARBPL TO <FIELD_CONT>." set to external now
    ASSIGN RCR01-WERKS TO <FIELD_WERK>." set to external now
    PLANT_FIELD_KNOWN = YES.
  ENDIF.
ENDFORM.                    "SPECIAL_FIELD_TEST

*----------------------------------------------------------------------*
*       FORM TEST_OTHER_FIELDS.                                        *
*----------------------------------------------------------------------*
*       Test non Workcenter fields to see if they are LIVE in ABAP     *
*       FIELD_KNOWN set globally is found in abap                      *
*----------------------------------------------------------------------*
FORM TEST_OTHER_FIELDS.
*.. special check now for workstation fields
  PERFORM BUILD_REDIRECT_FIELD. "Build the field name for <FIELD_CONT>
  PERFORM SET_PLANT_FIELD.             " decide matching plant field
  ASSIGN (FIELD_WERK_NAME) TO <FIELD_WERK>.    " assign plant
  IF SYST-SUBRC =  0.
    PLANT_FIELD_KNOWN = YES.
  ELSE.
    PLANT_FIELD_KNOWN = SPACE.
  ENDIF.
ENDFORM.                    "TEST_OTHER_FIELDS

*----------------------------------------------------------------------*
*       FORM BUILD_REDIRECT_FIELD                                      *
*----------------------------------------------------------------------*
*       Build the field name for <FIELD_CONT> and set FIELD_KNOWN flag *
*----------------------------------------------------------------------*
*  <--  p2        FIELD_CONT_NAME    <FIELD_CONT>     GLOBAL           *
*----------------------------------------------------------------------*
FORM BUILD_REDIRECT_FIELD.
*...     Field DDIC_STRUC and PM_FLD_NAM determine the field
*...  build the ABAP fieldname as found in t392
  FIELD_CONT_NAME       = T392-DDIC_STRUC.
  FIELD_CONT_NAME+10(1) = '-'.
  FIELD_CONT_NAME+11(10) = T392-PM_FLD_NAM.
  CONDENSE FIELD_CONT_NAME NO-GAPS.
*... we can now try and retrieve the contents of the field on which
*... print redirection is based.
*... now test main field, is it in ABAP
  ASSIGN (FIELD_CONT_NAME) TO <FIELD_CONT>.    " if field is in abap
  IF SYST-SUBRC = 0.                   " main field in ABAP ?
    FIELD_KNOWN = YES.                 " follow the main field
  ELSE.
    FIELD_KNOWN = SPACE.
  ENDIF.
ENDFORM.                    "BUILD_REDIRECT_FIELD

*----------------------------------------------------------------------*
*       FORM NEW_PAPER_TEST.                                           *
*----------------------------------------------------------------------*
*    If the Printer defined in the workcenter of the order operation   *
*    changes or printer redirection is on the we must call open form   *
*    again.                                                            *
*    The variable LAST_PRINTER is controlled globally in report.       *
*    It is only important that it contains an initial value that       *
*    can not possible be a valid destination.                          *
*----------------------------------------------------------------------*
FORM NEW_PAPER_TEST.                   " do we need to open a new form ?

  DATA: REDIRECTION_ON,
        CRHD_TMP LIKE CRHD.

  PERFORM CHECK_REDIRECTION USING REDIRECTION_ON.
*... get the printer of the workcenter
  CALL FUNCTION 'CR_WORKSTATION_READ'
    EXPORTING
      ID        = AFVGD-ARBID
    IMPORTING
      ECRHD     = CRHD_TMP
    EXCEPTIONS
      NOT_FOUND = 1
      OTHERS    = 2.
  AFVGD-PDEST = CRHD_TMP-PDEST.
*... test if a new form must be started
  IF AFVGD-PDEST <> LAST_PRINTER       " operation destination
  OR REDIRECTION_ON = YES.
    IF FORM_OPEN_FLAG = YES.
      PERFORM CLOSE_FORM.              " first close existing form
    ENDIF.

    PERFORM SET_GV_ARC_TYPE_AUFK USING caufvd-auart.        "n766146

* PERFORM OPEN_FORM  USING C_ARC_TYPE_AUFK                     "n766146
    PERFORM OPEN_FORM  USING gv_ARC_TYPE_AUFK               "n766146
                             CAUFVD-AUFNR
                             AFVGD-PDEST. " alternate printer sent
  ENDIF.
  LAST_PRINTER = AFVGD-PDEST.          " save last printer
ENDFORM.                    "NEW_PAPER_TEST

*----------------------------------------------------------------------*
*       FORM CLOSE_FORM.                                               *
*----------------------------------------------------------------------*
*       Close current open SAPSCRIPT form.                             *
*----------------------------------------------------------------------*
FORM CLOSE_FORM.
  CALL FUNCTION 'CLOSE_FORM'
    IMPORTING
      RESULT   = ITCPP           " Information can be useful
    EXCEPTIONS                      " eg dest, spool nr etc
      UNOPENED = 1.
ENDFORM.                    "CLOSE_FORM

*----------------------------------------------------------------------*
*       FORM TITLE.                                                    *
*----------------------------------------------------------------------*
*       Issue a standard title                                         *
*       Assumes TEXT ELEMENT and WINDOW are both called 'TITLE'        *
*----------------------------------------------------------------------*
FORM TITLE.
  PERFORM SET_TITLE.
*print the title
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      ELEMENT = 'TITLE'
      WINDOW  = 'TITLE'.         " Constant window in FORM
ENDFORM.                    "TITLE

*----------------------------------------------------------------------*
*       FORM TITLE_PAGE                                                *
*----------------------------------------------------------------------*
*       Prints title for every new page                                *
*----------------------------------------------------------------------*
FORM TITLE_PAGE.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      ELEMENT = 'TITLE_PAGE'
      WINDOW  = 'MAIN'.
ENDFORM.                    "TITLE_PAGE

*----------------------------------------------------------------------*
*       FORM TITLE_BLOCK                                               *
*----------------------------------------------------------------------*
*       Prints title for every new block (material, split, ...)        *
*----------------------------------------------------------------------*
FORM TITLE_BLOCK.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      ELEMENT = 'TITLE_BLOCK'
      WINDOW  = 'MAIN'.
ENDFORM.                    "TITLE_BLOCK

*----------------------------------------------------------------------*
*       FORM SET_TITLE.                                                *
*----------------------------------------------------------------------*
*       WIPRT-TITLE is set from text table .   From  T390_T            *
*       Use in all formulars as the title field                        *
*----------------------------------------------------------------------*
FORM SET_TITLE.
  CLEAR T390_T.
  SELECT SINGLE * FROM  T390_T         " Workpaper texts
         WHERE  SPRAS       = PRINT_LANGUAGE
         AND    PM_APPL     = T390-PM_APPL
         AND    WORKPAPER   = T390-WORKPAPER.
  WIPRT-TITLE = T390_T-PAPERTEXT.      " Set title of form
ENDFORM.                    "SET_TITLE

*----------------------------------------------------------------------*
*       FORM NOTIFICATION_HEADER.                                      *
*----------------------------------------------------------------------*
*       Print the Notification header. Read texts, Issue Element       *
*----------------------------------------------------------------------*
FORM NOTIFICATION_HEADER.
  DATA SAVE_RIWO1 LIKE RIWO1.

  CLEAR SAVE_RIWO1.
*-> get RIWO1 of notif (could be necessary within order printing)
  IF RIWO1-OBJNR <> VIQMEL-OBJNR.
    SAVE_RIWO1 = RIWO1.
    READ TABLE IRIWO1 WITH KEY OBJNR = VIQMEL-OBJNR.
    RIWO1 = IRIWO1.
  ENDIF.
*... Print the Notification Header Window, short version.
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      ELEMENT = 'NOTIF_HEADER_SHORT'
      WINDOW  = 'MAIN'.
*-> restore RIWO1 if saved above
  IF NOT SAVE_RIWO1 IS INITIAL.
    RIWO1 = SAVE_RIWO1.
  ENDIF.
*-> print longtext
  PERFORM PRINT_NOTIFICATION_LONGTEXT.
ENDFORM.                    "NOTIFICATION_HEADER

*----------------------------------------------------------------------*
*       FORM NOTIFICATION_HEADER_DETAIL                                *
*----------------------------------------------------------------------*
*       Print the Notification header. Read texts, Issue Element       *
*----------------------------------------------------------------------*
FORM NOTIFICATION_HEADER_DETAIL.
  DATA SAVE_RIWO1 LIKE RIWO1.

  CLEAR SAVE_RIWO1.
*-> get RIWO1 of notif (could be necessary within order printing)
  IF RIWO1-OBJNR <> VIQMEL-OBJNR.
    SAVE_RIWO1 = RIWO1.
    READ TABLE IRIWO1 WITH KEY OBJNR = VIQMEL-OBJNR.
    RIWO1 = IRIWO1.
  ENDIF.
*... Print the Notification Header Window, DETAIL version
  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      ELEMENT = 'NOTIF_HEADER_DETAIL'
      WINDOW  = 'MAIN'.
*-> restore RIWO1 if saved above
  IF NOT SAVE_RIWO1 IS INITIAL.
    RIWO1 = SAVE_RIWO1.
  ENDIF.
*-> print longtext
  PERFORM PRINT_NOTIFICATION_LONGTEXT.
ENDFORM.                    "NOTIFICATION_HEADER_DETAIL
*----------------------------------------------------------------------*
*       FORM END_OF_REPORT                                             *
*----------------------------------------------------------------------*
*       Issue Line 'END OF REPORT' to indicate last page.              *
*       So user can be sure he has all pages                           *
*----------------------------------------------------------------------*
FORM END_OF_REPORT.

  CALL FUNCTION 'WRITE_FORM'
    EXPORTING
      ELEMENT = 'END_OF_REPORT'
      WINDOW  = 'MAIN'.

ENDFORM.                    "END_OF_REPORT

*----------------------------------------------------------------------*
*       FORM PRINT_LONGTEXT                                            *
*----------------------------------------------------------------------*
*       The longtext will be read, using OBJECT                        *
*                                        OBJECT_NR                     *
*                                        SPRAS                         *
*                                        TXID                          *
*                                                                      *
*       And printed in WINDOW 'WINDOW' in the current FORM.            *
*                                                                      *
*----------------------------------------------------------------------*
*  -->  OBJECT    LONGTEXT OBJECT                                      *
*  -->  OBJECT_NR Key to longtext                                      *
*  -->  SPRAS     Language                                             *
*  -->  TXID      Text id                                              *
*  -->  WINDOW    FORM WINDOW                                          *
*  -->  START_LINE  Print longtext starting line nr                    *
*  -->  END_LINE  Last line number                                     *
*  -->  UNDERLINE_FLAG :   'X' = With Uline before and after text      *
*----------------------------------------------------------------------*
FORM PRINT_LONGTEXT USING OBJECT          TYPE CLIKE
                          OBJECT_NR       TYPE CLIKE
                          SPRAS           TYPE CLIKE
                          TXID            TYPE CLIKE
                          WINDOW          TYPE CLIKE
                          START_LINE_NR   TYPE NUMERIC
                          LAST_LINE_NR    TYPE NUMERIC
                          UNDERLINE_FLAG  TYPE CLIKE.


  DATA LV_SUBRC LIKE SY-SUBRC.

*... convert parameters to correct size
  TEXT_OBJECT  =   OBJECT.             " Move to special fields
  TEXT_NAME    =   OBJECT_NR.          " for sizes to call
  TEXT_ID      =   TXID.               " functions

*... First read the text.
  PERFORM READ_TEXT USING  TEXT_ID
                           SPRAS
                           TEXT_NAME
                           TEXT_OBJECT
                           RC.

  MOVE RC TO LV_SUBRC.
  IF LV_SUBRC NE 0.
* Wenn Druck im Dialog aktiviert ist, und die Meldung noch nicht
* gesichert war, kann der Text ¨¹ber %00000000001 aus dem Memory
* gelesen werden.
*--- T399J lesen
    DATA: W_T399J TYPE T399J.
    SELECT SINGLE * FROM  T399J CLIENT SPECIFIED INTO W_T399J
           WHERE  MANDT       = SYST-MANDT.
    IF SY-SUBRC EQ 0.
      IF W_T399J-DIALOG_PRT NE SPACE.         " Druck im Dialog?
* Positions- und Ursachennummer folgt nach der Meldungsnummer
        MOVE  '%00000000001' TO TEXT_NAME(12).
        PERFORM READ_TEXT USING  TEXT_ID
                                 SPRAS
                                 TEXT_NAME
                                 TEXT_OBJECT
                                 RC.
        MOVE RC TO LV_SUBRC.
      ENDIF. "Print in dialog
    ENDIF.   "No Entry in t399j
  ENDIF.     "Text not found.
  IF LV_SUBRC = 0.                   "When text is found
*... with something to print.
*... Remove unwanted text lines from end of table
    LOOP AT TABLE_LINES.
      IF SYST-TABIX > LAST_LINE_NR.
        DELETE TABLE_LINES.
      ENDIF.
    ENDLOOP.
*... Remove unwanted text lines from start of table
    IF START_LINE_NR > 1.
      DEL_LINES = START_LINE_NR - 1.
      DO DEL_LINES TIMES.
        DELETE TABLE_LINES INDEX 1.
      ENDDO.
    ENDIF.
*... PRINT THE TEXT NOW
    PERFORM TEXT_OUTPUT TABLES TABLE_LINES
                         USING  TABLE_HEADER
                                WINDOW
                                UNDERLINE_FLAG.

  ENDIF.                               " text was found

ENDFORM.                    "PRINT_LONGTEXT

*---------------------------------------------------------------------*
*       FORM TEXT_OUTPUT                                              *
*---------------------------------------------------------------------*
*  -->  TABLE_LINES                                                   *
*  -->  TABLE_HEADER                                                  *
*  -->  WINDOW                                                        *
*  -->  UNDERLINE_FLAG                                                *
*---------------------------------------------------------------------*
FORM TEXT_OUTPUT TABLES TABLE_LINES    STRUCTURE TLINE
                 USING  TABLE_HEADER   LIKE THEAD
                        WINDOW         TYPE CLIKE
                        UNDERLINE_FLAG TYPE CLIKE.

*... to protect longtexts from page breaks use the PROTECT
*... ENDPROTECT command in SAPSCRIPT
  PERFORM SAPSCRIPT_COMMAND USING  'PROTECT'.  "DO NOT TRANSLATE CMD

  IF UNDERLINE_FLAG = YES.
    PERFORM UNDER_LINE.                " underscore line
  ENDIF.

  CALL FUNCTION 'WRITE_FORM_LINES'
    EXPORTING
      HEADER    = TABLE_HEADER
      WINDOW    = WINDOW
    IMPORTING
      FROMPAGE  = FROMPAGE       " not interested ?
    TABLES
      LINES     = TABLE_LINES
    EXCEPTIONS
      FUNCTION  = 01
      TYPE      = 02
      UNOPENED  = 03
      UNSTARTED = 04
      WINDOW    = 05.
*... leave SYST-SUBRC set.  We dont mind if text was bad, nothing
*... we can do about here.

  IF UNDERLINE_FLAG = YES.
    PERFORM UNDER_LINE.                " underscore line
  ENDIF.

*... page break protect off.
  PERFORM SAPSCRIPT_COMMAND USING  'ENDPROTECT'.            "
ENDFORM.                    "TEXT_OUTPUT

*----------------------------------------------------------------------*
*       FORM PRINT_NOTIFICATION_LONTEXT.                               *
*----------------------------------------------------------------------*
*       Print the long text for the notification header.               *
*       It will be printed exactly as found in text file STXH          *
*       inside the current form in window MAIN.                        *
*----------------------------------------------------------------------*
*  -->  p1        VIQMEL    Globally the VIEW must be available        *
*----------------------------------------------------------------------*
FORM PRINT_NOTIFICATION_LONGTEXT.

*... LONGTEXT for NOTIFICATIOn Header
  IF NOT VIQMEL-INDTX IS INITIAL.      "Is there a long text for Notif
    TEXT_OBJECT_NAME =  'QMEL'.        " temp number
    PERFORM READ_TEXT USING LTXT_ID    " text for create
                            VIQMEL-KZMLA       " mode text
                            TEXT_OBJECT_NAME   " with temp number
                            C_QMEL                          "
                            RC.

*... now build the text name
    IF RC <> 0.
      TEXT_OBJECT_NAME = VIQMEL-QMNUM.
    ENDIF.

*... print the text
    PERFORM PRINT_LONGTEXT USING C_QMEL
                                 TEXT_OBJECT_NAME
                                 VIQMEL-KZMLA
                                 LTXT_ID
                                 C_MAIN
                                 C_START_LINE_NR
                                 C_LAST_LINE_NR
                                 YES.  "with underline around text
  ENDIF.
ENDFORM.                    "PRINT_NOTIFICATION_LONGTEXT


*----------------------------------------------------------------------*
*       FORM PRINT_position_LONTEXT.                                   *
*----------------------------------------------------------------------*
*       Print the long text for the notification POSITION              *
*       It will be printed exactly as found in text file STXH          *
*       inside the current form in window MAIN.                        *
*----------------------------------------------------------------------*
*  -->  WQMFE  Globally Position work record must be available         *
*----------------------------------------------------------------------*
FORM PRINT_POSITION_LONGTEXT.
*... LONGTEXT for Position
  IF NOT WQMFE-INDTX IS INITIAL.       "Is there a long text for POS
    TEXT_OBJECT_NAME =  'QMFE'.        " temp number
    PERFORM READ_TEXT USING LTXT_ID    " text for create
                            WQMFE-KZMLA" mode text
                            TEXT_OBJECT_NAME   " with temp number
                            C_QMEL                          "
                            RC.
    IF RC <> 0.
*... now build the text name                 see MIWO0f50
      TEXT_OBJECT_NAME+0(12) = WQMFE-QMNUM.
      TEXT_OBJECT_NAME+12(4) = WQMFE-FENUM.
      CONDENSE TEXT_OBJECT_NAME NO-GAPS.
    ENDIF.
*... print the text
    PERFORM PRINT_LONGTEXT USING C_QMFE
                                 TEXT_OBJECT_NAME
                                 WQMFE-KZMLA
                                 LTXT_ID
                                 C_MAIN
                                 C_START_LINE_NR
                                 C_LAST_LINE_NR
                                 YES.  "with underline around text
  ENDIF.
ENDFORM.                    "PRINT_POSITION_LONGTEXT

*----------------------------------------------------------------------*
*       FORM PRINT_CAUSE_LONGTEXT.                                     *
*----------------------------------------------------------------------*
*       Print the long text for the notification DAMAGE CAUSE.         *
*       It will be printed exactly as found in text file STXH          *
*       inside the current form in window MAIN.                        *
*----------------------------------------------------------------------*
*  -->  WQMUR  Globally CAUSE work record must be available            *
*----------------------------------------------------------------------*
FORM PRINT_CAUSE_LONGTEXT.

*... LONGTEXT for cause
  IF NOT WQMUR-INDTX IS INITIAL.       "Is there a long text for cause
    TEXT_OBJECT_NAME =  'QMUR'.        " temp number
    PERFORM READ_TEXT USING LTXT_ID    " text for create
                            WQMUR-KZMLA" mode text
                            TEXT_OBJECT_NAME   " with temp number
                            C_QMEL                          "
                            RC.

*... now build the text name                 see MIWO0f50
    IF RC <> 0.
      TEXT_OBJECT_NAME+0(12) = WQMUR-QMNUM.
      TEXT_OBJECT_NAME+12(4) = WQMUR-FENUM.
      TEXT_OBJECT_NAME+16(4) = WQMUR-URNUM.
      CONDENSE TEXT_OBJECT_NAME NO-GAPS.
    ENDIF.
*... print the text
    PERFORM PRINT_LONGTEXT USING C_QMUR
                                 TEXT_OBJECT_NAME
                                 WQMUR-KZMLA
                                 LTXT_ID
                                 C_MAIN
                                 C_START_LINE_NR
                                 C_LAST_LINE_NR
                                 YES.  "with underline around text
    CLEAR TEXT_OBJECT_NAME.
  ENDIF.
ENDFORM.                    "PRINT_CAUSE_LONGTEXT


*----------------------------------------------------------------------*
*       FORM LOCK_AND_SET.                                             *
*----------------------------------------------------------------------*
*       Enqueue print record   and determine copy number.              *
*       IF enqueue fails set COPY to 'NOT LOGGED'                      *
*----------------------------------------------------------------------*
FORM LOCK_AND_SET USING DEPTH LIKE IPRT_WA-PRT_DEPTH.
*... PMPL key is set, copy text (ORIGINAL/COPY) is set, LOG record
*... Locked.  All copy numbers are locked !

  NO_LOG = SPACE.                      " Clear lock flag
  CLEAR PMPL.                          " Clear log record.

  CALL FUNCTION 'PM_BUILD_PRINT_KEY'   " Build PMPL print key
       EXPORTING                       " based on for
            PM_APPL   =  T390-PM_APPL                       "
            PRT_DEPTH =  DEPTH         " which paper depth
            VIQMEL    =  VIQMEL
            WQMFE     =  WQMFE
            CAUFVD    =  CAUFVD
            AFVGD     =  AFVGD
            RESBD     =  RESBD
       IMPORTING
            PMPL      =  PMPL.

  PMPL-PM_PAPER  = T390-WORKPAPER.     " Now set the Workpaper
  PMPL-PM_APPL   = T390-PM_APPL.                            "
*  in display only mode do not lock pmpl
  IF DEVICE = C_SCREEN OR DEVICE = C_PREVIEW.
    PERFORM SET_PMPL_RECORD.           " complete PMPL record
    " and copy indicator
  ELSE.
    CALL FUNCTION 'ENQUEUE_EPMPL'
      EXPORTING
        PM_APPL        = PMPL-PM_APPL  "Lock
        PRINT_KEY      = PMPL-PRINT_KEY
        PM_PAPER       = PMPL-PM_PAPER
        _WAIT          = YES
      EXCEPTIONS
        FOREIGN_LOCK   = 01
        SYSTEM_FAILURE = 02.

    IF SYST-SUBRC <> 0.
      NO_LOG = YES.                    " The Document log is locked
      WIPRT-COPY_TEXT = 'LOG ERR'(501)." for exactly this document.
      " Print it without log.
    ELSE.
      PERFORM SET_PMPL_RECORD.         " complete PMPL record
      " and copy indicator
    ENDIF.
  ENDIF.
ENDFORM.                    "LOCK_AND_SET

*----------------------------------------------------------------------*
*       FORM SET_PMPL_RECORD.                                          *
*----------------------------------------------------------------------*
*       The PMPL print log record is set based on the current key      *
*       and current runtime variables.                                 *
*       The idea is to decide whether it is a copy or not              *
*       and set the complete PMPL for writing after form is completely *
*       output.                                                        *
*----------------------------------------------------------------------*
*  -->  p1        PMPL record                                          *
*  <--  p2        PMPL record completed plus WIPRT copy text           *
*----------------------------------------------------------------------*
FORM SET_PMPL_RECORD.
*... Now work out how many copies have been printed a set COPY TEXT
*... for priting on the FORM.

  LAST_COPY_NR = 0.
  SELECT MAX( COPY_NR ) INTO LAST_COPY_NR  FROM PMPL
         WHERE  PM_APPL     = PMPL-PM_APPL
         AND    PRINT_KEY   = PMPL-PRINT_KEY
         AND    PM_PAPER    = PMPL-PM_PAPER.
  PMPL-COPY_NR = LAST_COPY_NR + 1.

  IF PMPL-COPY_NR = 1.                 " First_one
    IF WWORKPAPER-PM_DELTA_P = 'X'.
      WIPRT-COPY_TEXT = 'Original/Delta'(505).
    ELSE.
      WIPRT-COPY_TEXT = 'Original'(502).
    ENDIF.
    G_REPEAT = PMPL-COPY_NR.           "f¨¹r QM Reaklamation
  ELSE.
    IF WWORKPAPER-PM_DELTA_P = 'X'.
      WIPRT-COPY_TEXT = 'Delta   '(504).
      WRITE PMPL-COPY_NR TO WIPRT-COPY_TEXT+8(3) NO-ZERO.
    ELSE.
      WIPRT-COPY_TEXT = 'Kopie   '(503).
      WRITE PMPL-COPY_NR TO WIPRT-COPY_TEXT+8(3) NO-ZERO.
    ENDIF.
    G_REPEAT = PMPL-COPY_NR.           "f¨¹r QM Reklamation
  ENDIF.

*... complete the PMPL Log record for later.
  PMPL-ABAPNAME   = ''.   "This field is not supported from 4.0 onward.
  PMPL-FORM       = T390-FORM.
  PMPL-UNAME      = SYST-UNAME.
  PMPL-DATUM      = SYST-DATUM.
  PMPL-UZEIT      = SYST-UZEIT.
  PMPL-TDDEST     = ITCPO-TDDEST.
  PMPL-PM_DELTA_P = WWORKPAPER-PM_DELTA_P.
  PMPL-TDTELENUM  = ITCPO-TDTELENUM.
  PMPL-TDTELELAND = ITCPO-TDTELELAND.
ENDFORM.                    "SET_PMPL_RECORD

*----------------------------------------------------------------------*
*       FORM UNLOCK_AND_LOG.                                           *
*----------------------------------------------------------------------*
*       Dequeue the Print log record PMPL and write the log record     *
*       not in that order. !                                           *
*----------------------------------------------------------------------*
*  -->  PMPL      Globally set (or should be !!!)                      *
*----------------------------------------------------------------------*
FORM UNLOCK_AND_LOG.
*... update LOG file PMPL  DEQUEUE MADE BY SYSTEM !!!!!!!!!!
*// no_log is set in lock_and_set
  CHECK NO_LOG = SPACE.                "enqueue worked and copy no. set
  IF DONT_LOG = SPACE.                 " see open_form
    IF SYST-ONCOM = SPACE AND SYST-BATCH = SPACE. " not in update task
      CALL FUNCTION 'PM_UPDATE_PMPL' IN UPDATE TASK
        EXPORTING
          INDUPD = C_INSERT
          WPMPL  = PMPL.
      COMMIT WORK.
    ELSE.                              " we are already in update task
      CALL FUNCTION 'PM_UPDATE_PMPL'
        EXPORTING
          INDUPD = C_INSERT
          WPMPL  = PMPL.
    ENDIF.
*... unlock print record / for workpaper
*... DEQUEUE ON EPMPL MADE BY SYSTEM WHEN PM_UPDATE_PMPL IS FINSIHED
  ENDIF.
ENDFORM.                    "UNLOCK_AND_LOG

*---------------------------------------------------------------------*
*       FORM SAPSCRIPT_COMMAND                                        *
*---------------------------------------------------------------------*
*  -->  CMD                                                           *
*---------------------------------------------------------------------*
FORM SAPSCRIPT_COMMAND USING CMD.
  CALL FUNCTION 'CONTROL_FORM'
    EXPORTING
      COMMAND   = CMD
    EXCEPTIONS
      UNOPENED  = 01
      UNSTARTED = 02.
ENDFORM.                    "SAPSCRIPT_COMMAND

*---------------------------------------------------------------------*
*       FORM PARTNER_DETAILS                                          *
*---------------------------------------------------------------------*
*  -->  IHPAD_LOC                                                     *
*---------------------------------------------------------------------*
FORM PARTNER_DETAILS TABLES IHPAD_LOC STRUCTURE IHPAD.
*... print the partner info in window main from IHPAD- record
  LOOP AT IHPAD_LOC.
    IHPAD = IHPAD_LOC.        " only can pass ddic fields to SAPSCRIPT
*-> read VTEXT in print language
    CALL FUNCTION 'PM_PARTNER_ROLL_TEXT'
      EXPORTING
        PARVW    = IHPAD-PARVW
        LANGUAGE = PRINT_LANGUAGE
      IMPORTING
        VTEXT    = IHPAD-VTEXT.

* begin of insert by air21099 on 2005.09.23 for AM: AFRA
*   other descriptions for partners are required
    if ihpad-parvw = 'WE'.
* begin of insert 2 by air21099 on 2005.10.13 for AM: CPRA
      case print_language.
        when 'F'.
* end of insert 2
          ihpad-vtext = 'Adresse livraison'.
* begin of insert 2 by air21099 on 2005.10.13 for AM: CPRA
        when 'V'.
          ihpad-vtext = 'Leveransadress'.
* begin of insert 3 by air21099 on 2005.11.02 for AM: GBAA
        when 'E'.
          ihpad-vtext = 'Delivery address'.
* end of insert 3
* begin of insert 4 by air21099 on 2006.02.02 for AM: IYAA
        when 'I'.
          ihpad-vtext = 'Indirizzo consegna'.
* end of insert 4
      endcase.
* end of insert 2
    elseif ihpad-parvw = 'RE'.
* begin of insert 2 by air21099 on 2005.10.13 for AM: CPRA
      case print_language.
        when 'F'.
* end of insert 2
          ihpad-vtext = 'Adresse facturation'.
* begin of insert 2 by air21099 on 2005.10.13 for AM: CPRA
        when 'V'.
          ihpad-vtext = 'Faktureringsadress'.
* begin of insert 3 by air21099 on 2005.11.02 for AM: GBAA
        when 'E'.
          ihpad-vtext = 'Invoice address'.
* end of insert 3
* begin of insert 4 by air21099 on 2006.02.02 for AM: IYAA
        when 'I'.
          ihpad-vtext = 'Indirizzo fattura'.
* end of insert 4
      endcase.
* end of insert 2
    endif.
* end of insert

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        ELEMENT = 'PARTNER_INFO'
        WINDOW  = 'MAIN'.
  ENDLOOP.
ENDFORM.                    "PARTNER_DETAILS

*&---------------------------------------------------------------------*
*&      Form  READ_EQUIPMENT_PARTNER
*&---------------------------------------------------------------------*
FORM TECH_OBJECT_PARTNER USING EQUIPMENT_NR LIKE VIQMEL-EQUNR
                               FUNCTIONAL_LOCATION LIKE RIWO1-TPLNR.
  DATA: IHPAD_COP LIKE IHPAD OCCURS   0 WITH HEADER LINE.

**begin of delete by air21099 on 2005.09.22 for AM: AFRA
* instead of sold-to address the adress of the functional location has
* has to be printed
* IF  NOT EQUIPMENT_NR IS INITIAL.
*   PERFORM GET_EQUIPMENT_DATA USING EQUIPMENT_NR.
*   PERFORM GET_PARTNER_FOR_OBJECT TABLES IHPAD_COP
*                                  USING EQUI-OBJNR.
*-> deletes double partners
*   PERFORM ONLY_NEW_PARTNERS TABLES IHPAD_COP.
*   PERFORM PARTNER_DETAILS  TABLES IHPAD_COP.              "
* ELSE.
**end of delete
  IF NOT FUNCTIONAL_LOCATION IS INITIAL.
    PERFORM GET_FUNC_LOC_DATA USING FUNCTIONAL_LOCATION.
**begin of change by air21099 on 2005.09.22 for AM: AFRA
*     PERFORM GET_PARTNER_FOR_OBJECT TABLES IHPAD_COP
*                                  USING IFLO-OBJNR.
*-> deletes double partners
*     PERFORM ONLY_NEW_PARTNERS TABLES IHPAD_COP.
*     PERFORM PARTNER_DETAILS TABLES  IHPAD_COP.
* the address of the functional location has to be printed
    clear ihpad.
    select name1 street city1 name2 tel_number post_code1
       into (ihpad-name1, ihpad-street, ihpad-city1,
             ihpad-name2, ihpad-tel_number, ihpad-post_code1)
       from ADRC
       where addrnumber = iflo-adrnr.
    endselect.
* begin of insert 2 by air21099 on 2005.10.13 for AM: CPRA
    case print_language.
      when 'F'.
* end of insert 2
        ihpad-vtext = 'Adresse site'.
* begin of insert 2 by air21099 on 2005.10.13 for AM: CPRA
      when 'V'.
        ihpad-vtext = 'Placeringsadress'.
* begin of insert 3 by air21099 on 2005.11.02 for AM: GBAA
      when 'E'.
        ihpad-vtext = 'Funct.loc. address'.
* end of insert 3
* begin of insert 4 by air21099 on 2006.02.02 for AM: IYAA
      when 'I'.
        ihpad-vtext = 'Indirizzo install.'.
* end of insert 4
    endcase.
* end of insert 2

    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        ELEMENT = 'PARTNER_INFO'
        WINDOW  = 'MAIN'.
  ENDIF.
* end of change
* begin of delete by air21099 on 2005.09.22 for AM: AFRA
* ENDIF.
* end of delete
ENDFORM.                               " READ_EQUIPMENT_PARTNER

*---------------------------------------------------------------------*
*       FORM GET_FUNC_LOC_DATA                                        *
*---------------------------------------------------------------------*
*  -->  FUNCTIONAL_LOCATION                                           *
*---------------------------------------------------------------------*
FORM GET_FUNC_LOC_DATA USING FUNCTIONAL_LOCATION LIKE RIWO1-TPLNR.
  CALL FUNCTION 'FUNC_LOCATION_READ'
    EXPORTING
      TPLNR           = FUNCTIONAL_LOCATION
    IMPORTING
      IFLO_WA         = IFLO
    EXCEPTIONS
      IFLOT_NOT_FOUND = 01
      ILOA_NOT_FOUND  = 02.
ENDFORM.                    "GET_FUNC_LOC_DATA

*---------------------------------------------------------------------*
*       FORM GET_EQUIPMENT_DATA                                       *
*---------------------------------------------------------------------*
*  -->  EQUIPMENT_NR                                                  *
*---------------------------------------------------------------------*
FORM GET_EQUIPMENT_DATA USING EQUIPMENT_NR  LIKE VIQMEL-EQUNR.
  CALL FUNCTION 'EQUIPMENT_READ'
    EXPORTING
      EQUI_NO        = EQUIPMENT_NR
    IMPORTING
      EFHM           = EFHM
      EQKT           = EQKT
      EQUI           = EQUI
      EQUZ           = EQUZ
      ILOA           = ILOA
    EXCEPTIONS
      AUTH_NO_BEGRP  = 01
      AUTH_NO_IWERK  = 02
      AUTH_NO_SWERK  = 03
      EQKT_NOT_FOUND = 04
      EQUI_NOT_FOUND = 05
      EQUZ_NOT_FOUND = 06
      ILOA_NOT_FOUND = 07.
ENDFORM.                    "GET_EQUIPMENT_DATA

*---------------------------------------------------------------------*
*       FORM GET_PARTNER_FOR_OBJECT                                   *
*---------------------------------------------------------------------*
*  -->  IHPAD_COP                                                     *
*  -->  OBJECT_NR                                                     *
*---------------------------------------------------------------------*
FORM GET_PARTNER_FOR_OBJECT TABLES IHPAD_COP STRUCTURE IHPAD
                            USING OBJECT_NR LIKE EQUI-OBJNR.
*... get the partners for the equipment
  CALL FUNCTION 'PM_GET_PARTNER_INFO'
    EXPORTING
      OBJECT_NUMBER = OBJECT_NR
    TABLES
      IHPAD_TAB_EXP = IHPAD_COP.

ENDFORM.                    "GET_PARTNER_FOR_OBJECT

*---------------------------------------------------------------------*
*       FORM WRITE_LONGTEXT                                           *
*---------------------------------------------------------------------*
*... ABAP write version of Long text print
FORM WRITE_LONGTEXT USING OBJECT         TYPE CLIKE
                          OBJECT_NR      TYPE CLIKE
                          SPRAS          TYPE CLIKE
                          TXID           TYPE CLIKE
                          START_LINE_NR  TYPE NUMERIC
                          LAST_LINE_NR   TYPE NUMERIC
                          UNDERLINE_FLAG TYPE CLIKE.


*... convert parameters to correct size
  TEXT_OBJECT  =   OBJECT.             " Move to special fields
  TEXT_NAME    =   OBJECT_NR.          " for sizes to call
  TEXT_ID      =   TXID.               " functions

*... First read the text.

  PERFORM READ_TEXT USING  TEXT_ID
                           PRINT_LANGUAGE
                           TEXT_NAME
                           TEXT_OBJECT
                           RC.

  IF RC = 0.                           "When text is found
*... with something to print.
*... Remove unwanted text lines from end of table
    LOOP AT TABLE_LINES.
      IF SYST-TABIX > LAST_LINE_NR.
        DELETE TABLE_LINES.
      ENDIF.
    ENDLOOP.
*... Remove unwanted text lines from start of table
    IF START_LINE_NR > 1.
      DEL_LINES = START_LINE_NR - 1.
      DO DEL_LINES TIMES.
        DELETE TABLE_LINES INDEX 1.
      ENDDO.
    ENDIF.

    IF UNDERLINE_FLAG = YES.
      ULINE.
    ENDIF.
*... text unformatted print   FUNCTION: Print_text is an option here
*...                         if you really need formated texts
*...                         Use a SAPSCRIPT print example is even
*...                         better.
    LOOP AT TABLE_LINES.
      WRITE: / TABLE_LINES-TDLINE.
    ENDLOOP.

    IF UNDERLINE_FLAG = YES.
      ULINE.
    ENDIF.
  ENDIF.                               " text was found
ENDFORM.                    "WRITE_LONGTEXT


*---------------------------------------------------------------------*
*       FORM READ_TEXT                                                *
*---------------------------------------------------------------------*
*  -->  TEXT_ID                                                       *
*  -->  PRINT_LANGUAGE                                                *
*  -->  TEXT_NAME                                                     *
*  -->  TEXT_OBJECT                                                   *
*  -->  LRC                                                           *
*---------------------------------------------------------------------*
FORM READ_TEXT USING  TEXT_ID          LIKE   THEAD-TDID
                      PRINT_LANGUAGE   LIKE   THEAD-TDSPRAS
                      TEXT_NAME        LIKE   THEAD-TDNAME
                      TEXT_OBJECT      LIKE   THEAD-TDOBJECT
                      LRC              LIKE    RC.
  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      ID              = TEXT_ID
      LANGUAGE        = PRINT_LANGUAGE
      NAME            = TEXT_NAME
      OBJECT          = TEXT_OBJECT
    IMPORTING
      HEADER          = TABLE_HEADER
    TABLES
      LINES           = TABLE_LINES
    EXCEPTIONS
      ID              = 01
      LANGUAGE        = 02
      NAME            = 03
      NOT_FOUND       = 04
      OBJECT          = 05
      REFERENCE_CHECK = 06.

  LRC = SYST-SUBRC.
ENDFORM.                    "READ_TEXT
*&---------------------------------------------------------------------*
*&      Form  READ_MATERIAL
*&---------------------------------------------------------------------*
*   Materailtext lesen                                                 *
*----------------------------------------------------------------------*
FORM READ_MATERIAL.

  TABLES: MTCOM,
          MTQSS.
  DATA :  BEGIN OF DUMMY_TAB OCCURS 0,
            DUMMY(1),
          END   OF DUMMY_TAB.

  MOVE  'MTQSS'          TO MTCOM-KENNG.
  MOVE  VIQMEL-MATNR     TO MTCOM-MATNR.
  if not wworkpaper-PRINT_LANG is initial.
    MOVE  wworkpaper-PRINT_LANG  TO MTCOM-SPRAS.
  else.
    MOVE  PRINT_LANGUAGE   TO MTCOM-SPRAS.
  endif.

  CALL FUNCTION 'MATERIAL_READ_MAQM'
    EXPORTING
      SCHLUESSEL         = MTCOM
    IMPORTING
      MATDATEN           = MTQSS
    TABLES
      SEQMAT01           = DUMMY_TAB
    EXCEPTIONS
      MATERIAL_NOT_FOUND = 04.
  IF SY-SUBRC EQ 0.
    MOVE MTQSS-MAKTX TO RIWO00-MATKTX.
  ENDIF.
ENDFORM.                               " READ_MATERIAL
*&---------------------------------------------------------------------*
*&      Form  READ_STATUS
*&---------------------------------------------------------------------*
* Statustext lesen                                                     *
*----------------------------------------------------------------------*
*  <--  sttxt     Text
*----------------------------------------------------------------------*
FORM READ_STATUS USING P_OBJNR
                       P_STTXT.

*-- statusleiste f¨¹llen                                          -----*
  CALL FUNCTION 'STATUS_TEXT_EDIT'
    EXPORTING
      FLG_USER_STAT    = YES
      OBJNR            = P_OBJNR
      SPRAS            = PRINT_LANGUAGE
    IMPORTING
      LINE             = P_STTXT
    EXCEPTIONS
      OBJECT_NOT_FOUND = 01.
ENDFORM.                               " READ_STATUS

*&---------------------------------------------------------------------*
*&      Form  PRINT_CLASSIFICATION
*&---------------------------------------------------------------------*
*-- Klassen drucken
FORM PRINT_CLASSIFICATION USING OBJECT     TYPE CLIKE
                                OBJECT_TAB TYPE CLIKE
                                FIELDNAME  TYPE CLIKE.

  TABLES: API_KSSK,                    "class header
          API_VAL_R.                   "values for each class
  DATA: LOCAL_OBJECT LIKE KSSK-OBJEK.
  DATA: LOCAL_OBJECT_TAB LIKE TCLT-OBTAB.
  DATA: LOCAL_FIELDNAME LIKE API_OB_KEY-FIELD.

  DATA: BEGIN OF INTKLASSEN OCCURS 0.
          INCLUDE STRUCTURE API_KSSK.
  DATA: END OF INTKLASSEN.
  DATA: BEGIN OF OBJECT_IDENTIFICATION OCCURS 0.
          INCLUDE STRUCTURE API_OB_KEY.
  DATA: END OF OBJECT_IDENTIFICATION.

  DATA: BEGIN OF CHARACT_VALUES OCCURS 0.
          INCLUDE STRUCTURE API_VAL_R.
  DATA: END OF CHARACT_VALUES.

  LOCAL_OBJECT = OBJECT.
  CHECK NOT LOCAL_OBJECT IS INITIAL.
  LOCAL_OBJECT_TAB = OBJECT_TAB.
  REFRESH INTKLASSEN.
  CALL FUNCTION 'CLAP_DDB_GET_CLASSIFICATION'
    EXPORTING
      OBJECT                 = LOCAL_OBJECT
      OBTAB                  = LOCAL_OBJECT_TAB
      SPRAS                  = PRINT_LANGUAGE
    TABLES
      ALLOCATIONS            = INTKLASSEN
    EXCEPTIONS
      NO_ALLOCATION          = 1
      SET_AENNR              = 2
      CHANGE_NR_NOT_EXIST    = 3
      DATE_IN_PAST           = 4
      ERROR_CLASS            = 5
      ERROR_DATE_RESTRICTION = 6
      ERROR_STATUS           = 7
      OTHERS                 = 8.

  LOCAL_FIELDNAME = FIELDNAME.
  REFRESH OBJECT_IDENTIFICATION.
*... set which type of class info is reguired, eg EQUI, EQUNR
  OBJECT_IDENTIFICATION-FIELD = LOCAL_FIELDNAME.
  OBJECT_IDENTIFICATION-VALUE = LOCAL_OBJECT.
  APPEND OBJECT_IDENTIFICATION.

  LOOP AT INTKLASSEN.
    API_KSSK = INTKLASSEN. "note current class in ddic structure
    CALL FUNCTION 'WRITE_FORM'
      EXPORTING
        ELEMENT = 'CLASS'.
    REFRESH  CHARACT_VALUES.
    CALL FUNCTION 'CACL_OBJECT_READ_VALIDATION'
      EXPORTING
        OBJECT_TYPE              = LOCAL_OBJECT_TAB
        CLASS_TYPE               = INTKLASSEN-KLART
        CLASS                    = INTKLASSEN-CLASS
        WITH_UNASSIGNED_CHARACTS = ' '
        WITH_INHERITED_CHARACTS  = ' '
        LANGUAGE                 = PRINT_LANGUAGE
      TABLES
        OBJECT_IDENTIFICATION    = OBJECT_IDENTIFICATION
        CHARACT_VALUES           = CHARACT_VALUES
      EXCEPTIONS
        ERROR                    = 1
        WARNING                  = 2
        OTHERS                   = 3.
    LOOP AT CHARACT_VALUES.
      API_VAL_R = CHARACT_VALUES.      "move to ddic struc for sapscript
      IF CHARACT_VALUES-VAL_ASSIGN = 'X'.
        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            ELEMENT = 'CLASS_FEATURE'.
      ELSE.
        CALL FUNCTION 'WRITE_FORM'
          EXPORTING
            ELEMENT = 'CLASS_FEATURE_INHERITED'.
      ENDIF.
    ENDLOOP.
  ENDLOOP.
ENDFORM.                    "PRINT_CLASSIFICATION
*&---------------------------------------------------------------------*
*&      Form  ONLY_NEW_PARTNERS
*&---------------------------------------------------------------------*
* deletes with equal PARNR and PARVW
*----------------------------------------------------------------------*
*      -->P_IHPAD_COP  text                                            *
*----------------------------------------------------------------------*
FORM ONLY_NEW_PARTNERS TABLES IHPAD_COP STRUCTURE IHPAD.
*-> check if a partner is already in the order_ihpad_tab
  LOOP AT IHPAD_COP. " delete all partners already printed with
    " order_ihpad_tab
*-> check order table
    READ TABLE ORDER_IHPAD_TAB WITH KEY PARNR   = IHPAD_COP-PARNR
                                        PARVW   = IHPAD_COP-PARVW.
    IF SY-SUBRC = 0.
*-> entry found - we don't need it in ihpad_cop any longer
      DELETE IHPAD_COP.
      CONTINUE.
    ENDIF.
*-> check notification table
    READ TABLE NOTIF_IHPAD_TAB WITH KEY PARNR   = IHPAD_COP-PARNR
                                        PARVW   = IHPAD_COP-PARVW.
    IF SY-SUBRC = 0.
*-> entry found - we don't need it in ihpad_cop any longer
      DELETE IHPAD_COP.
      CONTINUE.
    ENDIF.
*-> check common table
    READ TABLE IHPAD_TAB WITH KEY PARNR   = IHPAD_COP-PARNR
                                  PARVW   = IHPAD_COP-PARVW.
    IF SY-SUBRC = 0.
*-> entry found - we don't need it in ihpad_cop any longer
      DELETE IHPAD_COP.
      CONTINUE.
    ENDIF.
  ENDLOOP.
ENDFORM.                               " ONLY_NEW_PARTNERS
*&---------------------------------------------------------------------*
*&      Form  READ_OBJECT_TEXTS
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_RIWO1  text
*      -->P_PRINT_LANGUAGE  text
*----------------------------------------------------------------------*
FORM READ_OBJECT_TEXTS USING H_RIWO1 LIKE RIWO1 H_LANGU LIKE SY-LANGU.
  DATA: OLD_MAKT LIKE MAKT,
        OLD_EQKT LIKE EQKT,
        OLD_IFLO LIKE IFLO.

*-> store old value
  OLD_MAKT = MAKT.
  OLD_EQKT = EQKT.
  OLD_IFLO = IFLO.
*-> assembly
  IF NOT H_RIWO1-BAUTL IS INITIAL.
    CLEAR MAKT.
    SELECT SINGLE * FROM  MAKT
           WHERE  MATNR  = H_RIWO1-BAUTL
           AND    SPRAS  = H_LANGU.
    IF NOT MAKT-MAKTX IS INITIAL.
      H_RIWO1-BAUTX = MAKT-MAKTX.
    ENDIF.
    MAKT = OLD_MAKT.
  ENDIF.
*-> material number for serial number (with 4.0A)
  IF NOT H_RIWO1-MATNR IS INITIAL.
    CLEAR MAKT.
    SELECT SINGLE * FROM  MAKT
           WHERE  MATNR  = H_RIWO1-MATNR
           AND    SPRAS  = H_LANGU.
    IF NOT MAKT-MAKTX IS INITIAL.
      H_RIWO1-MATKTX = MAKT-MAKTX.
    ENDIF.
    MAKT = OLD_MAKT.
  ENDIF.
*-> equipment
  IF NOT H_RIWO1-EQUNR IS INITIAL.
    CLEAR EQKT.
    SELECT SINGLE * FROM  EQKT
           WHERE  EQUNR  = H_RIWO1-EQUNR
           AND    SPRAS  = H_LANGU.
    IF NOT EQKT-EQKTX IS INITIAL.
      H_RIWO1-EQTXT = EQKT-EQKTX.
    ENDIF.
    EQKT = OLD_EQKT.
  ENDIF.
*-> funct. loc.
  IF NOT H_RIWO1-TPLNR IS INITIAL.
    CLEAR IFLO.
    SELECT SINGLE * FROM  IFLO
           WHERE  TPLNR  = H_RIWO1-TPLNR
           AND    SPRAS  = H_LANGU.
    IF NOT IFLO-PLTXT IS INITIAL.
      H_RIWO1-PLTXT = IFLO-PLTXT.
    ENDIF.
    IFLO = OLD_IFLO.
  ENDIF.
ENDFORM.                    " READ_OBJECT_TEXT
*&---------------------------------------------------------------------*
*&      Form  NOTIFICATION_DATA_IMPORT
*&---------------------------------------------------------------------*
*       Imports the notification data
*----------------------------------------------------------------------*
*      --> Values from memory.
*          see list below
*----------------------------------------------------------------------*
FORM NOTIFICATION_DATA_IMPORT
  TABLES   I_IVIQMFE   TYPE T_IVIQMFE
           I_IVIQMMA   TYPE T_IVIQMMA
           I_IVIQMSM   TYPE T_IVIQMSM
           I_IVIQMUR   TYPE T_IVIQMUR
           I_IQKAT     TYPE T_IQKAT
           I_IHPAD_TAB TYPE T_IHPAD_TAB
  CHANGING I_IVIQMEL   LIKE IVIQMEL
           I_RIWO1     LIKE RIWO1
           I_RIWO00    LIKE RIWO00
           I_RQM00     LIKE RQM00.

  IMPORT IVIQMEL   TO I_IVIQMEL           " ... Notification
         IVIQMFE   TO I_IVIQMFE           " ... positions
         IVIQMMA   TO I_IVIQMMA           " ... codes
         IVIQMSM   TO I_IVIQMSM           " ... codes
         IVIQMUR   TO I_IVIQMUR           " ... codes
         IQKAT     TO I_IQKAT             " ... Catalogue
         IHPAD_TAB TO I_IHPAD_TAB         " ... partner table
         RIWO1     TO I_RIWO1             " ... Texts from Objects
         RIWO00    TO I_RIWO00   " ... Dialog structure with status info
         FROM MEMORY ID ID_IPRT_STRUCT.
  IF SYST-SUBRC <> 0.
    MESSAGE A650(ID).                  " import failed
  ELSE.
    IMPORT RQM00                       " QM-QN special data
    FROM MEMORY ID ID_IPRT_RQM00.
    IF SYST-SUBRC <> 0.
      MESSAGE I650(ID).                " only import QM-QN failed
    ENDIF.
  ENDIF.

ENDFORM.                    " NOTIFICATION_DATA_IMPORT
*&---------------------------------------------------------------------*
*&      Form  SET_GV_ARC_TYPE_AUFK
*&---------------------------------------------------------------------*
*  set global variable gv_arc_type_aufk to check for PM or CS
*----------------------------------------------------------------------*
*  --> new with note 766146
*  --> iv_auart       relevant oder type
*----------------------------------------------------------------------*
FORM SET_GV_ARC_TYPE_AUFK USING iv_auart LIKE t350-auart.

*check if object type for order 'CS' or 'PM'
  IF gs_t350-auart <> iv_auart.
    clear gs_t350.
    SELECT SINGLE * FROM t350 INTO gs_t350
      WHERE auart = iv_auart.
  ENDIF.

  IF gs_t350-service = 'X'.
    gv_ARC_TYPE_AUFK = C_ARC_TYPE_A_CS.
  ELSE.
    gv_ARC_TYPE_AUFK = C_ARC_TYPE_A_PM.
  ENDIF.

ENDFORM.                    " SET_GV_ARC_TYPE_AUFK
